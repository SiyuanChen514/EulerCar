
D:\car\EulerCar\chassis_mcu_code\application\out\bin\target.elf:     file format elf32-littleriscv


Disassembly of section .text.entry:

03000004 <_start>:

    .section      .text.entry
    .global _start
    .option norvc
_start:
    j handle_reset
 3000004:	5440006f          	j	3000548 <handle_reset>

03000008 <TrapHandler>:
.endm

/* The interrupt vector table must be aligned with 4 bytes */
.align 2
TrapHandler:
    j     TrapVector        /* trap and INT 0 */
 3000008:	4880006f          	j	3000490 <TrapVector>
    j     TrapVector        /* INT 1 */
 300000c:	4840006f          	j	3000490 <TrapVector>
    j     TrapVector        /* INT 2 */
 3000010:	4800006f          	j	3000490 <TrapVector>
    j     TrapVector        /* INT 3 */
 3000014:	47c0006f          	j	3000490 <TrapVector>
    j     TrapVector        /* INT 4 */
 3000018:	4780006f          	j	3000490 <TrapVector>
    j     TrapVector        /* INT 5 */
 300001c:	4740006f          	j	3000490 <TrapVector>
    j     TrapVector        /* INT 6 */
 3000020:	4700006f          	j	3000490 <TrapVector>
    j     TrapVector        /* INT 7 */
 3000024:	46c0006f          	j	3000490 <TrapVector>
    j     TrapVector        /* INT 8 */
 3000028:	4680006f          	j	3000490 <TrapVector>
    j     TrapVector        /* INT 9 */
 300002c:	4640006f          	j	3000490 <TrapVector>
    j     TrapVector        /* INT 10 */
 3000030:	4600006f          	j	3000490 <TrapVector>
    j     TrapVector        /* INT 11 */
 3000034:	45c0006f          	j	3000490 <TrapVector>
    j     TrapVector        /* INT 12 */
 3000038:	4580006f          	j	3000490 <TrapVector>
    j     TrapVector        /* INT 13 */
 300003c:	4540006f          	j	3000490 <TrapVector>
    j     TrapVector        /* INT 14 */
 3000040:	4500006f          	j	3000490 <TrapVector>
    j     TrapVector        /* INT 15 */
 3000044:	44c0006f          	j	3000490 <TrapVector>
    j     TrapVector        /* INT 16 */
 3000048:	4480006f          	j	3000490 <TrapVector>
    j     TrapVector        /* INT 17 */
 300004c:	4440006f          	j	3000490 <TrapVector>
    j     TrapVector        /* INT 18 */
 3000050:	4400006f          	j	3000490 <TrapVector>
    j     TrapVector        /* INT 19 */
 3000054:	43c0006f          	j	3000490 <TrapVector>
    j     TrapVector        /* INT 20 */
 3000058:	4380006f          	j	3000490 <TrapVector>
    j     TrapVector        /* INT 21 */
 300005c:	4340006f          	j	3000490 <TrapVector>
    j     TrapVector        /* INT 22 */
 3000060:	4300006f          	j	3000490 <TrapVector>
    j     TrapVector        /* INT 23 */
 3000064:	42c0006f          	j	3000490 <TrapVector>
    j     TrapVector        /* INT 24 */
 3000068:	4280006f          	j	3000490 <TrapVector>
    j     TrapVector        /* INT 25 */
 300006c:	4240006f          	j	3000490 <TrapVector>

    j     IntHandler        /* INT 26 */
 3000070:	2640006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 27 */
 3000074:	2600006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 28 */
 3000078:	25c0006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 29 */
 300007c:	2580006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 30 */
 3000080:	2540006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 31 */
 3000084:	2500006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 32 */
 3000088:	24c0006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 33 */
 300008c:	2480006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 34 */
 3000090:	2440006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 35 */
 3000094:	2400006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 36 */
 3000098:	23c0006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 37 */
 300009c:	2380006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 38 */
 30000a0:	2340006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 39 */
 30000a4:	2300006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 40 */
 30000a8:	22c0006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 41 */
 30000ac:	2280006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 42 */
 30000b0:	2240006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 43 */
 30000b4:	2200006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 44 */
 30000b8:	21c0006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 45 */
 30000bc:	2180006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 46 */
 30000c0:	2140006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 47 */
 30000c4:	2100006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 48 */
 30000c8:	20c0006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 49 */
 30000cc:	2080006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 50 */
 30000d0:	2040006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 51 */
 30000d4:	2000006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 52 */
 30000d8:	1fc0006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 53 */
 30000dc:	1f80006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 54 */
 30000e0:	1f40006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 55 */
 30000e4:	1f00006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 56 */
 30000e8:	1ec0006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 57 */
 30000ec:	1e80006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 58 */
 30000f0:	1e40006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 59 */
 30000f4:	1e00006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 60 */
 30000f8:	1dc0006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 61 */
 30000fc:	1d80006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 62 */
 3000100:	1d40006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 63 */
 3000104:	1d00006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 64 */
 3000108:	1cc0006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 65 */
 300010c:	1c80006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 66 */
 3000110:	1c40006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 67 */
 3000114:	1c00006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 68 */
 3000118:	1bc0006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 69 */
 300011c:	1b80006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 70 */
 3000120:	1b40006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 71 */
 3000124:	1b00006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 72 */
 3000128:	1ac0006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 73 */
 300012c:	1a80006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 74 */
 3000130:	1a40006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 75 */
 3000134:	1a00006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 76 */
 3000138:	19c0006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 77 */
 300013c:	1980006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 78 */
 3000140:	1940006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 79 */
 3000144:	1900006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 80 */
 3000148:	18c0006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 81 */
 300014c:	1880006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 82 */
 3000150:	1840006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 83 */
 3000154:	1800006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 84 */
 3000158:	17c0006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 85 */
 300015c:	1780006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 86 */
 3000160:	1740006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 87 */
 3000164:	1700006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 88 */
 3000168:	16c0006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 89 */
 300016c:	1680006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 90 */
 3000170:	1640006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 91 */
 3000174:	1600006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 92 */
 3000178:	15c0006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 93 */
 300017c:	1580006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 94 */
 3000180:	1540006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 95 */
 3000184:	1500006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 96 */
 3000188:	14c0006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 97 */
 300018c:	1480006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 98 */
 3000190:	1440006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 99 */
 3000194:	1400006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 100 */
 3000198:	13c0006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 101 */
 300019c:	1380006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 102 */
 30001a0:	1340006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 103 */
 30001a4:	1300006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 104 */
 30001a8:	12c0006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 105 */
 30001ac:	1280006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 106 */
 30001b0:	1240006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 107 */
 30001b4:	1200006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 108 */
 30001b8:	11c0006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 109 */
 30001bc:	1180006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 110 */
 30001c0:	1140006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 111 */
 30001c4:	1100006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 112 */
 30001c8:	10c0006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 113 */
 30001cc:	1080006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 114 */
 30001d0:	1040006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 115 */
 30001d4:	1000006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 116 */
 30001d8:	0fc0006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 117 */
 30001dc:	0f80006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 118 */
 30001e0:	0f40006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 119 */
 30001e4:	0f00006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 120 */
 30001e8:	0ec0006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 121 */
 30001ec:	0e80006f          	j	30002d4 <IntHandler>

030001f0 <NmiEntry>:

.align 2
NmiEntry:
    SAVE_SYSERR_REGS
 30001f0:	f9010113          	addi	sp,sp,-112
 30001f4:	04812023          	sw	s0,64(sp)
 30001f8:	04912223          	sw	s1,68(sp)
 30001fc:	05212423          	sw	s2,72(sp)
 3000200:	05312623          	sw	s3,76(sp)
 3000204:	05412823          	sw	s4,80(sp)
 3000208:	05512a23          	sw	s5,84(sp)
 300020c:	05612c23          	sw	s6,88(sp)
 3000210:	05712e23          	sw	s7,92(sp)
 3000214:	07812023          	sw	s8,96(sp)
 3000218:	07912223          	sw	s9,100(sp)
 300021c:	07a12423          	sw	s10,104(sp)
 3000220:	07b12623          	sw	s11,108(sp)
 3000224:	11010593          	addi	a1,sp,272
 3000228:	06b12823          	sw	a1,112(sp)
 300022c:	06312a23          	sw	gp,116(sp)
 3000230:	06412c23          	sw	tp,120(sp)
 3000234:	34102573          	csrr	a0,mepc
 3000238:	300025f3          	csrr	a1,mstatus
 300023c:	34302673          	csrr	a2,mtval
 3000240:	342026f3          	csrr	a3,mcause
 3000244:	06a12e23          	sw	a0,124(sp)
 3000248:	08b12023          	sw	a1,128(sp)
 300024c:	08c12223          	sw	a2,132(sp)
 3000250:	08d12423          	sw	a3,136(sp)
 3000254:	00010513          	mv	a0,sp
    call SysErrNmiEntry
 3000258:	719020ef          	jal	ra,3003170 <SysErrNmiEntry>

0300025c <deadLoop1>:
deadLoop1:
    tail deadLoop1
 300025c:	a001                	j	300025c <deadLoop1>
    nop
 300025e:	00000013          	nop

03000262 <TrapEntry>:

.align 2
TrapEntry:
    SAVE_SYSERR_REGS
 3000262:	f9010113          	addi	sp,sp,-112
 3000266:	04812023          	sw	s0,64(sp)
 300026a:	04912223          	sw	s1,68(sp)
 300026e:	05212423          	sw	s2,72(sp)
 3000272:	05312623          	sw	s3,76(sp)
 3000276:	05412823          	sw	s4,80(sp)
 300027a:	05512a23          	sw	s5,84(sp)
 300027e:	05612c23          	sw	s6,88(sp)
 3000282:	05712e23          	sw	s7,92(sp)
 3000286:	07812023          	sw	s8,96(sp)
 300028a:	07912223          	sw	s9,100(sp)
 300028e:	07a12423          	sw	s10,104(sp)
 3000292:	07b12623          	sw	s11,108(sp)
 3000296:	11010593          	addi	a1,sp,272
 300029a:	06b12823          	sw	a1,112(sp)
 300029e:	06312a23          	sw	gp,116(sp)
 30002a2:	06412c23          	sw	tp,120(sp)
 30002a6:	34102573          	csrr	a0,mepc
 30002aa:	300025f3          	csrr	a1,mstatus
 30002ae:	34302673          	csrr	a2,mtval
 30002b2:	342026f3          	csrr	a3,mcause
 30002b6:	06a12e23          	sw	a0,124(sp)
 30002ba:	08b12023          	sw	a1,128(sp)
 30002be:	08c12223          	sw	a2,132(sp)
 30002c2:	08d12423          	sw	a3,136(sp)
 30002c6:	00010513          	mv	a0,sp
    /* Exception run with interrupts masked */
    csrc mstatus, MSTATUS_MIE
 30002ca:	30047073          	csrci	mstatus,8
    call SysErrExcEntry
 30002ce:	685020ef          	jal	ra,3003152 <SysErrExcEntry>

030002d2 <deadLoop2>:
deadLoop2:
    tail deadLoop2
 30002d2:	a001                	j	30002d2 <deadLoop2>

030002d4 <IntHandler>:

.align 2
IntHandler:
    addi  sp, sp, -(TOTAL_INT_SIZE_ON_STACK)
 30002d4:	f6010113          	addi	sp,sp,-160

    SREG  a0, 3 * REGBYTES(sp)
 30002d8:	00a12623          	sw	a0,12(sp)
    SREG  a1, 4 * REGBYTES(sp)
 30002dc:	00b12823          	sw	a1,16(sp)

#if defined(USER_MODE_ENABLE) && (USER_MODE_ENABLE == 1)
    la    a0, g_RiscvPrivMode
 30002e0:	a8818513          	addi	a0,gp,-1400 # 4000184 <g_RiscvPrivMode>
    lw    a1, (a0)
 30002e4:	00052583          	lw	a1,0(a0)
    addi  a1, a1, 1
 30002e8:	00158593          	addi	a1,a1,1
    sw    a1, (a0)
 30002ec:	00b52023          	sw	a1,0(a0)
#endif

#if defined(HARD_NESTED_IRQ_SUPPORT) && (HARD_NESTED_IRQ_SUPPORT == 1)
    csrr  a0, mcause
#else
    csrr  a0, cipri
 30002f0:	7ed02573          	csrr	a0,0x7ed
    csrr  a1, prithd
 30002f4:	bfe025f3          	csrr	a1,0xbfe
    csrw  prithd, a0                /* read prithd */
 30002f8:	bfe51073          	csrw	0xbfe,a0
    SREG  a1, 6 * REGBYTES(sp)      /* save prithd */
 30002fc:	00b12c23          	sw	a1,24(sp)
    csrr  a1, mstatus               /* read mstatus */
 3000300:	300025f3          	csrr	a1,mstatus
    SREG  a1, 7 * REGBYTES(sp)      /* save mstatus */
 3000304:	00b12e23          	sw	a1,28(sp)
    csrr  a1, mepc                  /* read mepc */
 3000308:	341025f3          	csrr	a1,mepc
    SREG  a1, 8 * REGBYTES(sp)      /* save mepc */
 300030c:	02b12023          	sw	a1,32(sp)

    csrr  a0, mcause
 3000310:	34202573          	csrr	a0,mcause

    li  a1, (3<<11)
 3000314:	000025b7          	lui	a1,0x2
 3000318:	80058593          	addi	a1,a1,-2048 # 1800 <__bss_size__+0xb8c>
    csrs  mstatus, a1
 300031c:	3005a073          	csrs	mstatus,a1
    la    a1, custom_nested_irq_main_handler_entry
 3000320:	00000597          	auipc	a1,0x0
 3000324:	01058593          	addi	a1,a1,16 # 3000330 <custom_nested_irq_main_handler_entry>
    csrw  mepc, a1
 3000328:	34159073          	csrw	mepc,a1
    mret
 300032c:	30200073          	mret

03000330 <custom_nested_irq_main_handler_entry>:
#endif

.align 2
custom_nested_irq_main_handler_entry:
    SREG  t0, 0 * REGBYTES(sp)
 3000330:	00512023          	sw	t0,0(sp)
    SREG  t1, 1 * REGBYTES(sp)
 3000334:	00612223          	sw	t1,4(sp)
    SREG  t2, 2 * REGBYTES(sp)
 3000338:	00712423          	sw	t2,8(sp)
    SREG  a2, 5 * REGBYTES(sp)
 300033c:	00c12a23          	sw	a2,20(sp)
    SREG  ra, 9 * REGBYTES(sp)
 3000340:	02112223          	sw	ra,36(sp)
    SREG  a3, 10 * REGBYTES(sp)
 3000344:	02d12423          	sw	a3,40(sp)
    SREG  a4, 11 * REGBYTES(sp)
 3000348:	02e12623          	sw	a4,44(sp)
    SREG  a5, 12 * REGBYTES(sp)
 300034c:	02f12823          	sw	a5,48(sp)
    SREG  a6, 13 * REGBYTES(sp)
 3000350:	03012a23          	sw	a6,52(sp)
    SREG  a7, 14 * REGBYTES(sp)
 3000354:	03112c23          	sw	a7,56(sp)
    SREG  t3, 15 * REGBYTES(sp)
 3000358:	03c12e23          	sw	t3,60(sp)
    SREG  t4, 16 * REGBYTES(sp)
 300035c:	05d12023          	sw	t4,64(sp)
    SREG  t5, 17 * REGBYTES(sp)
 3000360:	05e12223          	sw	t5,68(sp)
    SREG  t6, 18 * REGBYTES(sp)
 3000364:	05f12423          	sw	t6,72(sp)

#ifdef FLOAT_SUPPORT
    FSREG  f0, 19 * REGBYTES(sp)
 3000368:	04012627          	fsw	ft0,76(sp)
    FSREG  f1, 20 * REGBYTES(sp)
 300036c:	04112827          	fsw	ft1,80(sp)
    FSREG  f2, 21 * REGBYTES(sp)
 3000370:	04212a27          	fsw	ft2,84(sp)
    FSREG  f3, 22 * REGBYTES(sp)
 3000374:	04312c27          	fsw	ft3,88(sp)
    FSREG  f4, 23 * REGBYTES(sp)
 3000378:	04412e27          	fsw	ft4,92(sp)
    FSREG  f5, 24 * REGBYTES(sp)
 300037c:	06512027          	fsw	ft5,96(sp)
    FSREG  f6, 25 * REGBYTES(sp)
 3000380:	06612227          	fsw	ft6,100(sp)
    FSREG  f7, 26 * REGBYTES(sp)
 3000384:	06712427          	fsw	ft7,104(sp)
    FSREG  f10, 27 * REGBYTES(sp)
 3000388:	06a12627          	fsw	fa0,108(sp)
    FSREG  f11, 28 * REGBYTES(sp)
 300038c:	06b12827          	fsw	fa1,112(sp)
    FSREG  f12, 29 * REGBYTES(sp)
 3000390:	06c12a27          	fsw	fa2,116(sp)
    FSREG  f13, 30 * REGBYTES(sp)
 3000394:	06d12c27          	fsw	fa3,120(sp)
    FSREG  f14, 31 * REGBYTES(sp)
 3000398:	06e12e27          	fsw	fa4,124(sp)
    FSREG  f15, 32 * REGBYTES(sp)
 300039c:	08f12027          	fsw	fa5,128(sp)
    FSREG  f16, 33 * REGBYTES(sp)
 30003a0:	09012227          	fsw	fa6,132(sp)
    FSREG  f17, 34 * REGBYTES(sp)
 30003a4:	09112427          	fsw	fa7,136(sp)
    FSREG  f28, 35 * REGBYTES(sp)
 30003a8:	09c12627          	fsw	ft8,140(sp)
    FSREG  f29, 36 * REGBYTES(sp)
 30003ac:	09d12827          	fsw	ft9,144(sp)
    FSREG  f30, 37 * REGBYTES(sp)
 30003b0:	09e12a27          	fsw	ft10,148(sp)
    FSREG  f31, 38 * REGBYTES(sp)
 30003b4:	09f12c27          	fsw	ft11,152(sp)
#endif

    andi  a0, a0, MCAUSE_MASK_INT_NUM
 30003b8:	0ff57513          	andi	a0,a0,255
    call  InterruptEntry
 30003bc:	303020ef          	jal	ra,3002ebe <InterruptEntry>

    LREG  t1, 1 * REGBYTES(sp)
 30003c0:	00412303          	lw	t1,4(sp)
    LREG  t2, 2 * REGBYTES(sp)
 30003c4:	00812383          	lw	t2,8(sp)
    LREG  a2, 5 * REGBYTES(sp)
 30003c8:	01412603          	lw	a2,20(sp)
    LREG  ra, 9 * REGBYTES(sp)
 30003cc:	02412083          	lw	ra,36(sp)
    LREG  a3, 10 * REGBYTES(sp)
 30003d0:	02812683          	lw	a3,40(sp)
    LREG  a4, 11 * REGBYTES(sp)
 30003d4:	02c12703          	lw	a4,44(sp)
    LREG  a5, 12 * REGBYTES(sp)
 30003d8:	03012783          	lw	a5,48(sp)
    LREG  a6, 13 * REGBYTES(sp)
 30003dc:	03412803          	lw	a6,52(sp)
    LREG  a7, 14 * REGBYTES(sp)
 30003e0:	03812883          	lw	a7,56(sp)
    LREG  t3, 15 * REGBYTES(sp)
 30003e4:	03c12e03          	lw	t3,60(sp)
    LREG  t4, 16 * REGBYTES(sp)
 30003e8:	04012e83          	lw	t4,64(sp)
    LREG  t5, 17 * REGBYTES(sp)
 30003ec:	04412f03          	lw	t5,68(sp)
    LREG  t6, 18 * REGBYTES(sp)
 30003f0:	04812f83          	lw	t6,72(sp)

#ifdef FLOAT_SUPPORT
    FLREG  f0, 19 * REGBYTES(sp)
 30003f4:	04c12007          	flw	ft0,76(sp)
    FLREG  f1, 20 * REGBYTES(sp)
 30003f8:	05012087          	flw	ft1,80(sp)
    FLREG  f2, 21 * REGBYTES(sp)
 30003fc:	05412107          	flw	ft2,84(sp)
    FLREG  f3, 22 * REGBYTES(sp)
 3000400:	05812187          	flw	ft3,88(sp)
    FLREG  f4, 23 * REGBYTES(sp)
 3000404:	05c12207          	flw	ft4,92(sp)
    FLREG  f5, 24 * REGBYTES(sp)
 3000408:	06012287          	flw	ft5,96(sp)
    FLREG  f6, 25 * REGBYTES(sp)
 300040c:	06412307          	flw	ft6,100(sp)
    FLREG  f7, 26 * REGBYTES(sp)
 3000410:	06812387          	flw	ft7,104(sp)
    FLREG  f10, 27 * REGBYTES(sp)
 3000414:	06c12507          	flw	fa0,108(sp)
    FLREG  f11, 28 * REGBYTES(sp)
 3000418:	07012587          	flw	fa1,112(sp)
    FLREG  f12, 29 * REGBYTES(sp)
 300041c:	07412607          	flw	fa2,116(sp)
    FLREG  f13, 30 * REGBYTES(sp)
 3000420:	07812687          	flw	fa3,120(sp)
    FLREG  f14, 31 * REGBYTES(sp)
 3000424:	07c12707          	flw	fa4,124(sp)
    FLREG  f15, 32 * REGBYTES(sp)
 3000428:	08012787          	flw	fa5,128(sp)
    FLREG  f16, 33 * REGBYTES(sp)
 300042c:	08412807          	flw	fa6,132(sp)
    FLREG  f17, 34 * REGBYTES(sp)
 3000430:	08812887          	flw	fa7,136(sp)
    FLREG  f28, 35 * REGBYTES(sp)
 3000434:	08c12e07          	flw	ft8,140(sp)
    FLREG  f29, 36 * REGBYTES(sp)
 3000438:	09012e87          	flw	ft9,144(sp)
    FLREG  f30, 37 * REGBYTES(sp)
 300043c:	09412f07          	flw	ft10,148(sp)
    FLREG  f31, 38 * REGBYTES(sp)
 3000440:	09812f87          	flw	ft11,152(sp)

03000444 <quit_int>:
     */

#if defined(HARD_NESTED_IRQ_SUPPORT) && (HARD_NESTED_IRQ_SUPPORT == 1)
    LREG  t0, 0 * REGBYTES(sp)
#else
    LREG  a0, 7 * REGBYTES(sp)  /* load mstatus */
 3000444:	01c12503          	lw	a0,28(sp)
    csrr  t0, mstatus
 3000448:	300022f3          	csrr	t0,mstatus
    LREG  a1, 8 * REGBYTES(sp)  /* load mepc */
 300044c:	02012583          	lw	a1,32(sp)
    andi  t0, t0, MSTATUS_MIE
 3000450:	0082f293          	andi	t0,t0,8
    bnei  t0, 0, restore_mstatus
 3000454:	0002923b          	bnei	t0,0,300045c <restore_mstatus>
    andi  a0, a0, ~(MSTATUS_MIE | MSTATUS_MPIE)
 3000458:	f7757513          	andi	a0,a0,-137

0300045c <restore_mstatus>:
restore_mstatus:
    csrw  mstatus, a0
 300045c:	30051073          	csrw	mstatus,a0

    LREG  t0, 0 * REGBYTES(sp)
 3000460:	00012283          	lw	t0,0(sp)
    csrw  mepc, a1
 3000464:	34159073          	csrw	mepc,a1
    LREG  a0, 6 * REGBYTES(sp)  /* load prithd */
 3000468:	01812503          	lw	a0,24(sp)
    csrw  prithd, a0
 300046c:	bfe51073          	csrw	0xbfe,a0
#endif

#if defined(USER_MODE_ENABLE) && (USER_MODE_ENABLE == 1)
    la    a0, g_RiscvPrivMode
 3000470:	a8818513          	addi	a0,gp,-1400 # 4000184 <g_RiscvPrivMode>
    lw    a1, (a0)
 3000474:	00052583          	lw	a1,0(a0)
    addi  a1, a1, -1
 3000478:	fff58593          	addi	a1,a1,-1
    sw    a1, (a0)
 300047c:	00b52023          	sw	a1,0(a0)
#endif

    LREG  a1, 4 * REGBYTES(sp)   /* 2 consecutive csrw instructions will have a bubble */
 3000480:	01012583          	lw	a1,16(sp)

    LREG  a0, 3 * REGBYTES(sp)
 3000484:	00c12503          	lw	a0,12(sp)

    addi  sp, sp, TOTAL_INT_SIZE_ON_STACK
 3000488:	0a010113          	addi	sp,sp,160

    mret
 300048c:	30200073          	mret

03000490 <TrapVector>:

.align 2
TrapVector:
    push_reg
 3000490:	f6010113          	addi	sp,sp,-160
 3000494:	fff11f8b          	stmia	{ra,t0-t6,a0-a7},(sp)
 3000498:	f6010113          	addi	sp,sp,-160
    csrr  a0, mcause
 300049c:	34202573          	csrr	a0,mcause
    li    t1, MCAUSE_ECALL_FROM_MMODE
 30004a0:	00b00313          	li	t1,11
#if defined(USER_MODE_ENABLE) && (USER_MODE_ENABLE == 1)
    beq   a0, t1, switch_to_umode
 30004a4:	02650c63          	beq	a0,t1,30004dc <switch_to_umode>
#else
    beq   a0, t1, switch_to_mmode
#endif
    li    t1, MCAUSE_ECALL_FROM_UMODE
 30004a8:	00800313          	li	t1,8
    beq   a0, t1, switch_to_mmode
 30004ac:	04650c63          	beq	a0,t1,3000504 <switch_to_mmode>

    li    a1, MCAUSE_MASK_INT_BIT
 30004b0:	800005b7          	lui	a1,0x80000
    li    a2, MCAUSE_MASK_INT_NUM
 30004b4:	0ff00613          	li	a2,255
    and   a1, a0, a1
 30004b8:	00b575b3          	and	a1,a0,a1
    and   a0, a0, a2
 30004bc:	00c57533          	and	a0,a0,a2

    li    a2, 0xc
 30004c0:	00c00613          	li	a2,12
    beq   a0, a2, NmiEntry
 30004c4:	d2c506e3          	beq	a0,a2,30001f0 <NmiEntry>
    beqz  a1, TrapEntry
 30004c8:	d8058de3          	beqz	a1,3000262 <TrapEntry>
    pop_reg
 30004cc:	0a010113          	addi	sp,sp,160
 30004d0:	fff10f8b          	ldmia	{ra,t0-t6,a0-a7},(sp)
 30004d4:	0a010113          	addi	sp,sp,160
    mret
 30004d8:	30200073          	mret

030004dc <switch_to_umode>:

#if defined(USER_MODE_ENABLE) && (USER_MODE_ENABLE == 1)
.align 2
switch_to_umode:
    li    t2,  MSTATUS_MPP_MACHINE
 30004dc:	000023b7          	lui	t2,0x2
 30004e0:	80038393          	addi	t2,t2,-2048 # 1800 <__bss_size__+0xb8c>
    csrc  mstatus, t2
 30004e4:	3003b073          	csrc	mstatus,t2
    csrr  t0,  mepc
 30004e8:	341022f3          	csrr	t0,mepc
    addi  t0,  t0,  4
 30004ec:	00428293          	addi	t0,t0,4
    csrw  mepc, t0
 30004f0:	34129073          	csrw	mepc,t0
    pop_reg
 30004f4:	0a010113          	addi	sp,sp,160
 30004f8:	fff10f8b          	ldmia	{ra,t0-t6,a0-a7},(sp)
 30004fc:	0a010113          	addi	sp,sp,160
    mret
 3000500:	30200073          	mret

03000504 <switch_to_mmode>:
#endif

.align 2
switch_to_mmode:
    li    t2,  MSTATUS_MPP_MACHINE
 3000504:	000023b7          	lui	t2,0x2
 3000508:	80038393          	addi	t2,t2,-2048 # 1800 <__bss_size__+0xb8c>
    csrs  mstatus, t2
 300050c:	3003a073          	csrs	mstatus,t2
    csrr  t0,  mepc
 3000510:	341022f3          	csrr	t0,mepc
    addi  t0,  t0,  4
 3000514:	00428293          	addi	t0,t0,4
    csrw  mepc, t0
 3000518:	34129073          	csrw	mepc,t0
    pop_reg
 300051c:	0a010113          	addi	sp,sp,160
 3000520:	fff10f8b          	ldmia	{ra,t0-t6,a0-a7},(sp)
 3000524:	0a010113          	addi	sp,sp,160
    mret
 3000528:	30200073          	mret

0300052c <mem_cpy>:

.align 2
mem_cpy:
    bge t0, t2, cpy_done
 300052c:	0072dc63          	bge	t0,t2,3000544 <cpy_done>
    lw  t3, (t1)
 3000530:	00032e03          	lw	t3,0(t1)
    sw  t3, (t0)
 3000534:	01c2a023          	sw	t3,0(t0)
    addi t0, t0, 4
 3000538:	00428293          	addi	t0,t0,4
    addi t1, t1, 4
 300053c:	00430313          	addi	t1,t1,4
    j mem_cpy
 3000540:	fedff06f          	j	300052c <mem_cpy>

03000544 <cpy_done>:
cpy_done:
    ret
 3000544:	00008067          	ret

03000548 <handle_reset>:

.align 2
handle_reset:
    csrwi mstatus, 0
 3000548:	30005073          	csrwi	mstatus,0
    csrwi mie,  0
 300054c:	30405073          	csrwi	mie,0
    csrci mstatus, 0x08
 3000550:	30047073          	csrci	mstatus,8
    la    t0,  TrapHandler
 3000554:	00000297          	auipc	t0,0x0
 3000558:	ab428293          	addi	t0,t0,-1356 # 3000008 <TrapHandler>
    addi  t0,  t0, 1
 300055c:	00128293          	addi	t0,t0,1
    csrw  mtvec, t0
 3000560:	30529073          	csrw	mtvec,t0
    csrwi 0x7EF, 0x1               /* lock mtvec */
 3000564:	7ef0d073          	csrwi	0x7ef,1

03000568 <flash_init>:
    csrwi 0x7C8, 0x1              /* enable hardware nest interrupt support */
#endif

flash_init:
/* eflash prefetch enable */
    li  t0, EFC_BASE_ADDR
 3000568:	147102b7          	lui	t0,0x14710
    lw  t1, 0x120(t0)
 300056c:	1202a303          	lw	t1,288(t0) # 14710120 <RAM_END+0x10708120>
    ori t1, t1, 1
 3000570:	00136313          	ori	t1,t1,1
    sw  t1, 0x120(t0)
 3000574:	1262a023          	sw	t1,288(t0)

/* eflash cache enable */
    lw  t1, 0x124(t0)
 3000578:	1242a303          	lw	t1,292(t0)
    ori t1, t1, 1
 300057c:	00136313          	ori	t1,t1,1
    sw  t1, 0x124(t0)
 3000580:	1262a223          	sw	t1,292(t0)

/* enable flash cmd */
    li t0, EFC_MAGIC_NUMBER
 3000584:	fedcc2b7          	lui	t0,0xfedcc
 3000588:	a9828293          	addi	t0,t0,-1384 # fedcba98 <RAM_END+0xfadc3a98>
    li t1, EFC_MAGIC_LOCK_RW
 300058c:	14710337          	lui	t1,0x14710
 3000590:	20030313          	addi	t1,t1,512 # 14710200 <RAM_END+0x10708200>
    sw t0, (t1)
 3000594:	00532023          	sw	t0,0(t1)

/* initialize global pointer */
    .option push
    .option norelax
    la gp, __global_pointer$
 3000598:	01000197          	auipc	gp,0x1000
 300059c:	16418193          	addi	gp,gp,356 # 40006fc <__global_pointer$>
    .option pop

/* initialize stack pointer */
    la sp, __stack_top
 30005a0:	01007117          	auipc	sp,0x1007
 30005a4:	66010113          	addi	sp,sp,1632 # 4007c00 <__INTERRUPT_STACK_BEGIN__>

/* timer0 interrupt enable */
    li t0, TIMER0_CONTROL
 30005a8:	143002b7          	lui	t0,0x14300
 30005ac:	00828293          	addi	t0,t0,8 # 14300008 <RAM_END+0x102f8008>
    lw t1, (t0)
 30005b0:	0002a303          	lw	t1,0(t0)
    andi t1, t1, TIMER0_INTENABLE
 30005b4:	02037313          	andi	t1,t1,32
    sw t1, (t0)
 30005b8:	0062a023          	sw	t1,0(t0)

/* uart0 deinit */
    li t0, 0x14000000
 30005bc:	140002b7          	lui	t0,0x14000
    li t1, 0
 30005c0:	00000313          	li	t1,0
    sw t1, IBRD_OFFSET(t0)
 30005c4:	0262a223          	sw	t1,36(t0) # 14000024 <RAM_END+0xfff8024>
    sw t1, FBRD_OFFSET(t0)
 30005c8:	0262a423          	sw	t1,40(t0)
    sw t1, LCR_H_OFFSET(t0)
 30005cc:	0262a623          	sw	t1,44(t0)
    sw t1, CR_OFFSET(t0)
 30005d0:	0262a823          	sw	t1,48(t0)
    sw t1, DMACR_OFFSET(t0)
 30005d4:	0462a423          	sw	t1,72(t0)

030005d8 <clear_sram>:

/* perform the rest of initialization in C */
clear_sram:
    /* clear sysram parity error */
    li  t0, SYSRAM_ERROR
 30005d8:	101082b7          	lui	t0,0x10108
 30005dc:	30028293          	addi	t0,t0,768 # 10108300 <RAM_END+0xc100300>
    lw  t1, (t0)
 30005e0:	0002a303          	lw	t1,0(t0)
    ori t1, t1, 1
 30005e4:	00136313          	ori	t1,t1,1
    sw  t1, (t0)
 30005e8:	0062a023          	sw	t1,0(t0)

    la t0, SRAM_START
 30005ec:	90418293          	addi	t0,gp,-1788 # 4000000 <g_tsensorGain>
    la t1, SRAM_END
 30005f0:	01008317          	auipc	t1,0x1008
 30005f4:	a1030313          	addi	t1,t1,-1520 # 4008000 <RAM_END>
    li t2, 0
 30005f8:	00000393          	li	t2,0

030005fc <clear_sram_loop>:

clear_sram_loop:
    sw      t2, (t0)            /* clear all sram */
 30005fc:	0072a023          	sw	t2,0(t0)
    addi    t0, t0, 4           /* increment clear index pointer */
 3000600:	00428293          	addi	t0,t0,4
    blt     t0, t1, clear_sram_loop /* are we at the end yet, if not , contiue till the end */
 3000604:	fe62cce3          	blt	t0,t1,30005fc <clear_sram_loop>

03000608 <start_coderom_code_copy>:

start_coderom_code_copy:
    la t0, __sram_code_start_addr    /* SRAM addr */
 3000608:	ff000297          	auipc	t0,0xff000
 300060c:	9f828293          	addi	t0,t0,-1544 # 2000000 <RAM_CODE_START>
    la t1, __sram_code_load_addr     /* ROM addr  */
 3000610:	00000317          	auipc	t1,0x0
 3000614:	12830313          	addi	t1,t1,296 # 3000738 <Chip_InitFail>
    la t2, __sram_code_end_addr
 3000618:	ff000397          	auipc	t2,0xff000
 300061c:	9e838393          	addi	t2,t2,-1560 # 2000000 <RAM_CODE_START>
    jal mem_cpy
 3000620:	f0dff0ef          	jal	ra,300052c <mem_cpy>

03000624 <start_reserved_data_copy>:

start_reserved_data_copy:
    la t0, __reserved_code_start_addr  /* SRAM addr */
 3000624:	90418293          	addi	t0,gp,-1788 # 4000000 <g_tsensorGain>
    la t1, __reserved_code_load_addr   /* ROM addr  */
 3000628:	00000317          	auipc	t1,0x0
 300062c:	11030313          	addi	t1,t1,272 # 3000738 <Chip_InitFail>
    la t2, __reserved_code_end_addr
 3000630:	90418393          	addi	t2,gp,-1788 # 4000000 <g_tsensorGain>
    jal mem_cpy
 3000634:	ef9ff0ef          	jal	ra,300052c <mem_cpy>

03000638 <start_coderom_data_copy>:

start_coderom_data_copy:
    la t0, __data_start              /* SRAM addr */
 3000638:	90418293          	addi	t0,gp,-1788 # 4000000 <g_tsensorGain>
    la t1, __data_load               /* ROM addr  */
 300063c:	00011317          	auipc	t1,0x11
 3000640:	c7430313          	addi	t1,t1,-908 # 30112b0 <__data_load>
    la t2, __data_end
 3000644:	a8818393          	addi	t2,gp,-1400 # 4000184 <g_RiscvPrivMode>
    jal mem_cpy
 3000648:	ee5ff0ef          	jal	ra,300052c <mem_cpy>

0300064c <pmp_init>:

pmp_init:
    li t0, 0xB00
 300064c:	000012b7          	lui	t0,0x1
 3000650:	b0028293          	addi	t0,t0,-1280 # b00 <cipri+0x313>
    csrw pmpaddr0, t0
 3000654:	3b029073          	csrw	pmpaddr0,t0
    li t0, 0x400400   /* 0x2C00~0x1000FFF, BOOTROM, enable R+X */
 3000658:	004002b7          	lui	t0,0x400
 300065c:	40028293          	addi	t0,t0,1024 # 400400 <FLASH_SIZE+0x3e0404>
    csrw pmpaddr1, t0
 3000660:	3b129073          	csrw	pmpaddr1,t0
    li t0, 0x800000   /* 0x1001000~0x1FFFFFF, Reserved: diable R+X+W */
 3000664:	008002b7          	lui	t0,0x800
    csrw pmpaddr2, t0
 3000668:	3b229073          	csrw	pmpaddr2,t0
    li t0, 0x802000   /* 0x2000000~0x2007FFF, SYSRAM_ITCM */
 300066c:	008022b7          	lui	t0,0x802
    csrw pmpaddr3, t0
 3000670:	3b329073          	csrw	pmpaddr3,t0
    li t0, 0xC00000   /* 0x2008000 ~ 0x2FFFFFF, Reserved: disable R+X+W */
 3000674:	00c002b7          	lui	t0,0xc00
    csrw pmpaddr4, t0
 3000678:	3b429073          	csrw	pmpaddr4,t0
    li t0, 0x1000000  /* 0x3000000 ~ 0x03FFFFFF: EFLASH: enable R+X */
 300067c:	010002b7          	lui	t0,0x1000
    csrw pmpaddr5, t0
 3000680:	3b529073          	csrw	pmpaddr5,t0
    li t0, 0x1002000  /* 0x4000000 ~ 0x04007FFF: SYSTEM_DTCM enable R+W */
 3000684:	010022b7          	lui	t0,0x1002
    csrw pmpaddr6, t0
 3000688:	3b629073          	csrw	pmpaddr6,t0
    li t0,0x7000400   /* 0x4008000 ~ 0x01C000FFF: REGISTER R+W  */
 300068c:	070002b7          	lui	t0,0x7000
 3000690:	40028293          	addi	t0,t0,1024 # 7000400 <RAM_END+0x2ff8400>
    csrw pmpaddr7, t0
 3000694:	3b729073          	csrw	pmpaddr7,t0

    li t0,0xf3333333  /* register TOR-R-W */
 3000698:	f33332b7          	lui	t0,0xf3333
 300069c:	33328293          	addi	t0,t0,819 # f3333333 <RAM_END+0xef32b333>
    csrw 0x7d8,t0
 30006a0:	7d829073          	csrw	0x7d8,t0
#if defined(USER_MODE_ENABLE) && (USER_MODE_ENABLE == 1)
    li t0,0x0d080d8b  /* 0x0d:TOR-R-X; 0x0b:TOR-R-W; 0x08:TOR; 0x0c:TOR-x; 0x09:TOR-R */
 30006a4:	0d0812b7          	lui	t0,0xd081
 30006a8:	d8b28293          	addi	t0,t0,-629 # d080d8b <RAM_END+0x9078d8b>
    csrw pmpcfg0,t0
 30006ac:	3a029073          	csrw	pmpcfg0,t0
    li t0,0x0b0b0d08
 30006b0:	0b0b12b7          	lui	t0,0xb0b1
 30006b4:	d0828293          	addi	t0,t0,-760 # b0b0d08 <RAM_END+0x70a8d08>
    csrw pmpcfg1,t0
 30006b8:	3a129073          	csrw	pmpcfg1,t0
    li t0,0x8b8b8d88
    csrw pmpcfg1,t0
#endif

/* disable Icache */
    csrwi  0x7C0, 0x0 /* disable ICACHE */
 30006bc:	7c005073          	csrwi	0x7c0,0
    fence
 30006c0:	0ff0000f          	fence

/* disable Dcache */
    csrwi  0x7C1, 0x0 /* disable DCACHE */
 30006c4:	7c105073          	csrwi	0x7c1,0
    fence
 30006c8:	0ff0000f          	fence

/* support float and mie */
    li t0,0x2008
 30006cc:	000022b7          	lui	t0,0x2
 30006d0:	00828293          	addi	t0,t0,8 # 2008 <__bss_size__+0x1394>
    csrs mstatus,t0
 30006d4:	3002a073          	csrs	mstatus,t0
    li t0,0x20
 30006d8:	02000293          	li	t0,32
    csrs misa,t0
 30006dc:	3012a073          	csrs	misa,t0

/* Interrupt set default priority = 1*/
    li t0, 0x11111111
 30006e0:	111112b7          	lui	t0,0x11111
 30006e4:	11128293          	addi	t0,t0,273 # 11111111 <RAM_END+0xd109111>
    csrw locipri0, t0
 30006e8:	bc029073          	csrw	0xbc0,t0
    csrw locipri1, t0
 30006ec:	bc129073          	csrw	0xbc1,t0
    csrw locipri2, t0
 30006f0:	bc229073          	csrw	0xbc2,t0
    csrw locipri3, t0
 30006f4:	bc329073          	csrw	0xbc3,t0
    csrw locipri4, t0
 30006f8:	bc429073          	csrw	0xbc4,t0
    csrw locipri5, t0
 30006fc:	bc529073          	csrw	0xbc5,t0
    csrw locipri6, t0
 3000700:	bc629073          	csrw	0xbc6,t0
    csrw locipri7, t0
 3000704:	bc729073          	csrw	0xbc7,t0
    csrw locipri8, t0
 3000708:	bc829073          	csrw	0xbc8,t0
    csrw locipri9, t0
 300070c:	bc929073          	csrw	0xbc9,t0
    csrw locipri10, t0
 3000710:	bca29073          	csrw	0xbca,t0
    csrw locipri11, t0
 3000714:	bcb29073          	csrw	0xbcb,t0
    csrw locipri12, t0
 3000718:	bcc29073          	csrw	0xbcc,t0
    csrw locipri13, t0
 300071c:	bcd29073          	csrw	0xbcd,t0
    csrw locipri14, t0
 3000720:	bce29073          	csrw	0xbce,t0
    csrw locipri15, t0
 3000724:	bcf29073          	csrw	0xbcf,t0

    ecall
 3000728:	00000073          	ecall
    jal Chip_Init
 300072c:	014000ef          	jal	ra,3000740 <Chip_Init>

/* jump to C func. */
    jal main
 3000730:	60d0b0ef          	jal	ra,300c53c <main>

03000734 <dead_loop>:

dead_loop:
    j dead_loop
 3000734:	0000006f          	j	3000734 <dead_loop>

Disassembly of section .text:

03000738 <Chip_InitFail>:
 * @brief Chip Init Fail Process, deadloop if Chip Init fail
 * @param None
 * @retval None
 */
static inline void Chip_InitFail(void)
{
 3000738:	1141                	addi	sp,sp,-16
 300073a:	c622                	sw	s0,12(sp)
 300073c:	0800                	addi	s0,sp,16
    while (1) {
 300073e:	a001                	j	300073e <Chip_InitFail+0x6>

03000740 <Chip_Init>:
 * @brief Chip Init
 * @param None
 * @retval None
 */
void Chip_Init(void)
{
 3000740:	1101                	addi	sp,sp,-32
 3000742:	ce06                	sw	ra,28(sp)
 3000744:	cc22                	sw	s0,24(sp)
 3000746:	1000                	addi	s0,sp,32
    CRG_CoreClkSelect coreClkSelect;
    /* Config CRG */
    if (CRG_Config(&coreClkSelect) != BASE_STATUS_OK) {
 3000748:	fec40793          	addi	a5,s0,-20
 300074c:	853e                	mv	a0,a5
 300074e:	37c0c0ef          	jal	ra,300caca <CRG_Config>
 3000752:	87aa                	mv	a5,a0
 3000754:	c391                	beqz	a5,3000758 <Chip_Init+0x18>
        Chip_InitFail();
 3000756:	37cd                	jal	ra,3000738 <Chip_InitFail>
    }

    /* Config FLASH Clock */
    FLASH_ClockConfig(coreClkSelect);
 3000758:	fec42783          	lw	a5,-20(s0)
 300075c:	853e                	mv	a0,a5
 300075e:	792000ef          	jal	ra,3000ef0 <FLASH_ClockConfig>
    SYSTICK_Init();
 3000762:	053000ef          	jal	ra,3000fb4 <SYSTICK_Init>
    /* Set CoreClock Select after FLASH Config Done */
    CRG_SetCoreClockSelect(coreClkSelect);
 3000766:	fec42783          	lw	a5,-20(s0)
 300076a:	853e                	mv	a0,a5
 300076c:	25a1                	jal	ra,3000db4 <CRG_SetCoreClockSelect>

    IRQ_Init();
 300076e:	794020ef          	jal	ra,3002f02 <IRQ_Init>
    ANAVREF_Init();
 3000772:	23d5                	jal	ra,3000d56 <ANAVREF_Init>
    ANATRIM_Entry();
 3000774:	2b41                	jal	ra,3000d04 <ANATRIM_Entry>
    /* User Add Code Here */
 3000776:	0001                	nop
 3000778:	40f2                	lw	ra,28(sp)
 300077a:	4462                	lw	s0,24(sp)
 300077c:	6105                	addi	sp,sp,32
 300077e:	8082                	ret

03000780 <CalculateGain>:
 * @brief Calculate the conversion gain of the tsensor.
 * @param data, original data.
 * @retval None
 */
static void CalculateGain(unsigned int data)
{
 3000780:	1101                	addi	sp,sp,-32
 3000782:	ce22                	sw	s0,28(sp)
 3000784:	1000                	addi	s0,sp,32
 3000786:	fea42623          	sw	a0,-20(s0)
    g_tsensorGain = ((float)(data) / 10000000.0f);
 300078a:	fec42783          	lw	a5,-20(s0)
 300078e:	d017f753          	fcvt.s.wu	fa4,a5
 3000792:	030107b7          	lui	a5,0x3010
 3000796:	50c7a787          	flw	fa5,1292(a5) # 301050c <__rodata_start>
 300079a:	18f777d3          	fdiv.s	fa5,fa4,fa5
 300079e:	90f1a227          	fsw	fa5,-1788(gp) # 4000000 <g_tsensorGain>
}
 30007a2:	0001                	nop
 30007a4:	4472                	lw	s0,28(sp)
 30007a6:	6105                	addi	sp,sp,32
 30007a8:	8082                	ret

030007aa <CHIP_GetInfo>:
 * @brief Obtains the chip ID.
 * @param None
 * @retval None
 */
static bool CHIP_GetInfo(void)
{
 30007aa:	7179                	addi	sp,sp,-48
 30007ac:	d606                	sw	ra,44(sp)
 30007ae:	d422                	sw	s0,40(sp)
 30007b0:	1800                	addi	s0,sp,48
    FOTP_INFO_RGN0_NUMBER_4 emptyData;
    FOTP_INFO_RGN0_NUMBER_2 idData;
    FOTP_InfoGet(FOTP_INFO_RNG0, 4U, (void *)&emptyData.comData);   /* 4 is the number of fotp_empty_flag in otp */
 30007b2:	fe040793          	addi	a5,s0,-32
 30007b6:	863e                	mv	a2,a5
 30007b8:	4591                	li	a1,4
 30007ba:	4501                	li	a0,0
 30007bc:	2391                	jal	ra,3000d00 <FOTP_InfoGet.trans.36>
    FOTP_InfoGet(FOTP_INFO_RNG0, 2U, (void *)&idData.comData);      /* 2 is the number of idData in otp */
 30007be:	fd040793          	addi	a5,s0,-48
 30007c2:	863e                	mv	a2,a5
 30007c4:	4589                	li	a1,2
 30007c6:	4501                	li	a0,0
 30007c8:	2b25                	jal	ra,3000d00 <FOTP_InfoGet.trans.36>
    if (emptyData.REG.fotp_empty_flag != 0x5AA59669 || idData.REG.chip_id == 0xFFFFFFFF) {
 30007ca:	fe042703          	lw	a4,-32(s0)
 30007ce:	5aa597b7          	lui	a5,0x5aa59
 30007d2:	66978793          	addi	a5,a5,1641 # 5aa59669 <RAM_END+0x56a51669>
 30007d6:	00f71763          	bne	a4,a5,30007e4 <CHIP_GetInfo+0x3a>
 30007da:	fd042703          	lw	a4,-48(s0)
 30007de:	57fd                	li	a5,-1
 30007e0:	00f71463          	bne	a4,a5,30007e8 <CHIP_GetInfo+0x3e>
        return false;
 30007e4:	4781                	li	a5,0
 30007e6:	a011                	j	30007ea <CHIP_GetInfo+0x40>
    }
    return true;
 30007e8:	4785                	li	a5,1
}
 30007ea:	853e                	mv	a0,a5
 30007ec:	50b2                	lw	ra,44(sp)
 30007ee:	5422                	lw	s0,40(sp)
 30007f0:	6145                	addi	sp,sp,48
 30007f2:	8082                	ret

030007f4 <CHIP_AnalogTrim>:
 * @brief Analog module trim.
 * @param None
 * @retval None
 */
static void CHIP_AnalogTrim(void)
{
 30007f4:	711d                	addi	sp,sp,-96
 30007f6:	ce86                	sw	ra,92(sp)
 30007f8:	cca2                	sw	s0,88(sp)
 30007fa:	1080                	addi	s0,sp,96
    FOTP_INFO_RGN0_NUMBER_20 trimData20;
    FOTP_InfoGet(FOTP_INFO_RNG0, 20U, (void *)&trimData20.comData); /* 20 is the number of trim data in otp */
 30007fc:	fdc40793          	addi	a5,s0,-36
 3000800:	863e                	mv	a2,a5
 3000802:	45d1                	li	a1,20
 3000804:	4501                	li	a0,0
 3000806:	29ed                	jal	ra,3000d00 <FOTP_InfoGet.trans.36>
    /* VREF */
    VREF->VREF_TRIM0.BIT.da_iref_trim = trimData20.REG.data0.da_iref_trim;
 3000808:	18100737          	lui	a4,0x18100
 300080c:	fdc42783          	lw	a5,-36(s0)
 3000810:	83c1                	srli	a5,a5,0x10
 3000812:	9bfd                	andi	a5,a5,-1
 3000814:	0ff7f693          	andi	a3,a5,255
 3000818:	433c                	lw	a5,64(a4)
 300081a:	0ff6f693          	andi	a3,a3,255
 300081e:	f007f793          	andi	a5,a5,-256
 3000822:	8fd5                	or	a5,a5,a3
 3000824:	c33c                	sw	a5,64(a4)
    VREF->VREF_TRIM0.BIT.da_ref_vref_trim = trimData20.REG.data0.da_ref_vref_trim;
 3000826:	18100737          	lui	a4,0x18100
 300082a:	fdc42783          	lw	a5,-36(s0)
 300082e:	83a1                	srli	a5,a5,0x8
 3000830:	9bfd                	andi	a5,a5,-1
 3000832:	0ff7f693          	andi	a3,a5,255
 3000836:	433c                	lw	a5,64(a4)
 3000838:	0ff6f693          	andi	a3,a3,255
 300083c:	06a2                	slli	a3,a3,0x8
 300083e:	7641                	lui	a2,0xffff0
 3000840:	0ff60613          	addi	a2,a2,255 # ffff00ff <RAM_END+0xfbfe80ff>
 3000844:	8ff1                	and	a5,a5,a2
 3000846:	8fd5                	or	a5,a5,a3
 3000848:	c33c                	sw	a5,64(a4)
    VREF->VREF_TRIM0.BIT.da_ref_vbg_trim = trimData20.REG.data0.da_ref_vbg_trim;
 300084a:	18100737          	lui	a4,0x18100
 300084e:	fdc42783          	lw	a5,-36(s0)
 3000852:	0ff7f693          	andi	a3,a5,255
 3000856:	433c                	lw	a5,64(a4)
 3000858:	0ff6f693          	andi	a3,a3,255
 300085c:	06c2                	slli	a3,a3,0x10
 300085e:	ff010637          	lui	a2,0xff010
 3000862:	167d                	addi	a2,a2,-1 # ff00ffff <RAM_END+0xfb007fff>
 3000864:	8ff1                	and	a5,a5,a2
 3000866:	8fd5                	or	a5,a5,a3
 3000868:	c33c                	sw	a5,64(a4)
    unsigned int value = trimData20.REG.data1.da_ref_temp_trim3;
 300086a:	fe042783          	lw	a5,-32(s0)
 300086e:	83c1                	srli	a5,a5,0x10
 3000870:	9bfd                	andi	a5,a5,-1
 3000872:	9f81                	uxtb	a5
 3000874:	fef42623          	sw	a5,-20(s0)
    value |= (trimData20.REG.data1.da_ref_temp_trim2 << 8U);    /* Shift left by 8 bits */
 3000878:	fe042783          	lw	a5,-32(s0)
 300087c:	83a1                	srli	a5,a5,0x8
 300087e:	9bfd                	andi	a5,a5,-1
 3000880:	9f81                	uxtb	a5
 3000882:	07a2                	slli	a5,a5,0x8
 3000884:	873e                	mv	a4,a5
 3000886:	fec42783          	lw	a5,-20(s0)
 300088a:	8fd9                	or	a5,a5,a4
 300088c:	fef42623          	sw	a5,-20(s0)
    value |= (trimData20.REG.data1.da_ref_temp_trim1 << 16U);   /* Shift left by 16 bits */
 3000890:	fe042783          	lw	a5,-32(s0)
 3000894:	9f81                	uxtb	a5
 3000896:	07c2                	slli	a5,a5,0x10
 3000898:	873e                	mv	a4,a5
 300089a:	fec42783          	lw	a5,-20(s0)
 300089e:	8fd9                	or	a5,a5,a4
 30008a0:	fef42623          	sw	a5,-20(s0)
    value |= (trimData20.REG.data0.da_ref_temp_trim0 << 24U);   /* Shift left by 24 bits */
 30008a4:	fdc42783          	lw	a5,-36(s0)
 30008a8:	83e1                	srli	a5,a5,0x18
 30008aa:	9f81                	uxtb	a5
 30008ac:	07e2                	slli	a5,a5,0x18
 30008ae:	873e                	mv	a4,a5
 30008b0:	fec42783          	lw	a5,-20(s0)
 30008b4:	8fd9                	or	a5,a5,a4
 30008b6:	fef42623          	sw	a5,-20(s0)
    VREF->VREF_TRIM1.reg = value;
 30008ba:	181007b7          	lui	a5,0x18100
 30008be:	fec42703          	lw	a4,-20(s0)
 30008c2:	c3f8                	sw	a4,68(a5)

    FOTP_INFO_RGN0_NUMBER_21 trimData21;
    FOTP_InfoGet(FOTP_INFO_RNG0, 21U, (void *)&trimData21.comData); /* 21 is the number of trim data in otp */
 30008c4:	fcc40793          	addi	a5,s0,-52
 30008c8:	863e                	mv	a2,a5
 30008ca:	45d5                	li	a1,21
 30008cc:	4501                	li	a0,0
 30008ce:	290d                	jal	ra,3000d00 <FOTP_InfoGet.trans.36>
    /* ADC */
    ADC0->ADC_OEGE_TRIM.BIT.cfg_gain_cali_trim = trimData21.REG.data1.saradc_gain;
 30008d0:	18000737          	lui	a4,0x18000
 30008d4:	fd042783          	lw	a5,-48(s0)
 30008d8:	86be                	mv	a3,a5
 30008da:	6789                	lui	a5,0x2
 30008dc:	17fd                	addi	a5,a5,-1 # 1fff <__bss_size__+0x138b>
 30008de:	8ff5                	and	a5,a5,a3
 30008e0:	01079613          	slli	a2,a5,0x10
 30008e4:	8241                	srli	a2,a2,0x10
 30008e6:	6785                	lui	a5,0x1
 30008e8:	973e                	add	a4,a4,a5
 30008ea:	80472783          	lw	a5,-2044(a4) # 17fff804 <RAM_END+0x13ff7804>
 30008ee:	6689                	lui	a3,0x2
 30008f0:	16fd                	addi	a3,a3,-1 # 1fff <__bss_size__+0x138b>
 30008f2:	8ef1                	and	a3,a3,a2
 30008f4:	06c2                	slli	a3,a3,0x10
 30008f6:	e0010637          	lui	a2,0xe0010
 30008fa:	167d                	addi	a2,a2,-1 # e000ffff <RAM_END+0xdc007fff>
 30008fc:	8ff1                	and	a5,a5,a2
 30008fe:	8fd5                	or	a5,a5,a3
 3000900:	80f72223          	sw	a5,-2044(a4)
    ADC0->ADC_OEGE_TRIM.BIT.cfg_ofst_cali_trim = trimData21.REG.data1.saradc_offset;
 3000904:	18000737          	lui	a4,0x18000
 3000908:	fd042783          	lw	a5,-48(s0)
 300090c:	83c1                	srli	a5,a5,0x10
 300090e:	86be                	mv	a3,a5
 3000910:	6785                	lui	a5,0x1
 3000912:	17fd                	addi	a5,a5,-1 # fff <__bss_size__+0x38b>
 3000914:	8ff5                	and	a5,a5,a3
 3000916:	01079613          	slli	a2,a5,0x10
 300091a:	8241                	srli	a2,a2,0x10
 300091c:	6785                	lui	a5,0x1
 300091e:	973e                	add	a4,a4,a5
 3000920:	80472783          	lw	a5,-2044(a4) # 17fff804 <RAM_END+0x13ff7804>
 3000924:	6685                	lui	a3,0x1
 3000926:	16fd                	addi	a3,a3,-1 # fff <__bss_size__+0x38b>
 3000928:	8ef1                	and	a3,a3,a2
 300092a:	767d                	lui	a2,0xfffff
 300092c:	8ff1                	and	a5,a5,a2
 300092e:	8fd5                	or	a5,a5,a3
 3000930:	80f72223          	sw	a5,-2044(a4)
   
    /* TSENSOR */
    TSENSOR->TSENSOR_TRIM.reg = trimData20.REG.data1.da_ref_vptat_trim;
 3000934:	fe042783          	lw	a5,-32(s0)
 3000938:	83e1                	srli	a5,a5,0x18
 300093a:	0ff7f713          	andi	a4,a5,255
 300093e:	185007b7          	lui	a5,0x18500
 3000942:	cb98                	sw	a4,16(a5)
    ADC0->ADC_TSENSOR_TRIM.BIT.cfg_tsensor_ofst_trim = trimData21.REG.data2.ts_offset;
 3000944:	18000737          	lui	a4,0x18000
 3000948:	fd442783          	lw	a5,-44(s0)
 300094c:	86be                	mv	a3,a5
 300094e:	6785                	lui	a5,0x1
 3000950:	17fd                	addi	a5,a5,-1 # fff <__bss_size__+0x38b>
 3000952:	8ff5                	and	a5,a5,a3
 3000954:	01079613          	slli	a2,a5,0x10
 3000958:	8241                	srli	a2,a2,0x10
 300095a:	6785                	lui	a5,0x1
 300095c:	973e                	add	a4,a4,a5
 300095e:	80072783          	lw	a5,-2048(a4) # 17fff800 <RAM_END+0x13ff7800>
 3000962:	6685                	lui	a3,0x1
 3000964:	16fd                	addi	a3,a3,-1 # fff <__bss_size__+0x38b>
 3000966:	8ef1                	and	a3,a3,a2
 3000968:	767d                	lui	a2,0xfffff
 300096a:	8ff1                	and	a5,a5,a2
 300096c:	8fd5                	or	a5,a5,a3
 300096e:	80f72023          	sw	a5,-2048(a4)
    CalculateGain(trimData21.REG.data3.ts_gain);
 3000972:	fd842783          	lw	a5,-40(s0)
 3000976:	83a5                	srli	a5,a5,0x9
 3000978:	853e                	mv	a0,a5
 300097a:	3519                	jal	ra,3000780 <CalculateGain>

    /* PGA */
    PGA0->PGA_TRIM.BIT.da_pga_vos_trim = trimData21.REG.data0.da_pga0_vos_trim;
 300097c:	18200737          	lui	a4,0x18200
 3000980:	fcc42783          	lw	a5,-52(s0)
 3000984:	1ff7f793          	andi	a5,a5,511
 3000988:	01079693          	slli	a3,a5,0x10
 300098c:	82c1                	srli	a3,a3,0x10
 300098e:	531c                	lw	a5,32(a4)
 3000990:	1ff6f693          	andi	a3,a3,511
 3000994:	e007f793          	andi	a5,a5,-512
 3000998:	8fd5                	or	a5,a5,a3
 300099a:	d31c                	sw	a5,32(a4)
    PGA1->PGA_TRIM.BIT.da_pga_vos_trim = trimData21.REG.data0.da_pga1_vos_trim;
 300099c:	18201737          	lui	a4,0x18201
 30009a0:	fcc42783          	lw	a5,-52(s0)
 30009a4:	83c1                	srli	a5,a5,0x10
 30009a6:	1ff7f793          	andi	a5,a5,511
 30009aa:	01079693          	slli	a3,a5,0x10
 30009ae:	82c1                	srli	a3,a3,0x10
 30009b0:	531c                	lw	a5,32(a4)
 30009b2:	1ff6f693          	andi	a3,a3,511
 30009b6:	e007f793          	andi	a5,a5,-512
 30009ba:	8fd5                	or	a5,a5,a3
 30009bc:	d31c                	sw	a5,32(a4)

    FOTP_INFO_RGN0_NUMBER_22 trimData22;
    FOTP_InfoGet(FOTP_INFO_RNG0, 22U, (void *)&trimData22.comData); /* 22 is the number of trim data in otp */
 30009be:	fbc40793          	addi	a5,s0,-68
 30009c2:	863e                	mv	a2,a5
 30009c4:	45d9                	li	a1,22
 30009c6:	4501                	li	a0,0
 30009c8:	257d                	jal	ra,3001076 <FOTP_InfoGet>
    ADC0->ADC_PGA0_OEGE_TRIM0.BIT.cfg_pga0_gain_trim2 = trimData22.REG.data0.pga0_gain2;
 30009ca:	18000737          	lui	a4,0x18000
 30009ce:	fbc42783          	lw	a5,-68(s0)
 30009d2:	86be                	mv	a3,a5
 30009d4:	6789                	lui	a5,0x2
 30009d6:	17fd                	addi	a5,a5,-1 # 1fff <__bss_size__+0x138b>
 30009d8:	8ff5                	and	a5,a5,a3
 30009da:	01079613          	slli	a2,a5,0x10
 30009de:	8241                	srli	a2,a2,0x10
 30009e0:	6785                	lui	a5,0x1
 30009e2:	973e                	add	a4,a4,a5
 30009e4:	81072783          	lw	a5,-2032(a4) # 17fff810 <RAM_END+0x13ff7810>
 30009e8:	6689                	lui	a3,0x2
 30009ea:	16fd                	addi	a3,a3,-1 # 1fff <__bss_size__+0x138b>
 30009ec:	8ef1                	and	a3,a3,a2
 30009ee:	06c2                	slli	a3,a3,0x10
 30009f0:	e0010637          	lui	a2,0xe0010
 30009f4:	167d                	addi	a2,a2,-1 # e000ffff <RAM_END+0xdc007fff>
 30009f6:	8ff1                	and	a5,a5,a2
 30009f8:	8fd5                	or	a5,a5,a3
 30009fa:	80f72823          	sw	a5,-2032(a4)
    ADC0->ADC_PGA0_OEGE_TRIM0.BIT.cfg_pga0_ofst_trim2 = trimData22.REG.data0.pga0_offset2;
 30009fe:	18000737          	lui	a4,0x18000
 3000a02:	fbc42783          	lw	a5,-68(s0)
 3000a06:	83c1                	srli	a5,a5,0x10
 3000a08:	86be                	mv	a3,a5
 3000a0a:	6785                	lui	a5,0x1
 3000a0c:	17fd                	addi	a5,a5,-1 # fff <__bss_size__+0x38b>
 3000a0e:	8ff5                	and	a5,a5,a3
 3000a10:	01079613          	slli	a2,a5,0x10
 3000a14:	8241                	srli	a2,a2,0x10
 3000a16:	6785                	lui	a5,0x1
 3000a18:	973e                	add	a4,a4,a5
 3000a1a:	81072783          	lw	a5,-2032(a4) # 17fff810 <RAM_END+0x13ff7810>
 3000a1e:	6685                	lui	a3,0x1
 3000a20:	16fd                	addi	a3,a3,-1 # fff <__bss_size__+0x38b>
 3000a22:	8ef1                	and	a3,a3,a2
 3000a24:	767d                	lui	a2,0xfffff
 3000a26:	8ff1                	and	a5,a5,a2
 3000a28:	8fd5                	or	a5,a5,a3
 3000a2a:	80f72823          	sw	a5,-2032(a4)
    ADC0->ADC_PGA0_OEGE_TRIM1.BIT.cfg_pga0_gain_trim4 = trimData22.REG.data1.pga0_gain4;
 3000a2e:	18000737          	lui	a4,0x18000
 3000a32:	fc042783          	lw	a5,-64(s0)
 3000a36:	86be                	mv	a3,a5
 3000a38:	6789                	lui	a5,0x2
 3000a3a:	17fd                	addi	a5,a5,-1 # 1fff <__bss_size__+0x138b>
 3000a3c:	8ff5                	and	a5,a5,a3
 3000a3e:	01079613          	slli	a2,a5,0x10
 3000a42:	8241                	srli	a2,a2,0x10
 3000a44:	6785                	lui	a5,0x1
 3000a46:	973e                	add	a4,a4,a5
 3000a48:	81472783          	lw	a5,-2028(a4) # 17fff814 <RAM_END+0x13ff7814>
 3000a4c:	6689                	lui	a3,0x2
 3000a4e:	16fd                	addi	a3,a3,-1 # 1fff <__bss_size__+0x138b>
 3000a50:	8ef1                	and	a3,a3,a2
 3000a52:	06c2                	slli	a3,a3,0x10
 3000a54:	e0010637          	lui	a2,0xe0010
 3000a58:	167d                	addi	a2,a2,-1 # e000ffff <RAM_END+0xdc007fff>
 3000a5a:	8ff1                	and	a5,a5,a2
 3000a5c:	8fd5                	or	a5,a5,a3
 3000a5e:	80f72a23          	sw	a5,-2028(a4)
    ADC0->ADC_PGA0_OEGE_TRIM1.BIT.cfg_pga0_ofst_trim4 = trimData22.REG.data1.pga0_offset4;
 3000a62:	18000737          	lui	a4,0x18000
 3000a66:	fc042783          	lw	a5,-64(s0)
 3000a6a:	83c1                	srli	a5,a5,0x10
 3000a6c:	86be                	mv	a3,a5
 3000a6e:	6785                	lui	a5,0x1
 3000a70:	17fd                	addi	a5,a5,-1 # fff <__bss_size__+0x38b>
 3000a72:	8ff5                	and	a5,a5,a3
 3000a74:	01079613          	slli	a2,a5,0x10
 3000a78:	8241                	srli	a2,a2,0x10
 3000a7a:	6785                	lui	a5,0x1
 3000a7c:	973e                	add	a4,a4,a5
 3000a7e:	81472783          	lw	a5,-2028(a4) # 17fff814 <RAM_END+0x13ff7814>
 3000a82:	6685                	lui	a3,0x1
 3000a84:	16fd                	addi	a3,a3,-1 # fff <__bss_size__+0x38b>
 3000a86:	8ef1                	and	a3,a3,a2
 3000a88:	767d                	lui	a2,0xfffff
 3000a8a:	8ff1                	and	a5,a5,a2
 3000a8c:	8fd5                	or	a5,a5,a3
 3000a8e:	80f72a23          	sw	a5,-2028(a4)
    ADC0->ADC_PGA0_OEGE_TRIM2.BIT.cfg_pga0_gain_trim8 = trimData22.REG.data2.pga0_gain8;
 3000a92:	18000737          	lui	a4,0x18000
 3000a96:	fc442783          	lw	a5,-60(s0)
 3000a9a:	86be                	mv	a3,a5
 3000a9c:	6789                	lui	a5,0x2
 3000a9e:	17fd                	addi	a5,a5,-1 # 1fff <__bss_size__+0x138b>
 3000aa0:	8ff5                	and	a5,a5,a3
 3000aa2:	01079613          	slli	a2,a5,0x10
 3000aa6:	8241                	srli	a2,a2,0x10
 3000aa8:	6785                	lui	a5,0x1
 3000aaa:	973e                	add	a4,a4,a5
 3000aac:	81872783          	lw	a5,-2024(a4) # 17fff818 <RAM_END+0x13ff7818>
 3000ab0:	6689                	lui	a3,0x2
 3000ab2:	16fd                	addi	a3,a3,-1 # 1fff <__bss_size__+0x138b>
 3000ab4:	8ef1                	and	a3,a3,a2
 3000ab6:	06c2                	slli	a3,a3,0x10
 3000ab8:	e0010637          	lui	a2,0xe0010
 3000abc:	167d                	addi	a2,a2,-1 # e000ffff <RAM_END+0xdc007fff>
 3000abe:	8ff1                	and	a5,a5,a2
 3000ac0:	8fd5                	or	a5,a5,a3
 3000ac2:	80f72c23          	sw	a5,-2024(a4)
    ADC0->ADC_PGA0_OEGE_TRIM2.BIT.cfg_pga0_ofst_trim8 = trimData22.REG.data2.pga0_offset8;
 3000ac6:	18000737          	lui	a4,0x18000
 3000aca:	fc442783          	lw	a5,-60(s0)
 3000ace:	83c1                	srli	a5,a5,0x10
 3000ad0:	86be                	mv	a3,a5
 3000ad2:	6785                	lui	a5,0x1
 3000ad4:	17fd                	addi	a5,a5,-1 # fff <__bss_size__+0x38b>
 3000ad6:	8ff5                	and	a5,a5,a3
 3000ad8:	01079613          	slli	a2,a5,0x10
 3000adc:	8241                	srli	a2,a2,0x10
 3000ade:	6785                	lui	a5,0x1
 3000ae0:	973e                	add	a4,a4,a5
 3000ae2:	81872783          	lw	a5,-2024(a4) # 17fff818 <RAM_END+0x13ff7818>
 3000ae6:	6685                	lui	a3,0x1
 3000ae8:	16fd                	addi	a3,a3,-1 # fff <__bss_size__+0x38b>
 3000aea:	8ef1                	and	a3,a3,a2
 3000aec:	767d                	lui	a2,0xfffff
 3000aee:	8ff1                	and	a5,a5,a2
 3000af0:	8fd5                	or	a5,a5,a3
 3000af2:	80f72c23          	sw	a5,-2024(a4)
    ADC0->ADC_PGA0_OEGE_TRIM3.BIT.cfg_pga0_gain_trim16 = trimData22.REG.data3.pga0_gain16;
 3000af6:	18000737          	lui	a4,0x18000
 3000afa:	fc842783          	lw	a5,-56(s0)
 3000afe:	86be                	mv	a3,a5
 3000b00:	6789                	lui	a5,0x2
 3000b02:	17fd                	addi	a5,a5,-1 # 1fff <__bss_size__+0x138b>
 3000b04:	8ff5                	and	a5,a5,a3
 3000b06:	01079613          	slli	a2,a5,0x10
 3000b0a:	8241                	srli	a2,a2,0x10
 3000b0c:	6785                	lui	a5,0x1
 3000b0e:	973e                	add	a4,a4,a5
 3000b10:	81c72783          	lw	a5,-2020(a4) # 17fff81c <RAM_END+0x13ff781c>
 3000b14:	6689                	lui	a3,0x2
 3000b16:	16fd                	addi	a3,a3,-1 # 1fff <__bss_size__+0x138b>
 3000b18:	8ef1                	and	a3,a3,a2
 3000b1a:	06c2                	slli	a3,a3,0x10
 3000b1c:	e0010637          	lui	a2,0xe0010
 3000b20:	167d                	addi	a2,a2,-1 # e000ffff <RAM_END+0xdc007fff>
 3000b22:	8ff1                	and	a5,a5,a2
 3000b24:	8fd5                	or	a5,a5,a3
 3000b26:	80f72e23          	sw	a5,-2020(a4)
    ADC0->ADC_PGA0_OEGE_TRIM3.BIT.cfg_pga0_ofst_trim16 = trimData22.REG.data3.pga0_offset16;
 3000b2a:	18000737          	lui	a4,0x18000
 3000b2e:	fc842783          	lw	a5,-56(s0)
 3000b32:	83c1                	srli	a5,a5,0x10
 3000b34:	86be                	mv	a3,a5
 3000b36:	6785                	lui	a5,0x1
 3000b38:	17fd                	addi	a5,a5,-1 # fff <__bss_size__+0x38b>
 3000b3a:	8ff5                	and	a5,a5,a3
 3000b3c:	01079613          	slli	a2,a5,0x10
 3000b40:	8241                	srli	a2,a2,0x10
 3000b42:	6785                	lui	a5,0x1
 3000b44:	973e                	add	a4,a4,a5
 3000b46:	81c72783          	lw	a5,-2020(a4) # 17fff81c <RAM_END+0x13ff781c>
 3000b4a:	6685                	lui	a3,0x1
 3000b4c:	16fd                	addi	a3,a3,-1 # fff <__bss_size__+0x38b>
 3000b4e:	8ef1                	and	a3,a3,a2
 3000b50:	767d                	lui	a2,0xfffff
 3000b52:	8ff1                	and	a5,a5,a2
 3000b54:	8fd5                	or	a5,a5,a3
 3000b56:	80f72e23          	sw	a5,-2020(a4)

    FOTP_INFO_RGN0_NUMBER_23 trimData23;
    FOTP_InfoGet(FOTP_INFO_RNG0, 23U, (void *)&trimData23.comData); /* 23 is the number of trim data in otp */
 3000b5a:	fac40793          	addi	a5,s0,-84
 3000b5e:	863e                	mv	a2,a5
 3000b60:	45dd                	li	a1,23
 3000b62:	4501                	li	a0,0
 3000b64:	2b09                	jal	ra,3001076 <FOTP_InfoGet>
    ADC0->ADC_PGA1_OEGE_TRIM0.BIT.cfg_pga1_gain_trim2 = trimData23.REG.data0.pga1_gain2;
 3000b66:	18000737          	lui	a4,0x18000
 3000b6a:	fac42783          	lw	a5,-84(s0)
 3000b6e:	86be                	mv	a3,a5
 3000b70:	6789                	lui	a5,0x2
 3000b72:	17fd                	addi	a5,a5,-1 # 1fff <__bss_size__+0x138b>
 3000b74:	8ff5                	and	a5,a5,a3
 3000b76:	01079613          	slli	a2,a5,0x10
 3000b7a:	8241                	srli	a2,a2,0x10
 3000b7c:	6785                	lui	a5,0x1
 3000b7e:	973e                	add	a4,a4,a5
 3000b80:	82072783          	lw	a5,-2016(a4) # 17fff820 <RAM_END+0x13ff7820>
 3000b84:	6689                	lui	a3,0x2
 3000b86:	16fd                	addi	a3,a3,-1 # 1fff <__bss_size__+0x138b>
 3000b88:	8ef1                	and	a3,a3,a2
 3000b8a:	06c2                	slli	a3,a3,0x10
 3000b8c:	e0010637          	lui	a2,0xe0010
 3000b90:	167d                	addi	a2,a2,-1 # e000ffff <RAM_END+0xdc007fff>
 3000b92:	8ff1                	and	a5,a5,a2
 3000b94:	8fd5                	or	a5,a5,a3
 3000b96:	82f72023          	sw	a5,-2016(a4)
    ADC0->ADC_PGA1_OEGE_TRIM0.BIT.cfg_pga1_ofst_trim2 = trimData23.REG.data0.pga1_offset2;
 3000b9a:	18000737          	lui	a4,0x18000
 3000b9e:	fac42783          	lw	a5,-84(s0)
 3000ba2:	83c1                	srli	a5,a5,0x10
 3000ba4:	86be                	mv	a3,a5
 3000ba6:	6785                	lui	a5,0x1
 3000ba8:	17fd                	addi	a5,a5,-1 # fff <__bss_size__+0x38b>
 3000baa:	8ff5                	and	a5,a5,a3
 3000bac:	01079613          	slli	a2,a5,0x10
 3000bb0:	8241                	srli	a2,a2,0x10
 3000bb2:	6785                	lui	a5,0x1
 3000bb4:	973e                	add	a4,a4,a5
 3000bb6:	82072783          	lw	a5,-2016(a4) # 17fff820 <RAM_END+0x13ff7820>
 3000bba:	6685                	lui	a3,0x1
 3000bbc:	16fd                	addi	a3,a3,-1 # fff <__bss_size__+0x38b>
 3000bbe:	8ef1                	and	a3,a3,a2
 3000bc0:	767d                	lui	a2,0xfffff
 3000bc2:	8ff1                	and	a5,a5,a2
 3000bc4:	8fd5                	or	a5,a5,a3
 3000bc6:	82f72023          	sw	a5,-2016(a4)
    ADC0->ADC_PGA1_OEGE_TRIM1.BIT.cfg_pga1_gain_trim4 = trimData23.REG.data1.pga1_gain4;
 3000bca:	18000737          	lui	a4,0x18000
 3000bce:	fb042783          	lw	a5,-80(s0)
 3000bd2:	86be                	mv	a3,a5
 3000bd4:	6789                	lui	a5,0x2
 3000bd6:	17fd                	addi	a5,a5,-1 # 1fff <__bss_size__+0x138b>
 3000bd8:	8ff5                	and	a5,a5,a3
 3000bda:	01079613          	slli	a2,a5,0x10
 3000bde:	8241                	srli	a2,a2,0x10
 3000be0:	6785                	lui	a5,0x1
 3000be2:	973e                	add	a4,a4,a5
 3000be4:	82472783          	lw	a5,-2012(a4) # 17fff824 <RAM_END+0x13ff7824>
 3000be8:	6689                	lui	a3,0x2
 3000bea:	16fd                	addi	a3,a3,-1 # 1fff <__bss_size__+0x138b>
 3000bec:	8ef1                	and	a3,a3,a2
 3000bee:	06c2                	slli	a3,a3,0x10
 3000bf0:	e0010637          	lui	a2,0xe0010
 3000bf4:	167d                	addi	a2,a2,-1 # e000ffff <RAM_END+0xdc007fff>
 3000bf6:	8ff1                	and	a5,a5,a2
 3000bf8:	8fd5                	or	a5,a5,a3
 3000bfa:	82f72223          	sw	a5,-2012(a4)
    ADC0->ADC_PGA1_OEGE_TRIM1.BIT.cfg_pga1_ofst_trim4 = trimData23.REG.data1.pga1_offset4;
 3000bfe:	18000737          	lui	a4,0x18000
 3000c02:	fb042783          	lw	a5,-80(s0)
 3000c06:	83c1                	srli	a5,a5,0x10
 3000c08:	86be                	mv	a3,a5
 3000c0a:	6785                	lui	a5,0x1
 3000c0c:	17fd                	addi	a5,a5,-1 # fff <__bss_size__+0x38b>
 3000c0e:	8ff5                	and	a5,a5,a3
 3000c10:	01079613          	slli	a2,a5,0x10
 3000c14:	8241                	srli	a2,a2,0x10
 3000c16:	6785                	lui	a5,0x1
 3000c18:	973e                	add	a4,a4,a5
 3000c1a:	82472783          	lw	a5,-2012(a4) # 17fff824 <RAM_END+0x13ff7824>
 3000c1e:	6685                	lui	a3,0x1
 3000c20:	16fd                	addi	a3,a3,-1 # fff <__bss_size__+0x38b>
 3000c22:	8ef1                	and	a3,a3,a2
 3000c24:	767d                	lui	a2,0xfffff
 3000c26:	8ff1                	and	a5,a5,a2
 3000c28:	8fd5                	or	a5,a5,a3
 3000c2a:	82f72223          	sw	a5,-2012(a4)
    ADC0->ADC_PGA1_OEGE_TRIM2.BIT.cfg_pga1_gain_trim8 = trimData23.REG.data2.pga1_gain8;
 3000c2e:	18000737          	lui	a4,0x18000
 3000c32:	fb442783          	lw	a5,-76(s0)
 3000c36:	86be                	mv	a3,a5
 3000c38:	6789                	lui	a5,0x2
 3000c3a:	17fd                	addi	a5,a5,-1 # 1fff <__bss_size__+0x138b>
 3000c3c:	8ff5                	and	a5,a5,a3
 3000c3e:	01079613          	slli	a2,a5,0x10
 3000c42:	8241                	srli	a2,a2,0x10
 3000c44:	6785                	lui	a5,0x1
 3000c46:	973e                	add	a4,a4,a5
 3000c48:	82872783          	lw	a5,-2008(a4) # 17fff828 <RAM_END+0x13ff7828>
 3000c4c:	6689                	lui	a3,0x2
 3000c4e:	16fd                	addi	a3,a3,-1 # 1fff <__bss_size__+0x138b>
 3000c50:	8ef1                	and	a3,a3,a2
 3000c52:	06c2                	slli	a3,a3,0x10
 3000c54:	e0010637          	lui	a2,0xe0010
 3000c58:	167d                	addi	a2,a2,-1 # e000ffff <RAM_END+0xdc007fff>
 3000c5a:	8ff1                	and	a5,a5,a2
 3000c5c:	8fd5                	or	a5,a5,a3
 3000c5e:	82f72423          	sw	a5,-2008(a4)
    ADC0->ADC_PGA1_OEGE_TRIM2.BIT.cfg_pga1_ofst_trim8 = trimData23.REG.data2.pga1_offset8;
 3000c62:	18000737          	lui	a4,0x18000
 3000c66:	fb442783          	lw	a5,-76(s0)
 3000c6a:	83c1                	srli	a5,a5,0x10
 3000c6c:	86be                	mv	a3,a5
 3000c6e:	6785                	lui	a5,0x1
 3000c70:	17fd                	addi	a5,a5,-1 # fff <__bss_size__+0x38b>
 3000c72:	8ff5                	and	a5,a5,a3
 3000c74:	01079613          	slli	a2,a5,0x10
 3000c78:	8241                	srli	a2,a2,0x10
 3000c7a:	6785                	lui	a5,0x1
 3000c7c:	973e                	add	a4,a4,a5
 3000c7e:	82872783          	lw	a5,-2008(a4) # 17fff828 <RAM_END+0x13ff7828>
 3000c82:	6685                	lui	a3,0x1
 3000c84:	16fd                	addi	a3,a3,-1 # fff <__bss_size__+0x38b>
 3000c86:	8ef1                	and	a3,a3,a2
 3000c88:	767d                	lui	a2,0xfffff
 3000c8a:	8ff1                	and	a5,a5,a2
 3000c8c:	8fd5                	or	a5,a5,a3
 3000c8e:	82f72423          	sw	a5,-2008(a4)
    ADC0->ADC_PGA1_OEGE_TRIM3.BIT.cfg_pga1_gain_trim16 = trimData23.REG.data3.pga1_gain16;
 3000c92:	18000737          	lui	a4,0x18000
 3000c96:	fb842783          	lw	a5,-72(s0)
 3000c9a:	86be                	mv	a3,a5
 3000c9c:	6789                	lui	a5,0x2
 3000c9e:	17fd                	addi	a5,a5,-1 # 1fff <__bss_size__+0x138b>
 3000ca0:	8ff5                	and	a5,a5,a3
 3000ca2:	01079613          	slli	a2,a5,0x10
 3000ca6:	8241                	srli	a2,a2,0x10
 3000ca8:	6785                	lui	a5,0x1
 3000caa:	973e                	add	a4,a4,a5
 3000cac:	82c72783          	lw	a5,-2004(a4) # 17fff82c <RAM_END+0x13ff782c>
 3000cb0:	6689                	lui	a3,0x2
 3000cb2:	16fd                	addi	a3,a3,-1 # 1fff <__bss_size__+0x138b>
 3000cb4:	8ef1                	and	a3,a3,a2
 3000cb6:	06c2                	slli	a3,a3,0x10
 3000cb8:	e0010637          	lui	a2,0xe0010
 3000cbc:	167d                	addi	a2,a2,-1 # e000ffff <RAM_END+0xdc007fff>
 3000cbe:	8ff1                	and	a5,a5,a2
 3000cc0:	8fd5                	or	a5,a5,a3
 3000cc2:	82f72623          	sw	a5,-2004(a4)
    ADC0->ADC_PGA1_OEGE_TRIM3.BIT.cfg_pga1_ofst_trim16 = trimData23.REG.data3.pga1_offset16;
 3000cc6:	18000737          	lui	a4,0x18000
 3000cca:	fb842783          	lw	a5,-72(s0)
 3000cce:	83c1                	srli	a5,a5,0x10
 3000cd0:	86be                	mv	a3,a5
 3000cd2:	6785                	lui	a5,0x1
 3000cd4:	17fd                	addi	a5,a5,-1 # fff <__bss_size__+0x38b>
 3000cd6:	8ff5                	and	a5,a5,a3
 3000cd8:	01079613          	slli	a2,a5,0x10
 3000cdc:	8241                	srli	a2,a2,0x10
 3000cde:	6785                	lui	a5,0x1
 3000ce0:	973e                	add	a4,a4,a5
 3000ce2:	82c72783          	lw	a5,-2004(a4) # 17fff82c <RAM_END+0x13ff782c>
 3000ce6:	6685                	lui	a3,0x1
 3000ce8:	16fd                	addi	a3,a3,-1 # fff <__bss_size__+0x38b>
 3000cea:	8ef1                	and	a3,a3,a2
 3000cec:	767d                	lui	a2,0xfffff
 3000cee:	8ff1                	and	a5,a5,a2
 3000cf0:	8fd5                	or	a5,a5,a3
 3000cf2:	82f72623          	sw	a5,-2004(a4)
}
 3000cf6:	0001                	nop
 3000cf8:	40f6                	lw	ra,92(sp)
 3000cfa:	4466                	lw	s0,88(sp)
 3000cfc:	6125                	addi	sp,sp,96
 3000cfe:	8082                	ret

03000d00 <FOTP_InfoGet.trans.36>:
 3000d00:	3760006f          	j	3001076 <FOTP_InfoGet>

03000d04 <ANATRIM_Entry>:
 * @brief Parameter calibration entry of the analog module.
 * @param None
 * @retval None
 */
void ANATRIM_Entry(void)
{
 3000d04:	1141                	addi	sp,sp,-16
 3000d06:	c606                	sw	ra,12(sp)
 3000d08:	c422                	sw	s0,8(sp)
 3000d0a:	0800                	addi	s0,sp,16
    if (CHIP_GetInfo() == false) { /* If the chip information is incorrect, calibration is not performed */
 3000d0c:	3c79                	jal	ra,30007aa <CHIP_GetInfo>
 3000d0e:	87aa                	mv	a5,a0
 3000d10:	0017c793          	xori	a5,a5,1
 3000d14:	9f81                	uxtb	a5
 3000d16:	eb9d                	bnez	a5,3000d4c <ANATRIM_Entry+0x48>
        return;
    }
    HAL_CRG_IpEnableSet((void *)ADC0, IP_CLK_ENABLE); /* Enable the clock for calibration */
 3000d18:	4585                	li	a1,1
 3000d1a:	18000537          	lui	a0,0x18000
 3000d1e:	2849                	jal	ra,3000db0 <HAL_CRG_IpEnableSet.trans.19>
    HAL_CRG_IpEnableSet((void *)PGA0, IP_CLK_ENABLE);
 3000d20:	4585                	li	a1,1
 3000d22:	18200537          	lui	a0,0x18200
 3000d26:	2069                	jal	ra,3000db0 <HAL_CRG_IpEnableSet.trans.19>
    HAL_CRG_IpEnableSet((void *)PGA1, IP_CLK_ENABLE);
 3000d28:	4585                	li	a1,1
 3000d2a:	18201537          	lui	a0,0x18201
 3000d2e:	2049                	jal	ra,3000db0 <HAL_CRG_IpEnableSet.trans.19>
    CHIP_AnalogTrim();
 3000d30:	34d1                	jal	ra,30007f4 <CHIP_AnalogTrim>
    HAL_CRG_IpEnableSet((void *)ADC0, IP_CLK_DISABLE); /* The clock is disabled after calibration */
 3000d32:	4581                	li	a1,0
 3000d34:	18000537          	lui	a0,0x18000
 3000d38:	28a5                	jal	ra,3000db0 <HAL_CRG_IpEnableSet.trans.19>
    HAL_CRG_IpEnableSet((void *)PGA0, IP_CLK_DISABLE);
 3000d3a:	4581                	li	a1,0
 3000d3c:	18200537          	lui	a0,0x18200
 3000d40:	2885                	jal	ra,3000db0 <HAL_CRG_IpEnableSet.trans.19>
    HAL_CRG_IpEnableSet((void *)PGA1, IP_CLK_DISABLE);
 3000d42:	4581                	li	a1,0
 3000d44:	18201537          	lui	a0,0x18201
 3000d48:	20a5                	jal	ra,3000db0 <HAL_CRG_IpEnableSet.trans.19>
 3000d4a:	a011                	j	3000d4e <ANATRIM_Entry+0x4a>
        return;
 3000d4c:	0001                	nop
 3000d4e:	40b2                	lw	ra,12(sp)
 3000d50:	4422                	lw	s0,8(sp)
 3000d52:	0141                	addi	sp,sp,16
 3000d54:	8082                	ret

03000d56 <ANAVREF_Init>:
 * @brief Set Crg Core clock select
 * @param None
 * @retval None
 */
void ANAVREF_Init(void)
{
 3000d56:	1141                	addi	sp,sp,-16
 3000d58:	c606                	sw	ra,12(sp)
 3000d5a:	c422                	sw	s0,8(sp)
 3000d5c:	0800                	addi	s0,sp,16
    HAL_CRG_IpEnableSet(VREF_BASE, IP_CLK_ENABLE);
 3000d5e:	4585                	li	a1,1
 3000d60:	18100537          	lui	a0,0x18100
 3000d64:	20b1                	jal	ra,3000db0 <HAL_CRG_IpEnableSet.trans.19>
    VREF->VREF_CTRL1.BIT.da_ref_temp_trim_enh = 0x1;
 3000d66:	18100737          	lui	a4,0x18100
 3000d6a:	531c                	lw	a5,32(a4)
 3000d6c:	66c1                	lui	a3,0x10
 3000d6e:	8fd5                	or	a5,a5,a3
 3000d70:	d31c                	sw	a5,32(a4)
    VREF->VREF_CTRL0.BIT.da_ref_enh = BASE_CFG_ENABLE;
 3000d72:	18100737          	lui	a4,0x18100
 3000d76:	431c                	lw	a5,0(a4)
 3000d78:	0017e793          	ori	a5,a5,1
 3000d7c:	c31c                	sw	a5,0(a4)
    BASE_FUNC_DELAY_US(200); /* delay 200us */
 3000d7e:	000f47b7          	lui	a5,0xf4
 3000d82:	24078593          	addi	a1,a5,576 # f4240 <FLASH_SIZE+0xd4244>
 3000d86:	0c800513          	li	a0,200
 3000d8a:	20b5                	jal	ra,3000df6 <BASE_FUNC_Delay.trans.37>
    VREF->VREF_CTRL1.BIT.da_ref_chop_enh = BASE_CFG_ENABLE;
 3000d8c:	18100737          	lui	a4,0x18100
 3000d90:	531c                	lw	a5,32(a4)
 3000d92:	0017e793          	ori	a5,a5,1
 3000d96:	d31c                	sw	a5,32(a4)
    BASE_FUNC_DELAY_US(40); /* delay 40us */
 3000d98:	000f47b7          	lui	a5,0xf4
 3000d9c:	24078593          	addi	a1,a5,576 # f4240 <FLASH_SIZE+0xd4244>
 3000da0:	02800513          	li	a0,40
 3000da4:	2889                	jal	ra,3000df6 <BASE_FUNC_Delay.trans.37>
 3000da6:	0001                	nop
 3000da8:	40b2                	lw	ra,12(sp)
 3000daa:	4422                	lw	s0,8(sp)
 3000dac:	0141                	addi	sp,sp,16
 3000dae:	8082                	ret

03000db0 <HAL_CRG_IpEnableSet.trans.19>:
 3000db0:	2320406f          	j	3004fe2 <HAL_CRG_IpEnableSet>

03000db4 <CRG_SetCoreClockSelect>:
 * @brief Set Crg Core clock select
 * @param coreClkSelect Input core clock select value
 * @retval None
 */
void CRG_SetCoreClockSelect(CRG_CoreClkSelect coreClkSelect)
{
 3000db4:	715d                	addi	sp,sp,-80
 3000db6:	c686                	sw	ra,76(sp)
 3000db8:	c4a2                	sw	s0,72(sp)
 3000dba:	0880                	addi	s0,sp,80
 3000dbc:	faa42e23          	sw	a0,-68(s0)
    CRG_Handle crg;
    crg.baseAddress = CRG;
 3000dc0:	100007b7          	lui	a5,0x10000
 3000dc4:	fcf42423          	sw	a5,-56(s0)
    crg.coreClkSelect = coreClkSelect;
 3000dc8:	fbc42783          	lw	a5,-68(s0)
 3000dcc:	fef42023          	sw	a5,-32(s0)
    if (crg.coreClkSelect == CRG_CORE_CLK_SELECT_TCXO) { /* If an external crystal oscillator is selected. */
 3000dd0:	fe042703          	lw	a4,-32(s0)
 3000dd4:	4785                	li	a5,1
 3000dd6:	00f71663          	bne	a4,a5,3000de2 <CRG_SetCoreClockSelect+0x2e>
        BASE_FUNC_DELAY_MS(10);  /* 10: delay 10ms, wait clokc stable. */
 3000dda:	3e800593          	li	a1,1000
 3000dde:	4529                	li	a0,10
 3000de0:	2819                	jal	ra,3000df6 <BASE_FUNC_Delay.trans.37>
    }
    HAL_CRG_SetCoreClockSelect(&crg);
 3000de2:	fc840793          	addi	a5,s0,-56
 3000de6:	853e                	mv	a0,a5
 3000de8:	6eb030ef          	jal	ra,3004cd2 <HAL_CRG_SetCoreClockSelect>
 3000dec:	0001                	nop
 3000dee:	40b6                	lw	ra,76(sp)
 3000df0:	4426                	lw	s0,72(sp)
 3000df2:	6161                	addi	sp,sp,80
 3000df4:	8082                	ret

03000df6 <BASE_FUNC_Delay.trans.37>:
 3000df6:	0560206f          	j	3002e4c <BASE_FUNC_Delay>

03000dfa <SetFlashDiv>:
 * @param frequence frequnce
 * @param div Output Divison
 * @retval None
 */
static void SetFlashDiv(unsigned int frequency, unsigned int *nreadDiv)
{
 3000dfa:	7179                	addi	sp,sp,-48
 3000dfc:	d622                	sw	s0,44(sp)
 3000dfe:	1800                	addi	s0,sp,48
 3000e00:	fca42e23          	sw	a0,-36(s0)
 3000e04:	fcb42c23          	sw	a1,-40(s0)
    unsigned int div;
    unsigned int freq = frequency;
 3000e08:	fdc42783          	lw	a5,-36(s0)
 3000e0c:	fef42423          	sw	a5,-24(s0)
    /* Get frequency divider of flash. */
    if (freq < FLASH_BASE_FREQ) {
 3000e10:	fe842703          	lw	a4,-24(s0)
 3000e14:	023c37b7          	lui	a5,0x23c3
 3000e18:	45f78793          	addi	a5,a5,1119 # 23c345f <RAM_CODE_START+0x3c345f>
 3000e1c:	00e7e863          	bltu	a5,a4,3000e2c <SetFlashDiv+0x32>
        freq = FLASH_BASE_FREQ;
 3000e20:	023c37b7          	lui	a5,0x23c3
 3000e24:	46078793          	addi	a5,a5,1120 # 23c3460 <RAM_CODE_START+0x3c3460>
 3000e28:	fef42423          	sw	a5,-24(s0)
    }
    /* Get the flash frequency division based on the frequency. */
    if ((freq % FLASH_BASE_FREQ) == 0) {
 3000e2c:	fe842703          	lw	a4,-24(s0)
 3000e30:	023c37b7          	lui	a5,0x23c3
 3000e34:	46078793          	addi	a5,a5,1120 # 23c3460 <RAM_CODE_START+0x3c3460>
 3000e38:	02f777b3          	remu	a5,a4,a5
 3000e3c:	ef81                	bnez	a5,3000e54 <SetFlashDiv+0x5a>
        div = freq / FLASH_BASE_FREQ;
 3000e3e:	fe842703          	lw	a4,-24(s0)
 3000e42:	023c37b7          	lui	a5,0x23c3
 3000e46:	46078793          	addi	a5,a5,1120 # 23c3460 <RAM_CODE_START+0x3c3460>
 3000e4a:	02f757b3          	divu	a5,a4,a5
 3000e4e:	fef42623          	sw	a5,-20(s0)
 3000e52:	a821                	j	3000e6a <SetFlashDiv+0x70>
    } else {
        div = (freq / FLASH_BASE_FREQ) + 1;
 3000e54:	fe842703          	lw	a4,-24(s0)
 3000e58:	023c37b7          	lui	a5,0x23c3
 3000e5c:	46078793          	addi	a5,a5,1120 # 23c3460 <RAM_CODE_START+0x3c3460>
 3000e60:	02f757b3          	divu	a5,a4,a5
 3000e64:	0785                	addi	a5,a5,1
 3000e66:	fef42623          	sw	a5,-20(s0)
    }
    /* Ensure the flash frequency division is valid. */
    if (div > FLASH_MAX_DIV) {
 3000e6a:	fec42703          	lw	a4,-20(s0)
 3000e6e:	4791                	li	a5,4
 3000e70:	00e7f563          	bgeu	a5,a4,3000e7a <SetFlashDiv+0x80>
        div = FLASH_MAX_DIV;
 3000e74:	4791                	li	a5,4
 3000e76:	fef42623          	sw	a5,-20(s0)
    }
    *nreadDiv = div;
 3000e7a:	fd842783          	lw	a5,-40(s0)
 3000e7e:	fec42703          	lw	a4,-20(s0)
 3000e82:	c398                	sw	a4,0(a5)
}
 3000e84:	0001                	nop
 3000e86:	5432                	lw	s0,44(sp)
 3000e88:	6145                	addi	sp,sp,48
 3000e8a:	8082                	ret

03000e8c <GetFlashFreq>:
 * @brief Get the Rounding up value
 * @param coreClkSelect Core Clock select
 * @retval Frequency of Flash
 */
static unsigned int GetFlashFreq(CRG_CoreClkSelect coreClkSelect)
{
 3000e8c:	7179                	addi	sp,sp,-48
 3000e8e:	d606                	sw	ra,44(sp)
 3000e90:	d422                	sw	s0,40(sp)
 3000e92:	1800                	addi	s0,sp,48
 3000e94:	fca42e23          	sw	a0,-36(s0)
    unsigned int hclk;
    /* Get frequency of flash. */
    switch (coreClkSelect) {
 3000e98:	fdc42783          	lw	a5,-36(s0)
 3000e9c:	4705                	li	a4,1
 3000e9e:	02e78063          	beq	a5,a4,3000ebe <GetFlashFreq+0x32>
 3000ea2:	4705                	li	a4,1
 3000ea4:	00e7e663          	bltu	a5,a4,3000eb0 <GetFlashFreq+0x24>
 3000ea8:	4709                	li	a4,2
 3000eaa:	02e78163          	beq	a5,a4,3000ecc <GetFlashFreq+0x40>
 3000eae:	a025                	j	3000ed6 <GetFlashFreq+0x4a>
        case CRG_CORE_CLK_SELECT_HOSC:
            hclk = HOSC_FREQ;
 3000eb0:	017d87b7          	lui	a5,0x17d8
 3000eb4:	84078793          	addi	a5,a5,-1984 # 17d7840 <FLASH_SIZE+0x17b7844>
 3000eb8:	fef42623          	sw	a5,-20(s0)
            break;
 3000ebc:	a01d                	j	3000ee2 <GetFlashFreq+0x56>
        case CRG_CORE_CLK_SELECT_TCXO:
            hclk = XTRAIL_FREQ;
 3000ebe:	01c9c7b7          	lui	a5,0x1c9c
 3000ec2:	38078793          	addi	a5,a5,896 # 1c9c380 <FLASH_SIZE+0x1c7c384>
 3000ec6:	fef42623          	sw	a5,-20(s0)
            break;
 3000eca:	a821                	j	3000ee2 <GetFlashFreq+0x56>
        case CRG_CORE_CLK_SELECT_PLL:
            hclk = HAL_CRG_GetPllFreq();
 3000ecc:	72b030ef          	jal	ra,3004df6 <HAL_CRG_GetPllFreq>
 3000ed0:	fea42623          	sw	a0,-20(s0)
            break;
 3000ed4:	a039                	j	3000ee2 <GetFlashFreq+0x56>
        default:
            hclk = LOSC_FREQ;
 3000ed6:	67a1                	lui	a5,0x8
 3000ed8:	d0078793          	addi	a5,a5,-768 # 7d00 <RAM_SIZE+0x2d00>
 3000edc:	fef42623          	sw	a5,-20(s0)
            break;
 3000ee0:	0001                	nop
    }
    return hclk;
 3000ee2:	fec42783          	lw	a5,-20(s0)
}
 3000ee6:	853e                	mv	a0,a5
 3000ee8:	50b2                	lw	ra,44(sp)
 3000eea:	5422                	lw	s0,40(sp)
 3000eec:	6145                	addi	sp,sp,48
 3000eee:	8082                	ret

03000ef0 <FLASH_ClockConfig>:
 * @brief Set flash clock frequence base on hclk
 * @param coreClkSelect core clock select
 * @retval None
 */
void FLASH_ClockConfig(CRG_CoreClkSelect coreClkSelect)
{
 3000ef0:	7179                	addi	sp,sp,-48
 3000ef2:	d606                	sw	ra,44(sp)
 3000ef4:	d422                	sw	s0,40(sp)
 3000ef6:	1800                	addi	s0,sp,48
 3000ef8:	fca42e23          	sw	a0,-36(s0)
    EFC_RegStruct *efc = EFC;
 3000efc:	147107b7          	lui	a5,0x14710
 3000f00:	fef42623          	sw	a5,-20(s0)
    EFLASH_CLK_CFG_REG cfg;
    unsigned int hclk;
    unsigned int nreadDiv;

    /* Step 1: Set nread_div */
    hclk = GetFlashFreq(coreClkSelect);
 3000f04:	fdc42503          	lw	a0,-36(s0)
 3000f08:	3751                	jal	ra,3000e8c <GetFlashFreq>
 3000f0a:	fea42423          	sw	a0,-24(s0)
    cfg.reg = efc->EFLASH_CLK_CFG.reg;
 3000f0e:	fec42703          	lw	a4,-20(s0)
 3000f12:	6785                	lui	a5,0x1
 3000f14:	97ba                	add	a5,a5,a4
 3000f16:	9407a783          	lw	a5,-1728(a5) # 940 <cipri+0x153>
 3000f1a:	fef42223          	sw	a5,-28(s0)
    SetFlashDiv(hclk, &nreadDiv);
 3000f1e:	fe040793          	addi	a5,s0,-32
 3000f22:	85be                	mv	a1,a5
 3000f24:	fe842503          	lw	a0,-24(s0)
 3000f28:	3dc9                	jal	ra,3000dfa <SetFlashDiv>
    cfg.BIT.nread_div = nreadDiv;
 3000f2a:	fe042783          	lw	a5,-32(s0)
 3000f2e:	8bbd                	andi	a5,a5,15
 3000f30:	0ff7f713          	andi	a4,a5,255
 3000f34:	fe442783          	lw	a5,-28(s0)
 3000f38:	8b3d                	andi	a4,a4,15
 3000f3a:	0712                	slli	a4,a4,0x4
 3000f3c:	f0f7f793          	andi	a5,a5,-241
 3000f40:	8fd9                	or	a5,a5,a4
 3000f42:	fef42223          	sw	a5,-28(s0)
    cfg.BIT.busclk_sw_req = BASE_CFG_SET;
 3000f46:	fe442783          	lw	a5,-28(s0)
 3000f4a:	00100737          	lui	a4,0x100
 3000f4e:	8fd9                	or	a5,a5,a4
 3000f50:	fef42223          	sw	a5,-28(s0)
    cfg.BIT.cur_read_vref_cal = BASE_CFG_SET;
 3000f54:	fe442783          	lw	a5,-28(s0)
 3000f58:	00400737          	lui	a4,0x400
 3000f5c:	8fd9                	or	a5,a5,a4
 3000f5e:	fef42223          	sw	a5,-28(s0)

    /* Step 2: Wait Busclk_sw_req */
    cfg.BIT.cur_read_vref_cal = BASE_CFG_SET;
 3000f62:	fe442783          	lw	a5,-28(s0)
 3000f66:	00400737          	lui	a4,0x400
 3000f6a:	8fd9                	or	a5,a5,a4
 3000f6c:	fef42223          	sw	a5,-28(s0)
    cfg.BIT.busclk_sw_req = BASE_CFG_SET;
 3000f70:	fe442783          	lw	a5,-28(s0)
 3000f74:	00100737          	lui	a4,0x100
 3000f78:	8fd9                	or	a5,a5,a4
 3000f7a:	fef42223          	sw	a5,-28(s0)
    efc->EFLASH_CLK_CFG.reg = cfg.reg;
 3000f7e:	fe442703          	lw	a4,-28(s0)
 3000f82:	fec42683          	lw	a3,-20(s0)
 3000f86:	6785                	lui	a5,0x1
 3000f88:	97b6                	add	a5,a5,a3
 3000f8a:	94e7a023          	sw	a4,-1728(a5) # 940 <cipri+0x153>
    while (efc->EFLASH_CLK_CFG.BIT.busclk_sw_req == BASE_CFG_SET) {
 3000f8e:	0001                	nop
 3000f90:	fec42703          	lw	a4,-20(s0)
 3000f94:	6785                	lui	a5,0x1
 3000f96:	97ba                	add	a5,a5,a4
 3000f98:	9407a783          	lw	a5,-1728(a5) # 940 <cipri+0x153>
 3000f9c:	83d1                	srli	a5,a5,0x14
 3000f9e:	8b85                	andi	a5,a5,1
 3000fa0:	0ff7f713          	andi	a4,a5,255
 3000fa4:	4785                	li	a5,1
 3000fa6:	fef705e3          	beq	a4,a5,3000f90 <FLASH_ClockConfig+0xa0>
        ;
    }
 3000faa:	0001                	nop
 3000fac:	50b2                	lw	ra,44(sp)
 3000fae:	5422                	lw	s0,40(sp)
 3000fb0:	6145                	addi	sp,sp,48
 3000fb2:	8082                	ret

03000fb4 <SYSTICK_Init>:
  * @brief   Init the systick
  * @param   None
  * @retval  None
  */
void SYSTICK_Init(void)
{
 3000fb4:	1141                	addi	sp,sp,-16
 3000fb6:	c622                	sw	s0,12(sp)
 3000fb8:	0800                	addi	s0,sp,16
    SYSTICK->TIMER_CTRL.reg = 0;
 3000fba:	143807b7          	lui	a5,0x14380
 3000fbe:	0007a023          	sw	zero,0(a5) # 14380000 <RAM_END+0x10378000>
    SYSTICK->TIMER_CTRL.BIT.enable = 1;
 3000fc2:	14380737          	lui	a4,0x14380
 3000fc6:	431c                	lw	a5,0(a4)
 3000fc8:	0017e793          	ori	a5,a5,1
 3000fcc:	c31c                	sw	a5,0(a4)
}
 3000fce:	0001                	nop
 3000fd0:	4432                	lw	s0,12(sp)
 3000fd2:	0141                	addi	sp,sp,16
 3000fd4:	8082                	ret

03000fd6 <SYSTICK_GetCRGHZ>:
  * @brief   Get the Systick frep(Hz)
  * @param   None
  * @retval  Clock frep of systick(Hz)
  */
unsigned int SYSTICK_GetCRGHZ(void)
{
 3000fd6:	1141                	addi	sp,sp,-16
 3000fd8:	c606                	sw	ra,12(sp)
 3000fda:	c422                	sw	s0,8(sp)
 3000fdc:	0800                	addi	s0,sp,16
    /* Get the Systick IP */
    return HAL_CRG_GetIpFreq(SYSTICK_BASE);
 3000fde:	14380537          	lui	a0,0x14380
 3000fe2:	711030ef          	jal	ra,3004ef2 <HAL_CRG_GetIpFreq>
 3000fe6:	87aa                	mv	a5,a0
 3000fe8:	853e                	mv	a0,a5
 3000fea:	40b2                	lw	ra,12(sp)
 3000fec:	4422                	lw	s0,8(sp)
 3000fee:	0141                	addi	sp,sp,16
 3000ff0:	8082                	ret

03000ff2 <FOTP_CheckReadStatus>:
  * @param efc  Flash control register base address
  * @retval BASE_STATUS_ERROR fail.
  * @retval BASE_STATUS_OK success.
  */
static unsigned int FOTP_CheckReadStatus(EFC_RegStruct *efc)
{
 3000ff2:	1101                	addi	sp,sp,-32
 3000ff4:	ce22                	sw	s0,28(sp)
 3000ff6:	1000                	addi	s0,sp,32
 3000ff8:	fea42623          	sw	a0,-20(s0)
    /* Check for errors in the flash reading process. */
    if (efc->INT_RAW_STATUS.BIT.int_raw_err_illegal ||
 3000ffc:	fec42783          	lw	a5,-20(s0)
 3001000:	1007a783          	lw	a5,256(a5)
 3001004:	83c1                	srli	a5,a5,0x10
 3001006:	8b85                	andi	a5,a5,1
 3001008:	9f81                	uxtb	a5
 300100a:	e38d                	bnez	a5,300102c <FOTP_CheckReadStatus+0x3a>
        efc->INT_RAW_STATUS.BIT.int_raw_err_ecc_corr ||
 300100c:	fec42783          	lw	a5,-20(s0)
 3001010:	1007a783          	lw	a5,256(a5)
 3001014:	83cd                	srli	a5,a5,0x13
 3001016:	8b85                	andi	a5,a5,1
 3001018:	9f81                	uxtb	a5
    if (efc->INT_RAW_STATUS.BIT.int_raw_err_illegal ||
 300101a:	eb89                	bnez	a5,300102c <FOTP_CheckReadStatus+0x3a>
        efc->INT_RAW_STATUS.BIT.int_raw_err_ecc_chk) {
 300101c:	fec42783          	lw	a5,-20(s0)
 3001020:	1007a783          	lw	a5,256(a5)
 3001024:	83d1                	srli	a5,a5,0x14
 3001026:	8b85                	andi	a5,a5,1
 3001028:	9f81                	uxtb	a5
        efc->INT_RAW_STATUS.BIT.int_raw_err_ecc_corr ||
 300102a:	c3a9                	beqz	a5,300106c <FOTP_CheckReadStatus+0x7a>
        efc->INT_CLEAR.BIT.int_clr_err_ecc_corr = BASE_CFG_SET;
 300102c:	fec42703          	lw	a4,-20(s0)
 3001030:	10c72783          	lw	a5,268(a4) # 1438010c <RAM_END+0x1037810c>
 3001034:	000806b7          	lui	a3,0x80
 3001038:	8fd5                	or	a5,a5,a3
 300103a:	10f72623          	sw	a5,268(a4)
        efc->INT_CLEAR.BIT.int_clr_err_illegal = BASE_CFG_SET;
 300103e:	fec42703          	lw	a4,-20(s0)
 3001042:	10c72783          	lw	a5,268(a4)
 3001046:	66c1                	lui	a3,0x10
 3001048:	8fd5                	or	a5,a5,a3
 300104a:	10f72623          	sw	a5,268(a4)
        efc->INT_CLEAR.BIT.int_clr_err_ecc_chk = BASE_CFG_SET;
 300104e:	fec42703          	lw	a4,-20(s0)
 3001052:	10c72783          	lw	a5,268(a4)
 3001056:	001006b7          	lui	a3,0x100
 300105a:	8fd5                	or	a5,a5,a3
 300105c:	10f72623          	sw	a5,268(a4)
        efc->MAGIC_LOCK = FLASH_KEY_REGISTER_LOCK_VALUE;
 3001060:	fec42783          	lw	a5,-20(s0)
 3001064:	2007a023          	sw	zero,512(a5)
        return BASE_STATUS_ERROR;
 3001068:	4785                	li	a5,1
 300106a:	a011                	j	300106e <FOTP_CheckReadStatus+0x7c>
    }
    return BASE_STATUS_OK;
 300106c:	4781                	li	a5,0
}
 300106e:	853e                	mv	a0,a5
 3001070:	4472                	lw	s0,28(sp)
 3001072:	6105                	addi	sp,sp,32
 3001074:	8082                	ret

03001076 <FOTP_InfoGet>:
  * @param buf   Buffer of read data
  * @retval BASE_STATUS_ERROR fail.
  * @retval BASE_STATUS_OK success.
  */
unsigned int FOTP_InfoGet(FOTP_InfoRngType type, unsigned int index, FOTP_CommonData *buf)
{
 3001076:	7179                	addi	sp,sp,-48
 3001078:	d606                	sw	ra,44(sp)
 300107a:	d422                	sw	s0,40(sp)
 300107c:	1800                	addi	s0,sp,48
 300107e:	fca42e23          	sw	a0,-36(s0)
 3001082:	fcb42c23          	sw	a1,-40(s0)
 3001086:	fcc42a23          	sw	a2,-44(s0)
    EFC_RegStruct *p = EFC;
 300108a:	147107b7          	lui	a5,0x14710
 300108e:	fef42423          	sw	a5,-24(s0)
    unsigned int addr;

    if (buf == NULL) {
 3001092:	fd442783          	lw	a5,-44(s0)
 3001096:	e399                	bnez	a5,300109c <FOTP_InfoGet+0x26>
        return BASE_STATUS_ERROR;
 3001098:	4785                	li	a5,1
 300109a:	aa15                	j	30011ce <FOTP_InfoGet+0x158>
    }
    
    if ((type >= FOTP_INFO_MAXTYPE) || (index > FOTP_INFO_REG_MAX_ID)) {
 300109c:	fdc42703          	lw	a4,-36(s0)
 30010a0:	4785                	li	a5,1
 30010a2:	00e7e763          	bltu	a5,a4,30010b0 <FOTP_InfoGet+0x3a>
 30010a6:	fd842703          	lw	a4,-40(s0)
 30010aa:	47e5                	li	a5,25
 30010ac:	00e7f463          	bgeu	a5,a4,30010b4 <FOTP_InfoGet+0x3e>
        return BASE_STATUS_ERROR;
 30010b0:	4785                	li	a5,1
 30010b2:	aa31                	j	30011ce <FOTP_InfoGet+0x158>
    }

    /* If there is a read command, return */
    if (p->EFLASH_CMD.BIT.cmd_start) {
 30010b4:	fe842783          	lw	a5,-24(s0)
 30010b8:	439c                	lw	a5,0(a5)
 30010ba:	8b85                	andi	a5,a5,1
 30010bc:	9f81                	uxtb	a5
 30010be:	c399                	beqz	a5,30010c4 <FOTP_InfoGet+0x4e>
        return BASE_STATUS_ERROR;
 30010c0:	4785                	li	a5,1
 30010c2:	a231                	j	30011ce <FOTP_InfoGet+0x158>
    }

    p->MAGIC_LOCK = FLASH_KEY_REGISTER_UNLOCK_VALUE;
 30010c4:	fe842783          	lw	a5,-24(s0)
 30010c8:	fedcc737          	lui	a4,0xfedcc
 30010cc:	a9870713          	addi	a4,a4,-1384 # fedcba98 <RAM_END+0xfadc3a98>
 30010d0:	20e7a023          	sw	a4,512(a5) # 14710200 <RAM_END+0x10708200>

    /* Configure the read command parameters and start the read command */
    addr = (type == FOTP_INFO_RNG0) ? FOTP_INFO_RNG0_BASEADDR : FOTP_INFO_RNG1_BASEADDR;
 30010d4:	fdc42783          	lw	a5,-36(s0)
 30010d8:	e781                	bnez	a5,30010e0 <FOTP_InfoGet+0x6a>
 30010da:	008007b7          	lui	a5,0x800
 30010de:	a019                	j	30010e4 <FOTP_InfoGet+0x6e>
 30010e0:	008017b7          	lui	a5,0x801
 30010e4:	fef42223          	sw	a5,-28(s0)
    addr += index * REG_WORDS_NUM;
 30010e8:	fd842783          	lw	a5,-40(s0)
 30010ec:	0792                	slli	a5,a5,0x4
 30010ee:	fe442703          	lw	a4,-28(s0)
 30010f2:	97ba                	add	a5,a5,a4
 30010f4:	fef42223          	sw	a5,-28(s0)
    p->EFLASH_ADDR.BIT.cmd_addr = addr >> 2; /* Right shift 2 bit change to word */
 30010f8:	fe442783          	lw	a5,-28(s0)
 30010fc:	0027d713          	srli	a4,a5,0x2
 3001100:	004007b7          	lui	a5,0x400
 3001104:	17fd                	addi	a5,a5,-1 # 3fffff <FLASH_SIZE+0x3e0003>
 3001106:	00f77633          	and	a2,a4,a5
 300110a:	fe842703          	lw	a4,-24(s0)
 300110e:	435c                	lw	a5,4(a4)
 3001110:	004006b7          	lui	a3,0x400
 3001114:	16fd                	addi	a3,a3,-1 # 3fffff <FLASH_SIZE+0x3e0003>
 3001116:	8ef1                	and	a3,a3,a2
 3001118:	068a                	slli	a3,a3,0x2
 300111a:	ff000637          	lui	a2,0xff000
 300111e:	060d                	addi	a2,a2,3 # ff000003 <RAM_END+0xfaff8003>
 3001120:	8ff1                	and	a5,a5,a2
 3001122:	8fd5                	or	a5,a5,a3
 3001124:	c35c                	sw	a5,4(a4)
    p->EFLASH_CMD.BIT.cmd_code = FLASH_OPERATION_READ;
 3001126:	fe842703          	lw	a4,-24(s0)
 300112a:	431c                	lw	a5,0(a4)
 300112c:	8ff7f793          	andi	a5,a5,-1793
 3001130:	1007e793          	ori	a5,a5,256
 3001134:	c31c                	sw	a5,0(a4)
    p->EFLASH_CMD.BIT.cmd_read_size = FLASH_READ_128BIT;
 3001136:	fe842703          	lw	a4,-24(s0)
 300113a:	431c                	lw	a5,0(a4)
 300113c:	d00006b7          	lui	a3,0xd0000
 3001140:	16fd                	addi	a3,a3,-1 # cfffffff <RAM_END+0xcbff7fff>
 3001142:	8efd                	and	a3,a3,a5
 3001144:	100007b7          	lui	a5,0x10000
 3001148:	8fd5                	or	a5,a5,a3
 300114a:	c31c                	sw	a5,0(a4)
    p->EFLASH_CMD.BIT.cmd_start = BASE_CFG_SET;
 300114c:	fe842703          	lw	a4,-24(s0)
 3001150:	431c                	lw	a5,0(a4)
 3001152:	0017e793          	ori	a5,a5,1
 3001156:	c31c                	sw	a5,0(a4)

    while (p->EFLASH_CMD.BIT.cmd_start) {
 3001158:	0001                	nop
 300115a:	fe842783          	lw	a5,-24(s0)
 300115e:	439c                	lw	a5,0(a5)
 3001160:	8b85                	andi	a5,a5,1
 3001162:	9f81                	uxtb	a5
 3001164:	fbfd                	bnez	a5,300115a <FOTP_InfoGet+0xe4>
        ;
    }
    while (p->EFLASH_CMD.BIT.exec_state) {
 3001166:	0001                	nop
 3001168:	fe842783          	lw	a5,-24(s0)
 300116c:	439c                	lw	a5,0(a5)
 300116e:	8399                	srli	a5,a5,0x6
 3001170:	8b8d                	andi	a5,a5,3
 3001172:	9f81                	uxtb	a5
 3001174:	fbf5                	bnez	a5,3001168 <FOTP_InfoGet+0xf2>
        ;
    }
    /* read error, clear interrupt and return */
    if (FOTP_CheckReadStatus(p) != BASE_STATUS_OK) {
 3001176:	fe842503          	lw	a0,-24(s0)
 300117a:	3da5                	jal	ra,3000ff2 <FOTP_CheckReadStatus>
 300117c:	87aa                	mv	a5,a0
 300117e:	c399                	beqz	a5,3001184 <FOTP_InfoGet+0x10e>
        return BASE_STATUS_ERROR;
 3001180:	4785                	li	a5,1
 3001182:	a0b1                	j	30011ce <FOTP_InfoGet+0x158>
    }
    /* Read data from FIFO to buffer */
    for (unsigned int i = 0; i < sizeof(buf->data) / sizeof(buf->data[0]); ++i) {
 3001184:	fe042623          	sw	zero,-20(s0)
 3001188:	a00d                	j	30011aa <FOTP_InfoGet+0x134>
        buf->data[i] = p->FLASH_RDATA;
 300118a:	fe842783          	lw	a5,-24(s0)
 300118e:	6007a703          	lw	a4,1536(a5) # 10000600 <RAM_END+0xbff8600>
 3001192:	fd442683          	lw	a3,-44(s0)
 3001196:	fec42783          	lw	a5,-20(s0)
 300119a:	078a                	slli	a5,a5,0x2
 300119c:	97b6                	add	a5,a5,a3
 300119e:	c398                	sw	a4,0(a5)
    for (unsigned int i = 0; i < sizeof(buf->data) / sizeof(buf->data[0]); ++i) {
 30011a0:	fec42783          	lw	a5,-20(s0)
 30011a4:	0785                	addi	a5,a5,1
 30011a6:	fef42623          	sw	a5,-20(s0)
 30011aa:	fec42703          	lw	a4,-20(s0)
 30011ae:	478d                	li	a5,3
 30011b0:	fce7fde3          	bgeu	a5,a4,300118a <FOTP_InfoGet+0x114>
    }
    p->INT_CLEAR.BIT.int_clr_finish = BASE_CFG_SET;
 30011b4:	fe842703          	lw	a4,-24(s0)
 30011b8:	10c72783          	lw	a5,268(a4)
 30011bc:	0107e793          	ori	a5,a5,16
 30011c0:	10f72623          	sw	a5,268(a4)
    p->MAGIC_LOCK = FLASH_KEY_REGISTER_LOCK_VALUE;
 30011c4:	fe842783          	lw	a5,-24(s0)
 30011c8:	2007a023          	sw	zero,512(a5)
    return BASE_STATUS_OK;
 30011cc:	4781                	li	a5,0
 30011ce:	853e                	mv	a0,a5
 30011d0:	50b2                	lw	ra,44(sp)
 30011d2:	5422                	lw	s0,40(sp)
 30011d4:	6145                	addi	sp,sp,48
 30011d6:	8082                	ret

030011d8 <GetCrgIpMatchInfo>:
  * @param baseAddr The ip base address
  * @retval The Address(offset) in g_crgIpMatch if match success
  * @retval 0 if match fail
  */
CHIP_CrgIpMatchInfo *GetCrgIpMatchInfo(const void *baseAddr)
{
 30011d8:	7179                	addi	sp,sp,-48
 30011da:	d622                	sw	s0,44(sp)
 30011dc:	1800                	addi	s0,sp,48
 30011de:	fca42e23          	sw	a0,-36(s0)
    unsigned int i;
    for (i = 0; i < sizeof(g_crgIpMatch) / sizeof(g_crgIpMatch[0]); ++i) {
 30011e2:	fe042623          	sw	zero,-20(s0)
 30011e6:	a081                	j	3001226 <GetCrgIpMatchInfo+0x4e>
        if (baseAddr == g_crgIpMatch[i].ipBaseAddr) {
 30011e8:	030107b7          	lui	a5,0x3010
 30011ec:	51078713          	addi	a4,a5,1296 # 3010510 <g_crgIpMatch>
 30011f0:	fec42683          	lw	a3,-20(s0)
 30011f4:	47b1                	li	a5,12
 30011f6:	02f687b3          	mul	a5,a3,a5
 30011fa:	97ba                	add	a5,a5,a4
 30011fc:	439c                	lw	a5,0(a5)
 30011fe:	fdc42703          	lw	a4,-36(s0)
 3001202:	00f71d63          	bne	a4,a5,300121c <GetCrgIpMatchInfo+0x44>
            return (CHIP_CrgIpMatchInfo *)&g_crgIpMatch[i];
 3001206:	fec42703          	lw	a4,-20(s0)
 300120a:	47b1                	li	a5,12
 300120c:	02f70733          	mul	a4,a4,a5
 3001210:	030107b7          	lui	a5,0x3010
 3001214:	51078793          	addi	a5,a5,1296 # 3010510 <g_crgIpMatch>
 3001218:	97ba                	add	a5,a5,a4
 300121a:	a829                	j	3001234 <GetCrgIpMatchInfo+0x5c>
    for (i = 0; i < sizeof(g_crgIpMatch) / sizeof(g_crgIpMatch[0]); ++i) {
 300121c:	fec42783          	lw	a5,-20(s0)
 3001220:	0785                	addi	a5,a5,1
 3001222:	fef42623          	sw	a5,-20(s0)
 3001226:	fec42703          	lw	a4,-20(s0)
 300122a:	02d00793          	li	a5,45
 300122e:	fae7fde3          	bgeu	a5,a4,30011e8 <GetCrgIpMatchInfo+0x10>
        }
    }
    return (CHIP_CrgIpMatchInfo *)0; /* The base address does not match, return 0. */
 3001232:	4781                	li	a5,0
}
 3001234:	853e                	mv	a0,a5
 3001236:	5432                	lw	s0,44(sp)
 3001238:	6145                	addi	sp,sp,48
 300123a:	8082                	ret

0300123c <IsADCSampleChannel>:
 * @brief Check ADC sample input.
 * @param input Number of input.
 * @retval bool
 */
static inline bool IsADCSampleChannel(ADC_Input input)
{
 300123c:	1101                	addi	sp,sp,-32
 300123e:	ce22                	sw	s0,28(sp)
 3001240:	1000                	addi	s0,sp,32
 3001242:	fea42623          	sw	a0,-20(s0)
    return (input >= ADC_CH_ADCINA0) && (input <= ADC_CH_ADCINA19);
 3001246:	fec42783          	lw	a5,-20(s0)
 300124a:	0147b793          	sltiu	a5,a5,20
 300124e:	9f81                	uxtb	a5
}
 3001250:	853e                	mv	a0,a5
 3001252:	4472                	lw	s0,28(sp)
 3001254:	6105                	addi	sp,sp,32
 3001256:	8082                	ret

03001258 <IsADCSOCx>:
 * are configured through the SOC.
 * @param soc Number of SOC.
 * @retval bool
 */
static inline bool IsADCSOCx(ADC_SOCNumber soc)
{
 3001258:	1101                	addi	sp,sp,-32
 300125a:	ce22                	sw	s0,28(sp)
 300125c:	1000                	addi	s0,sp,32
 300125e:	fea42623          	sw	a0,-20(s0)
    return (soc >= ADC_SOC_NUM0) && (soc <= ADC_SOC_NUM15);
 3001262:	fec42783          	lw	a5,-20(s0)
 3001266:	0107b793          	sltiu	a5,a5,16
 300126a:	9f81                	uxtb	a5
}
 300126c:	853e                	mv	a0,a5
 300126e:	4472                	lw	s0,28(sp)
 3001270:	6105                	addi	sp,sp,32
 3001272:	8082                	ret

03001274 <IsADCTrigSource>:
 * @brief Check SOC trigger source.
 * @param trig Type of trigger source.
 * @retval bool
 */
static inline bool IsADCTrigSource(ADC_TrigSource trig)
{
 3001274:	1101                	addi	sp,sp,-32
 3001276:	ce22                	sw	s0,28(sp)
 3001278:	1000                	addi	s0,sp,32
 300127a:	fea42623          	sw	a0,-20(s0)
    return (trig >= ADC_TRIGSOC_SOFT) && (trig <= ADC_TRIGSOC_GPIOPF1);
 300127e:	fec42783          	lw	a5,-20(s0)
 3001282:	0157b793          	sltiu	a5,a5,21
 3001286:	9f81                	uxtb	a5
}
 3001288:	853e                	mv	a0,a5
 300128a:	4472                	lw	s0,28(sp)
 300128c:	6105                	addi	sp,sp,32
 300128e:	8082                	ret

03001290 <IsADCFinishMode>:
 * @brief Check mode of completion of SOC sample
 * @param mode Type of completion.
 * @retval bool
 */
static inline bool IsADCFinishMode(ADC_SOCFinishMode mode)
{
 3001290:	1101                	addi	sp,sp,-32
 3001292:	ce22                	sw	s0,28(sp)
 3001294:	1000                	addi	s0,sp,32
 3001296:	fea42623          	sw	a0,-20(s0)
    return (mode >= ADC_SOCFINISH_NONE) && (mode <= ADC_SOCFINISH_INT3);
 300129a:	fec42783          	lw	a5,-20(s0)
 300129e:	cb81                	beqz	a5,30012ae <IsADCFinishMode+0x1e>
 30012a0:	fec42703          	lw	a4,-20(s0)
 30012a4:	4799                	li	a5,6
 30012a6:	00e7e463          	bltu	a5,a4,30012ae <IsADCFinishMode+0x1e>
 30012aa:	4785                	li	a5,1
 30012ac:	a011                	j	30012b0 <IsADCFinishMode+0x20>
 30012ae:	4781                	li	a5,0
 30012b0:	8b85                	andi	a5,a5,1
 30012b2:	9f81                	uxtb	a5
}
 30012b4:	853e                	mv	a0,a5
 30012b6:	4472                	lw	s0,28(sp)
 30012b8:	6105                	addi	sp,sp,32
 30012ba:	8082                	ret

030012bc <IsADCPriorityMode>:
 * @brief Check ADC sample priority parameter.
 * @param mode Priority mode of SOC.
 * @retval bool
 */
static inline bool IsADCPriorityMode(ADC_PriorityMode mode)
{
 30012bc:	1101                	addi	sp,sp,-32
 30012be:	ce22                	sw	s0,28(sp)
 30012c0:	1000                	addi	s0,sp,32
 30012c2:	fea42623          	sw	a0,-20(s0)
    return (mode >= ADC_PRIMODE_ALL_ROUND) && (mode <= ADC_PRIMODE_ALL_PRIORITY);
 30012c6:	fec42703          	lw	a4,-20(s0)
 30012ca:	67c1                	lui	a5,0x10
 30012cc:	00f737b3          	sltu	a5,a4,a5
 30012d0:	9f81                	uxtb	a5
}
 30012d2:	853e                	mv	a0,a5
 30012d4:	4472                	lw	s0,28(sp)
 30012d6:	6105                	addi	sp,sp,32
 30012d8:	8082                	ret

030012da <IsADCTotalTime>:
 * @brief Check time of total ADC sampling time.
 * @param acqps Time of total ADC sampling time.
 * @retval bool
 */
static inline bool IsADCTotalTime(unsigned int acqps)
{
 30012da:	1101                	addi	sp,sp,-32
 30012dc:	ce22                	sw	s0,28(sp)
 30012de:	1000                	addi	s0,sp,32
 30012e0:	fea42623          	sw	a0,-20(s0)
    return (acqps <= ADC_SOCSAMPLE_500CLK);
 30012e4:	fec42783          	lw	a5,-20(s0)
 30012e8:	0107b793          	sltiu	a5,a5,16
 30012ec:	9f81                	uxtb	a5
}
 30012ee:	853e                	mv	a0,a5
 30012f0:	4472                	lw	s0,28(sp)
 30012f2:	6105                	addi	sp,sp,32
 30012f4:	8082                	ret

030012f6 <ADC_GetCTRLAddr>:
 * @param adcx ADC register base address.
 * @param socx Number of SOC, @ref ADC_SOCNumber.
 * @retval addr, the base address of the SOC registers.
 */
static unsigned int ADC_GetCTRLAddr(ADC_RegStruct * const adcx, ADC_SOCNumber socx)
{
 30012f6:	7179                	addi	sp,sp,-48
 30012f8:	d622                	sw	s0,44(sp)
 30012fa:	1800                	addi	s0,sp,48
 30012fc:	fca42e23          	sw	a0,-36(s0)
 3001300:	fcb42c23          	sw	a1,-40(s0)
    unsigned int addr;
    addr = (uintptr_t)(void *)&(adcx->ADC_SOC0_CFG);
 3001304:	fdc42783          	lw	a5,-36(s0)
 3001308:	10078793          	addi	a5,a5,256 # 10100 <RAM_SIZE+0xb100>
 300130c:	fef42623          	sw	a5,-20(s0)
    addr += ((unsigned int)socx * 4); /* Register base address difference 4 */
 3001310:	fd842783          	lw	a5,-40(s0)
 3001314:	078a                	slli	a5,a5,0x2
 3001316:	fec42703          	lw	a4,-20(s0)
 300131a:	97ba                	add	a5,a5,a4
 300131c:	fef42623          	sw	a5,-20(s0)
    return addr;
 3001320:	fec42783          	lw	a5,-20(s0)
}
 3001324:	853e                	mv	a0,a5
 3001326:	5432                	lw	s0,44(sp)
 3001328:	6145                	addi	sp,sp,48
 300132a:	8082                	ret

0300132c <DCL_ADC_SOCxSelcetChannel>:
 * @param socx Number of SOC, @ref ADC_SOCNumber.
 * @param input ADC input, @ref ADC_Input.
 * @retval None.
 */
static inline void DCL_ADC_SOCxSelcetChannel(ADC_RegStruct * const adcx, ADC_SOCNumber socx, ADC_Input input)
{
 300132c:	7179                	addi	sp,sp,-48
 300132e:	d606                	sw	ra,44(sp)
 3001330:	d422                	sw	s0,40(sp)
 3001332:	1800                	addi	s0,sp,48
 3001334:	fca42e23          	sw	a0,-36(s0)
 3001338:	fcb42c23          	sw	a1,-40(s0)
 300133c:	fcc42a23          	sw	a2,-44(s0)
    ADC_ASSERT_PARAM(IsADCInstance(adcx));
 3001340:	fdc42703          	lw	a4,-36(s0)
 3001344:	180007b7          	lui	a5,0x18000
 3001348:	00f70b63          	beq	a4,a5,300135e <DCL_ADC_SOCxSelcetChannel+0x32>
 300134c:	6785                	lui	a5,0x1
 300134e:	8fa78593          	addi	a1,a5,-1798 # 8fa <cipri+0x10d>
 3001352:	030107b7          	lui	a5,0x3010
 3001356:	73878513          	addi	a0,a5,1848 # 3010738 <g_crgIpMatch+0x228>
 300135a:	2349                	jal	ra,30018dc <AssertErrorLog.trans.0>
 300135c:	a001                	j	300135c <DCL_ADC_SOCxSelcetChannel+0x30>
    ADC_PARAM_CHECK_NO_RET(IsADCSOCx(socx) && IsADCSampleChannel(input));
 300135e:	fd842503          	lw	a0,-40(s0)
 3001362:	3ddd                	jal	ra,3001258 <IsADCSOCx>
 3001364:	87aa                	mv	a5,a0
 3001366:	0017c793          	xori	a5,a5,1
 300136a:	9f81                	uxtb	a5
 300136c:	eb89                	bnez	a5,300137e <DCL_ADC_SOCxSelcetChannel+0x52>
 300136e:	fd442503          	lw	a0,-44(s0)
 3001372:	35e9                	jal	ra,300123c <IsADCSampleChannel>
 3001374:	87aa                	mv	a5,a0
 3001376:	0017c793          	xori	a5,a5,1
 300137a:	9f81                	uxtb	a5
 300137c:	cb91                	beqz	a5,3001390 <DCL_ADC_SOCxSelcetChannel+0x64>
 300137e:	6785                	lui	a5,0x1
 3001380:	8fb78593          	addi	a1,a5,-1797 # 8fb <cipri+0x10e>
 3001384:	030107b7          	lui	a5,0x3010
 3001388:	73878513          	addi	a0,a5,1848 # 3010738 <g_crgIpMatch+0x228>
 300138c:	2b81                	jal	ra,30018dc <AssertErrorLog.trans.0>
 300138e:	a815                	j	30013c2 <DCL_ADC_SOCxSelcetChannel+0x96>
    ADC_SOC0_CFG_REG *soc = NULL;
 3001390:	fe042623          	sw	zero,-20(s0)
    unsigned int addr = ADC_GetCTRLAddr(adcx, socx); /* Get the Address After Translation */
 3001394:	fd842583          	lw	a1,-40(s0)
 3001398:	fdc42503          	lw	a0,-36(s0)
 300139c:	3fa9                	jal	ra,30012f6 <ADC_GetCTRLAddr>
 300139e:	fea42423          	sw	a0,-24(s0)
    soc = (ADC_SOC0_CFG_REG *)(void *)(uintptr_t)addr;
 30013a2:	fe842783          	lw	a5,-24(s0)
 30013a6:	fef42623          	sw	a5,-20(s0)
    soc->BIT.cfg_soc0_ch_sel = (unsigned int)input;
 30013aa:	fd442783          	lw	a5,-44(s0)
 30013ae:	8bfd                	andi	a5,a5,31
 30013b0:	0ff7f693          	andi	a3,a5,255
 30013b4:	fec42703          	lw	a4,-20(s0)
 30013b8:	431c                	lw	a5,0(a4)
 30013ba:	8afd                	andi	a3,a3,31
 30013bc:	9b81                	andi	a5,a5,-32
 30013be:	8fd5                	or	a5,a5,a3
 30013c0:	c31c                	sw	a5,0(a4)
}
 30013c2:	50b2                	lw	ra,44(sp)
 30013c4:	5422                	lw	s0,40(sp)
 30013c6:	6145                	addi	sp,sp,48
 30013c8:	8082                	ret

030013ca <DCL_ADC_SOCxSelcetTrigSource>:
 * @param socx Number of SOC, @ref ADC_SOCNumber.
 * @param trig Source of trigger, @ref ADC_TrigSource.
 * @retval None.
 */
static inline void DCL_ADC_SOCxSelcetTrigSource(ADC_RegStruct * const adcx, ADC_SOCNumber socx, ADC_TrigSource trig)
{
 30013ca:	7179                	addi	sp,sp,-48
 30013cc:	d606                	sw	ra,44(sp)
 30013ce:	d422                	sw	s0,40(sp)
 30013d0:	1800                	addi	s0,sp,48
 30013d2:	fca42e23          	sw	a0,-36(s0)
 30013d6:	fcb42c23          	sw	a1,-40(s0)
 30013da:	fcc42a23          	sw	a2,-44(s0)
    ADC_ASSERT_PARAM(IsADCInstance(adcx));
 30013de:	fdc42703          	lw	a4,-36(s0)
 30013e2:	180007b7          	lui	a5,0x18000
 30013e6:	00f70b63          	beq	a4,a5,30013fc <DCL_ADC_SOCxSelcetTrigSource+0x32>
 30013ea:	6785                	lui	a5,0x1
 30013ec:	90b78593          	addi	a1,a5,-1781 # 90b <cipri+0x11e>
 30013f0:	030107b7          	lui	a5,0x3010
 30013f4:	73878513          	addi	a0,a5,1848 # 3010738 <g_crgIpMatch+0x228>
 30013f8:	21d5                	jal	ra,30018dc <AssertErrorLog.trans.0>
 30013fa:	a001                	j	30013fa <DCL_ADC_SOCxSelcetTrigSource+0x30>
    ADC_PARAM_CHECK_NO_RET(IsADCSOCx(socx) && IsADCTrigSource(trig));
 30013fc:	fd842503          	lw	a0,-40(s0)
 3001400:	3da1                	jal	ra,3001258 <IsADCSOCx>
 3001402:	87aa                	mv	a5,a0
 3001404:	0017c793          	xori	a5,a5,1
 3001408:	9f81                	uxtb	a5
 300140a:	eb89                	bnez	a5,300141c <DCL_ADC_SOCxSelcetTrigSource+0x52>
 300140c:	fd442503          	lw	a0,-44(s0)
 3001410:	3595                	jal	ra,3001274 <IsADCTrigSource>
 3001412:	87aa                	mv	a5,a0
 3001414:	0017c793          	xori	a5,a5,1
 3001418:	9f81                	uxtb	a5
 300141a:	cb91                	beqz	a5,300142e <DCL_ADC_SOCxSelcetTrigSource+0x64>
 300141c:	6785                	lui	a5,0x1
 300141e:	90c78593          	addi	a1,a5,-1780 # 90c <cipri+0x11f>
 3001422:	030107b7          	lui	a5,0x3010
 3001426:	73878513          	addi	a0,a5,1848 # 3010738 <g_crgIpMatch+0x228>
 300142a:	294d                	jal	ra,30018dc <AssertErrorLog.trans.0>
 300142c:	a835                	j	3001468 <DCL_ADC_SOCxSelcetTrigSource+0x9e>
    unsigned int addr = ADC_GetCTRLAddr(adcx, socx); /* Obtaining the Address for Configuring the SOC */
 300142e:	fd842583          	lw	a1,-40(s0)
 3001432:	fdc42503          	lw	a0,-36(s0)
 3001436:	35c1                	jal	ra,30012f6 <ADC_GetCTRLAddr>
 3001438:	fea42623          	sw	a0,-20(s0)
    ADC_SOC0_CFG_REG *soc = NULL;
 300143c:	fe042423          	sw	zero,-24(s0)
    soc = (ADC_SOC0_CFG_REG *)(void *)(uintptr_t)addr;
 3001440:	fec42783          	lw	a5,-20(s0)
 3001444:	fef42423          	sw	a5,-24(s0)
    soc->BIT.cfg_soc0_trig_sel = (unsigned int)trig;
 3001448:	fd442783          	lw	a5,-44(s0)
 300144c:	8bfd                	andi	a5,a5,31
 300144e:	0ff7f693          	andi	a3,a5,255
 3001452:	fe842703          	lw	a4,-24(s0)
 3001456:	431c                	lw	a5,0(a4)
 3001458:	8afd                	andi	a3,a3,31
 300145a:	06a6                	slli	a3,a3,0x9
 300145c:	7671                	lui	a2,0xffffc
 300145e:	1ff60613          	addi	a2,a2,511 # ffffc1ff <RAM_END+0xfbff41ff>
 3001462:	8ff1                	and	a5,a5,a2
 3001464:	8fd5                	or	a5,a5,a3
 3001466:	c31c                	sw	a5,0(a4)
}
 3001468:	50b2                	lw	ra,44(sp)
 300146a:	5422                	lw	s0,40(sp)
 300146c:	6145                	addi	sp,sp,48
 300146e:	8082                	ret

03001470 <DCL_ADC_SOCxSetAcqps>:
 * @param socx Number of SOC, @ref ADC_SOCNumber.
 * @param acqps Capacitor charging time.
 * @retval None.
 */
static inline void DCL_ADC_SOCxSetAcqps(ADC_RegStruct * const adcx, ADC_SOCNumber socx, unsigned int acqps)
{
 3001470:	7179                	addi	sp,sp,-48
 3001472:	d606                	sw	ra,44(sp)
 3001474:	d422                	sw	s0,40(sp)
 3001476:	1800                	addi	s0,sp,48
 3001478:	fca42e23          	sw	a0,-36(s0)
 300147c:	fcb42c23          	sw	a1,-40(s0)
 3001480:	fcc42a23          	sw	a2,-44(s0)
    ADC_ASSERT_PARAM(IsADCInstance(adcx));
 3001484:	fdc42703          	lw	a4,-36(s0)
 3001488:	180007b7          	lui	a5,0x18000
 300148c:	00f70b63          	beq	a4,a5,30014a2 <DCL_ADC_SOCxSetAcqps+0x32>
 3001490:	6785                	lui	a5,0x1
 3001492:	91c78593          	addi	a1,a5,-1764 # 91c <cipri+0x12f>
 3001496:	030107b7          	lui	a5,0x3010
 300149a:	73878513          	addi	a0,a5,1848 # 3010738 <g_crgIpMatch+0x228>
 300149e:	293d                	jal	ra,30018dc <AssertErrorLog.trans.0>
 30014a0:	a001                	j	30014a0 <DCL_ADC_SOCxSetAcqps+0x30>
    ADC_PARAM_CHECK_NO_RET(IsADCSOCx(socx));
 30014a2:	fd842503          	lw	a0,-40(s0)
 30014a6:	3b4d                	jal	ra,3001258 <IsADCSOCx>
 30014a8:	87aa                	mv	a5,a0
 30014aa:	0017c793          	xori	a5,a5,1
 30014ae:	9f81                	uxtb	a5
 30014b0:	cb91                	beqz	a5,30014c4 <DCL_ADC_SOCxSetAcqps+0x54>
 30014b2:	6785                	lui	a5,0x1
 30014b4:	91d78593          	addi	a1,a5,-1763 # 91d <cipri+0x130>
 30014b8:	030107b7          	lui	a5,0x3010
 30014bc:	73878513          	addi	a0,a5,1848 # 3010738 <g_crgIpMatch+0x228>
 30014c0:	2931                	jal	ra,30018dc <AssertErrorLog.trans.0>
 30014c2:	a891                	j	3001516 <DCL_ADC_SOCxSetAcqps+0xa6>
    ADC_PARAM_CHECK_NO_RET(acqps <= 15); /* The value of acqps ranges from 0 to 15 */
 30014c4:	fd442703          	lw	a4,-44(s0)
 30014c8:	47bd                	li	a5,15
 30014ca:	00e7fb63          	bgeu	a5,a4,30014e0 <DCL_ADC_SOCxSetAcqps+0x70>
 30014ce:	6785                	lui	a5,0x1
 30014d0:	91e78593          	addi	a1,a5,-1762 # 91e <cipri+0x131>
 30014d4:	030107b7          	lui	a5,0x3010
 30014d8:	73878513          	addi	a0,a5,1848 # 3010738 <g_crgIpMatch+0x228>
 30014dc:	2101                	jal	ra,30018dc <AssertErrorLog.trans.0>
 30014de:	a825                	j	3001516 <DCL_ADC_SOCxSetAcqps+0xa6>
    unsigned int addr = ADC_GetCTRLAddr(adcx, socx);
 30014e0:	fd842583          	lw	a1,-40(s0)
 30014e4:	fdc42503          	lw	a0,-36(s0)
 30014e8:	3539                	jal	ra,30012f6 <ADC_GetCTRLAddr>
 30014ea:	fea42623          	sw	a0,-20(s0)
    ADC_SOC0_CFG_REG *soc = NULL;
 30014ee:	fe042423          	sw	zero,-24(s0)
    soc = (ADC_SOC0_CFG_REG *)(void *)(uintptr_t)addr;
 30014f2:	fec42783          	lw	a5,-20(s0)
 30014f6:	fef42423          	sw	a5,-24(s0)
    soc->BIT.cfg_soc0_samptime_sel = acqps;
 30014fa:	fd442783          	lw	a5,-44(s0)
 30014fe:	8bbd                	andi	a5,a5,15
 3001500:	0ff7f693          	andi	a3,a5,255
 3001504:	fe842703          	lw	a4,-24(s0)
 3001508:	431c                	lw	a5,0(a4)
 300150a:	8abd                	andi	a3,a3,15
 300150c:	0696                	slli	a3,a3,0x5
 300150e:	e1f7f793          	andi	a5,a5,-481
 3001512:	8fd5                	or	a5,a5,a3
 3001514:	c31c                	sw	a5,0(a4)
}
 3001516:	50b2                	lw	ra,44(sp)
 3001518:	5422                	lw	s0,40(sp)
 300151a:	6145                	addi	sp,sp,48
 300151c:	8082                	ret

0300151e <DCL_ADC_SOCxSetPriority>:
 * @param adcx ADC register base address.
 * @param priorityMode Mode of SOC priority, @ref ADC_PriorityMode.
 * @retval None.
 */
static inline void DCL_ADC_SOCxSetPriority(ADC_RegStruct * const adcx, ADC_PriorityMode priorityMode)
{
 300151e:	1101                	addi	sp,sp,-32
 3001520:	ce06                	sw	ra,28(sp)
 3001522:	cc22                	sw	s0,24(sp)
 3001524:	1000                	addi	s0,sp,32
 3001526:	fea42623          	sw	a0,-20(s0)
 300152a:	feb42423          	sw	a1,-24(s0)
    ADC_ASSERT_PARAM(IsADCInstance(adcx));
 300152e:	fec42703          	lw	a4,-20(s0)
 3001532:	180007b7          	lui	a5,0x18000
 3001536:	00f70b63          	beq	a4,a5,300154c <DCL_ADC_SOCxSetPriority+0x2e>
 300153a:	6785                	lui	a5,0x1
 300153c:	94778593          	addi	a1,a5,-1721 # 947 <cipri+0x15a>
 3001540:	030107b7          	lui	a5,0x3010
 3001544:	73878513          	addi	a0,a5,1848 # 3010738 <g_crgIpMatch+0x228>
 3001548:	2e51                	jal	ra,30018dc <AssertErrorLog.trans.0>
 300154a:	a001                	j	300154a <DCL_ADC_SOCxSetPriority+0x2c>
    ADC_PARAM_CHECK_NO_RET(IsADCPriorityMode(priorityMode));
 300154c:	fe842503          	lw	a0,-24(s0)
 3001550:	33b5                	jal	ra,30012bc <IsADCPriorityMode>
 3001552:	87aa                	mv	a5,a0
 3001554:	0017c793          	xori	a5,a5,1
 3001558:	9f81                	uxtb	a5
 300155a:	cb91                	beqz	a5,300156e <DCL_ADC_SOCxSetPriority+0x50>
 300155c:	6785                	lui	a5,0x1
 300155e:	94878593          	addi	a1,a5,-1720 # 948 <cipri+0x15b>
 3001562:	030107b7          	lui	a5,0x3010
 3001566:	73878513          	addi	a0,a5,1848 # 3010738 <g_crgIpMatch+0x228>
 300156a:	2e8d                	jal	ra,30018dc <AssertErrorLog.trans.0>
 300156c:	a039                	j	300157a <DCL_ADC_SOCxSetPriority+0x5c>
    adcx->ADC_ARBT0.reg = priorityMode;
 300156e:	fec42783          	lw	a5,-20(s0)
 3001572:	fe842703          	lw	a4,-24(s0)
 3001576:	20e7a023          	sw	a4,512(a5)
}
 300157a:	40f2                	lw	ra,28(sp)
 300157c:	4462                	lw	s0,24(sp)
 300157e:	6105                	addi	sp,sp,32
 3001580:	8082                	ret

03001582 <DCL_ADC_EnableSOCxContinue>:
 * @param adcx ADC register base address.
 * @param socx Number of SOC, @ref ADC_SOCNumber.
 * @retval None.
 */
static inline void DCL_ADC_EnableSOCxContinue(ADC_RegStruct * const adcx, ADC_SOCNumber socx)
{
 3001582:	7179                	addi	sp,sp,-48
 3001584:	d606                	sw	ra,44(sp)
 3001586:	d422                	sw	s0,40(sp)
 3001588:	1800                	addi	s0,sp,48
 300158a:	fca42e23          	sw	a0,-36(s0)
 300158e:	fcb42c23          	sw	a1,-40(s0)
    ADC_ASSERT_PARAM(IsADCInstance(adcx));
 3001592:	fdc42703          	lw	a4,-36(s0)
 3001596:	180007b7          	lui	a5,0x18000
 300159a:	00f70b63          	beq	a4,a5,30015b0 <DCL_ADC_EnableSOCxContinue+0x2e>
 300159e:	6785                	lui	a5,0x1
 30015a0:	b2178593          	addi	a1,a5,-1247 # b21 <cipri+0x334>
 30015a4:	030107b7          	lui	a5,0x3010
 30015a8:	73878513          	addi	a0,a5,1848 # 3010738 <g_crgIpMatch+0x228>
 30015ac:	2e05                	jal	ra,30018dc <AssertErrorLog.trans.0>
 30015ae:	a001                	j	30015ae <DCL_ADC_EnableSOCxContinue+0x2c>
    ADC_PARAM_CHECK_NO_RET(IsADCSOCx(socx));
 30015b0:	fd842503          	lw	a0,-40(s0)
 30015b4:	3155                	jal	ra,3001258 <IsADCSOCx>
 30015b6:	87aa                	mv	a5,a0
 30015b8:	0017c793          	xori	a5,a5,1
 30015bc:	9f81                	uxtb	a5
 30015be:	cb91                	beqz	a5,30015d2 <DCL_ADC_EnableSOCxContinue+0x50>
 30015c0:	6785                	lui	a5,0x1
 30015c2:	b2278593          	addi	a1,a5,-1246 # b22 <cipri+0x335>
 30015c6:	030107b7          	lui	a5,0x3010
 30015ca:	73878513          	addi	a0,a5,1848 # 3010738 <g_crgIpMatch+0x228>
 30015ce:	2639                	jal	ra,30018dc <AssertErrorLog.trans.0>
 30015d0:	a025                	j	30015f8 <DCL_ADC_EnableSOCxContinue+0x76>
    unsigned int addr = ADC_GetCTRLAddr(adcx, socx); /* Obtains the SOC base address  */
 30015d2:	fd842583          	lw	a1,-40(s0)
 30015d6:	fdc42503          	lw	a0,-36(s0)
 30015da:	3b31                	jal	ra,30012f6 <ADC_GetCTRLAddr>
 30015dc:	fea42623          	sw	a0,-20(s0)
    ADC_SOC0_CFG_REG *soc = NULL;
 30015e0:	fe042423          	sw	zero,-24(s0)
    soc = (ADC_SOC0_CFG_REG *)(void *)(uintptr_t)addr;
 30015e4:	fec42783          	lw	a5,-20(s0)
 30015e8:	fef42423          	sw	a5,-24(s0)
    soc->BIT.cfg_soc0_cont_en = BASE_CFG_ENABLE;
 30015ec:	fe842703          	lw	a4,-24(s0)
 30015f0:	431c                	lw	a5,0(a4)
 30015f2:	6691                	lui	a3,0x4
 30015f4:	8fd5                	or	a5,a5,a3
 30015f6:	c31c                	sw	a5,0(a4)
}
 30015f8:	50b2                	lw	ra,44(sp)
 30015fa:	5422                	lw	s0,40(sp)
 30015fc:	6145                	addi	sp,sp,48
 30015fe:	8082                	ret

03001600 <DCL_ADC_DisableSOCxContinue>:
 * @param adcx ADC register base address.
 * @param socx Number of SOC, @ref ADC_SOCNumber.
 * @retval None.
 */
static inline void DCL_ADC_DisableSOCxContinue(ADC_RegStruct * const adcx, ADC_SOCNumber socx)
{
 3001600:	7179                	addi	sp,sp,-48
 3001602:	d606                	sw	ra,44(sp)
 3001604:	d422                	sw	s0,40(sp)
 3001606:	1800                	addi	s0,sp,48
 3001608:	fca42e23          	sw	a0,-36(s0)
 300160c:	fcb42c23          	sw	a1,-40(s0)
    ADC_ASSERT_PARAM(IsADCInstance(adcx));
 3001610:	fdc42703          	lw	a4,-36(s0)
 3001614:	180007b7          	lui	a5,0x18000
 3001618:	00f70b63          	beq	a4,a5,300162e <DCL_ADC_DisableSOCxContinue+0x2e>
 300161c:	6785                	lui	a5,0x1
 300161e:	b3178593          	addi	a1,a5,-1231 # b31 <cipri+0x344>
 3001622:	030107b7          	lui	a5,0x3010
 3001626:	73878513          	addi	a0,a5,1848 # 3010738 <g_crgIpMatch+0x228>
 300162a:	2c4d                	jal	ra,30018dc <AssertErrorLog.trans.0>
 300162c:	a001                	j	300162c <DCL_ADC_DisableSOCxContinue+0x2c>
    ADC_PARAM_CHECK_NO_RET(IsADCSOCx(socx));
 300162e:	fd842503          	lw	a0,-40(s0)
 3001632:	311d                	jal	ra,3001258 <IsADCSOCx>
 3001634:	87aa                	mv	a5,a0
 3001636:	0017c793          	xori	a5,a5,1
 300163a:	9f81                	uxtb	a5
 300163c:	cb91                	beqz	a5,3001650 <DCL_ADC_DisableSOCxContinue+0x50>
 300163e:	6785                	lui	a5,0x1
 3001640:	b3278593          	addi	a1,a5,-1230 # b32 <cipri+0x345>
 3001644:	030107b7          	lui	a5,0x3010
 3001648:	73878513          	addi	a0,a5,1848 # 3010738 <g_crgIpMatch+0x228>
 300164c:	2c41                	jal	ra,30018dc <AssertErrorLog.trans.0>
 300164e:	a02d                	j	3001678 <DCL_ADC_DisableSOCxContinue+0x78>
    unsigned int addr = ADC_GetCTRLAddr(adcx, socx); /* Obtains the SOC base address  */
 3001650:	fd842583          	lw	a1,-40(s0)
 3001654:	fdc42503          	lw	a0,-36(s0)
 3001658:	3979                	jal	ra,30012f6 <ADC_GetCTRLAddr>
 300165a:	fea42623          	sw	a0,-20(s0)
    ADC_SOC0_CFG_REG *soc = NULL;
 300165e:	fe042423          	sw	zero,-24(s0)
    soc = (ADC_SOC0_CFG_REG *)(void *)(uintptr_t)addr;
 3001662:	fec42783          	lw	a5,-20(s0)
 3001666:	fef42423          	sw	a5,-24(s0)
    soc->BIT.cfg_soc0_cont_en = BASE_CFG_DISABLE;
 300166a:	fe842703          	lw	a4,-24(s0)
 300166e:	431c                	lw	a5,0(a4)
 3001670:	76f1                	lui	a3,0xffffc
 3001672:	16fd                	addi	a3,a3,-1 # ffffbfff <RAM_END+0xfbff3fff>
 3001674:	8ff5                	and	a5,a5,a3
 3001676:	c31c                	sw	a5,0(a4)
}
 3001678:	50b2                	lw	ra,44(sp)
 300167a:	5422                	lw	s0,40(sp)
 300167c:	6145                	addi	sp,sp,48
 300167e:	8082                	ret

03001680 <HAL_ADC_Init>:
  * triggered at least 100 us later.
  * @param adcHandle ADC handle.
  * @retval BASE status type: OK, ERROR.
  */
BASE_StatusType HAL_ADC_Init(ADC_Handle *adcHandle)
{
 3001680:	1101                	addi	sp,sp,-32
 3001682:	ce06                	sw	ra,28(sp)
 3001684:	cc22                	sw	s0,24(sp)
 3001686:	1000                	addi	s0,sp,32
 3001688:	fea42623          	sw	a0,-20(s0)
    ADC_ASSERT_PARAM(adcHandle != NULL);
 300168c:	fec42783          	lw	a5,-20(s0)
 3001690:	eb89                	bnez	a5,30016a2 <HAL_ADC_Init+0x22>
 3001692:	02b00593          	li	a1,43
 3001696:	030107b7          	lui	a5,0x3010
 300169a:	75478513          	addi	a0,a5,1876 # 3010754 <g_crgIpMatch+0x244>
 300169e:	2c3d                	jal	ra,30018dc <AssertErrorLog.trans.0>
 30016a0:	a001                	j	30016a0 <HAL_ADC_Init+0x20>
    ADC_ASSERT_PARAM(IsADCInstance(adcHandle->baseAddress));
 30016a2:	fec42783          	lw	a5,-20(s0)
 30016a6:	4398                	lw	a4,0(a5)
 30016a8:	180007b7          	lui	a5,0x18000
 30016ac:	00f70a63          	beq	a4,a5,30016c0 <HAL_ADC_Init+0x40>
 30016b0:	02c00593          	li	a1,44
 30016b4:	030107b7          	lui	a5,0x3010
 30016b8:	75478513          	addi	a0,a5,1876 # 3010754 <g_crgIpMatch+0x244>
 30016bc:	2405                	jal	ra,30018dc <AssertErrorLog.trans.0>
 30016be:	a001                	j	30016be <HAL_ADC_Init+0x3e>
    ADC_PARAM_CHECK_WITH_RET(IsADCPriorityMode(adcHandle->socPriority) == true, BASE_STATUS_ERROR);
 30016c0:	fec42783          	lw	a5,-20(s0)
 30016c4:	43dc                	lw	a5,4(a5)
 30016c6:	853e                	mv	a0,a5
 30016c8:	3ed5                	jal	ra,30012bc <IsADCPriorityMode>
 30016ca:	87aa                	mv	a5,a0
 30016cc:	0017c793          	xori	a5,a5,1
 30016d0:	9f81                	uxtb	a5
 30016d2:	cb91                	beqz	a5,30016e6 <HAL_ADC_Init+0x66>
 30016d4:	02d00593          	li	a1,45
 30016d8:	030107b7          	lui	a5,0x3010
 30016dc:	75478513          	addi	a0,a5,1876 # 3010754 <g_crgIpMatch+0x244>
 30016e0:	2af5                	jal	ra,30018dc <AssertErrorLog.trans.0>
 30016e2:	4785                	li	a5,1
 30016e4:	a099                	j	300172a <HAL_ADC_Init+0xaa>
    DCL_ADC_SOCxSetPriority(adcHandle->baseAddress, adcHandle->socPriority);
 30016e6:	fec42783          	lw	a5,-20(s0)
 30016ea:	4398                	lw	a4,0(a5)
 30016ec:	fec42783          	lw	a5,-20(s0)
 30016f0:	43dc                	lw	a5,4(a5)
 30016f2:	85be                	mv	a1,a5
 30016f4:	853a                	mv	a0,a4
 30016f6:	3525                	jal	ra,300151e <DCL_ADC_SOCxSetPriority>
    adcHandle->baseAddress->ADC_ANA_CTRL0.BIT.cfg_sar_samp_cap_sel = 0x4; /* Set the Number of Sampling Capacitors */
 30016f8:	fec42783          	lw	a5,-20(s0)
 30016fc:	4398                	lw	a4,0(a5)
 30016fe:	65472783          	lw	a5,1620(a4)
 3001702:	100006b7          	lui	a3,0x10000
 3001706:	16fd                	addi	a3,a3,-1 # fffffff <RAM_END+0xbff7fff>
 3001708:	8efd                	and	a3,a3,a5
 300170a:	400007b7          	lui	a5,0x40000
 300170e:	8fd5                	or	a5,a5,a3
 3001710:	64f72a23          	sw	a5,1620(a4)
    adcHandle->baseAddress->ADC_EN.reg = BASE_CFG_ENABLE; /* Enable ADC Controller */
 3001714:	fec42783          	lw	a5,-20(s0)
 3001718:	439c                	lw	a5,0(a5)
 300171a:	4705                	li	a4,1
 300171c:	30e7a023          	sw	a4,768(a5) # 40000300 <RAM_END+0x3bff8300>
    BASE_FUNC_DelayUs(100);  /* Wait for 100 us until the ADC controller is stable */
 3001720:	06400513          	li	a0,100
 3001724:	65c010ef          	jal	ra,3002d80 <BASE_FUNC_DelayUs>
    return BASE_STATUS_OK;
 3001728:	4781                	li	a5,0
}
 300172a:	853e                	mv	a0,a5
 300172c:	40f2                	lw	ra,28(sp)
 300172e:	4462                	lw	s0,24(sp)
 3001730:	6105                	addi	sp,sp,32
 3001732:	8082                	ret

03001734 <HAL_ADC_ConfigureSoc>:
  * @param soc ID of SOC(start of conversion), managing the specific sample inputs.
  * @param socParam Param struct of SOC. This is related to the peripheral circuit design, @ref SOC_Param.
  * @retval BASE status type: OK, ERROR.
  */
BASE_StatusType HAL_ADC_ConfigureSoc(ADC_Handle *adcHandle, ADC_SOCNumber soc, SOC_Param *socParam)
{
 3001734:	1101                	addi	sp,sp,-32
 3001736:	ce06                	sw	ra,28(sp)
 3001738:	cc22                	sw	s0,24(sp)
 300173a:	1000                	addi	s0,sp,32
 300173c:	fea42623          	sw	a0,-20(s0)
 3001740:	feb42423          	sw	a1,-24(s0)
 3001744:	fec42223          	sw	a2,-28(s0)
    ADC_ASSERT_PARAM(adcHandle != NULL);
 3001748:	fec42783          	lw	a5,-20(s0)
 300174c:	eb89                	bnez	a5,300175e <HAL_ADC_ConfigureSoc+0x2a>
 300174e:	04b00593          	li	a1,75
 3001752:	030107b7          	lui	a5,0x3010
 3001756:	75478513          	addi	a0,a5,1876 # 3010754 <g_crgIpMatch+0x244>
 300175a:	2249                	jal	ra,30018dc <AssertErrorLog.trans.0>
 300175c:	a001                	j	300175c <HAL_ADC_ConfigureSoc+0x28>
    ADC_ASSERT_PARAM(IsADCInstance(adcHandle->baseAddress));
 300175e:	fec42783          	lw	a5,-20(s0)
 3001762:	4398                	lw	a4,0(a5)
 3001764:	180007b7          	lui	a5,0x18000
 3001768:	00f70a63          	beq	a4,a5,300177c <HAL_ADC_ConfigureSoc+0x48>
 300176c:	04c00593          	li	a1,76
 3001770:	030107b7          	lui	a5,0x3010
 3001774:	75478513          	addi	a0,a5,1876 # 3010754 <g_crgIpMatch+0x244>
 3001778:	2295                	jal	ra,30018dc <AssertErrorLog.trans.0>
 300177a:	a001                	j	300177a <HAL_ADC_ConfigureSoc+0x46>
    ADC_PARAM_CHECK_WITH_RET(IsADCSOCx(soc) == true, BASE_STATUS_ERROR);
 300177c:	fe842503          	lw	a0,-24(s0)
 3001780:	3ce1                	jal	ra,3001258 <IsADCSOCx>
 3001782:	87aa                	mv	a5,a0
 3001784:	0017c793          	xori	a5,a5,1
 3001788:	9f81                	uxtb	a5
 300178a:	cb91                	beqz	a5,300179e <HAL_ADC_ConfigureSoc+0x6a>
 300178c:	04d00593          	li	a1,77
 3001790:	030107b7          	lui	a5,0x3010
 3001794:	75478513          	addi	a0,a5,1876 # 3010754 <g_crgIpMatch+0x244>
 3001798:	2291                	jal	ra,30018dc <AssertErrorLog.trans.0>
 300179a:	4785                	li	a5,1
 300179c:	aa1d                	j	30018d2 <HAL_ADC_ConfigureSoc+0x19e>
    ADC_ASSERT_PARAM(socParam != NULL);
 300179e:	fe442783          	lw	a5,-28(s0)
 30017a2:	eb89                	bnez	a5,30017b4 <HAL_ADC_ConfigureSoc+0x80>
 30017a4:	04e00593          	li	a1,78
 30017a8:	030107b7          	lui	a5,0x3010
 30017ac:	75478513          	addi	a0,a5,1876 # 3010754 <g_crgIpMatch+0x244>
 30017b0:	2235                	jal	ra,30018dc <AssertErrorLog.trans.0>
 30017b2:	a001                	j	30017b2 <HAL_ADC_ConfigureSoc+0x7e>
    ADC_PARAM_CHECK_WITH_RET(IsADCSampleChannel(socParam->adcInput) == true, BASE_STATUS_ERROR);
 30017b4:	fe442783          	lw	a5,-28(s0)
 30017b8:	439c                	lw	a5,0(a5)
 30017ba:	853e                	mv	a0,a5
 30017bc:	3441                	jal	ra,300123c <IsADCSampleChannel>
 30017be:	87aa                	mv	a5,a0
 30017c0:	0017c793          	xori	a5,a5,1
 30017c4:	9f81                	uxtb	a5
 30017c6:	cb91                	beqz	a5,30017da <HAL_ADC_ConfigureSoc+0xa6>
 30017c8:	04f00593          	li	a1,79
 30017cc:	030107b7          	lui	a5,0x3010
 30017d0:	75478513          	addi	a0,a5,1876 # 3010754 <g_crgIpMatch+0x244>
 30017d4:	2221                	jal	ra,30018dc <AssertErrorLog.trans.0>
 30017d6:	4785                	li	a5,1
 30017d8:	a8ed                	j	30018d2 <HAL_ADC_ConfigureSoc+0x19e>
    ADC_PARAM_CHECK_WITH_RET(IsADCTotalTime(socParam->sampleTotalTime) == true, BASE_STATUS_ERROR);
 30017da:	fe442783          	lw	a5,-28(s0)
 30017de:	43dc                	lw	a5,4(a5)
 30017e0:	853e                	mv	a0,a5
 30017e2:	3ce5                	jal	ra,30012da <IsADCTotalTime>
 30017e4:	87aa                	mv	a5,a0
 30017e6:	0017c793          	xori	a5,a5,1
 30017ea:	9f81                	uxtb	a5
 30017ec:	cb91                	beqz	a5,3001800 <HAL_ADC_ConfigureSoc+0xcc>
 30017ee:	05000593          	li	a1,80
 30017f2:	030107b7          	lui	a5,0x3010
 30017f6:	75478513          	addi	a0,a5,1876 # 3010754 <g_crgIpMatch+0x244>
 30017fa:	20cd                	jal	ra,30018dc <AssertErrorLog.trans.0>
 30017fc:	4785                	li	a5,1
 30017fe:	a8d1                	j	30018d2 <HAL_ADC_ConfigureSoc+0x19e>
    ADC_PARAM_CHECK_WITH_RET(IsADCTrigSource(socParam->trigSource) == true, BASE_STATUS_ERROR);
 3001800:	fe442783          	lw	a5,-28(s0)
 3001804:	479c                	lw	a5,8(a5)
 3001806:	853e                	mv	a0,a5
 3001808:	34b5                	jal	ra,3001274 <IsADCTrigSource>
 300180a:	87aa                	mv	a5,a0
 300180c:	0017c793          	xori	a5,a5,1
 3001810:	9f81                	uxtb	a5
 3001812:	cb91                	beqz	a5,3001826 <HAL_ADC_ConfigureSoc+0xf2>
 3001814:	05100593          	li	a1,81
 3001818:	030107b7          	lui	a5,0x3010
 300181c:	75478513          	addi	a0,a5,1876 # 3010754 <g_crgIpMatch+0x244>
 3001820:	2875                	jal	ra,30018dc <AssertErrorLog.trans.0>
 3001822:	4785                	li	a5,1
 3001824:	a07d                	j	30018d2 <HAL_ADC_ConfigureSoc+0x19e>
    ADC_PARAM_CHECK_WITH_RET(IsADCFinishMode(socParam->finishMode) == true, BASE_STATUS_ERROR);
 3001826:	fe442783          	lw	a5,-28(s0)
 300182a:	4b9c                	lw	a5,16(a5)
 300182c:	853e                	mv	a0,a5
 300182e:	348d                	jal	ra,3001290 <IsADCFinishMode>
 3001830:	87aa                	mv	a5,a0
 3001832:	0017c793          	xori	a5,a5,1
 3001836:	9f81                	uxtb	a5
 3001838:	cb91                	beqz	a5,300184c <HAL_ADC_ConfigureSoc+0x118>
 300183a:	05200593          	li	a1,82
 300183e:	030107b7          	lui	a5,0x3010
 3001842:	75478513          	addi	a0,a5,1876 # 3010754 <g_crgIpMatch+0x244>
 3001846:	2859                	jal	ra,30018dc <AssertErrorLog.trans.0>
 3001848:	4785                	li	a5,1
 300184a:	a061                	j	30018d2 <HAL_ADC_ConfigureSoc+0x19e>
    DCL_ADC_SOCxSelcetChannel(adcHandle->baseAddress, soc, socParam->adcInput);      /* Set channel */
 300184c:	fec42783          	lw	a5,-20(s0)
 3001850:	4398                	lw	a4,0(a5)
 3001852:	fe442783          	lw	a5,-28(s0)
 3001856:	439c                	lw	a5,0(a5)
 3001858:	863e                	mv	a2,a5
 300185a:	fe842583          	lw	a1,-24(s0)
 300185e:	853a                	mv	a0,a4
 3001860:	34f1                	jal	ra,300132c <DCL_ADC_SOCxSelcetChannel>
    DCL_ADC_SOCxSetAcqps(adcHandle->baseAddress, soc, socParam->sampleTotalTime);    /* Set sampling time */
 3001862:	fec42783          	lw	a5,-20(s0)
 3001866:	4398                	lw	a4,0(a5)
 3001868:	fe442783          	lw	a5,-28(s0)
 300186c:	43dc                	lw	a5,4(a5)
 300186e:	863e                	mv	a2,a5
 3001870:	fe842583          	lw	a1,-24(s0)
 3001874:	853a                	mv	a0,a4
 3001876:	3eed                	jal	ra,3001470 <DCL_ADC_SOCxSetAcqps>
    DCL_ADC_SOCxSelcetTrigSource(adcHandle->baseAddress, soc, socParam->trigSource); /* Set trigger source */
 3001878:	fec42783          	lw	a5,-20(s0)
 300187c:	4398                	lw	a4,0(a5)
 300187e:	fe442783          	lw	a5,-28(s0)
 3001882:	479c                	lw	a5,8(a5)
 3001884:	863e                	mv	a2,a5
 3001886:	fe842583          	lw	a1,-24(s0)
 300188a:	853a                	mv	a0,a4
 300188c:	3e3d                	jal	ra,30013ca <DCL_ADC_SOCxSelcetTrigSource>
    if (socParam->continueMode == true) { /* Continuous Mode Judgment */
 300188e:	fe442783          	lw	a5,-28(s0)
 3001892:	27dc                	lbu	a5,12(a5)
 3001894:	cb89                	beqz	a5,30018a6 <HAL_ADC_ConfigureSoc+0x172>
        DCL_ADC_EnableSOCxContinue(adcHandle->baseAddress, soc);
 3001896:	fec42783          	lw	a5,-20(s0)
 300189a:	439c                	lw	a5,0(a5)
 300189c:	fe842583          	lw	a1,-24(s0)
 30018a0:	853e                	mv	a0,a5
 30018a2:	31c5                	jal	ra,3001582 <DCL_ADC_EnableSOCxContinue>
 30018a4:	a801                	j	30018b4 <HAL_ADC_ConfigureSoc+0x180>
    } else {
        DCL_ADC_DisableSOCxContinue(adcHandle->baseAddress, soc);
 30018a6:	fec42783          	lw	a5,-20(s0)
 30018aa:	439c                	lw	a5,0(a5)
 30018ac:	fe842583          	lw	a1,-24(s0)
 30018b0:	853e                	mv	a0,a5
 30018b2:	33b9                	jal	ra,3001600 <DCL_ADC_DisableSOCxContinue>
    }
    adcHandle->ADC_SOCxParam[soc].finishMode = socParam->finishMode;
 30018b4:	fe442783          	lw	a5,-28(s0)
 30018b8:	4b9c                	lw	a5,16(a5)
 30018ba:	01079713          	slli	a4,a5,0x10
 30018be:	8341                	srli	a4,a4,0x10
 30018c0:	fec42683          	lw	a3,-20(s0)
 30018c4:	fe842783          	lw	a5,-24(s0)
 30018c8:	07a1                	addi	a5,a5,8
 30018ca:	0786                	slli	a5,a5,0x1
 30018cc:	97b6                	add	a5,a5,a3
 30018ce:	a3da                	sh	a4,4(a5)
    return BASE_STATUS_OK;
 30018d0:	4781                	li	a5,0
}
 30018d2:	853e                	mv	a0,a5
 30018d4:	40f2                	lw	ra,28(sp)
 30018d6:	4462                	lw	s0,24(sp)
 30018d8:	6105                	addi	sp,sp,32
 30018da:	8082                	ret

030018dc <AssertErrorLog.trans.0>:
 30018dc:	4620106f          	j	3002d3e <AssertErrorLog>

030018e0 <APT_TimeBaseInit>:
  * @brief Initialize the time-base counter of APT module.
  * @param aptHandle APT module handle.
  * @retval None.
  */
static void APT_TimeBaseInit(APT_Handle *aptHandle)
{
 30018e0:	1101                	addi	sp,sp,-32
 30018e2:	ce22                	sw	s0,28(sp)
 30018e4:	1000                	addi	s0,sp,32
 30018e6:	fea42623          	sw	a0,-20(s0)
    aptHandle->baseAddress->TC_MODE.BIT.rg_cnt_mode = aptHandle->waveform.cntMode;
 30018ea:	fec42783          	lw	a5,-20(s0)
 30018ee:	4b94                	lw	a3,16(a5)
 30018f0:	fec42783          	lw	a5,-20(s0)
 30018f4:	4398                	lw	a4,0(a5)
 30018f6:	87b6                	mv	a5,a3
 30018f8:	8b8d                	andi	a5,a5,3
 30018fa:	0ff7f693          	andi	a3,a5,255
 30018fe:	4b1c                	lw	a5,16(a4)
 3001900:	8a8d                	andi	a3,a3,3
 3001902:	9bf1                	andi	a5,a5,-4
 3001904:	8fd5                	or	a5,a5,a3
 3001906:	cb1c                	sw	a5,16(a4)
    aptHandle->baseAddress->TC_MODE.BIT.rg_div_fac = aptHandle->waveform.dividerFactor;
 3001908:	fec42783          	lw	a5,-20(s0)
 300190c:	2bd6                	lhu	a3,20(a5)
 300190e:	fec42783          	lw	a5,-20(s0)
 3001912:	4398                	lw	a4,0(a5)
 3001914:	6785                	lui	a5,0x1
 3001916:	17fd                	addi	a5,a5,-1 # fff <__bss_size__+0x38b>
 3001918:	8ff5                	and	a5,a5,a3
 300191a:	01079613          	slli	a2,a5,0x10
 300191e:	8241                	srli	a2,a2,0x10
 3001920:	4b1c                	lw	a5,16(a4)
 3001922:	6685                	lui	a3,0x1
 3001924:	16fd                	addi	a3,a3,-1 # fff <__bss_size__+0x38b>
 3001926:	8ef1                	and	a3,a3,a2
 3001928:	06c2                	slli	a3,a3,0x10
 300192a:	f0010637          	lui	a2,0xf0010
 300192e:	167d                	addi	a2,a2,-1 # f000ffff <RAM_END+0xec007fff>
 3001930:	8ff1                	and	a5,a5,a2
 3001932:	8fd5                	or	a5,a5,a3
 3001934:	cb1c                	sw	a5,16(a4)
    /* Disable buffer mode of TC_PRD */
    aptHandle->baseAddress->TC_BUF_EN.reg &= (~(0b11 << 0));
 3001936:	fec42783          	lw	a5,-20(s0)
 300193a:	439c                	lw	a5,0(a5)
 300193c:	4bb8                	lw	a4,80(a5)
 300193e:	fec42783          	lw	a5,-20(s0)
 3001942:	439c                	lw	a5,0(a5)
 3001944:	9b71                	andi	a4,a4,-4
 3001946:	cbb8                	sw	a4,80(a5)
    aptHandle->baseAddress->TC_PRD.BIT.rg_cnt_prd = aptHandle->waveform.timerPeriod;
 3001948:	fec42783          	lw	a5,-20(s0)
 300194c:	4398                	lw	a4,0(a5)
 300194e:	fec42783          	lw	a5,-20(s0)
 3001952:	2bf2                	lhu	a2,22(a5)
 3001954:	531c                	lw	a5,32(a4)
 3001956:	66c1                	lui	a3,0x10
 3001958:	16fd                	addi	a3,a3,-1 # ffff <RAM_SIZE+0xafff>
 300195a:	8ef1                	and	a3,a3,a2
 300195c:	7641                	lui	a2,0xffff0
 300195e:	8ff1                	and	a5,a5,a2
 3001960:	8fd5                	or	a5,a5,a3
 3001962:	d31c                	sw	a5,32(a4)
    /* Set the override value of divier and timebase counter */
    aptHandle->baseAddress->TC_OVRID.BIT.rg_cnt_ovrid = aptHandle->waveform.cntInitVal;
 3001964:	fec42783          	lw	a5,-20(s0)
 3001968:	4398                	lw	a4,0(a5)
 300196a:	fec42783          	lw	a5,-20(s0)
 300196e:	2fb2                	lhu	a2,26(a5)
 3001970:	4f1c                	lw	a5,24(a4)
 3001972:	66c1                	lui	a3,0x10
 3001974:	16fd                	addi	a3,a3,-1 # ffff <RAM_SIZE+0xafff>
 3001976:	8ef1                	and	a3,a3,a2
 3001978:	7641                	lui	a2,0xffff0
 300197a:	8ff1                	and	a5,a5,a2
 300197c:	8fd5                	or	a5,a5,a3
 300197e:	cf1c                	sw	a5,24(a4)
    aptHandle->baseAddress->TC_OVRID.BIT.rg_cnt_ovrid_en = 1;
 3001980:	fec42783          	lw	a5,-20(s0)
 3001984:	4398                	lw	a4,0(a5)
 3001986:	4f1c                	lw	a5,24(a4)
 3001988:	800006b7          	lui	a3,0x80000
 300198c:	8fd5                	or	a5,a5,a3
 300198e:	cf1c                	sw	a5,24(a4)
}
 3001990:	0001                	nop
 3001992:	4472                	lw	s0,28(sp)
 3001994:	6105                	addi	sp,sp,32
 3001996:	8082                	ret

03001998 <APT_SetPWMCompareVal>:
  * @brief Initialize the count compare points for PWM waveform generation.
  * @param aptHandle APT module handle.
  * @retval None.
  */
static void APT_SetPWMCompareVal(APT_Handle *aptHandle)
{
 3001998:	7179                	addi	sp,sp,-48
 300199a:	d622                	sw	s0,44(sp)
 300199c:	1800                	addi	s0,sp,48
 300199e:	fca42e23          	sw	a0,-36(s0)
    /* Configure the compare point along the left and right edges of PWM waveform */
    TC_REFC_REG tmpC;
    TC_REFD_REG tmpD;
    /* Set the value of the active register of CMPC and CMPD */
    tmpC = aptHandle->baseAddress->TC_REFC;
 30019a2:	fdc42783          	lw	a5,-36(s0)
 30019a6:	439c                	lw	a5,0(a5)
 30019a8:	5f9c                	lw	a5,56(a5)
 30019aa:	fef42223          	sw	a5,-28(s0)
    tmpC.BIT.rg_cnt_refc = aptHandle->waveform.cntCmpLeftEdge;
 30019ae:	fdc42783          	lw	a5,-36(s0)
 30019b2:	2fd6                	lhu	a3,28(a5)
 30019b4:	fe442783          	lw	a5,-28(s0)
 30019b8:	6741                	lui	a4,0x10
 30019ba:	177d                	addi	a4,a4,-1 # ffff <RAM_SIZE+0xafff>
 30019bc:	8f75                	and	a4,a4,a3
 30019be:	76c1                	lui	a3,0xffff0
 30019c0:	8ff5                	and	a5,a5,a3
 30019c2:	8fd9                	or	a5,a5,a4
 30019c4:	fef42223          	sw	a5,-28(s0)
    aptHandle->baseAddress->TC_REFC = tmpC;
 30019c8:	fdc42783          	lw	a5,-36(s0)
 30019cc:	439c                	lw	a5,0(a5)
 30019ce:	fe442703          	lw	a4,-28(s0)
 30019d2:	df98                	sw	a4,56(a5)
    tmpD = aptHandle->baseAddress->TC_REFD;
 30019d4:	fdc42783          	lw	a5,-36(s0)
 30019d8:	439c                	lw	a5,0(a5)
 30019da:	5fdc                	lw	a5,60(a5)
 30019dc:	fef42023          	sw	a5,-32(s0)
    tmpD.BIT.rg_cnt_refd = aptHandle->waveform.cntCmpRightEdge;
 30019e0:	fdc42783          	lw	a5,-36(s0)
 30019e4:	2ff6                	lhu	a3,30(a5)
 30019e6:	fe042783          	lw	a5,-32(s0)
 30019ea:	6741                	lui	a4,0x10
 30019ec:	177d                	addi	a4,a4,-1 # ffff <RAM_SIZE+0xafff>
 30019ee:	8f75                	and	a4,a4,a3
 30019f0:	76c1                	lui	a3,0xffff0
 30019f2:	8ff5                	and	a5,a5,a3
 30019f4:	8fd9                	or	a5,a5,a4
 30019f6:	fef42023          	sw	a5,-32(s0)
    aptHandle->baseAddress->TC_REFD = tmpD;
 30019fa:	fdc42783          	lw	a5,-36(s0)
 30019fe:	439c                	lw	a5,0(a5)
 3001a00:	fe042703          	lw	a4,-32(s0)
 3001a04:	dfd8                	sw	a4,60(a5)
    /* Set the buffer load mode of CMPC and CMPD */
    if (aptHandle->waveform.cntCmpLoadMode == APT_BUFFER_DISABLE) {
 3001a06:	fdc42783          	lw	a5,-36(s0)
 3001a0a:	539c                	lw	a5,32(a5)
 3001a0c:	e385                	bnez	a5,3001a2c <APT_SetPWMCompareVal+0x94>
        aptHandle->baseAddress->TC_BUF_EN.BIT.rg_refc_buf_en = 0;
 3001a0e:	fdc42783          	lw	a5,-36(s0)
 3001a12:	4398                	lw	a4,0(a5)
 3001a14:	4b3c                	lw	a5,80(a4)
 3001a16:	eff7f793          	andi	a5,a5,-257
 3001a1a:	cb3c                	sw	a5,80(a4)
        aptHandle->baseAddress->TC_BUF_EN.BIT.rg_refd_buf_en = 0;
 3001a1c:	fdc42783          	lw	a5,-36(s0)
 3001a20:	4398                	lw	a4,0(a5)
 3001a22:	4b3c                	lw	a5,80(a4)
 3001a24:	bff7f793          	andi	a5,a5,-1025
 3001a28:	cb3c                	sw	a5,80(a4)
        aptHandle->baseAddress->TC_REFC = tmpC; /* write back changed data back to register */
        tmpD = aptHandle->baseAddress->TC_REFD; /* read register */
        tmpD.BIT.rg_cnt_refd = aptHandle->waveform.cntCmpRightEdge;
        aptHandle->baseAddress->TC_REFD = tmpD; /* write back changed data back to register */
    }
}
 3001a2a:	a2bd                	j	3001b98 <APT_SetPWMCompareVal+0x200>
        aptHandle->baseAddress->TC_BUF_EN.BIT.rg_refc_buf_en = 1;
 3001a2c:	fdc42783          	lw	a5,-36(s0)
 3001a30:	4398                	lw	a4,0(a5)
 3001a32:	4b3c                	lw	a5,80(a4)
 3001a34:	1007e793          	ori	a5,a5,256
 3001a38:	cb3c                	sw	a5,80(a4)
        aptHandle->baseAddress->TC_BUF_EN.BIT.rg_refd_buf_en = 1;
 3001a3a:	fdc42783          	lw	a5,-36(s0)
 3001a3e:	4398                	lw	a4,0(a5)
 3001a40:	4b3c                	lw	a5,80(a4)
 3001a42:	4007e793          	ori	a5,a5,1024
 3001a46:	cb3c                	sw	a5,80(a4)
        unsigned int gldLdEn = (aptHandle->waveform.cntCmpLoadMode == APT_BUFFER_GLOBAL_LOAD) ? 1 : 0;
 3001a48:	fdc42783          	lw	a5,-36(s0)
 3001a4c:	539c                	lw	a5,32(a5)
 3001a4e:	17f5                	addi	a5,a5,-3
 3001a50:	0017b793          	seqz	a5,a5
 3001a54:	9f81                	uxtb	a5
 3001a56:	fef42623          	sw	a5,-20(s0)
        aptHandle->baseAddress->TC_BUF_EN.BIT.rg_refc_gld_en = gldLdEn;
 3001a5a:	fdc42783          	lw	a5,-36(s0)
 3001a5e:	4398                	lw	a4,0(a5)
 3001a60:	fec42783          	lw	a5,-20(s0)
 3001a64:	8b85                	andi	a5,a5,1
 3001a66:	0ff7f693          	andi	a3,a5,255
 3001a6a:	4b3c                	lw	a5,80(a4)
 3001a6c:	8a85                	andi	a3,a3,1
 3001a6e:	06a6                	slli	a3,a3,0x9
 3001a70:	dff7f793          	andi	a5,a5,-513
 3001a74:	8fd5                	or	a5,a5,a3
 3001a76:	cb3c                	sw	a5,80(a4)
        aptHandle->baseAddress->TC_BUF_EN.BIT.rg_refd_gld_en = gldLdEn;
 3001a78:	fdc42783          	lw	a5,-36(s0)
 3001a7c:	4398                	lw	a4,0(a5)
 3001a7e:	fec42783          	lw	a5,-20(s0)
 3001a82:	8b85                	andi	a5,a5,1
 3001a84:	0ff7f693          	andi	a3,a5,255
 3001a88:	4b3c                	lw	a5,80(a4)
 3001a8a:	8a85                	andi	a3,a3,1
 3001a8c:	06ae                	slli	a3,a3,0xb
 3001a8e:	767d                	lui	a2,0xfffff
 3001a90:	7ff60613          	addi	a2,a2,2047 # fffff7ff <RAM_END+0xfbff77ff>
 3001a94:	8ff1                	and	a5,a5,a2
 3001a96:	8fd5                	or	a5,a5,a3
 3001a98:	cb3c                	sw	a5,80(a4)
        unsigned int refBufField = 8; /* reference buffer field */
 3001a9a:	47a1                	li	a5,8
 3001a9c:	fef42423          	sw	a5,-24(s0)
        aptHandle->baseAddress->TC_REF_LOAD.reg &= (~(0x1F << (APT_COMPARE_REFERENCE_C * refBufField)));
 3001aa0:	fdc42783          	lw	a5,-36(s0)
 3001aa4:	439c                	lw	a5,0(a5)
 3001aa6:	4fb8                	lw	a4,88(a5)
 3001aa8:	fe842783          	lw	a5,-24(s0)
 3001aac:	0786                	slli	a5,a5,0x1
 3001aae:	46fd                	li	a3,31
 3001ab0:	00f697b3          	sll	a5,a3,a5
 3001ab4:	fff7c793          	not	a5,a5
 3001ab8:	86be                	mv	a3,a5
 3001aba:	fdc42783          	lw	a5,-36(s0)
 3001abe:	439c                	lw	a5,0(a5)
 3001ac0:	8f75                	and	a4,a4,a3
 3001ac2:	cfb8                	sw	a4,88(a5)
        aptHandle->baseAddress->TC_REF_LOAD.reg &= (~(0x1F << (APT_COMPARE_REFERENCE_D * refBufField)));
 3001ac4:	fdc42783          	lw	a5,-36(s0)
 3001ac8:	439c                	lw	a5,0(a5)
 3001aca:	4fb8                	lw	a4,88(a5)
 3001acc:	fe842683          	lw	a3,-24(s0)
 3001ad0:	478d                	li	a5,3
 3001ad2:	02f687b3          	mul	a5,a3,a5
 3001ad6:	46fd                	li	a3,31
 3001ad8:	00f697b3          	sll	a5,a3,a5
 3001adc:	fff7c793          	not	a5,a5
 3001ae0:	86be                	mv	a3,a5
 3001ae2:	fdc42783          	lw	a5,-36(s0)
 3001ae6:	439c                	lw	a5,0(a5)
 3001ae8:	8f75                	and	a4,a4,a3
 3001aea:	cfb8                	sw	a4,88(a5)
        aptHandle->baseAddress->TC_REF_LOAD.reg |=
 3001aec:	fdc42783          	lw	a5,-36(s0)
 3001af0:	439c                	lw	a5,0(a5)
 3001af2:	4fb4                	lw	a3,88(a5)
            (aptHandle->waveform.cntCmpLoadEvt << (APT_COMPARE_REFERENCE_C * refBufField));
 3001af4:	fdc42783          	lw	a5,-36(s0)
 3001af8:	53d8                	lw	a4,36(a5)
 3001afa:	fe842783          	lw	a5,-24(s0)
 3001afe:	0786                	slli	a5,a5,0x1
 3001b00:	00f71733          	sll	a4,a4,a5
        aptHandle->baseAddress->TC_REF_LOAD.reg |=
 3001b04:	fdc42783          	lw	a5,-36(s0)
 3001b08:	439c                	lw	a5,0(a5)
 3001b0a:	8f55                	or	a4,a4,a3
 3001b0c:	cfb8                	sw	a4,88(a5)
        aptHandle->baseAddress->TC_REF_LOAD.reg |=
 3001b0e:	fdc42783          	lw	a5,-36(s0)
 3001b12:	439c                	lw	a5,0(a5)
 3001b14:	4fb4                	lw	a3,88(a5)
            (aptHandle->waveform.cntCmpLoadEvt << (APT_COMPARE_REFERENCE_D * refBufField));
 3001b16:	fdc42783          	lw	a5,-36(s0)
 3001b1a:	53d8                	lw	a4,36(a5)
 3001b1c:	fe842603          	lw	a2,-24(s0)
 3001b20:	478d                	li	a5,3
 3001b22:	02f607b3          	mul	a5,a2,a5
 3001b26:	00f71733          	sll	a4,a4,a5
        aptHandle->baseAddress->TC_REF_LOAD.reg |=
 3001b2a:	fdc42783          	lw	a5,-36(s0)
 3001b2e:	439c                	lw	a5,0(a5)
 3001b30:	8f55                	or	a4,a4,a3
 3001b32:	cfb8                	sw	a4,88(a5)
        tmpC = aptHandle->baseAddress->TC_REFC; /* read register */
 3001b34:	fdc42783          	lw	a5,-36(s0)
 3001b38:	439c                	lw	a5,0(a5)
 3001b3a:	5f9c                	lw	a5,56(a5)
 3001b3c:	fef42223          	sw	a5,-28(s0)
        tmpC.BIT.rg_cnt_refc = aptHandle->waveform.cntCmpLeftEdge;
 3001b40:	fdc42783          	lw	a5,-36(s0)
 3001b44:	2fd6                	lhu	a3,28(a5)
 3001b46:	fe442783          	lw	a5,-28(s0)
 3001b4a:	6741                	lui	a4,0x10
 3001b4c:	177d                	addi	a4,a4,-1 # ffff <RAM_SIZE+0xafff>
 3001b4e:	8f75                	and	a4,a4,a3
 3001b50:	76c1                	lui	a3,0xffff0
 3001b52:	8ff5                	and	a5,a5,a3
 3001b54:	8fd9                	or	a5,a5,a4
 3001b56:	fef42223          	sw	a5,-28(s0)
        aptHandle->baseAddress->TC_REFC = tmpC; /* write back changed data back to register */
 3001b5a:	fdc42783          	lw	a5,-36(s0)
 3001b5e:	439c                	lw	a5,0(a5)
 3001b60:	fe442703          	lw	a4,-28(s0)
 3001b64:	df98                	sw	a4,56(a5)
        tmpD = aptHandle->baseAddress->TC_REFD; /* read register */
 3001b66:	fdc42783          	lw	a5,-36(s0)
 3001b6a:	439c                	lw	a5,0(a5)
 3001b6c:	5fdc                	lw	a5,60(a5)
 3001b6e:	fef42023          	sw	a5,-32(s0)
        tmpD.BIT.rg_cnt_refd = aptHandle->waveform.cntCmpRightEdge;
 3001b72:	fdc42783          	lw	a5,-36(s0)
 3001b76:	2ff6                	lhu	a3,30(a5)
 3001b78:	fe042783          	lw	a5,-32(s0)
 3001b7c:	6741                	lui	a4,0x10
 3001b7e:	177d                	addi	a4,a4,-1 # ffff <RAM_SIZE+0xafff>
 3001b80:	8f75                	and	a4,a4,a3
 3001b82:	76c1                	lui	a3,0xffff0
 3001b84:	8ff5                	and	a5,a5,a3
 3001b86:	8fd9                	or	a5,a5,a4
 3001b88:	fef42023          	sw	a5,-32(s0)
        aptHandle->baseAddress->TC_REFD = tmpD; /* write back changed data back to register */
 3001b8c:	fdc42783          	lw	a5,-36(s0)
 3001b90:	439c                	lw	a5,0(a5)
 3001b92:	fe042703          	lw	a4,-32(s0)
 3001b96:	dfd8                	sw	a4,60(a5)
}
 3001b98:	0001                	nop
 3001b9a:	5432                	lw	s0,44(sp)
 3001b9c:	6145                	addi	sp,sp,48
 3001b9e:	8082                	ret

03001ba0 <APT_SetOutputABasicType>:
  * @param aptHandle APT module handle.
  * @param wavePara PWM waveform parameter.
  * @retval None.
  */
static void APT_SetOutputABasicType(APT_Handle *aptHandle, const APT_WaveformPara *wavePara)
{
 3001ba0:	1101                	addi	sp,sp,-32
 3001ba2:	ce22                	sw	s0,28(sp)
 3001ba4:	1000                	addi	s0,sp,32
 3001ba6:	fea42623          	sw	a0,-20(s0)
 3001baa:	feb42423          	sw	a1,-24(s0)
    switch (aptHandle->waveform.cntMode) {
 3001bae:	fec42783          	lw	a5,-20(s0)
 3001bb2:	4b9c                	lw	a5,16(a5)
 3001bb4:	4705                	li	a4,1
 3001bb6:	06e78363          	beq	a5,a4,3001c1c <APT_SetOutputABasicType+0x7c>
 3001bba:	4705                	li	a4,1
 3001bbc:	00e7e663          	bltu	a5,a4,3001bc8 <APT_SetOutputABasicType+0x28>
 3001bc0:	4709                	li	a4,2
 3001bc2:	0ae78763          	beq	a5,a4,3001c70 <APT_SetOutputABasicType+0xd0>
        case APT_COUNT_MODE_UP_DOWN:
            aptHandle->baseAddress->PG_ACT_A.BIT.rg_pga_act_refc_inc = wavePara->leftEdgeActA;
            aptHandle->baseAddress->PG_ACT_A.BIT.rg_pga_act_refd_dec = wavePara->rightEdgeActA;
            break;
        default:
            break;
 3001bc6:	a8fd                	j	3001cc4 <APT_SetOutputABasicType+0x124>
            aptHandle->baseAddress->PG_ACT_A.BIT.rg_pga_act_refc_inc = wavePara->leftEdgeActA;
 3001bc8:	fe842783          	lw	a5,-24(s0)
 3001bcc:	4394                	lw	a3,0(a5)
 3001bce:	fec42783          	lw	a5,-20(s0)
 3001bd2:	4398                	lw	a4,0(a5)
 3001bd4:	87b6                	mv	a5,a3
 3001bd6:	8b8d                	andi	a5,a5,3
 3001bd8:	0ff7f693          	andi	a3,a5,255
 3001bdc:	10072783          	lw	a5,256(a4)
 3001be0:	8a8d                	andi	a3,a3,3
 3001be2:	06b2                	slli	a3,a3,0xc
 3001be4:	7675                	lui	a2,0xffffd
 3001be6:	167d                	addi	a2,a2,-1 # ffffcfff <RAM_END+0xfbff4fff>
 3001be8:	8ff1                	and	a5,a5,a2
 3001bea:	8fd5                	or	a5,a5,a3
 3001bec:	10f72023          	sw	a5,256(a4)
            aptHandle->baseAddress->PG_ACT_A.BIT.rg_pga_act_refd_inc = wavePara->rightEdgeActA;
 3001bf0:	fe842783          	lw	a5,-24(s0)
 3001bf4:	43d4                	lw	a3,4(a5)
 3001bf6:	fec42783          	lw	a5,-20(s0)
 3001bfa:	4398                	lw	a4,0(a5)
 3001bfc:	87b6                	mv	a5,a3
 3001bfe:	8b8d                	andi	a5,a5,3
 3001c00:	0ff7f693          	andi	a3,a5,255
 3001c04:	10072783          	lw	a5,256(a4)
 3001c08:	8a8d                	andi	a3,a3,3
 3001c0a:	06c2                	slli	a3,a3,0x10
 3001c0c:	fffd0637          	lui	a2,0xfffd0
 3001c10:	167d                	addi	a2,a2,-1 # fffcffff <RAM_END+0xfbfc7fff>
 3001c12:	8ff1                	and	a5,a5,a2
 3001c14:	8fd5                	or	a5,a5,a3
 3001c16:	10f72023          	sw	a5,256(a4)
            break;
 3001c1a:	a06d                	j	3001cc4 <APT_SetOutputABasicType+0x124>
            aptHandle->baseAddress->PG_ACT_A.BIT.rg_pga_act_refc_dec = wavePara->rightEdgeActA;
 3001c1c:	fe842783          	lw	a5,-24(s0)
 3001c20:	43d4                	lw	a3,4(a5)
 3001c22:	fec42783          	lw	a5,-20(s0)
 3001c26:	4398                	lw	a4,0(a5)
 3001c28:	87b6                	mv	a5,a3
 3001c2a:	8b8d                	andi	a5,a5,3
 3001c2c:	0ff7f693          	andi	a3,a5,255
 3001c30:	10072783          	lw	a5,256(a4)
 3001c34:	8a8d                	andi	a3,a3,3
 3001c36:	06ba                	slli	a3,a3,0xe
 3001c38:	7651                	lui	a2,0xffff4
 3001c3a:	167d                	addi	a2,a2,-1 # ffff3fff <RAM_END+0xfbfebfff>
 3001c3c:	8ff1                	and	a5,a5,a2
 3001c3e:	8fd5                	or	a5,a5,a3
 3001c40:	10f72023          	sw	a5,256(a4)
            aptHandle->baseAddress->PG_ACT_A.BIT.rg_pga_act_refd_dec = wavePara->leftEdgeActA;
 3001c44:	fe842783          	lw	a5,-24(s0)
 3001c48:	4394                	lw	a3,0(a5)
 3001c4a:	fec42783          	lw	a5,-20(s0)
 3001c4e:	4398                	lw	a4,0(a5)
 3001c50:	87b6                	mv	a5,a3
 3001c52:	8b8d                	andi	a5,a5,3
 3001c54:	0ff7f693          	andi	a3,a5,255
 3001c58:	10072783          	lw	a5,256(a4)
 3001c5c:	8a8d                	andi	a3,a3,3
 3001c5e:	06ca                	slli	a3,a3,0x12
 3001c60:	fff40637          	lui	a2,0xfff40
 3001c64:	167d                	addi	a2,a2,-1 # fff3ffff <RAM_END+0xfbf37fff>
 3001c66:	8ff1                	and	a5,a5,a2
 3001c68:	8fd5                	or	a5,a5,a3
 3001c6a:	10f72023          	sw	a5,256(a4)
            break;
 3001c6e:	a899                	j	3001cc4 <APT_SetOutputABasicType+0x124>
            aptHandle->baseAddress->PG_ACT_A.BIT.rg_pga_act_refc_inc = wavePara->leftEdgeActA;
 3001c70:	fe842783          	lw	a5,-24(s0)
 3001c74:	4394                	lw	a3,0(a5)
 3001c76:	fec42783          	lw	a5,-20(s0)
 3001c7a:	4398                	lw	a4,0(a5)
 3001c7c:	87b6                	mv	a5,a3
 3001c7e:	8b8d                	andi	a5,a5,3
 3001c80:	0ff7f693          	andi	a3,a5,255
 3001c84:	10072783          	lw	a5,256(a4)
 3001c88:	8a8d                	andi	a3,a3,3
 3001c8a:	06b2                	slli	a3,a3,0xc
 3001c8c:	7675                	lui	a2,0xffffd
 3001c8e:	167d                	addi	a2,a2,-1 # ffffcfff <RAM_END+0xfbff4fff>
 3001c90:	8ff1                	and	a5,a5,a2
 3001c92:	8fd5                	or	a5,a5,a3
 3001c94:	10f72023          	sw	a5,256(a4)
            aptHandle->baseAddress->PG_ACT_A.BIT.rg_pga_act_refd_dec = wavePara->rightEdgeActA;
 3001c98:	fe842783          	lw	a5,-24(s0)
 3001c9c:	43d4                	lw	a3,4(a5)
 3001c9e:	fec42783          	lw	a5,-20(s0)
 3001ca2:	4398                	lw	a4,0(a5)
 3001ca4:	87b6                	mv	a5,a3
 3001ca6:	8b8d                	andi	a5,a5,3
 3001ca8:	0ff7f693          	andi	a3,a5,255
 3001cac:	10072783          	lw	a5,256(a4)
 3001cb0:	8a8d                	andi	a3,a3,3
 3001cb2:	06ca                	slli	a3,a3,0x12
 3001cb4:	fff40637          	lui	a2,0xfff40
 3001cb8:	167d                	addi	a2,a2,-1 # fff3ffff <RAM_END+0xfbf37fff>
 3001cba:	8ff1                	and	a5,a5,a2
 3001cbc:	8fd5                	or	a5,a5,a3
 3001cbe:	10f72023          	sw	a5,256(a4)
            break;
 3001cc2:	0001                	nop
    }
    return;
 3001cc4:	0001                	nop
}
 3001cc6:	4472                	lw	s0,28(sp)
 3001cc8:	6105                	addi	sp,sp,32
 3001cca:	8082                	ret

03001ccc <APT_SetOutputBBasicType>:
  * @param aptHandle APT module handle.
  * @param wavePara PWM waveform parameter.
  * @retval None.
  */
static void APT_SetOutputBBasicType(APT_Handle *aptHandle, const APT_WaveformPara *wavePara)
{
 3001ccc:	1101                	addi	sp,sp,-32
 3001cce:	ce22                	sw	s0,28(sp)
 3001cd0:	1000                	addi	s0,sp,32
 3001cd2:	fea42623          	sw	a0,-20(s0)
 3001cd6:	feb42423          	sw	a1,-24(s0)
    switch (aptHandle->waveform.cntMode) {
 3001cda:	fec42783          	lw	a5,-20(s0)
 3001cde:	4b9c                	lw	a5,16(a5)
 3001ce0:	4705                	li	a4,1
 3001ce2:	06e78363          	beq	a5,a4,3001d48 <APT_SetOutputBBasicType+0x7c>
 3001ce6:	4705                	li	a4,1
 3001ce8:	00e7e663          	bltu	a5,a4,3001cf4 <APT_SetOutputBBasicType+0x28>
 3001cec:	4709                	li	a4,2
 3001cee:	0ae78763          	beq	a5,a4,3001d9c <APT_SetOutputBBasicType+0xd0>
        case APT_COUNT_MODE_UP_DOWN:
            aptHandle->baseAddress->PG_ACT_B.BIT.rg_pgb_act_refc_inc = wavePara->leftEdgeActB;
            aptHandle->baseAddress->PG_ACT_B.BIT.rg_pgb_act_refd_dec = wavePara->rightEdgeActB;
            break;
        default:
            break;
 3001cf2:	a8fd                	j	3001df0 <APT_SetOutputBBasicType+0x124>
            aptHandle->baseAddress->PG_ACT_B.BIT.rg_pgb_act_refc_inc = wavePara->leftEdgeActB;
 3001cf4:	fe842783          	lw	a5,-24(s0)
 3001cf8:	4794                	lw	a3,8(a5)
 3001cfa:	fec42783          	lw	a5,-20(s0)
 3001cfe:	4398                	lw	a4,0(a5)
 3001d00:	87b6                	mv	a5,a3
 3001d02:	8b8d                	andi	a5,a5,3
 3001d04:	0ff7f693          	andi	a3,a5,255
 3001d08:	10472783          	lw	a5,260(a4)
 3001d0c:	8a8d                	andi	a3,a3,3
 3001d0e:	06b2                	slli	a3,a3,0xc
 3001d10:	7675                	lui	a2,0xffffd
 3001d12:	167d                	addi	a2,a2,-1 # ffffcfff <RAM_END+0xfbff4fff>
 3001d14:	8ff1                	and	a5,a5,a2
 3001d16:	8fd5                	or	a5,a5,a3
 3001d18:	10f72223          	sw	a5,260(a4)
            aptHandle->baseAddress->PG_ACT_B.BIT.rg_pgb_act_refd_inc = wavePara->rightEdgeActB;
 3001d1c:	fe842783          	lw	a5,-24(s0)
 3001d20:	47d4                	lw	a3,12(a5)
 3001d22:	fec42783          	lw	a5,-20(s0)
 3001d26:	4398                	lw	a4,0(a5)
 3001d28:	87b6                	mv	a5,a3
 3001d2a:	8b8d                	andi	a5,a5,3
 3001d2c:	0ff7f693          	andi	a3,a5,255
 3001d30:	10472783          	lw	a5,260(a4)
 3001d34:	8a8d                	andi	a3,a3,3
 3001d36:	06c2                	slli	a3,a3,0x10
 3001d38:	fffd0637          	lui	a2,0xfffd0
 3001d3c:	167d                	addi	a2,a2,-1 # fffcffff <RAM_END+0xfbfc7fff>
 3001d3e:	8ff1                	and	a5,a5,a2
 3001d40:	8fd5                	or	a5,a5,a3
 3001d42:	10f72223          	sw	a5,260(a4)
            break;
 3001d46:	a06d                	j	3001df0 <APT_SetOutputBBasicType+0x124>
            aptHandle->baseAddress->PG_ACT_B.BIT.rg_pgb_act_refc_dec = wavePara->rightEdgeActB;
 3001d48:	fe842783          	lw	a5,-24(s0)
 3001d4c:	47d4                	lw	a3,12(a5)
 3001d4e:	fec42783          	lw	a5,-20(s0)
 3001d52:	4398                	lw	a4,0(a5)
 3001d54:	87b6                	mv	a5,a3
 3001d56:	8b8d                	andi	a5,a5,3
 3001d58:	0ff7f693          	andi	a3,a5,255
 3001d5c:	10472783          	lw	a5,260(a4)
 3001d60:	8a8d                	andi	a3,a3,3
 3001d62:	06ba                	slli	a3,a3,0xe
 3001d64:	7651                	lui	a2,0xffff4
 3001d66:	167d                	addi	a2,a2,-1 # ffff3fff <RAM_END+0xfbfebfff>
 3001d68:	8ff1                	and	a5,a5,a2
 3001d6a:	8fd5                	or	a5,a5,a3
 3001d6c:	10f72223          	sw	a5,260(a4)
            aptHandle->baseAddress->PG_ACT_B.BIT.rg_pgb_act_refd_dec = wavePara->leftEdgeActB;
 3001d70:	fe842783          	lw	a5,-24(s0)
 3001d74:	4794                	lw	a3,8(a5)
 3001d76:	fec42783          	lw	a5,-20(s0)
 3001d7a:	4398                	lw	a4,0(a5)
 3001d7c:	87b6                	mv	a5,a3
 3001d7e:	8b8d                	andi	a5,a5,3
 3001d80:	0ff7f693          	andi	a3,a5,255
 3001d84:	10472783          	lw	a5,260(a4)
 3001d88:	8a8d                	andi	a3,a3,3
 3001d8a:	06ca                	slli	a3,a3,0x12
 3001d8c:	fff40637          	lui	a2,0xfff40
 3001d90:	167d                	addi	a2,a2,-1 # fff3ffff <RAM_END+0xfbf37fff>
 3001d92:	8ff1                	and	a5,a5,a2
 3001d94:	8fd5                	or	a5,a5,a3
 3001d96:	10f72223          	sw	a5,260(a4)
            break;
 3001d9a:	a899                	j	3001df0 <APT_SetOutputBBasicType+0x124>
            aptHandle->baseAddress->PG_ACT_B.BIT.rg_pgb_act_refc_inc = wavePara->leftEdgeActB;
 3001d9c:	fe842783          	lw	a5,-24(s0)
 3001da0:	4794                	lw	a3,8(a5)
 3001da2:	fec42783          	lw	a5,-20(s0)
 3001da6:	4398                	lw	a4,0(a5)
 3001da8:	87b6                	mv	a5,a3
 3001daa:	8b8d                	andi	a5,a5,3
 3001dac:	0ff7f693          	andi	a3,a5,255
 3001db0:	10472783          	lw	a5,260(a4)
 3001db4:	8a8d                	andi	a3,a3,3
 3001db6:	06b2                	slli	a3,a3,0xc
 3001db8:	7675                	lui	a2,0xffffd
 3001dba:	167d                	addi	a2,a2,-1 # ffffcfff <RAM_END+0xfbff4fff>
 3001dbc:	8ff1                	and	a5,a5,a2
 3001dbe:	8fd5                	or	a5,a5,a3
 3001dc0:	10f72223          	sw	a5,260(a4)
            aptHandle->baseAddress->PG_ACT_B.BIT.rg_pgb_act_refd_dec = wavePara->rightEdgeActB;
 3001dc4:	fe842783          	lw	a5,-24(s0)
 3001dc8:	47d4                	lw	a3,12(a5)
 3001dca:	fec42783          	lw	a5,-20(s0)
 3001dce:	4398                	lw	a4,0(a5)
 3001dd0:	87b6                	mv	a5,a3
 3001dd2:	8b8d                	andi	a5,a5,3
 3001dd4:	0ff7f693          	andi	a3,a5,255
 3001dd8:	10472783          	lw	a5,260(a4)
 3001ddc:	8a8d                	andi	a3,a3,3
 3001dde:	06ca                	slli	a3,a3,0x12
 3001de0:	fff40637          	lui	a2,0xfff40
 3001de4:	167d                	addi	a2,a2,-1 # fff3ffff <RAM_END+0xfbf37fff>
 3001de6:	8ff1                	and	a5,a5,a2
 3001de8:	8fd5                	or	a5,a5,a3
 3001dea:	10f72223          	sw	a5,260(a4)
            break;
 3001dee:	0001                	nop
    }
    return;
 3001df0:	0001                	nop
}
 3001df2:	4472                	lw	s0,28(sp)
 3001df4:	6105                	addi	sp,sp,32
 3001df6:	8082                	ret

03001df8 <APT_SetPWMBasicType>:
  * @param aptHandle APT module handle.
  * @param wavePara PWM waveform parameter.
  * @retval None.
  */
static void APT_SetPWMBasicType(APT_Handle *aptHandle, const APT_WaveformPara *wavePara)
{
 3001df8:	1101                	addi	sp,sp,-32
 3001dfa:	ce06                	sw	ra,28(sp)
 3001dfc:	cc22                	sw	s0,24(sp)
 3001dfe:	1000                	addi	s0,sp,32
 3001e00:	fea42623          	sw	a0,-20(s0)
 3001e04:	feb42423          	sw	a1,-24(s0)
    /* Configure PWM waveform of PWM channel A */
    if (aptHandle->waveform.chAOutType == APT_PWM_OUT_BASIC_TYPE) {
 3001e08:	fec42783          	lw	a5,-20(s0)
 3001e0c:	479c                	lw	a5,8(a5)
 3001e0e:	e791                	bnez	a5,3001e1a <APT_SetPWMBasicType+0x22>
        APT_SetOutputABasicType(aptHandle, wavePara);
 3001e10:	fe842583          	lw	a1,-24(s0)
 3001e14:	fec42503          	lw	a0,-20(s0)
 3001e18:	3361                	jal	ra,3001ba0 <APT_SetOutputABasicType>
    }
    /* Configure PWM waveform of PWM channel B */
    if (aptHandle->waveform.chBOutType == APT_PWM_OUT_BASIC_TYPE) {
 3001e1a:	fec42783          	lw	a5,-20(s0)
 3001e1e:	47dc                	lw	a5,12(a5)
 3001e20:	e791                	bnez	a5,3001e2c <APT_SetPWMBasicType+0x34>
        APT_SetOutputBBasicType(aptHandle, wavePara);
 3001e22:	fe842583          	lw	a1,-24(s0)
 3001e26:	fec42503          	lw	a0,-20(s0)
 3001e2a:	354d                	jal	ra,3001ccc <APT_SetOutputBBasicType>
    }
    /* Configure dead band of PWM channel A and channel B */
    if (aptHandle->waveform.chAOutType == APT_PWM_OUT_BASIC_TYPE &&
 3001e2c:	fec42783          	lw	a5,-20(s0)
 3001e30:	479c                	lw	a5,8(a5)
 3001e32:	eff1                	bnez	a5,3001f0e <APT_SetPWMBasicType+0x116>
        aptHandle->waveform.chBOutType == APT_PWM_OUT_BASIC_TYPE) {
 3001e34:	fec42783          	lw	a5,-20(s0)
 3001e38:	47dc                	lw	a5,12(a5)
    if (aptHandle->waveform.chAOutType == APT_PWM_OUT_BASIC_TYPE &&
 3001e3a:	ebf1                	bnez	a5,3001f0e <APT_SetPWMBasicType+0x116>
        aptHandle->baseAddress->DG_CFG.BIT.rg_dg_red_isel = wavePara->redInput;
 3001e3c:	fe842783          	lw	a5,-24(s0)
 3001e40:	4b94                	lw	a3,16(a5)
 3001e42:	fec42783          	lw	a5,-20(s0)
 3001e46:	4398                	lw	a4,0(a5)
 3001e48:	87b6                	mv	a5,a3
 3001e4a:	8b8d                	andi	a5,a5,3
 3001e4c:	0ff7f693          	andi	a3,a5,255
 3001e50:	20872783          	lw	a5,520(a4)
 3001e54:	8a8d                	andi	a3,a3,3
 3001e56:	9bf1                	andi	a5,a5,-4
 3001e58:	8fd5                	or	a5,a5,a3
 3001e5a:	20f72423          	sw	a5,520(a4)
        aptHandle->baseAddress->DG_CFG.BIT.rg_dg_red_osel = wavePara->redOutMode;
 3001e5e:	fe842783          	lw	a5,-24(s0)
 3001e62:	4bd4                	lw	a3,20(a5)
 3001e64:	fec42783          	lw	a5,-20(s0)
 3001e68:	4398                	lw	a4,0(a5)
 3001e6a:	87b6                	mv	a5,a3
 3001e6c:	8b8d                	andi	a5,a5,3
 3001e6e:	0ff7f693          	andi	a3,a5,255
 3001e72:	20872783          	lw	a5,520(a4)
 3001e76:	8a8d                	andi	a3,a3,3
 3001e78:	0692                	slli	a3,a3,0x4
 3001e7a:	fcf7f793          	andi	a5,a5,-49
 3001e7e:	8fd5                	or	a5,a5,a3
 3001e80:	20f72423          	sw	a5,520(a4)
        aptHandle->baseAddress->DG_RED.BIT.rg_dg_red = aptHandle->waveform.deadBandCnt;
 3001e84:	fec42783          	lw	a5,-20(s0)
 3001e88:	4398                	lw	a4,0(a5)
 3001e8a:	fec42783          	lw	a5,-20(s0)
 3001e8e:	3792                	lhu	a2,40(a5)
 3001e90:	20072783          	lw	a5,512(a4)
 3001e94:	66c1                	lui	a3,0x10
 3001e96:	16fd                	addi	a3,a3,-1 # ffff <RAM_SIZE+0xafff>
 3001e98:	8ef1                	and	a3,a3,a2
 3001e9a:	7641                	lui	a2,0xffff0
 3001e9c:	8ff1                	and	a5,a5,a2
 3001e9e:	8fd5                	or	a5,a5,a3
 3001ea0:	20f72023          	sw	a5,512(a4)
        aptHandle->baseAddress->DG_CFG.BIT.rg_dg_fed_isel = wavePara->fedInput;
 3001ea4:	fe842783          	lw	a5,-24(s0)
 3001ea8:	4f94                	lw	a3,24(a5)
 3001eaa:	fec42783          	lw	a5,-20(s0)
 3001eae:	4398                	lw	a4,0(a5)
 3001eb0:	87b6                	mv	a5,a3
 3001eb2:	8b8d                	andi	a5,a5,3
 3001eb4:	0ff7f693          	andi	a3,a5,255
 3001eb8:	20872783          	lw	a5,520(a4)
 3001ebc:	8a8d                	andi	a3,a3,3
 3001ebe:	068a                	slli	a3,a3,0x2
 3001ec0:	9bcd                	andi	a5,a5,-13
 3001ec2:	8fd5                	or	a5,a5,a3
 3001ec4:	20f72423          	sw	a5,520(a4)
        aptHandle->baseAddress->DG_CFG.BIT.rg_dg_fed_osel = wavePara->fedOutMode;
 3001ec8:	fe842783          	lw	a5,-24(s0)
 3001ecc:	4fd4                	lw	a3,28(a5)
 3001ece:	fec42783          	lw	a5,-20(s0)
 3001ed2:	4398                	lw	a4,0(a5)
 3001ed4:	87b6                	mv	a5,a3
 3001ed6:	8b8d                	andi	a5,a5,3
 3001ed8:	0ff7f693          	andi	a3,a5,255
 3001edc:	20872783          	lw	a5,520(a4)
 3001ee0:	8a8d                	andi	a3,a3,3
 3001ee2:	069a                	slli	a3,a3,0x6
 3001ee4:	f3f7f793          	andi	a5,a5,-193
 3001ee8:	8fd5                	or	a5,a5,a3
 3001eea:	20f72423          	sw	a5,520(a4)
        aptHandle->baseAddress->DG_FED.BIT.rg_dg_fed = aptHandle->waveform.deadBandCnt;
 3001eee:	fec42783          	lw	a5,-20(s0)
 3001ef2:	4398                	lw	a4,0(a5)
 3001ef4:	fec42783          	lw	a5,-20(s0)
 3001ef8:	3792                	lhu	a2,40(a5)
 3001efa:	20472783          	lw	a5,516(a4)
 3001efe:	66c1                	lui	a3,0x10
 3001f00:	16fd                	addi	a3,a3,-1 # ffff <RAM_SIZE+0xafff>
 3001f02:	8ef1                	and	a3,a3,a2
 3001f04:	7641                	lui	a2,0xffff0
 3001f06:	8ff1                	and	a5,a5,a2
 3001f08:	8fd5                	or	a5,a5,a3
 3001f0a:	20f72223          	sw	a5,516(a4)
    }
}
 3001f0e:	0001                	nop
 3001f10:	40f2                	lw	ra,28(sp)
 3001f12:	4462                	lw	s0,24(sp)
 3001f14:	6105                	addi	sp,sp,32
 3001f16:	8082                	ret

03001f18 <APT_SetContWaveform>:
  * @brief Set the actual outputs of PWM channelA and channelB when basic PWM waveform type is not used.
  * @param aptHandle APT module handle.
  * @retval None.
  */
static void APT_SetContWaveform(APT_Handle *aptHandle)
{
 3001f18:	7179                	addi	sp,sp,-48
 3001f1a:	d622                	sw	s0,44(sp)
 3001f1c:	1800                	addi	s0,sp,48
 3001f1e:	fca42e23          	sw	a0,-36(s0)
    if (aptHandle->waveform.chAOutType != APT_PWM_OUT_BASIC_TYPE) {
 3001f22:	fdc42783          	lw	a5,-36(s0)
 3001f26:	479c                	lw	a5,8(a5)
 3001f28:	cb9d                	beqz	a5,3001f5e <APT_SetContWaveform+0x46>
        unsigned int contActA = (aptHandle->waveform.chAOutType == APT_PWM_OUT_ALWAYS_LOW) ? 0b01 : 0b10;
 3001f2a:	fdc42783          	lw	a5,-36(s0)
 3001f2e:	4798                	lw	a4,8(a5)
 3001f30:	4785                	li	a5,1
 3001f32:	00f71463          	bne	a4,a5,3001f3a <APT_SetContWaveform+0x22>
 3001f36:	4785                	li	a5,1
 3001f38:	a011                	j	3001f3c <APT_SetContWaveform+0x24>
 3001f3a:	4789                	li	a5,2
 3001f3c:	fef42623          	sw	a5,-20(s0)
        aptHandle->baseAddress->PG_ACT_A.BIT.rg_pga_act_zro = contActA;
 3001f40:	fdc42783          	lw	a5,-36(s0)
 3001f44:	4398                	lw	a4,0(a5)
 3001f46:	fec42783          	lw	a5,-20(s0)
 3001f4a:	8b8d                	andi	a5,a5,3
 3001f4c:	0ff7f693          	andi	a3,a5,255
 3001f50:	10072783          	lw	a5,256(a4)
 3001f54:	8a8d                	andi	a3,a3,3
 3001f56:	9bf1                	andi	a5,a5,-4
 3001f58:	8fd5                	or	a5,a5,a3
 3001f5a:	10f72023          	sw	a5,256(a4)
    }
    if (aptHandle->waveform.chBOutType != APT_PWM_OUT_BASIC_TYPE) {
 3001f5e:	fdc42783          	lw	a5,-36(s0)
 3001f62:	47dc                	lw	a5,12(a5)
 3001f64:	cb9d                	beqz	a5,3001f9a <APT_SetContWaveform+0x82>
        unsigned int contActB = (aptHandle->waveform.chBOutType == APT_PWM_OUT_ALWAYS_LOW) ? 0b01 : 0b10;
 3001f66:	fdc42783          	lw	a5,-36(s0)
 3001f6a:	47d8                	lw	a4,12(a5)
 3001f6c:	4785                	li	a5,1
 3001f6e:	00f71463          	bne	a4,a5,3001f76 <APT_SetContWaveform+0x5e>
 3001f72:	4785                	li	a5,1
 3001f74:	a011                	j	3001f78 <APT_SetContWaveform+0x60>
 3001f76:	4789                	li	a5,2
 3001f78:	fef42423          	sw	a5,-24(s0)
        aptHandle->baseAddress->PG_ACT_B.BIT.rg_pgb_act_zro = contActB;
 3001f7c:	fdc42783          	lw	a5,-36(s0)
 3001f80:	4398                	lw	a4,0(a5)
 3001f82:	fe842783          	lw	a5,-24(s0)
 3001f86:	8b8d                	andi	a5,a5,3
 3001f88:	0ff7f693          	andi	a3,a5,255
 3001f8c:	10472783          	lw	a5,260(a4)
 3001f90:	8a8d                	andi	a3,a3,3
 3001f92:	9bf1                	andi	a5,a5,-4
 3001f94:	8fd5                	or	a5,a5,a3
 3001f96:	10f72223          	sw	a5,260(a4)
    }
}
 3001f9a:	0001                	nop
 3001f9c:	5432                	lw	s0,44(sp)
 3001f9e:	6145                	addi	sp,sp,48
 3001fa0:	8082                	ret

03001fa2 <APT_SetPWMWaveform>:
  * @brief Initialize the PWM waveform parameters according to the selected PWM basic type.
  * @param aptHandle APT module handle.
  * @retval None.
  */
static void APT_SetPWMWaveform(APT_Handle *aptHandle)
{
 3001fa2:	7139                	addi	sp,sp,-64
 3001fa4:	de06                	sw	ra,60(sp)
 3001fa6:	dc22                	sw	s0,56(sp)
 3001fa8:	0080                	addi	s0,sp,64
 3001faa:	fca42623          	sw	a0,-52(s0)
    APT_SetContWaveform(aptHandle);
 3001fae:	fcc42503          	lw	a0,-52(s0)
 3001fb2:	379d                	jal	ra,3001f18 <APT_SetContWaveform>
    /* Configure the basic type of PWM waveform */
    APT_WaveformPara wavePara = {0, 0, 0, 0, 0, 0, 0, 0};
 3001fb4:	fc042823          	sw	zero,-48(s0)
 3001fb8:	fc042a23          	sw	zero,-44(s0)
 3001fbc:	fc042c23          	sw	zero,-40(s0)
 3001fc0:	fc042e23          	sw	zero,-36(s0)
 3001fc4:	fe042023          	sw	zero,-32(s0)
 3001fc8:	fe042223          	sw	zero,-28(s0)
 3001fcc:	fe042423          	sw	zero,-24(s0)
 3001fd0:	fe042623          	sw	zero,-20(s0)
    switch (aptHandle->waveform.basicType) {
 3001fd4:	fcc42783          	lw	a5,-52(s0)
 3001fd8:	43dc                	lw	a5,4(a5)
 3001fda:	4705                	li	a4,1
 3001fdc:	04e78263          	beq	a5,a4,3002020 <APT_SetPWMWaveform+0x7e>
 3001fe0:	4705                	li	a4,1
 3001fe2:	00e7e963          	bltu	a5,a4,3001ff4 <APT_SetPWMWaveform+0x52>
 3001fe6:	4709                	li	a4,2
 3001fe8:	06e78463          	beq	a5,a4,3002050 <APT_SetPWMWaveform+0xae>
 3001fec:	470d                	li	a4,3
 3001fee:	08e78663          	beq	a5,a4,300207a <APT_SetPWMWaveform+0xd8>
            wavePara.fedOutMode = APT_DB_FED_OUTPUT_NOT_INVERT;
            wavePara.redInput = APT_DB_RED_INPUT_PWM_B;
            wavePara.redOutMode = APT_DB_RED_OUTPUT_NOT_INVERT;
            break;
        default:
            break;
 3001ff2:	a85d                	j	30020a8 <APT_SetPWMWaveform+0x106>
            wavePara.leftEdgeActA = APT_PWM_ACTION_HIGH;
 3001ff4:	4789                	li	a5,2
 3001ff6:	fcf42823          	sw	a5,-48(s0)
            wavePara.rightEdgeActA = APT_PWM_ACTION_LOW;
 3001ffa:	4785                	li	a5,1
 3001ffc:	fcf42a23          	sw	a5,-44(s0)
            wavePara.leftEdgeActB = APT_PWM_ACTION_HIGH;
 3002000:	4789                	li	a5,2
 3002002:	fcf42c23          	sw	a5,-40(s0)
            wavePara.rightEdgeActB = APT_PWM_ACTION_LOW;
 3002006:	4785                	li	a5,1
 3002008:	fcf42e23          	sw	a5,-36(s0)
            wavePara.redInput = APT_DB_RED_INPUT_PWM_A;
 300200c:	fe042023          	sw	zero,-32(s0)
            wavePara.redOutMode = APT_DB_RED_OUTPUT_NOT_INVERT;
 3002010:	fe042223          	sw	zero,-28(s0)
            wavePara.fedInput = APT_DB_FED_INPUT_PWM_B;
 3002014:	fe042423          	sw	zero,-24(s0)
            wavePara.fedOutMode = APT_DB_FED_OUTPUT_INVERT;
 3002018:	4789                	li	a5,2
 300201a:	fef42623          	sw	a5,-20(s0)
            break;
 300201e:	a069                	j	30020a8 <APT_SetPWMWaveform+0x106>
            wavePara.leftEdgeActA = APT_PWM_ACTION_LOW;
 3002020:	4785                	li	a5,1
 3002022:	fcf42823          	sw	a5,-48(s0)
            wavePara.rightEdgeActA = APT_PWM_ACTION_HIGH;
 3002026:	4789                	li	a5,2
 3002028:	fcf42a23          	sw	a5,-44(s0)
            wavePara.leftEdgeActB = APT_PWM_ACTION_LOW;
 300202c:	4785                	li	a5,1
 300202e:	fcf42c23          	sw	a5,-40(s0)
            wavePara.rightEdgeActB = APT_PWM_ACTION_HIGH;
 3002032:	4789                	li	a5,2
 3002034:	fcf42e23          	sw	a5,-36(s0)
            wavePara.fedInput = APT_DB_FED_INPUT_PWM_A;
 3002038:	4785                	li	a5,1
 300203a:	fef42423          	sw	a5,-24(s0)
            wavePara.fedOutMode = APT_DB_FED_OUTPUT_INVERT;
 300203e:	4789                	li	a5,2
 3002040:	fef42623          	sw	a5,-20(s0)
            wavePara.redInput = APT_DB_RED_INPUT_PWM_B;
 3002044:	4785                	li	a5,1
 3002046:	fef42023          	sw	a5,-32(s0)
            wavePara.redOutMode = APT_DB_RED_OUTPUT_NOT_INVERT;
 300204a:	fe042223          	sw	zero,-28(s0)
            break;
 300204e:	a8a9                	j	30020a8 <APT_SetPWMWaveform+0x106>
            wavePara.leftEdgeActA = APT_PWM_ACTION_HIGH;
 3002050:	4789                	li	a5,2
 3002052:	fcf42823          	sw	a5,-48(s0)
            wavePara.rightEdgeActA = APT_PWM_ACTION_LOW;
 3002056:	4785                	li	a5,1
 3002058:	fcf42a23          	sw	a5,-44(s0)
            wavePara.leftEdgeActB = APT_PWM_ACTION_HIGH;
 300205c:	4789                	li	a5,2
 300205e:	fcf42c23          	sw	a5,-40(s0)
            wavePara.rightEdgeActB = APT_PWM_ACTION_LOW;
 3002062:	4785                	li	a5,1
 3002064:	fcf42e23          	sw	a5,-36(s0)
            wavePara.redInput = APT_DB_RED_INPUT_PWM_A;
 3002068:	fe042023          	sw	zero,-32(s0)
            wavePara.redOutMode = APT_DB_RED_OUTPUT_NOT_INVERT;
 300206c:	fe042223          	sw	zero,-28(s0)
            wavePara.fedInput = APT_DB_FED_INPUT_PWM_B;
 3002070:	fe042423          	sw	zero,-24(s0)
            wavePara.fedOutMode = APT_DB_FED_OUTPUT_NOT_INVERT;
 3002074:	fe042623          	sw	zero,-20(s0)
            break;
 3002078:	a805                	j	30020a8 <APT_SetPWMWaveform+0x106>
            wavePara.leftEdgeActA = APT_PWM_ACTION_LOW;
 300207a:	4785                	li	a5,1
 300207c:	fcf42823          	sw	a5,-48(s0)
            wavePara.rightEdgeActA = APT_PWM_ACTION_HIGH;
 3002080:	4789                	li	a5,2
 3002082:	fcf42a23          	sw	a5,-44(s0)
            wavePara.leftEdgeActB = APT_PWM_ACTION_LOW;
 3002086:	4785                	li	a5,1
 3002088:	fcf42c23          	sw	a5,-40(s0)
            wavePara.rightEdgeActB = APT_PWM_ACTION_HIGH;
 300208c:	4789                	li	a5,2
 300208e:	fcf42e23          	sw	a5,-36(s0)
            wavePara.fedInput = APT_DB_FED_INPUT_PWM_A;
 3002092:	4785                	li	a5,1
 3002094:	fef42423          	sw	a5,-24(s0)
            wavePara.fedOutMode = APT_DB_FED_OUTPUT_NOT_INVERT;
 3002098:	fe042623          	sw	zero,-20(s0)
            wavePara.redInput = APT_DB_RED_INPUT_PWM_B;
 300209c:	4785                	li	a5,1
 300209e:	fef42023          	sw	a5,-32(s0)
            wavePara.redOutMode = APT_DB_RED_OUTPUT_NOT_INVERT;
 30020a2:	fe042223          	sw	zero,-28(s0)
            break;
 30020a6:	0001                	nop
    }
    APT_SetPWMBasicType(aptHandle, &wavePara);
 30020a8:	fd040793          	addi	a5,s0,-48
 30020ac:	85be                	mv	a1,a5
 30020ae:	fcc42503          	lw	a0,-52(s0)
 30020b2:	3399                	jal	ra,3001df8 <APT_SetPWMBasicType>
}
 30020b4:	0001                	nop
 30020b6:	50f2                	lw	ra,60(sp)
 30020b8:	5462                	lw	s0,56(sp)
 30020ba:	6121                	addi	sp,sp,64
 30020bc:	8082                	ret

030020be <APT_SetADCTrgCompareVal>:
  * @brief Initialize the count compare points for triggering ADC sampling.
  * @param aptHandle APT module handle.
  * @retval None.
  */
static void APT_SetADCTrgCompareVal(APT_Handle *aptHandle)
{
 30020be:	7179                	addi	sp,sp,-48
 30020c0:	d622                	sw	s0,44(sp)
 30020c2:	1800                	addi	s0,sp,48
 30020c4:	fca42e23          	sw	a0,-36(s0)
    /* Configure the count compare point for triggering SOCA and SOCB */
    TC_REFA_REG tmpA;
    TC_REFB_REG tmpB;
    /* Set the value of active register for CMPA and CMPB */
    tmpA = aptHandle->baseAddress->TC_REFA; /* read register */
 30020c8:	fdc42783          	lw	a5,-36(s0)
 30020cc:	439c                	lw	a5,0(a5)
 30020ce:	5b9c                	lw	a5,48(a5)
 30020d0:	fef42223          	sw	a5,-28(s0)
    tmpA.BIT.rg_cnt_refa = aptHandle->adcTrg.cntCmpSOCA;
 30020d4:	fdc42783          	lw	a5,-36(s0)
 30020d8:	3bf6                	lhu	a3,54(a5)
 30020da:	fe442783          	lw	a5,-28(s0)
 30020de:	6741                	lui	a4,0x10
 30020e0:	177d                	addi	a4,a4,-1 # ffff <RAM_SIZE+0xafff>
 30020e2:	8f75                	and	a4,a4,a3
 30020e4:	76c1                	lui	a3,0xffff0
 30020e6:	8ff5                	and	a5,a5,a3
 30020e8:	8fd9                	or	a5,a5,a4
 30020ea:	fef42223          	sw	a5,-28(s0)
    aptHandle->baseAddress->TC_REFA = tmpA; /* write back changed data to register */
 30020ee:	fdc42783          	lw	a5,-36(s0)
 30020f2:	439c                	lw	a5,0(a5)
 30020f4:	fe442703          	lw	a4,-28(s0)
 30020f8:	db98                	sw	a4,48(a5)
    tmpB = aptHandle->baseAddress->TC_REFB;
 30020fa:	fdc42783          	lw	a5,-36(s0)
 30020fe:	439c                	lw	a5,0(a5)
 3002100:	5bdc                	lw	a5,52(a5)
 3002102:	fef42023          	sw	a5,-32(s0)
    tmpB.BIT.rg_cnt_refb = aptHandle->adcTrg.cntCmpSOCB;
 3002106:	fdc42783          	lw	a5,-36(s0)
 300210a:	0427d683          	lhu	a3,66(a5)
 300210e:	fe042783          	lw	a5,-32(s0)
 3002112:	6741                	lui	a4,0x10
 3002114:	177d                	addi	a4,a4,-1 # ffff <RAM_SIZE+0xafff>
 3002116:	8f75                	and	a4,a4,a3
 3002118:	76c1                	lui	a3,0xffff0
 300211a:	8ff5                	and	a5,a5,a3
 300211c:	8fd9                	or	a5,a5,a4
 300211e:	fef42023          	sw	a5,-32(s0)
    aptHandle->baseAddress->TC_REFB = tmpB;
 3002122:	fdc42783          	lw	a5,-36(s0)
 3002126:	439c                	lw	a5,0(a5)
 3002128:	fe042703          	lw	a4,-32(s0)
 300212c:	dbd8                	sw	a4,52(a5)
    /* Set the buffer load mode of CMPA and CMPB */
    if (aptHandle->adcTrg.cntCmpLoadMode == APT_BUFFER_DISABLE) {
 300212e:	fdc42783          	lw	a5,-36(s0)
 3002132:	43fc                	lw	a5,68(a5)
 3002134:	ef99                	bnez	a5,3002152 <APT_SetADCTrgCompareVal+0x94>
        aptHandle->baseAddress->TC_BUF_EN.BIT.rg_refa_buf_en = 0; /* disable buffer function */
 3002136:	fdc42783          	lw	a5,-36(s0)
 300213a:	4398                	lw	a4,0(a5)
 300213c:	4b3c                	lw	a5,80(a4)
 300213e:	9bbd                	andi	a5,a5,-17
 3002140:	cb3c                	sw	a5,80(a4)
        aptHandle->baseAddress->TC_BUF_EN.BIT.rg_refb_buf_en = 0; /* disable buffer function */
 3002142:	fdc42783          	lw	a5,-36(s0)
 3002146:	4398                	lw	a4,0(a5)
 3002148:	4b3c                	lw	a5,80(a4)
 300214a:	fbf7f793          	andi	a5,a5,-65
 300214e:	cb3c                	sw	a5,80(a4)
        aptHandle->baseAddress->TC_REFA = tmpA;
        tmpB = aptHandle->baseAddress->TC_REFB;
        tmpB.BIT.rg_cnt_refb = aptHandle->adcTrg.cntCmpSOCB;
        aptHandle->baseAddress->TC_REFB = tmpB;
    }
}
 3002150:	a291                	j	3002294 <APT_SetADCTrgCompareVal+0x1d6>
        aptHandle->baseAddress->TC_BUF_EN.BIT.rg_refa_buf_en = 1;
 3002152:	fdc42783          	lw	a5,-36(s0)
 3002156:	4398                	lw	a4,0(a5)
 3002158:	4b3c                	lw	a5,80(a4)
 300215a:	0107e793          	ori	a5,a5,16
 300215e:	cb3c                	sw	a5,80(a4)
        aptHandle->baseAddress->TC_BUF_EN.BIT.rg_refb_buf_en = 1;
 3002160:	fdc42783          	lw	a5,-36(s0)
 3002164:	4398                	lw	a4,0(a5)
 3002166:	4b3c                	lw	a5,80(a4)
 3002168:	0407e793          	ori	a5,a5,64
 300216c:	cb3c                	sw	a5,80(a4)
        unsigned int gldLdEn = (aptHandle->adcTrg.cntCmpLoadMode == APT_BUFFER_GLOBAL_LOAD) ? 1 : 0;
 300216e:	fdc42783          	lw	a5,-36(s0)
 3002172:	43fc                	lw	a5,68(a5)
 3002174:	17f5                	addi	a5,a5,-3
 3002176:	0017b793          	seqz	a5,a5
 300217a:	9f81                	uxtb	a5
 300217c:	fef42623          	sw	a5,-20(s0)
        aptHandle->baseAddress->TC_BUF_EN.BIT.rg_refa_gld_en = gldLdEn;
 3002180:	fdc42783          	lw	a5,-36(s0)
 3002184:	4398                	lw	a4,0(a5)
 3002186:	fec42783          	lw	a5,-20(s0)
 300218a:	8b85                	andi	a5,a5,1
 300218c:	0ff7f693          	andi	a3,a5,255
 3002190:	4b3c                	lw	a5,80(a4)
 3002192:	8a85                	andi	a3,a3,1
 3002194:	0696                	slli	a3,a3,0x5
 3002196:	fdf7f793          	andi	a5,a5,-33
 300219a:	8fd5                	or	a5,a5,a3
 300219c:	cb3c                	sw	a5,80(a4)
        aptHandle->baseAddress->TC_BUF_EN.BIT.rg_refb_gld_en = gldLdEn;
 300219e:	fdc42783          	lw	a5,-36(s0)
 30021a2:	4398                	lw	a4,0(a5)
 30021a4:	fec42783          	lw	a5,-20(s0)
 30021a8:	8b85                	andi	a5,a5,1
 30021aa:	0ff7f693          	andi	a3,a5,255
 30021ae:	4b3c                	lw	a5,80(a4)
 30021b0:	8a85                	andi	a3,a3,1
 30021b2:	069e                	slli	a3,a3,0x7
 30021b4:	f7f7f793          	andi	a5,a5,-129
 30021b8:	8fd5                	or	a5,a5,a3
 30021ba:	cb3c                	sw	a5,80(a4)
        unsigned int refBufField = 8;
 30021bc:	47a1                	li	a5,8
 30021be:	fef42423          	sw	a5,-24(s0)
        aptHandle->baseAddress->TC_REF_LOAD.reg &= (~(0x1F << (APT_COMPARE_REFERENCE_A * refBufField)));
 30021c2:	fdc42783          	lw	a5,-36(s0)
 30021c6:	439c                	lw	a5,0(a5)
 30021c8:	4fb8                	lw	a4,88(a5)
 30021ca:	fdc42783          	lw	a5,-36(s0)
 30021ce:	439c                	lw	a5,0(a5)
 30021d0:	9b01                	andi	a4,a4,-32
 30021d2:	cfb8                	sw	a4,88(a5)
        aptHandle->baseAddress->TC_REF_LOAD.reg &= (~(0x1F << (APT_COMPARE_REFERENCE_B * refBufField)));
 30021d4:	fdc42783          	lw	a5,-36(s0)
 30021d8:	439c                	lw	a5,0(a5)
 30021da:	4fb8                	lw	a4,88(a5)
 30021dc:	46fd                	li	a3,31
 30021de:	fe842783          	lw	a5,-24(s0)
 30021e2:	00f697b3          	sll	a5,a3,a5
 30021e6:	fff7c793          	not	a5,a5
 30021ea:	86be                	mv	a3,a5
 30021ec:	fdc42783          	lw	a5,-36(s0)
 30021f0:	439c                	lw	a5,0(a5)
 30021f2:	8f75                	and	a4,a4,a3
 30021f4:	cfb8                	sw	a4,88(a5)
        aptHandle->baseAddress->TC_REF_LOAD.reg |=
 30021f6:	fdc42783          	lw	a5,-36(s0)
 30021fa:	439c                	lw	a5,0(a5)
 30021fc:	4fb4                	lw	a3,88(a5)
            (aptHandle->adcTrg.cntCmpLoadEvt << (APT_COMPARE_REFERENCE_A * refBufField));
 30021fe:	fdc42783          	lw	a5,-36(s0)
 3002202:	47b8                	lw	a4,72(a5)
        aptHandle->baseAddress->TC_REF_LOAD.reg |=
 3002204:	fdc42783          	lw	a5,-36(s0)
 3002208:	439c                	lw	a5,0(a5)
 300220a:	8f55                	or	a4,a4,a3
 300220c:	cfb8                	sw	a4,88(a5)
        aptHandle->baseAddress->TC_REF_LOAD.reg |=
 300220e:	fdc42783          	lw	a5,-36(s0)
 3002212:	439c                	lw	a5,0(a5)
 3002214:	4fb4                	lw	a3,88(a5)
            (aptHandle->adcTrg.cntCmpLoadEvt << (APT_COMPARE_REFERENCE_B * refBufField));
 3002216:	fdc42783          	lw	a5,-36(s0)
 300221a:	47b8                	lw	a4,72(a5)
 300221c:	fe842783          	lw	a5,-24(s0)
 3002220:	00f71733          	sll	a4,a4,a5
        aptHandle->baseAddress->TC_REF_LOAD.reg |=
 3002224:	fdc42783          	lw	a5,-36(s0)
 3002228:	439c                	lw	a5,0(a5)
 300222a:	8f55                	or	a4,a4,a3
 300222c:	cfb8                	sw	a4,88(a5)
        tmpA = aptHandle->baseAddress->TC_REFA;
 300222e:	fdc42783          	lw	a5,-36(s0)
 3002232:	439c                	lw	a5,0(a5)
 3002234:	5b9c                	lw	a5,48(a5)
 3002236:	fef42223          	sw	a5,-28(s0)
        tmpA.BIT.rg_cnt_refa = aptHandle->adcTrg.cntCmpSOCA;
 300223a:	fdc42783          	lw	a5,-36(s0)
 300223e:	3bf6                	lhu	a3,54(a5)
 3002240:	fe442783          	lw	a5,-28(s0)
 3002244:	6741                	lui	a4,0x10
 3002246:	177d                	addi	a4,a4,-1 # ffff <RAM_SIZE+0xafff>
 3002248:	8f75                	and	a4,a4,a3
 300224a:	76c1                	lui	a3,0xffff0
 300224c:	8ff5                	and	a5,a5,a3
 300224e:	8fd9                	or	a5,a5,a4
 3002250:	fef42223          	sw	a5,-28(s0)
        aptHandle->baseAddress->TC_REFA = tmpA;
 3002254:	fdc42783          	lw	a5,-36(s0)
 3002258:	439c                	lw	a5,0(a5)
 300225a:	fe442703          	lw	a4,-28(s0)
 300225e:	db98                	sw	a4,48(a5)
        tmpB = aptHandle->baseAddress->TC_REFB;
 3002260:	fdc42783          	lw	a5,-36(s0)
 3002264:	439c                	lw	a5,0(a5)
 3002266:	5bdc                	lw	a5,52(a5)
 3002268:	fef42023          	sw	a5,-32(s0)
        tmpB.BIT.rg_cnt_refb = aptHandle->adcTrg.cntCmpSOCB;
 300226c:	fdc42783          	lw	a5,-36(s0)
 3002270:	0427d683          	lhu	a3,66(a5)
 3002274:	fe042783          	lw	a5,-32(s0)
 3002278:	6741                	lui	a4,0x10
 300227a:	177d                	addi	a4,a4,-1 # ffff <RAM_SIZE+0xafff>
 300227c:	8f75                	and	a4,a4,a3
 300227e:	76c1                	lui	a3,0xffff0
 3002280:	8ff5                	and	a5,a5,a3
 3002282:	8fd9                	or	a5,a5,a4
 3002284:	fef42023          	sw	a5,-32(s0)
        aptHandle->baseAddress->TC_REFB = tmpB;
 3002288:	fdc42783          	lw	a5,-36(s0)
 300228c:	439c                	lw	a5,0(a5)
 300228e:	fe042703          	lw	a4,-32(s0)
 3002292:	dbd8                	sw	a4,52(a5)
}
 3002294:	0001                	nop
 3002296:	5432                	lw	s0,44(sp)
 3002298:	6145                	addi	sp,sp,48
 300229a:	8082                	ret

0300229c <APT_SetADCTrigger>:
  * @brief Initialize the ADC trigger function of APT module.
  * @param aptHandle APT module handle
  * @retval None.
  */
static void APT_SetADCTrigger(APT_Handle *aptHandle)
{
 300229c:	1101                	addi	sp,sp,-32
 300229e:	ce06                	sw	ra,28(sp)
 30022a0:	cc22                	sw	s0,24(sp)
 30022a2:	1000                	addi	s0,sp,32
 30022a4:	fea42623          	sw	a0,-20(s0)
    APT_PARAM_CHECK_NO_RET(aptHandle->adcTrg.trgScaleSOCA <= ADC_CONVERSION_START_CNT_MAX);
 30022a8:	fec42783          	lw	a5,-20(s0)
 30022ac:	3bda                	lhu	a4,52(a5)
 30022ae:	47bd                	li	a5,15
 30022b0:	00e7fa63          	bgeu	a5,a4,30022c4 <APT_SetADCTrigger+0x28>
 30022b4:	13e00593          	li	a1,318
 30022b8:	030107b7          	lui	a5,0x3010
 30022bc:	78c78513          	addi	a0,a5,1932 # 301078c <g_crgIpMatch+0x27c>
 30022c0:	26a9                	jal	ra,300260a <AssertErrorLog.trans.1>
 30022c2:	a0fd                	j	30023b0 <APT_SetADCTrigger+0x114>
    APT_PARAM_CHECK_NO_RET(aptHandle->adcTrg.trgScaleSOCB <= ADC_CONVERSION_START_CNT_MAX);
 30022c4:	fec42783          	lw	a5,-20(s0)
 30022c8:	0407d703          	lhu	a4,64(a5)
 30022cc:	47bd                	li	a5,15
 30022ce:	00e7fa63          	bgeu	a5,a4,30022e2 <APT_SetADCTrigger+0x46>
 30022d2:	13f00593          	li	a1,319
 30022d6:	030107b7          	lui	a5,0x3010
 30022da:	78c78513          	addi	a0,a5,1932 # 301078c <g_crgIpMatch+0x27c>
 30022de:	2635                	jal	ra,300260a <AssertErrorLog.trans.1>
 30022e0:	a8c1                	j	30023b0 <APT_SetADCTrigger+0x114>
    /* Configure ADC trigger source SOCA */
    aptHandle->baseAddress->CS_TMR_SELA.BIT.rg_csa_tmr_sel = aptHandle->adcTrg.trgSrcSOCA;
 30022e2:	fec42783          	lw	a5,-20(s0)
 30022e6:	5b94                	lw	a3,48(a5)
 30022e8:	fec42783          	lw	a5,-20(s0)
 30022ec:	4398                	lw	a4,0(a5)
 30022ee:	87b6                	mv	a5,a3
 30022f0:	8bbd                	andi	a5,a5,15
 30022f2:	0ff7f693          	andi	a3,a5,255
 30022f6:	50072783          	lw	a5,1280(a4)
 30022fa:	8abd                	andi	a3,a3,15
 30022fc:	9bc1                	andi	a5,a5,-16
 30022fe:	8fd5                	or	a5,a5,a3
 3002300:	50f72023          	sw	a5,1280(a4)
    aptHandle->baseAddress->CS_PRSCA_CFG.BIT.rg_csa_prsc_prd = aptHandle->adcTrg.trgScaleSOCA;
 3002304:	fec42783          	lw	a5,-20(s0)
 3002308:	3bd6                	lhu	a3,52(a5)
 300230a:	fec42783          	lw	a5,-20(s0)
 300230e:	4398                	lw	a4,0(a5)
 3002310:	87b6                	mv	a5,a3
 3002312:	8bbd                	andi	a5,a5,15
 3002314:	0ff7f693          	andi	a3,a5,255
 3002318:	50872783          	lw	a5,1288(a4)
 300231c:	8abd                	andi	a3,a3,15
 300231e:	9bc1                	andi	a5,a5,-16
 3002320:	8fd5                	or	a5,a5,a3
 3002322:	50f72423          	sw	a5,1288(a4)
    aptHandle->baseAddress->CS_TMR_SELA.BIT.rg_csa_en_cs = aptHandle->adcTrg.trgEnSOCA;
 3002326:	fec42783          	lw	a5,-20(s0)
 300232a:	4398                	lw	a4,0(a5)
 300232c:	fec42783          	lw	a5,-20(s0)
 3002330:	02c7c683          	lbu	a3,44(a5)
 3002334:	50072783          	lw	a5,1280(a4)
 3002338:	8a85                	andi	a3,a3,1
 300233a:	06c2                	slli	a3,a3,0x10
 300233c:	7641                	lui	a2,0xffff0
 300233e:	167d                	addi	a2,a2,-1 # fffeffff <RAM_END+0xfbfe7fff>
 3002340:	8ff1                	and	a5,a5,a2
 3002342:	8fd5                	or	a5,a5,a3
 3002344:	50f72023          	sw	a5,1280(a4)
    /* Configure ADC trigger source SOCB */
    aptHandle->baseAddress->CS_TMR_SELB.BIT.rg_csb_tmr_sel = aptHandle->adcTrg.trgSrcSOCB;
 3002348:	fec42783          	lw	a5,-20(s0)
 300234c:	5fd4                	lw	a3,60(a5)
 300234e:	fec42783          	lw	a5,-20(s0)
 3002352:	4398                	lw	a4,0(a5)
 3002354:	87b6                	mv	a5,a3
 3002356:	8bbd                	andi	a5,a5,15
 3002358:	0ff7f693          	andi	a3,a5,255
 300235c:	50472783          	lw	a5,1284(a4)
 3002360:	8abd                	andi	a3,a3,15
 3002362:	9bc1                	andi	a5,a5,-16
 3002364:	8fd5                	or	a5,a5,a3
 3002366:	50f72223          	sw	a5,1284(a4)
    aptHandle->baseAddress->CS_PRSCB_CFG.BIT.rg_csb_prsc_prd = aptHandle->adcTrg.trgScaleSOCB;
 300236a:	fec42783          	lw	a5,-20(s0)
 300236e:	0407d683          	lhu	a3,64(a5)
 3002372:	fec42783          	lw	a5,-20(s0)
 3002376:	4398                	lw	a4,0(a5)
 3002378:	87b6                	mv	a5,a3
 300237a:	8bbd                	andi	a5,a5,15
 300237c:	0ff7f693          	andi	a3,a5,255
 3002380:	50c72783          	lw	a5,1292(a4)
 3002384:	8abd                	andi	a3,a3,15
 3002386:	9bc1                	andi	a5,a5,-16
 3002388:	8fd5                	or	a5,a5,a3
 300238a:	50f72623          	sw	a5,1292(a4)
    aptHandle->baseAddress->CS_TMR_SELB.BIT.rg_csb_en_cs = aptHandle->adcTrg.trgEnSOCB;
 300238e:	fec42783          	lw	a5,-20(s0)
 3002392:	4398                	lw	a4,0(a5)
 3002394:	fec42783          	lw	a5,-20(s0)
 3002398:	0387c683          	lbu	a3,56(a5)
 300239c:	50472783          	lw	a5,1284(a4)
 30023a0:	8a85                	andi	a3,a3,1
 30023a2:	06c2                	slli	a3,a3,0x10
 30023a4:	7641                	lui	a2,0xffff0
 30023a6:	167d                	addi	a2,a2,-1 # fffeffff <RAM_END+0xfbfe7fff>
 30023a8:	8ff1                	and	a5,a5,a2
 30023aa:	8fd5                	or	a5,a5,a3
 30023ac:	50f72223          	sw	a5,1284(a4)
}
 30023b0:	40f2                	lw	ra,28(sp)
 30023b2:	4462                	lw	s0,24(sp)
 30023b4:	6105                	addi	sp,sp,32
 30023b6:	8082                	ret

030023b8 <APT_SetTimerInterrupt>:
  * @brief Initialize the timer interrupt of APT module.
  * @param aptHandle APT module handle.
  * @retval None.
  */
static void APT_SetTimerInterrupt(APT_Handle *aptHandle)
{
 30023b8:	1101                	addi	sp,sp,-32
 30023ba:	ce06                	sw	ra,28(sp)
 30023bc:	cc22                	sw	s0,24(sp)
 30023be:	1000                	addi	s0,sp,32
 30023c0:	fea42623          	sw	a0,-20(s0)
    APT_PARAM_CHECK_NO_RET(aptHandle->tmrInterrupt.tmrInterruptScale <= TIMER_INTERRUPT_CNT_MAX);
 30023c4:	fec42783          	lw	a5,-20(s0)
 30023c8:	0547d703          	lhu	a4,84(a5)
 30023cc:	47bd                	li	a5,15
 30023ce:	00e7fa63          	bgeu	a5,a4,30023e2 <APT_SetTimerInterrupt+0x2a>
 30023d2:	15100593          	li	a1,337
 30023d6:	030107b7          	lui	a5,0x3010
 30023da:	78c78513          	addi	a0,a5,1932 # 301078c <g_crgIpMatch+0x27c>
 30023de:	2435                	jal	ra,300260a <AssertErrorLog.trans.1>
 30023e0:	a095                	j	3002444 <APT_SetTimerInterrupt+0x8c>
    aptHandle->baseAddress->INT_TMR_SEL.BIT.rg_int_tmr_sel = aptHandle->tmrInterrupt.tmrInterruptSrc;
 30023e2:	fec42783          	lw	a5,-20(s0)
 30023e6:	4bb4                	lw	a3,80(a5)
 30023e8:	fec42783          	lw	a5,-20(s0)
 30023ec:	4398                	lw	a4,0(a5)
 30023ee:	87b6                	mv	a5,a3
 30023f0:	8bbd                	andi	a5,a5,15
 30023f2:	0ff7f693          	andi	a3,a5,255
 30023f6:	42472783          	lw	a5,1060(a4)
 30023fa:	8abd                	andi	a3,a3,15
 30023fc:	9bc1                	andi	a5,a5,-16
 30023fe:	8fd5                	or	a5,a5,a3
 3002400:	42f72223          	sw	a5,1060(a4)
    aptHandle->baseAddress->INT_PRSC_CFG.BIT.rg_int_prsc_prd = aptHandle->tmrInterrupt.tmrInterruptScale;
 3002404:	fec42783          	lw	a5,-20(s0)
 3002408:	0547d683          	lhu	a3,84(a5)
 300240c:	fec42783          	lw	a5,-20(s0)
 3002410:	4398                	lw	a4,0(a5)
 3002412:	87b6                	mv	a5,a3
 3002414:	8bbd                	andi	a5,a5,15
 3002416:	0ff7f693          	andi	a3,a5,255
 300241a:	42872783          	lw	a5,1064(a4)
 300241e:	8abd                	andi	a3,a3,15
 3002420:	9bc1                	andi	a5,a5,-16
 3002422:	8fd5                	or	a5,a5,a3
 3002424:	42f72423          	sw	a5,1064(a4)
    aptHandle->baseAddress->INT_TMR_EN.BIT.rg_int_en_tmr = aptHandle->tmrInterrupt.tmrInterruptEn;
 3002428:	fec42783          	lw	a5,-20(s0)
 300242c:	4398                	lw	a4,0(a5)
 300242e:	fec42783          	lw	a5,-20(s0)
 3002432:	04c7c683          	lbu	a3,76(a5)
 3002436:	41472783          	lw	a5,1044(a4)
 300243a:	8a85                	andi	a3,a3,1
 300243c:	9bf9                	andi	a5,a5,-2
 300243e:	8fd5                	or	a5,a5,a3
 3002440:	40f72a23          	sw	a5,1044(a4)
}
 3002444:	40f2                	lw	ra,28(sp)
 3002446:	4462                	lw	s0,24(sp)
 3002448:	6105                	addi	sp,sp,32
 300244a:	8082                	ret

0300244c <HAL_APT_PWMInit>:
  * @brief Initialize the APT hardware configuration based on the APT module handle.
  * @param aptHandle APT module handle.
  * @retval BASE_StatusType: OK, ERROR, BUSY, TIMEOUT.
  */
BASE_StatusType HAL_APT_PWMInit(APT_Handle *aptHandle)
{
 300244c:	1101                	addi	sp,sp,-32
 300244e:	ce06                	sw	ra,28(sp)
 3002450:	cc22                	sw	s0,24(sp)
 3002452:	1000                	addi	s0,sp,32
 3002454:	fea42623          	sw	a0,-20(s0)
    APT_ASSERT_PARAM(aptHandle != NULL);
 3002458:	fec42783          	lw	a5,-20(s0)
 300245c:	eb89                	bnez	a5,300246e <HAL_APT_PWMInit+0x22>
 300245e:	15e00593          	li	a1,350
 3002462:	030107b7          	lui	a5,0x3010
 3002466:	78c78513          	addi	a0,a5,1932 # 301078c <g_crgIpMatch+0x27c>
 300246a:	2245                	jal	ra,300260a <AssertErrorLog.trans.1>
 300246c:	a001                	j	300246c <HAL_APT_PWMInit+0x20>
    APT_ASSERT_PARAM(IsAPTInstance(aptHandle->baseAddress));
 300246e:	fec42783          	lw	a5,-20(s0)
 3002472:	4398                	lw	a4,0(a5)
 3002474:	14a007b7          	lui	a5,0x14a00
 3002478:	02f70f63          	beq	a4,a5,30024b6 <HAL_APT_PWMInit+0x6a>
 300247c:	fec42783          	lw	a5,-20(s0)
 3002480:	4398                	lw	a4,0(a5)
 3002482:	14a017b7          	lui	a5,0x14a01
 3002486:	02f70863          	beq	a4,a5,30024b6 <HAL_APT_PWMInit+0x6a>
 300248a:	fec42783          	lw	a5,-20(s0)
 300248e:	4398                	lw	a4,0(a5)
 3002490:	14a027b7          	lui	a5,0x14a02
 3002494:	02f70163          	beq	a4,a5,30024b6 <HAL_APT_PWMInit+0x6a>
 3002498:	fec42783          	lw	a5,-20(s0)
 300249c:	4398                	lw	a4,0(a5)
 300249e:	14a037b7          	lui	a5,0x14a03
 30024a2:	00f70a63          	beq	a4,a5,30024b6 <HAL_APT_PWMInit+0x6a>
 30024a6:	15f00593          	li	a1,351
 30024aa:	030107b7          	lui	a5,0x3010
 30024ae:	78c78513          	addi	a0,a5,1932 # 301078c <g_crgIpMatch+0x27c>
 30024b2:	2aa1                	jal	ra,300260a <AssertErrorLog.trans.1>
 30024b4:	a001                	j	30024b4 <HAL_APT_PWMInit+0x68>
    APT_PARAM_CHECK_WITH_RET(aptHandle->waveform.dividerFactor <= DIVIDER_FACTOR_MAX, BASE_STATUS_ERROR);
 30024b6:	fec42783          	lw	a5,-20(s0)
 30024ba:	2bda                	lhu	a4,20(a5)
 30024bc:	6785                	lui	a5,0x1
 30024be:	00f76b63          	bltu	a4,a5,30024d4 <HAL_APT_PWMInit+0x88>
 30024c2:	16000593          	li	a1,352
 30024c6:	030107b7          	lui	a5,0x3010
 30024ca:	78c78513          	addi	a0,a5,1932 # 301078c <g_crgIpMatch+0x27c>
 30024ce:	2a35                	jal	ra,300260a <AssertErrorLog.trans.1>
 30024d0:	4785                	li	a5,1
 30024d2:	a23d                	j	3002600 <HAL_APT_PWMInit+0x1b4>
    APT_PARAM_CHECK_WITH_RET(aptHandle->waveform.divInitVal <= aptHandle->waveform.dividerFactor, BASE_STATUS_ERROR);
 30024d4:	fec42783          	lw	a5,-20(s0)
 30024d8:	2f9a                	lhu	a4,24(a5)
 30024da:	fec42783          	lw	a5,-20(s0)
 30024de:	2bde                	lhu	a5,20(a5)
 30024e0:	00e7fb63          	bgeu	a5,a4,30024f6 <HAL_APT_PWMInit+0xaa>
 30024e4:	16100593          	li	a1,353
 30024e8:	030107b7          	lui	a5,0x3010
 30024ec:	78c78513          	addi	a0,a5,1932 # 301078c <g_crgIpMatch+0x27c>
 30024f0:	2a29                	jal	ra,300260a <AssertErrorLog.trans.1>
 30024f2:	4785                	li	a5,1
 30024f4:	a231                	j	3002600 <HAL_APT_PWMInit+0x1b4>
    APT_PARAM_CHECK_WITH_RET(aptHandle->waveform.cntInitVal < aptHandle->waveform.timerPeriod, BASE_STATUS_ERROR);
 30024f6:	fec42783          	lw	a5,-20(s0)
 30024fa:	2fba                	lhu	a4,26(a5)
 30024fc:	fec42783          	lw	a5,-20(s0)
 3002500:	2bfe                	lhu	a5,22(a5)
 3002502:	00f76b63          	bltu	a4,a5,3002518 <HAL_APT_PWMInit+0xcc>
 3002506:	16200593          	li	a1,354
 300250a:	030107b7          	lui	a5,0x3010
 300250e:	78c78513          	addi	a0,a5,1932 # 301078c <g_crgIpMatch+0x27c>
 3002512:	28e5                	jal	ra,300260a <AssertErrorLog.trans.1>
 3002514:	4785                	li	a5,1
 3002516:	a0ed                	j	3002600 <HAL_APT_PWMInit+0x1b4>
    APT_PARAM_CHECK_WITH_RET(aptHandle->waveform.cntCmpLeftEdge > 0, BASE_STATUS_ERROR);
 3002518:	fec42783          	lw	a5,-20(s0)
 300251c:	2fde                	lhu	a5,28(a5)
 300251e:	eb91                	bnez	a5,3002532 <HAL_APT_PWMInit+0xe6>
 3002520:	16300593          	li	a1,355
 3002524:	030107b7          	lui	a5,0x3010
 3002528:	78c78513          	addi	a0,a5,1932 # 301078c <g_crgIpMatch+0x27c>
 300252c:	28f9                	jal	ra,300260a <AssertErrorLog.trans.1>
 300252e:	4785                	li	a5,1
 3002530:	a8c1                	j	3002600 <HAL_APT_PWMInit+0x1b4>
    APT_PARAM_CHECK_WITH_RET(aptHandle->waveform.cntCmpLeftEdge < aptHandle->waveform.timerPeriod, BASE_STATUS_ERROR);
 3002532:	fec42783          	lw	a5,-20(s0)
 3002536:	2fda                	lhu	a4,28(a5)
 3002538:	fec42783          	lw	a5,-20(s0)
 300253c:	2bfe                	lhu	a5,22(a5)
 300253e:	00f76b63          	bltu	a4,a5,3002554 <HAL_APT_PWMInit+0x108>
 3002542:	16400593          	li	a1,356
 3002546:	030107b7          	lui	a5,0x3010
 300254a:	78c78513          	addi	a0,a5,1932 # 301078c <g_crgIpMatch+0x27c>
 300254e:	2875                	jal	ra,300260a <AssertErrorLog.trans.1>
 3002550:	4785                	li	a5,1
 3002552:	a07d                	j	3002600 <HAL_APT_PWMInit+0x1b4>
    APT_PARAM_CHECK_WITH_RET(aptHandle->waveform.cntCmpRightEdge > 0, BASE_STATUS_ERROR);
 3002554:	fec42783          	lw	a5,-20(s0)
 3002558:	2ffe                	lhu	a5,30(a5)
 300255a:	eb91                	bnez	a5,300256e <HAL_APT_PWMInit+0x122>
 300255c:	16500593          	li	a1,357
 3002560:	030107b7          	lui	a5,0x3010
 3002564:	78c78513          	addi	a0,a5,1932 # 301078c <g_crgIpMatch+0x27c>
 3002568:	204d                	jal	ra,300260a <AssertErrorLog.trans.1>
 300256a:	4785                	li	a5,1
 300256c:	a851                	j	3002600 <HAL_APT_PWMInit+0x1b4>
    APT_PARAM_CHECK_WITH_RET(aptHandle->waveform.cntCmpRightEdge < aptHandle->waveform.timerPeriod, BASE_STATUS_ERROR);
 300256e:	fec42783          	lw	a5,-20(s0)
 3002572:	2ffa                	lhu	a4,30(a5)
 3002574:	fec42783          	lw	a5,-20(s0)
 3002578:	2bfe                	lhu	a5,22(a5)
 300257a:	00f76b63          	bltu	a4,a5,3002590 <HAL_APT_PWMInit+0x144>
 300257e:	16600593          	li	a1,358
 3002582:	030107b7          	lui	a5,0x3010
 3002586:	78c78513          	addi	a0,a5,1932 # 301078c <g_crgIpMatch+0x27c>
 300258a:	2041                	jal	ra,300260a <AssertErrorLog.trans.1>
 300258c:	4785                	li	a5,1
 300258e:	a88d                	j	3002600 <HAL_APT_PWMInit+0x1b4>
    APT_PARAM_CHECK_WITH_RET(aptHandle->adcTrg.cntCmpSOCA >= 0, BASE_STATUS_ERROR);
    APT_PARAM_CHECK_WITH_RET(aptHandle->adcTrg.cntCmpSOCA < aptHandle->waveform.timerPeriod, BASE_STATUS_ERROR);
 3002590:	fec42783          	lw	a5,-20(s0)
 3002594:	3bfa                	lhu	a4,54(a5)
 3002596:	fec42783          	lw	a5,-20(s0)
 300259a:	2bfe                	lhu	a5,22(a5)
 300259c:	00f76b63          	bltu	a4,a5,30025b2 <HAL_APT_PWMInit+0x166>
 30025a0:	16800593          	li	a1,360
 30025a4:	030107b7          	lui	a5,0x3010
 30025a8:	78c78513          	addi	a0,a5,1932 # 301078c <g_crgIpMatch+0x27c>
 30025ac:	28b9                	jal	ra,300260a <AssertErrorLog.trans.1>
 30025ae:	4785                	li	a5,1
 30025b0:	a881                	j	3002600 <HAL_APT_PWMInit+0x1b4>
    APT_PARAM_CHECK_WITH_RET(aptHandle->adcTrg.cntCmpSOCB >= 0, BASE_STATUS_ERROR);
    APT_PARAM_CHECK_WITH_RET(aptHandle->adcTrg.cntCmpSOCB < aptHandle->waveform.timerPeriod, BASE_STATUS_ERROR);
 30025b2:	fec42783          	lw	a5,-20(s0)
 30025b6:	0427d703          	lhu	a4,66(a5)
 30025ba:	fec42783          	lw	a5,-20(s0)
 30025be:	2bfe                	lhu	a5,22(a5)
 30025c0:	00f76b63          	bltu	a4,a5,30025d6 <HAL_APT_PWMInit+0x18a>
 30025c4:	16a00593          	li	a1,362
 30025c8:	030107b7          	lui	a5,0x3010
 30025cc:	78c78513          	addi	a0,a5,1932 # 301078c <g_crgIpMatch+0x27c>
 30025d0:	282d                	jal	ra,300260a <AssertErrorLog.trans.1>
 30025d2:	4785                	li	a5,1
 30025d4:	a035                	j	3002600 <HAL_APT_PWMInit+0x1b4>
    APT_TimeBaseInit(aptHandle);
 30025d6:	fec42503          	lw	a0,-20(s0)
 30025da:	b06ff0ef          	jal	ra,30018e0 <APT_TimeBaseInit>
    APT_SetPWMCompareVal(aptHandle);
 30025de:	fec42503          	lw	a0,-20(s0)
 30025e2:	bb6ff0ef          	jal	ra,3001998 <APT_SetPWMCompareVal>
    APT_SetPWMWaveform(aptHandle);
 30025e6:	fec42503          	lw	a0,-20(s0)
 30025ea:	3a65                	jal	ra,3001fa2 <APT_SetPWMWaveform>
    APT_SetADCTrgCompareVal(aptHandle);
 30025ec:	fec42503          	lw	a0,-20(s0)
 30025f0:	34f9                	jal	ra,30020be <APT_SetADCTrgCompareVal>
    APT_SetADCTrigger(aptHandle);
 30025f2:	fec42503          	lw	a0,-20(s0)
 30025f6:	315d                	jal	ra,300229c <APT_SetADCTrigger>
    APT_SetTimerInterrupt(aptHandle);
 30025f8:	fec42503          	lw	a0,-20(s0)
 30025fc:	3b75                	jal	ra,30023b8 <APT_SetTimerInterrupt>
    return BASE_STATUS_OK;
 30025fe:	4781                	li	a5,0
}
 3002600:	853e                	mv	a0,a5
 3002602:	40f2                	lw	ra,28(sp)
 3002604:	4462                	lw	s0,24(sp)
 3002606:	6105                	addi	sp,sp,32
 3002608:	8082                	ret

0300260a <AssertErrorLog.trans.1>:
 300260a:	7340006f          	j	3002d3e <AssertErrorLog>

0300260e <HAL_APT_StartModule>:
  *            RUN_APT7 - apt7_run bit in SYSCTRL1 register.
  *            RUN_APT8 - apt8_run bit in SYSCTRL1 register.
  * @retval None.
  */
void HAL_APT_StartModule(unsigned int aptRunMask)
{
 300260e:	1101                	addi	sp,sp,-32
 3002610:	ce22                	sw	s0,28(sp)
 3002612:	1000                	addi	s0,sp,32
 3002614:	fea42623          	sw	a0,-20(s0)
    SYSCTRL1->APT_RUN.reg |= aptRunMask;
 3002618:	10100737          	lui	a4,0x10100
 300261c:	67a1                	lui	a5,0x8
 300261e:	97ba                	add	a5,a5,a4
 3002620:	4398                	lw	a4,0(a5)
 3002622:	101006b7          	lui	a3,0x10100
 3002626:	fec42783          	lw	a5,-20(s0)
 300262a:	8f5d                	or	a4,a4,a5
 300262c:	67a1                	lui	a5,0x8
 300262e:	97b6                	add	a5,a5,a3
 3002630:	c398                	sw	a4,0(a5)
}
 3002632:	0001                	nop
 3002634:	4472                	lw	s0,28(sp)
 3002636:	6105                	addi	sp,sp,32
 3002638:	8082                	ret

0300263a <HAL_APT_StopModule>:
  *            RUN_APT7 - apt7_run bit in SYSCTRL1 register.
  *            RUN_APT8 - apt8_run bit in SYSCTRL1 register.
  * @retval None.
  */
void HAL_APT_StopModule(unsigned int aptRunMask)
{
 300263a:	1101                	addi	sp,sp,-32
 300263c:	ce22                	sw	s0,28(sp)
 300263e:	1000                	addi	s0,sp,32
 3002640:	fea42623          	sw	a0,-20(s0)
    SYSCTRL1->APT_RUN.reg &= (~aptRunMask);
 3002644:	10100737          	lui	a4,0x10100
 3002648:	67a1                	lui	a5,0x8
 300264a:	97ba                	add	a5,a5,a4
 300264c:	4398                	lw	a4,0(a5)
 300264e:	fec42783          	lw	a5,-20(s0)
 3002652:	fff7c793          	not	a5,a5
 3002656:	101006b7          	lui	a3,0x10100
 300265a:	8f7d                	and	a4,a4,a5
 300265c:	67a1                	lui	a5,0x8
 300265e:	97b6                	add	a5,a5,a3
 3002660:	c398                	sw	a4,0(a5)
}
 3002662:	0001                	nop
 3002664:	4472                	lw	s0,28(sp)
 3002666:	6105                	addi	sp,sp,32
 3002668:	8082                	ret

0300266a <HAL_APT_SetPWMDutyByNumber>:
  * @param aptHandle APT module handle.
  * @param duty PWM duty. Range: 1 ~ 99.
  * @retval BASE_StatusType: OK, ERROR, BUSY, TIMEOUT.
  */
BASE_StatusType HAL_APT_SetPWMDutyByNumber(APT_Handle *aptHandle, unsigned int duty)
{
 300266a:	7179                	addi	sp,sp,-48
 300266c:	d606                	sw	ra,44(sp)
 300266e:	d422                	sw	s0,40(sp)
 3002670:	1800                	addi	s0,sp,48
 3002672:	fca42e23          	sw	a0,-36(s0)
 3002676:	fcb42c23          	sw	a1,-40(s0)
    APT_ASSERT_PARAM(aptHandle != NULL);
 300267a:	fdc42783          	lw	a5,-36(s0)
 300267e:	eb89                	bnez	a5,3002690 <HAL_APT_SetPWMDutyByNumber+0x26>
 3002680:	42d00593          	li	a1,1069
 3002684:	030107b7          	lui	a5,0x3010
 3002688:	78c78513          	addi	a0,a5,1932 # 301078c <g_crgIpMatch+0x27c>
 300268c:	2d4d                	jal	ra,3002d3e <AssertErrorLog>
 300268e:	a001                	j	300268e <HAL_APT_SetPWMDutyByNumber+0x24>
    APT_ASSERT_PARAM(IsAPTInstance(aptHandle->baseAddress));
 3002690:	fdc42783          	lw	a5,-36(s0)
 3002694:	4398                	lw	a4,0(a5)
 3002696:	14a007b7          	lui	a5,0x14a00
 300269a:	02f70f63          	beq	a4,a5,30026d8 <HAL_APT_SetPWMDutyByNumber+0x6e>
 300269e:	fdc42783          	lw	a5,-36(s0)
 30026a2:	4398                	lw	a4,0(a5)
 30026a4:	14a017b7          	lui	a5,0x14a01
 30026a8:	02f70863          	beq	a4,a5,30026d8 <HAL_APT_SetPWMDutyByNumber+0x6e>
 30026ac:	fdc42783          	lw	a5,-36(s0)
 30026b0:	4398                	lw	a4,0(a5)
 30026b2:	14a027b7          	lui	a5,0x14a02
 30026b6:	02f70163          	beq	a4,a5,30026d8 <HAL_APT_SetPWMDutyByNumber+0x6e>
 30026ba:	fdc42783          	lw	a5,-36(s0)
 30026be:	4398                	lw	a4,0(a5)
 30026c0:	14a037b7          	lui	a5,0x14a03
 30026c4:	00f70a63          	beq	a4,a5,30026d8 <HAL_APT_SetPWMDutyByNumber+0x6e>
 30026c8:	42e00593          	li	a1,1070
 30026cc:	030107b7          	lui	a5,0x3010
 30026d0:	78c78513          	addi	a0,a5,1932 # 301078c <g_crgIpMatch+0x27c>
 30026d4:	25ad                	jal	ra,3002d3e <AssertErrorLog>
 30026d6:	a001                	j	30026d6 <HAL_APT_SetPWMDutyByNumber+0x6c>
    APT_PARAM_CHECK_WITH_RET(duty < MAX_DUTY, BASE_STATUS_ERROR);
 30026d8:	fd842703          	lw	a4,-40(s0)
 30026dc:	06300793          	li	a5,99
 30026e0:	00e7fb63          	bgeu	a5,a4,30026f6 <HAL_APT_SetPWMDutyByNumber+0x8c>
 30026e4:	42f00593          	li	a1,1071
 30026e8:	030107b7          	lui	a5,0x3010
 30026ec:	78c78513          	addi	a0,a5,1932 # 301078c <g_crgIpMatch+0x27c>
 30026f0:	25b9                	jal	ra,3002d3e <AssertErrorLog>
 30026f2:	4785                	li	a5,1
 30026f4:	aa01                	j	3002804 <HAL_APT_SetPWMDutyByNumber+0x19a>
    APT_PARAM_CHECK_WITH_RET(duty > 0, BASE_STATUS_ERROR);
 30026f6:	fd842783          	lw	a5,-40(s0)
 30026fa:	eb91                	bnez	a5,300270e <HAL_APT_SetPWMDutyByNumber+0xa4>
 30026fc:	43000593          	li	a1,1072
 3002700:	030107b7          	lui	a5,0x3010
 3002704:	78c78513          	addi	a0,a5,1932 # 301078c <g_crgIpMatch+0x27c>
 3002708:	2d1d                	jal	ra,3002d3e <AssertErrorLog>
 300270a:	4785                	li	a5,1
 300270c:	a8e5                	j	3002804 <HAL_APT_SetPWMDutyByNumber+0x19a>

    unsigned int cntCmpLeftEdge, cntCmpRightEdge;
    TC_REFC_REG tmpC;
    TC_REFD_REG tmpD;

    if (aptHandle->waveform.cntMode == APT_COUNT_MODE_UP_DOWN) {
 300270e:	fdc42783          	lw	a5,-36(s0)
 3002712:	4b98                	lw	a4,16(a5)
 3002714:	4789                	li	a5,2
 3002716:	04f71263          	bne	a4,a5,300275a <HAL_APT_SetPWMDutyByNumber+0xf0>
        cntCmpLeftEdge = aptHandle->waveform.timerPeriod - \
 300271a:	fdc42783          	lw	a5,-36(s0)
 300271e:	2bfe                	lhu	a5,22(a5)
 3002720:	873e                	mv	a4,a5
                         (int)(((float)aptHandle->waveform.timerPeriod / MAX_DUTY) * duty);
 3002722:	fdc42783          	lw	a5,-36(s0)
 3002726:	2bfe                	lhu	a5,22(a5)
 3002728:	d017f753          	fcvt.s.wu	fa4,a5
 300272c:	030107b7          	lui	a5,0x3010
 3002730:	7b87a787          	flw	fa5,1976(a5) # 30107b8 <g_crgIpMatch+0x2a8>
 3002734:	18f77753          	fdiv.s	fa4,fa4,fa5
 3002738:	fd842783          	lw	a5,-40(s0)
 300273c:	d017f7d3          	fcvt.s.wu	fa5,a5
 3002740:	10f777d3          	fmul.s	fa5,fa4,fa5
 3002744:	c00797d3          	fcvt.w.s	a5,fa5,rtz
        cntCmpLeftEdge = aptHandle->waveform.timerPeriod - \
 3002748:	40f707b3          	sub	a5,a4,a5
 300274c:	fef42623          	sw	a5,-20(s0)
        cntCmpRightEdge = cntCmpLeftEdge;
 3002750:	fec42783          	lw	a5,-20(s0)
 3002754:	fef42423          	sw	a5,-24(s0)
 3002758:	a83d                	j	3002796 <HAL_APT_SetPWMDutyByNumber+0x12c>
    } else {
        cntCmpLeftEdge = 1;
 300275a:	4785                	li	a5,1
 300275c:	fef42623          	sw	a5,-20(s0)
        cntCmpRightEdge = (int)(((float)aptHandle->waveform.timerPeriod / MAX_DUTY) * duty + cntCmpLeftEdge);
 3002760:	fdc42783          	lw	a5,-36(s0)
 3002764:	2bfe                	lhu	a5,22(a5)
 3002766:	d017f753          	fcvt.s.wu	fa4,a5
 300276a:	030107b7          	lui	a5,0x3010
 300276e:	7b87a787          	flw	fa5,1976(a5) # 30107b8 <g_crgIpMatch+0x2a8>
 3002772:	18f77753          	fdiv.s	fa4,fa4,fa5
 3002776:	fd842783          	lw	a5,-40(s0)
 300277a:	d017f7d3          	fcvt.s.wu	fa5,a5
 300277e:	10f77753          	fmul.s	fa4,fa4,fa5
 3002782:	fec42783          	lw	a5,-20(s0)
 3002786:	d017f7d3          	fcvt.s.wu	fa5,a5
 300278a:	00f777d3          	fadd.s	fa5,fa4,fa5
 300278e:	c00797d3          	fcvt.w.s	a5,fa5,rtz
 3002792:	fef42423          	sw	a5,-24(s0)
    }
    tmpC = aptHandle->baseAddress->TC_REFC;
 3002796:	fdc42783          	lw	a5,-36(s0)
 300279a:	439c                	lw	a5,0(a5)
 300279c:	5f9c                	lw	a5,56(a5)
 300279e:	fef42223          	sw	a5,-28(s0)
    tmpC.BIT.rg_cnt_refc = cntCmpLeftEdge;
 30027a2:	fec42783          	lw	a5,-20(s0)
 30027a6:	01079693          	slli	a3,a5,0x10
 30027aa:	82c1                	srli	a3,a3,0x10
 30027ac:	fe442783          	lw	a5,-28(s0)
 30027b0:	6741                	lui	a4,0x10
 30027b2:	177d                	addi	a4,a4,-1 # ffff <RAM_SIZE+0xafff>
 30027b4:	8f75                	and	a4,a4,a3
 30027b6:	76c1                	lui	a3,0xffff0
 30027b8:	8ff5                	and	a5,a5,a3
 30027ba:	8fd9                	or	a5,a5,a4
 30027bc:	fef42223          	sw	a5,-28(s0)
    aptHandle->baseAddress->TC_REFC = tmpC;
 30027c0:	fdc42783          	lw	a5,-36(s0)
 30027c4:	439c                	lw	a5,0(a5)
 30027c6:	fe442703          	lw	a4,-28(s0)
 30027ca:	df98                	sw	a4,56(a5)
    tmpD = aptHandle->baseAddress->TC_REFD;
 30027cc:	fdc42783          	lw	a5,-36(s0)
 30027d0:	439c                	lw	a5,0(a5)
 30027d2:	5fdc                	lw	a5,60(a5)
 30027d4:	fef42023          	sw	a5,-32(s0)
    tmpD.BIT.rg_cnt_refd = cntCmpRightEdge;
 30027d8:	fe842783          	lw	a5,-24(s0)
 30027dc:	01079693          	slli	a3,a5,0x10
 30027e0:	82c1                	srli	a3,a3,0x10
 30027e2:	fe042783          	lw	a5,-32(s0)
 30027e6:	6741                	lui	a4,0x10
 30027e8:	177d                	addi	a4,a4,-1 # ffff <RAM_SIZE+0xafff>
 30027ea:	8f75                	and	a4,a4,a3
 30027ec:	76c1                	lui	a3,0xffff0
 30027ee:	8ff5                	and	a5,a5,a3
 30027f0:	8fd9                	or	a5,a5,a4
 30027f2:	fef42023          	sw	a5,-32(s0)
    aptHandle->baseAddress->TC_REFD = tmpD;
 30027f6:	fdc42783          	lw	a5,-36(s0)
 30027fa:	439c                	lw	a5,0(a5)
 30027fc:	fe042703          	lw	a4,-32(s0)
 3002800:	dfd8                	sw	a4,60(a5)
    return BASE_STATUS_OK;
 3002802:	4781                	li	a5,0
}
 3002804:	853e                	mv	a0,a5
 3002806:	50b2                	lw	ra,44(sp)
 3002808:	5422                	lw	s0,40(sp)
 300280a:	6145                	addi	sp,sp,48
 300280c:	8082                	ret

0300280e <APT_ConfigAction>:
  * @param aptHandle APT module handle.
  * @param refDotParameters Attribute structure of a reference point.
  * @retval BASE_StatusType: OK, ERROR.
  */
static BASE_StatusType APT_ConfigAction(APT_Handle *aptHandle, APT_RefDotParameters *refDotParameters)
{
 300280e:	1101                	addi	sp,sp,-32
 3002810:	ce22                	sw	s0,28(sp)
 3002812:	1000                	addi	s0,sp,32
 3002814:	fea42623          	sw	a0,-20(s0)
 3002818:	feb42423          	sw	a1,-24(s0)
    /* Action configuration of the reference point of channel B. */
    if (refDotParameters->pwmChannel == APT_PWM_CHANNEL_B) {
 300281c:	fe842783          	lw	a5,-24(s0)
 3002820:	43d8                	lw	a4,4(a5)
 3002822:	4785                	li	a5,1
 3002824:	04f71b63          	bne	a4,a5,300287a <APT_ConfigAction+0x6c>
        aptHandle->baseAddress->PG_ACT_B.reg &= (~(0b11 << refDotParameters->actionEvent)); /* Reset configuration */
 3002828:	fec42783          	lw	a5,-20(s0)
 300282c:	439c                	lw	a5,0(a5)
 300282e:	1047a703          	lw	a4,260(a5)
 3002832:	fe842783          	lw	a5,-24(s0)
 3002836:	479c                	lw	a5,8(a5)
 3002838:	468d                	li	a3,3
 300283a:	00f697b3          	sll	a5,a3,a5
 300283e:	fff7c793          	not	a5,a5
 3002842:	86be                	mv	a3,a5
 3002844:	fec42783          	lw	a5,-20(s0)
 3002848:	439c                	lw	a5,0(a5)
 300284a:	8f75                	and	a4,a4,a3
 300284c:	10e7a223          	sw	a4,260(a5)
        aptHandle->baseAddress->PG_ACT_B.reg |=  (refDotParameters->action << refDotParameters->actionEvent);
 3002850:	fec42783          	lw	a5,-20(s0)
 3002854:	439c                	lw	a5,0(a5)
 3002856:	1047a683          	lw	a3,260(a5)
 300285a:	fe842783          	lw	a5,-24(s0)
 300285e:	47d8                	lw	a4,12(a5)
 3002860:	fe842783          	lw	a5,-24(s0)
 3002864:	479c                	lw	a5,8(a5)
 3002866:	00f71733          	sll	a4,a4,a5
 300286a:	fec42783          	lw	a5,-20(s0)
 300286e:	439c                	lw	a5,0(a5)
 3002870:	8f55                	or	a4,a4,a3
 3002872:	10e7a223          	sw	a4,260(a5)
        return BASE_STATUS_OK;
 3002876:	4781                	li	a5,0
 3002878:	a8b9                	j	30028d6 <APT_ConfigAction+0xc8>
    }
    /* Action configuration of the reference point of channel A. */
    if (refDotParameters->pwmChannel == APT_PWM_CHANNEL_A) {
 300287a:	fe842783          	lw	a5,-24(s0)
 300287e:	43dc                	lw	a5,4(a5)
 3002880:	ebb1                	bnez	a5,30028d4 <APT_ConfigAction+0xc6>
        aptHandle->baseAddress->PG_ACT_A.reg &= (~(0b11 << refDotParameters->actionEvent)); /* Reset configuration */
 3002882:	fec42783          	lw	a5,-20(s0)
 3002886:	439c                	lw	a5,0(a5)
 3002888:	1007a703          	lw	a4,256(a5)
 300288c:	fe842783          	lw	a5,-24(s0)
 3002890:	479c                	lw	a5,8(a5)
 3002892:	468d                	li	a3,3
 3002894:	00f697b3          	sll	a5,a3,a5
 3002898:	fff7c793          	not	a5,a5
 300289c:	86be                	mv	a3,a5
 300289e:	fec42783          	lw	a5,-20(s0)
 30028a2:	439c                	lw	a5,0(a5)
 30028a4:	8f75                	and	a4,a4,a3
 30028a6:	10e7a023          	sw	a4,256(a5)
        aptHandle->baseAddress->PG_ACT_A.reg |=  (refDotParameters->action << refDotParameters->actionEvent);
 30028aa:	fec42783          	lw	a5,-20(s0)
 30028ae:	439c                	lw	a5,0(a5)
 30028b0:	1007a683          	lw	a3,256(a5)
 30028b4:	fe842783          	lw	a5,-24(s0)
 30028b8:	47d8                	lw	a4,12(a5)
 30028ba:	fe842783          	lw	a5,-24(s0)
 30028be:	479c                	lw	a5,8(a5)
 30028c0:	00f71733          	sll	a4,a4,a5
 30028c4:	fec42783          	lw	a5,-20(s0)
 30028c8:	439c                	lw	a5,0(a5)
 30028ca:	8f55                	or	a4,a4,a3
 30028cc:	10e7a023          	sw	a4,256(a5)
        return BASE_STATUS_OK;
 30028d0:	4781                	li	a5,0
 30028d2:	a011                	j	30028d6 <APT_ConfigAction+0xc8>
    }
    return BASE_STATUS_ERROR;
 30028d4:	4785                	li	a5,1
}
 30028d6:	853e                	mv	a0,a5
 30028d8:	4472                	lw	s0,28(sp)
 30028da:	6105                	addi	sp,sp,32
 30028dc:	8082                	ret

030028de <APT_ConfigRefA>:
  * @param aptHandle APT module handle.
  * @param refDotParameters Reference point A configuration property set.
  * @retval BASE_StatusType: OK, ERROR.
  */
BASE_StatusType APT_ConfigRefA(APT_Handle *aptHandle, APT_RefDotParameters *refDotParameters)
{
 30028de:	1101                	addi	sp,sp,-32
 30028e0:	ce06                	sw	ra,28(sp)
 30028e2:	cc22                	sw	s0,24(sp)
 30028e4:	1000                	addi	s0,sp,32
 30028e6:	fea42623          	sw	a0,-20(s0)
 30028ea:	feb42423          	sw	a1,-24(s0)
    APT_ASSERT_PARAM(aptHandle != NULL);
 30028ee:	fec42783          	lw	a5,-20(s0)
 30028f2:	eb89                	bnez	a5,3002904 <APT_ConfigRefA+0x26>
 30028f4:	51c00593          	li	a1,1308
 30028f8:	030107b7          	lui	a5,0x3010
 30028fc:	78c78513          	addi	a0,a5,1932 # 301078c <g_crgIpMatch+0x27c>
 3002900:	293d                	jal	ra,3002d3e <AssertErrorLog>
 3002902:	a001                	j	3002902 <APT_ConfigRefA+0x24>
    APT_ASSERT_PARAM(aptHandle->baseAddress != NULL);
 3002904:	fec42783          	lw	a5,-20(s0)
 3002908:	439c                	lw	a5,0(a5)
 300290a:	eb89                	bnez	a5,300291c <APT_ConfigRefA+0x3e>
 300290c:	51d00593          	li	a1,1309
 3002910:	030107b7          	lui	a5,0x3010
 3002914:	78c78513          	addi	a0,a5,1932 # 301078c <g_crgIpMatch+0x27c>
 3002918:	211d                	jal	ra,3002d3e <AssertErrorLog>
 300291a:	a001                	j	300291a <APT_ConfigRefA+0x3c>
    APT_ASSERT_PARAM(IsAPTInstance(aptHandle->baseAddress));
 300291c:	fec42783          	lw	a5,-20(s0)
 3002920:	4398                	lw	a4,0(a5)
 3002922:	14a007b7          	lui	a5,0x14a00
 3002926:	02f70f63          	beq	a4,a5,3002964 <APT_ConfigRefA+0x86>
 300292a:	fec42783          	lw	a5,-20(s0)
 300292e:	4398                	lw	a4,0(a5)
 3002930:	14a017b7          	lui	a5,0x14a01
 3002934:	02f70863          	beq	a4,a5,3002964 <APT_ConfigRefA+0x86>
 3002938:	fec42783          	lw	a5,-20(s0)
 300293c:	4398                	lw	a4,0(a5)
 300293e:	14a027b7          	lui	a5,0x14a02
 3002942:	02f70163          	beq	a4,a5,3002964 <APT_ConfigRefA+0x86>
 3002946:	fec42783          	lw	a5,-20(s0)
 300294a:	4398                	lw	a4,0(a5)
 300294c:	14a037b7          	lui	a5,0x14a03
 3002950:	00f70a63          	beq	a4,a5,3002964 <APT_ConfigRefA+0x86>
 3002954:	51e00593          	li	a1,1310
 3002958:	030107b7          	lui	a5,0x3010
 300295c:	78c78513          	addi	a0,a5,1932 # 301078c <g_crgIpMatch+0x27c>
 3002960:	2ef9                	jal	ra,3002d3e <AssertErrorLog>
 3002962:	a001                	j	3002962 <APT_ConfigRefA+0x84>
    /* Check the attributes of the reference point A: PWM Channel. */
    APT_PARAM_CHECK_WITH_RET(refDotParameters->pwmChannel >= APT_PWM_CHANNEL_A, BASE_STATUS_ERROR);
    APT_PARAM_CHECK_WITH_RET(refDotParameters->pwmChannel <= APT_PWM_CHANNEL_B, BASE_STATUS_ERROR);
 3002964:	fe842783          	lw	a5,-24(s0)
 3002968:	43d8                	lw	a4,4(a5)
 300296a:	4785                	li	a5,1
 300296c:	00e7fb63          	bgeu	a5,a4,3002982 <APT_ConfigRefA+0xa4>
 3002970:	52100593          	li	a1,1313
 3002974:	030107b7          	lui	a5,0x3010
 3002978:	78c78513          	addi	a0,a5,1932 # 301078c <g_crgIpMatch+0x27c>
 300297c:	26c9                	jal	ra,3002d3e <AssertErrorLog>
 300297e:	4785                	li	a5,1
 3002980:	a0b5                	j	30029ec <APT_ConfigRefA+0x10e>
    /* Check the attributes of the reference point A: triggle action event. */
    APT_PARAM_CHECK_WITH_RET(refDotParameters->actionEvent >= APT_PWM_ACTION_ON_TIMEBASE_ZERO, BASE_STATUS_ERROR);
    APT_PARAM_CHECK_WITH_RET(refDotParameters->actionEvent <= APT_PWM_ACTION_ON_C2_COUNT_DOWN, BASE_STATUS_ERROR);
 3002982:	fe842783          	lw	a5,-24(s0)
 3002986:	4798                	lw	a4,8(a5)
 3002988:	47e9                	li	a5,26
 300298a:	00e7fb63          	bgeu	a5,a4,30029a0 <APT_ConfigRefA+0xc2>
 300298e:	52400593          	li	a1,1316
 3002992:	030107b7          	lui	a5,0x3010
 3002996:	78c78513          	addi	a0,a5,1932 # 301078c <g_crgIpMatch+0x27c>
 300299a:	2655                	jal	ra,3002d3e <AssertErrorLog>
 300299c:	4785                	li	a5,1
 300299e:	a0b9                	j	30029ec <APT_ConfigRefA+0x10e>
    /* Check the attributes of the reference point A: triggle action. */
    APT_PARAM_CHECK_WITH_RET(refDotParameters->action <= APT_PWM_ACTION_TOGGLE, BASE_STATUS_ERROR);
 30029a0:	fe842783          	lw	a5,-24(s0)
 30029a4:	47d8                	lw	a4,12(a5)
 30029a6:	478d                	li	a5,3
 30029a8:	00e7fb63          	bgeu	a5,a4,30029be <APT_ConfigRefA+0xe0>
 30029ac:	52600593          	li	a1,1318
 30029b0:	030107b7          	lui	a5,0x3010
 30029b4:	78c78513          	addi	a0,a5,1932 # 301078c <g_crgIpMatch+0x27c>
 30029b8:	2659                	jal	ra,3002d3e <AssertErrorLog>
 30029ba:	4785                	li	a5,1
 30029bc:	a805                	j	30029ec <APT_ConfigRefA+0x10e>
    /* Change reference dot A value and division value. */
    aptHandle->baseAddress->TC_REFA.BIT.rg_cnt_refa = refDotParameters->refDotValue;
 30029be:	fe842783          	lw	a5,-24(s0)
 30029c2:	4394                	lw	a3,0(a5)
 30029c4:	fec42783          	lw	a5,-20(s0)
 30029c8:	4398                	lw	a4,0(a5)
 30029ca:	01069613          	slli	a2,a3,0x10
 30029ce:	8241                	srli	a2,a2,0x10
 30029d0:	5b1c                	lw	a5,48(a4)
 30029d2:	66c1                	lui	a3,0x10
 30029d4:	16fd                	addi	a3,a3,-1 # ffff <RAM_SIZE+0xafff>
 30029d6:	8ef1                	and	a3,a3,a2
 30029d8:	7641                	lui	a2,0xffff0
 30029da:	8ff1                	and	a5,a5,a2
 30029dc:	8fd5                	or	a5,a5,a3
 30029de:	db1c                	sw	a5,48(a4)
    /* Reference dot A triggle event and action */
    return APT_ConfigAction(aptHandle, refDotParameters);
 30029e0:	fe842583          	lw	a1,-24(s0)
 30029e4:	fec42503          	lw	a0,-20(s0)
 30029e8:	351d                	jal	ra,300280e <APT_ConfigAction>
 30029ea:	87aa                	mv	a5,a0
}
 30029ec:	853e                	mv	a0,a5
 30029ee:	40f2                	lw	ra,28(sp)
 30029f0:	4462                	lw	s0,24(sp)
 30029f2:	6105                	addi	sp,sp,32
 30029f4:	8082                	ret

030029f6 <APT_ConfigRefB>:
  * @param aptHandle APT module handle.
  * @param refDotParameters Reference point B configuration property set.
  * @retval BASE_StatusType: OK, ERROR.
  */
BASE_StatusType APT_ConfigRefB(APT_Handle *aptHandle, APT_RefDotParameters *refDotParameters)
{
 30029f6:	1101                	addi	sp,sp,-32
 30029f8:	ce06                	sw	ra,28(sp)
 30029fa:	cc22                	sw	s0,24(sp)
 30029fc:	1000                	addi	s0,sp,32
 30029fe:	fea42623          	sw	a0,-20(s0)
 3002a02:	feb42423          	sw	a1,-24(s0)
    APT_ASSERT_PARAM(aptHandle != NULL);
 3002a06:	fec42783          	lw	a5,-20(s0)
 3002a0a:	eb89                	bnez	a5,3002a1c <APT_ConfigRefB+0x26>
 3002a0c:	53500593          	li	a1,1333
 3002a10:	030107b7          	lui	a5,0x3010
 3002a14:	78c78513          	addi	a0,a5,1932 # 301078c <g_crgIpMatch+0x27c>
 3002a18:	261d                	jal	ra,3002d3e <AssertErrorLog>
 3002a1a:	a001                	j	3002a1a <APT_ConfigRefB+0x24>
    APT_ASSERT_PARAM(aptHandle->baseAddress != NULL);
 3002a1c:	fec42783          	lw	a5,-20(s0)
 3002a20:	439c                	lw	a5,0(a5)
 3002a22:	eb89                	bnez	a5,3002a34 <APT_ConfigRefB+0x3e>
 3002a24:	53600593          	li	a1,1334
 3002a28:	030107b7          	lui	a5,0x3010
 3002a2c:	78c78513          	addi	a0,a5,1932 # 301078c <g_crgIpMatch+0x27c>
 3002a30:	2639                	jal	ra,3002d3e <AssertErrorLog>
 3002a32:	a001                	j	3002a32 <APT_ConfigRefB+0x3c>
    APT_ASSERT_PARAM(IsAPTInstance(aptHandle->baseAddress));
 3002a34:	fec42783          	lw	a5,-20(s0)
 3002a38:	4398                	lw	a4,0(a5)
 3002a3a:	14a007b7          	lui	a5,0x14a00
 3002a3e:	02f70f63          	beq	a4,a5,3002a7c <APT_ConfigRefB+0x86>
 3002a42:	fec42783          	lw	a5,-20(s0)
 3002a46:	4398                	lw	a4,0(a5)
 3002a48:	14a017b7          	lui	a5,0x14a01
 3002a4c:	02f70863          	beq	a4,a5,3002a7c <APT_ConfigRefB+0x86>
 3002a50:	fec42783          	lw	a5,-20(s0)
 3002a54:	4398                	lw	a4,0(a5)
 3002a56:	14a027b7          	lui	a5,0x14a02
 3002a5a:	02f70163          	beq	a4,a5,3002a7c <APT_ConfigRefB+0x86>
 3002a5e:	fec42783          	lw	a5,-20(s0)
 3002a62:	4398                	lw	a4,0(a5)
 3002a64:	14a037b7          	lui	a5,0x14a03
 3002a68:	00f70a63          	beq	a4,a5,3002a7c <APT_ConfigRefB+0x86>
 3002a6c:	53700593          	li	a1,1335
 3002a70:	030107b7          	lui	a5,0x3010
 3002a74:	78c78513          	addi	a0,a5,1932 # 301078c <g_crgIpMatch+0x27c>
 3002a78:	24d9                	jal	ra,3002d3e <AssertErrorLog>
 3002a7a:	a001                	j	3002a7a <APT_ConfigRefB+0x84>
    /* Check the attributes of the reference point B: PWM Channel. */
    APT_PARAM_CHECK_WITH_RET(refDotParameters->pwmChannel >= APT_PWM_CHANNEL_A, BASE_STATUS_ERROR);
    APT_PARAM_CHECK_WITH_RET(refDotParameters->pwmChannel <= APT_PWM_CHANNEL_B, BASE_STATUS_ERROR);
 3002a7c:	fe842783          	lw	a5,-24(s0)
 3002a80:	43d8                	lw	a4,4(a5)
 3002a82:	4785                	li	a5,1
 3002a84:	00e7fb63          	bgeu	a5,a4,3002a9a <APT_ConfigRefB+0xa4>
 3002a88:	53a00593          	li	a1,1338
 3002a8c:	030107b7          	lui	a5,0x3010
 3002a90:	78c78513          	addi	a0,a5,1932 # 301078c <g_crgIpMatch+0x27c>
 3002a94:	246d                	jal	ra,3002d3e <AssertErrorLog>
 3002a96:	4785                	li	a5,1
 3002a98:	a0b5                	j	3002b04 <APT_ConfigRefB+0x10e>
    /* Check the attributes of the reference point B: triggle action event. */
    APT_PARAM_CHECK_WITH_RET(refDotParameters->actionEvent >= APT_PWM_ACTION_ON_TIMEBASE_ZERO, BASE_STATUS_ERROR);
    APT_PARAM_CHECK_WITH_RET(refDotParameters->actionEvent <= APT_PWM_ACTION_ON_C2_COUNT_DOWN, BASE_STATUS_ERROR);
 3002a9a:	fe842783          	lw	a5,-24(s0)
 3002a9e:	4798                	lw	a4,8(a5)
 3002aa0:	47e9                	li	a5,26
 3002aa2:	00e7fb63          	bgeu	a5,a4,3002ab8 <APT_ConfigRefB+0xc2>
 3002aa6:	53d00593          	li	a1,1341
 3002aaa:	030107b7          	lui	a5,0x3010
 3002aae:	78c78513          	addi	a0,a5,1932 # 301078c <g_crgIpMatch+0x27c>
 3002ab2:	2471                	jal	ra,3002d3e <AssertErrorLog>
 3002ab4:	4785                	li	a5,1
 3002ab6:	a0b9                	j	3002b04 <APT_ConfigRefB+0x10e>
    /* Check the attributes of the reference point B: triggle action. */
    APT_PARAM_CHECK_WITH_RET(refDotParameters->action <= APT_PWM_ACTION_TOGGLE, BASE_STATUS_ERROR);
 3002ab8:	fe842783          	lw	a5,-24(s0)
 3002abc:	47d8                	lw	a4,12(a5)
 3002abe:	478d                	li	a5,3
 3002ac0:	00e7fb63          	bgeu	a5,a4,3002ad6 <APT_ConfigRefB+0xe0>
 3002ac4:	53f00593          	li	a1,1343
 3002ac8:	030107b7          	lui	a5,0x3010
 3002acc:	78c78513          	addi	a0,a5,1932 # 301078c <g_crgIpMatch+0x27c>
 3002ad0:	24bd                	jal	ra,3002d3e <AssertErrorLog>
 3002ad2:	4785                	li	a5,1
 3002ad4:	a805                	j	3002b04 <APT_ConfigRefB+0x10e>
    /* Change reference dot B value and division value. */
    aptHandle->baseAddress->TC_REFB.BIT.rg_cnt_refb = refDotParameters->refDotValue;
 3002ad6:	fe842783          	lw	a5,-24(s0)
 3002ada:	4394                	lw	a3,0(a5)
 3002adc:	fec42783          	lw	a5,-20(s0)
 3002ae0:	4398                	lw	a4,0(a5)
 3002ae2:	01069613          	slli	a2,a3,0x10
 3002ae6:	8241                	srli	a2,a2,0x10
 3002ae8:	5b5c                	lw	a5,52(a4)
 3002aea:	66c1                	lui	a3,0x10
 3002aec:	16fd                	addi	a3,a3,-1 # ffff <RAM_SIZE+0xafff>
 3002aee:	8ef1                	and	a3,a3,a2
 3002af0:	7641                	lui	a2,0xffff0
 3002af2:	8ff1                	and	a5,a5,a2
 3002af4:	8fd5                	or	a5,a5,a3
 3002af6:	db5c                	sw	a5,52(a4)
    /* Reference dot B triggle event and action. */
    return APT_ConfigAction(aptHandle, refDotParameters);
 3002af8:	fe842583          	lw	a1,-24(s0)
 3002afc:	fec42503          	lw	a0,-20(s0)
 3002b00:	3339                	jal	ra,300280e <APT_ConfigAction>
 3002b02:	87aa                	mv	a5,a0
}
 3002b04:	853e                	mv	a0,a5
 3002b06:	40f2                	lw	ra,28(sp)
 3002b08:	4462                	lw	s0,24(sp)
 3002b0a:	6105                	addi	sp,sp,32
 3002b0c:	8082                	ret

03002b0e <APT_ConfigRefC>:
  * @param aptHandle APT module handle.
  * @param refDotParameters Reference point C configuration property set.
  * @retval BASE_StatusType: OK, ERROR.
  */
BASE_StatusType APT_ConfigRefC(APT_Handle *aptHandle, APT_RefDotParameters *refDotParameters)
{
 3002b0e:	1101                	addi	sp,sp,-32
 3002b10:	ce06                	sw	ra,28(sp)
 3002b12:	cc22                	sw	s0,24(sp)
 3002b14:	1000                	addi	s0,sp,32
 3002b16:	fea42623          	sw	a0,-20(s0)
 3002b1a:	feb42423          	sw	a1,-24(s0)
    APT_ASSERT_PARAM(aptHandle != NULL);
 3002b1e:	fec42783          	lw	a5,-20(s0)
 3002b22:	eb89                	bnez	a5,3002b34 <APT_ConfigRefC+0x26>
 3002b24:	54e00593          	li	a1,1358
 3002b28:	030107b7          	lui	a5,0x3010
 3002b2c:	78c78513          	addi	a0,a5,1932 # 301078c <g_crgIpMatch+0x27c>
 3002b30:	2439                	jal	ra,3002d3e <AssertErrorLog>
 3002b32:	a001                	j	3002b32 <APT_ConfigRefC+0x24>
    APT_ASSERT_PARAM(aptHandle->baseAddress != NULL);
 3002b34:	fec42783          	lw	a5,-20(s0)
 3002b38:	439c                	lw	a5,0(a5)
 3002b3a:	eb89                	bnez	a5,3002b4c <APT_ConfigRefC+0x3e>
 3002b3c:	54f00593          	li	a1,1359
 3002b40:	030107b7          	lui	a5,0x3010
 3002b44:	78c78513          	addi	a0,a5,1932 # 301078c <g_crgIpMatch+0x27c>
 3002b48:	2add                	jal	ra,3002d3e <AssertErrorLog>
 3002b4a:	a001                	j	3002b4a <APT_ConfigRefC+0x3c>
    APT_ASSERT_PARAM(IsAPTInstance(aptHandle->baseAddress));
 3002b4c:	fec42783          	lw	a5,-20(s0)
 3002b50:	4398                	lw	a4,0(a5)
 3002b52:	14a007b7          	lui	a5,0x14a00
 3002b56:	02f70f63          	beq	a4,a5,3002b94 <APT_ConfigRefC+0x86>
 3002b5a:	fec42783          	lw	a5,-20(s0)
 3002b5e:	4398                	lw	a4,0(a5)
 3002b60:	14a017b7          	lui	a5,0x14a01
 3002b64:	02f70863          	beq	a4,a5,3002b94 <APT_ConfigRefC+0x86>
 3002b68:	fec42783          	lw	a5,-20(s0)
 3002b6c:	4398                	lw	a4,0(a5)
 3002b6e:	14a027b7          	lui	a5,0x14a02
 3002b72:	02f70163          	beq	a4,a5,3002b94 <APT_ConfigRefC+0x86>
 3002b76:	fec42783          	lw	a5,-20(s0)
 3002b7a:	4398                	lw	a4,0(a5)
 3002b7c:	14a037b7          	lui	a5,0x14a03
 3002b80:	00f70a63          	beq	a4,a5,3002b94 <APT_ConfigRefC+0x86>
 3002b84:	55000593          	li	a1,1360
 3002b88:	030107b7          	lui	a5,0x3010
 3002b8c:	78c78513          	addi	a0,a5,1932 # 301078c <g_crgIpMatch+0x27c>
 3002b90:	227d                	jal	ra,3002d3e <AssertErrorLog>
 3002b92:	a001                	j	3002b92 <APT_ConfigRefC+0x84>
    /* Check the attributes of the reference point C: PWM Channel. */
    APT_PARAM_CHECK_WITH_RET(refDotParameters->pwmChannel >= APT_PWM_CHANNEL_A, BASE_STATUS_ERROR);
    APT_PARAM_CHECK_WITH_RET(refDotParameters->pwmChannel <= APT_PWM_CHANNEL_B, BASE_STATUS_ERROR);
 3002b94:	fe842783          	lw	a5,-24(s0)
 3002b98:	43d8                	lw	a4,4(a5)
 3002b9a:	4785                	li	a5,1
 3002b9c:	00e7fb63          	bgeu	a5,a4,3002bb2 <APT_ConfigRefC+0xa4>
 3002ba0:	55300593          	li	a1,1363
 3002ba4:	030107b7          	lui	a5,0x3010
 3002ba8:	78c78513          	addi	a0,a5,1932 # 301078c <g_crgIpMatch+0x27c>
 3002bac:	2a49                	jal	ra,3002d3e <AssertErrorLog>
 3002bae:	4785                	li	a5,1
 3002bb0:	a0b5                	j	3002c1c <APT_ConfigRefC+0x10e>
    /* Check the attributes of the reference point C: triggle action event. */
    APT_PARAM_CHECK_WITH_RET(refDotParameters->actionEvent >= APT_PWM_ACTION_ON_TIMEBASE_ZERO, BASE_STATUS_ERROR);
    APT_PARAM_CHECK_WITH_RET(refDotParameters->actionEvent <= APT_PWM_ACTION_ON_C2_COUNT_DOWN, BASE_STATUS_ERROR);
 3002bb2:	fe842783          	lw	a5,-24(s0)
 3002bb6:	4798                	lw	a4,8(a5)
 3002bb8:	47e9                	li	a5,26
 3002bba:	00e7fb63          	bgeu	a5,a4,3002bd0 <APT_ConfigRefC+0xc2>
 3002bbe:	55600593          	li	a1,1366
 3002bc2:	030107b7          	lui	a5,0x3010
 3002bc6:	78c78513          	addi	a0,a5,1932 # 301078c <g_crgIpMatch+0x27c>
 3002bca:	2a95                	jal	ra,3002d3e <AssertErrorLog>
 3002bcc:	4785                	li	a5,1
 3002bce:	a0b9                	j	3002c1c <APT_ConfigRefC+0x10e>
    /* Check the attributes of the reference point C: triggle action. */
    APT_PARAM_CHECK_WITH_RET(refDotParameters->action <= APT_PWM_ACTION_TOGGLE, BASE_STATUS_ERROR);
 3002bd0:	fe842783          	lw	a5,-24(s0)
 3002bd4:	47d8                	lw	a4,12(a5)
 3002bd6:	478d                	li	a5,3
 3002bd8:	00e7fb63          	bgeu	a5,a4,3002bee <APT_ConfigRefC+0xe0>
 3002bdc:	55800593          	li	a1,1368
 3002be0:	030107b7          	lui	a5,0x3010
 3002be4:	78c78513          	addi	a0,a5,1932 # 301078c <g_crgIpMatch+0x27c>
 3002be8:	2a99                	jal	ra,3002d3e <AssertErrorLog>
 3002bea:	4785                	li	a5,1
 3002bec:	a805                	j	3002c1c <APT_ConfigRefC+0x10e>
    /* Change reference dot C value and division value. */
    aptHandle->baseAddress->TC_REFC.BIT.rg_cnt_refc = refDotParameters->refDotValue;
 3002bee:	fe842783          	lw	a5,-24(s0)
 3002bf2:	4394                	lw	a3,0(a5)
 3002bf4:	fec42783          	lw	a5,-20(s0)
 3002bf8:	4398                	lw	a4,0(a5)
 3002bfa:	01069613          	slli	a2,a3,0x10
 3002bfe:	8241                	srli	a2,a2,0x10
 3002c00:	5f1c                	lw	a5,56(a4)
 3002c02:	66c1                	lui	a3,0x10
 3002c04:	16fd                	addi	a3,a3,-1 # ffff <RAM_SIZE+0xafff>
 3002c06:	8ef1                	and	a3,a3,a2
 3002c08:	7641                	lui	a2,0xffff0
 3002c0a:	8ff1                	and	a5,a5,a2
 3002c0c:	8fd5                	or	a5,a5,a3
 3002c0e:	df1c                	sw	a5,56(a4)
    /* Reference dot C triggle event and action. */
    return APT_ConfigAction(aptHandle, refDotParameters);
 3002c10:	fe842583          	lw	a1,-24(s0)
 3002c14:	fec42503          	lw	a0,-20(s0)
 3002c18:	3edd                	jal	ra,300280e <APT_ConfigAction>
 3002c1a:	87aa                	mv	a5,a0
}
 3002c1c:	853e                	mv	a0,a5
 3002c1e:	40f2                	lw	ra,28(sp)
 3002c20:	4462                	lw	s0,24(sp)
 3002c22:	6105                	addi	sp,sp,32
 3002c24:	8082                	ret

03002c26 <APT_ConfigRefD>:
  * @param aptHandle APT module handle.
  * @param refDotParameters Reference point D configuration property set.
  * @retval BASE_StatusType: OK, ERROR.
  */
BASE_StatusType APT_ConfigRefD(APT_Handle *aptHandle, APT_RefDotParameters *refDotParameters)
{
 3002c26:	1101                	addi	sp,sp,-32
 3002c28:	ce06                	sw	ra,28(sp)
 3002c2a:	cc22                	sw	s0,24(sp)
 3002c2c:	1000                	addi	s0,sp,32
 3002c2e:	fea42623          	sw	a0,-20(s0)
 3002c32:	feb42423          	sw	a1,-24(s0)
    APT_ASSERT_PARAM(aptHandle != NULL);
 3002c36:	fec42783          	lw	a5,-20(s0)
 3002c3a:	eb89                	bnez	a5,3002c4c <APT_ConfigRefD+0x26>
 3002c3c:	56700593          	li	a1,1383
 3002c40:	030107b7          	lui	a5,0x3010
 3002c44:	78c78513          	addi	a0,a5,1932 # 301078c <g_crgIpMatch+0x27c>
 3002c48:	28dd                	jal	ra,3002d3e <AssertErrorLog>
 3002c4a:	a001                	j	3002c4a <APT_ConfigRefD+0x24>
    APT_ASSERT_PARAM(aptHandle->baseAddress != NULL);
 3002c4c:	fec42783          	lw	a5,-20(s0)
 3002c50:	439c                	lw	a5,0(a5)
 3002c52:	eb89                	bnez	a5,3002c64 <APT_ConfigRefD+0x3e>
 3002c54:	56800593          	li	a1,1384
 3002c58:	030107b7          	lui	a5,0x3010
 3002c5c:	78c78513          	addi	a0,a5,1932 # 301078c <g_crgIpMatch+0x27c>
 3002c60:	28f9                	jal	ra,3002d3e <AssertErrorLog>
 3002c62:	a001                	j	3002c62 <APT_ConfigRefD+0x3c>
    APT_ASSERT_PARAM(IsAPTInstance(aptHandle->baseAddress));
 3002c64:	fec42783          	lw	a5,-20(s0)
 3002c68:	4398                	lw	a4,0(a5)
 3002c6a:	14a007b7          	lui	a5,0x14a00
 3002c6e:	02f70f63          	beq	a4,a5,3002cac <APT_ConfigRefD+0x86>
 3002c72:	fec42783          	lw	a5,-20(s0)
 3002c76:	4398                	lw	a4,0(a5)
 3002c78:	14a017b7          	lui	a5,0x14a01
 3002c7c:	02f70863          	beq	a4,a5,3002cac <APT_ConfigRefD+0x86>
 3002c80:	fec42783          	lw	a5,-20(s0)
 3002c84:	4398                	lw	a4,0(a5)
 3002c86:	14a027b7          	lui	a5,0x14a02
 3002c8a:	02f70163          	beq	a4,a5,3002cac <APT_ConfigRefD+0x86>
 3002c8e:	fec42783          	lw	a5,-20(s0)
 3002c92:	4398                	lw	a4,0(a5)
 3002c94:	14a037b7          	lui	a5,0x14a03
 3002c98:	00f70a63          	beq	a4,a5,3002cac <APT_ConfigRefD+0x86>
 3002c9c:	56900593          	li	a1,1385
 3002ca0:	030107b7          	lui	a5,0x3010
 3002ca4:	78c78513          	addi	a0,a5,1932 # 301078c <g_crgIpMatch+0x27c>
 3002ca8:	2859                	jal	ra,3002d3e <AssertErrorLog>
 3002caa:	a001                	j	3002caa <APT_ConfigRefD+0x84>
    /* Check the attributes of the reference point D: PWM Channel. */
    APT_PARAM_CHECK_WITH_RET(refDotParameters->pwmChannel >= APT_PWM_CHANNEL_A, BASE_STATUS_ERROR);
    APT_PARAM_CHECK_WITH_RET(refDotParameters->pwmChannel <= APT_PWM_CHANNEL_B, BASE_STATUS_ERROR);
 3002cac:	fe842783          	lw	a5,-24(s0)
 3002cb0:	43d8                	lw	a4,4(a5)
 3002cb2:	4785                	li	a5,1
 3002cb4:	00e7fb63          	bgeu	a5,a4,3002cca <APT_ConfigRefD+0xa4>
 3002cb8:	56c00593          	li	a1,1388
 3002cbc:	030107b7          	lui	a5,0x3010
 3002cc0:	78c78513          	addi	a0,a5,1932 # 301078c <g_crgIpMatch+0x27c>
 3002cc4:	28ad                	jal	ra,3002d3e <AssertErrorLog>
 3002cc6:	4785                	li	a5,1
 3002cc8:	a0b5                	j	3002d34 <APT_ConfigRefD+0x10e>
    /* Check the attributes of the reference point D: triggle action event. */
    APT_PARAM_CHECK_WITH_RET(refDotParameters->actionEvent >= APT_PWM_ACTION_ON_TIMEBASE_ZERO, BASE_STATUS_ERROR);
    APT_PARAM_CHECK_WITH_RET(refDotParameters->actionEvent <= APT_PWM_ACTION_ON_C2_COUNT_DOWN, BASE_STATUS_ERROR);
 3002cca:	fe842783          	lw	a5,-24(s0)
 3002cce:	4798                	lw	a4,8(a5)
 3002cd0:	47e9                	li	a5,26
 3002cd2:	00e7fb63          	bgeu	a5,a4,3002ce8 <APT_ConfigRefD+0xc2>
 3002cd6:	56f00593          	li	a1,1391
 3002cda:	030107b7          	lui	a5,0x3010
 3002cde:	78c78513          	addi	a0,a5,1932 # 301078c <g_crgIpMatch+0x27c>
 3002ce2:	28b1                	jal	ra,3002d3e <AssertErrorLog>
 3002ce4:	4785                	li	a5,1
 3002ce6:	a0b9                	j	3002d34 <APT_ConfigRefD+0x10e>
    /* Check the attributes of the reference point D: triggle action. */
    APT_PARAM_CHECK_WITH_RET(refDotParameters->action <= APT_PWM_ACTION_TOGGLE, BASE_STATUS_ERROR);
 3002ce8:	fe842783          	lw	a5,-24(s0)
 3002cec:	47d8                	lw	a4,12(a5)
 3002cee:	478d                	li	a5,3
 3002cf0:	00e7fb63          	bgeu	a5,a4,3002d06 <APT_ConfigRefD+0xe0>
 3002cf4:	57100593          	li	a1,1393
 3002cf8:	030107b7          	lui	a5,0x3010
 3002cfc:	78c78513          	addi	a0,a5,1932 # 301078c <g_crgIpMatch+0x27c>
 3002d00:	283d                	jal	ra,3002d3e <AssertErrorLog>
 3002d02:	4785                	li	a5,1
 3002d04:	a805                	j	3002d34 <APT_ConfigRefD+0x10e>
    /* Change reference dot D value and division value. */
    aptHandle->baseAddress->TC_REFD.BIT.rg_cnt_refd = refDotParameters->refDotValue;
 3002d06:	fe842783          	lw	a5,-24(s0)
 3002d0a:	4394                	lw	a3,0(a5)
 3002d0c:	fec42783          	lw	a5,-20(s0)
 3002d10:	4398                	lw	a4,0(a5)
 3002d12:	01069613          	slli	a2,a3,0x10
 3002d16:	8241                	srli	a2,a2,0x10
 3002d18:	5f5c                	lw	a5,60(a4)
 3002d1a:	66c1                	lui	a3,0x10
 3002d1c:	16fd                	addi	a3,a3,-1 # ffff <RAM_SIZE+0xafff>
 3002d1e:	8ef1                	and	a3,a3,a2
 3002d20:	7641                	lui	a2,0xffff0
 3002d22:	8ff1                	and	a5,a5,a2
 3002d24:	8fd5                	or	a5,a5,a3
 3002d26:	df5c                	sw	a5,60(a4)
    /* Reference dot D triggle event and action. */
    return APT_ConfigAction(aptHandle, refDotParameters);
 3002d28:	fe842583          	lw	a1,-24(s0)
 3002d2c:	fec42503          	lw	a0,-20(s0)
 3002d30:	3cf9                	jal	ra,300280e <APT_ConfigAction>
 3002d32:	87aa                	mv	a5,a0
}
 3002d34:	853e                	mv	a0,a5
 3002d36:	40f2                	lw	ra,28(sp)
 3002d38:	4462                	lw	s0,24(sp)
 3002d3a:	6105                	addi	sp,sp,32
 3002d3c:	8082                	ret

03002d3e <AssertErrorLog>:
  * @param file Pointer to the name of the file where the error occurs.
  * @param line Number of the line where the error occurs.
  * @retval None.
  */
__weak void AssertErrorLog(char *file, unsigned int line)
{
 3002d3e:	1101                	addi	sp,sp,-32
 3002d40:	ce22                	sw	s0,28(sp)
 3002d42:	1000                	addi	s0,sp,32
 3002d44:	fea42623          	sw	a0,-20(s0)
 3002d48:	feb42423          	sw	a1,-24(s0)
    /* Use only if the user apllication is not defined. */
    BASE_FUNC_UNUSED(file);
    BASE_FUNC_UNUSED(line);
 3002d4c:	0001                	nop
 3002d4e:	4472                	lw	s0,28(sp)
 3002d50:	6105                	addi	sp,sp,32
 3002d52:	8082                	ret

03002d54 <DCL_SYSTICK_GetTick>:
  * @brief   Get the systick
  * @param   None
  * @retval  The SysTick Value
  */
static inline unsigned int DCL_SYSTICK_GetTick(void)
{
 3002d54:	1141                	addi	sp,sp,-16
 3002d56:	c622                	sw	s0,12(sp)
 3002d58:	0800                	addi	s0,sp,16
    return SYSTICK->MTIME;   /* Systick value(Lower 32bit register) */
 3002d5a:	143807b7          	lui	a5,0x14380
 3002d5e:	479c                	lw	a5,8(a5)
}
 3002d60:	853e                	mv	a0,a5
 3002d62:	4432                	lw	s0,12(sp)
 3002d64:	0141                	addi	sp,sp,16
 3002d66:	8082                	ret

03002d68 <BASE_FUNC_GetCpuFreqHz>:
  * @brief Get the current CPU frequency.
  * @param None.
  * @retval System clock frequency in Hz.
  */
unsigned int BASE_FUNC_GetCpuFreqHz(void)
{
 3002d68:	1141                	addi	sp,sp,-16
 3002d6a:	c606                	sw	ra,12(sp)
 3002d6c:	c422                	sw	s0,8(sp)
 3002d6e:	0800                	addi	s0,sp,16
    return HAL_CRG_GetCoreClkFreq();
 3002d70:	0f0020ef          	jal	ra,3004e60 <HAL_CRG_GetCoreClkFreq>
 3002d74:	87aa                	mv	a5,a0
}
 3002d76:	853e                	mv	a0,a5
 3002d78:	40b2                	lw	ra,12(sp)
 3002d7a:	4422                	lw	s0,8(sp)
 3002d7c:	0141                	addi	sp,sp,16
 3002d7e:	8082                	ret

03002d80 <BASE_FUNC_DelayUs>:
  * @brief Delay number of us.
  * @param us The number of us to delay.
  * @retval None.
  */
void BASE_FUNC_DelayUs(unsigned int us)
{
 3002d80:	7179                	addi	sp,sp,-48
 3002d82:	d606                	sw	ra,44(sp)
 3002d84:	d422                	sw	s0,40(sp)
 3002d86:	1800                	addi	s0,sp,48
 3002d88:	fca42e23          	sw	a0,-36(s0)
    unsigned int preTick = DCL_SYSTICK_GetTick();
 3002d8c:	37e1                	jal	ra,3002d54 <DCL_SYSTICK_GetTick>
 3002d8e:	fea42623          	sw	a0,-20(s0)
    unsigned int tickInUs = (SYSTICK_GetCRGHZ() / CRG_FREQ_1MHz) * us;
 3002d92:	a44fe0ef          	jal	ra,3000fd6 <SYSTICK_GetCRGHZ>
 3002d96:	872a                	mv	a4,a0
 3002d98:	000f47b7          	lui	a5,0xf4
 3002d9c:	24078793          	addi	a5,a5,576 # f4240 <FLASH_SIZE+0xd4244>
 3002da0:	02f757b3          	divu	a5,a4,a5
 3002da4:	fdc42703          	lw	a4,-36(s0)
 3002da8:	02f707b3          	mul	a5,a4,a5
 3002dac:	fef42423          	sw	a5,-24(s0)
    unsigned int curTick;
    unsigned int delta;

	/* Wait until the delta is greater than tickInUs */
    do {
        curTick = DCL_SYSTICK_GetTick();
 3002db0:	3755                	jal	ra,3002d54 <DCL_SYSTICK_GetTick>
 3002db2:	fea42223          	sw	a0,-28(s0)
        delta = (curTick >= preTick) ? curTick - preTick : SYSTICK_MAX_VALUE - preTick + curTick + 1;
 3002db6:	fe442703          	lw	a4,-28(s0)
 3002dba:	fec42783          	lw	a5,-20(s0)
 3002dbe:	40f707b3          	sub	a5,a4,a5
 3002dc2:	fef42023          	sw	a5,-32(s0)
    } while (delta < tickInUs);
 3002dc6:	fe042703          	lw	a4,-32(s0)
 3002dca:	fe842783          	lw	a5,-24(s0)
 3002dce:	fef761e3          	bltu	a4,a5,3002db0 <BASE_FUNC_DelayUs+0x30>
}
 3002dd2:	0001                	nop
 3002dd4:	50b2                	lw	ra,44(sp)
 3002dd6:	5422                	lw	s0,40(sp)
 3002dd8:	6145                	addi	sp,sp,48
 3002dda:	8082                	ret

03002ddc <BASE_FUNC_DelayMs>:
  * @brief Delay number of ms.
  * @param ms The number of ms to delay.
  * @retval None.
  */
void BASE_FUNC_DelayMs(unsigned int ms)
{
 3002ddc:	7179                	addi	sp,sp,-48
 3002dde:	d606                	sw	ra,44(sp)
 3002de0:	d422                	sw	s0,40(sp)
 3002de2:	1800                	addi	s0,sp,48
 3002de4:	fca42e23          	sw	a0,-36(s0)
    for (unsigned int i = 0; i < ms; ++i) {
 3002de8:	fe042623          	sw	zero,-20(s0)
 3002dec:	a809                	j	3002dfe <BASE_FUNC_DelayMs+0x22>
        BASE_FUNC_DelayUs(BASE_DEFINE_DELAY_US_IN_MS);
 3002dee:	3e800513          	li	a0,1000
 3002df2:	3779                	jal	ra,3002d80 <BASE_FUNC_DelayUs>
    for (unsigned int i = 0; i < ms; ++i) {
 3002df4:	fec42783          	lw	a5,-20(s0)
 3002df8:	0785                	addi	a5,a5,1
 3002dfa:	fef42623          	sw	a5,-20(s0)
 3002dfe:	fec42703          	lw	a4,-20(s0)
 3002e02:	fdc42783          	lw	a5,-36(s0)
 3002e06:	fef764e3          	bltu	a4,a5,3002dee <BASE_FUNC_DelayMs+0x12>
    }
}
 3002e0a:	0001                	nop
 3002e0c:	50b2                	lw	ra,44(sp)
 3002e0e:	5422                	lw	s0,40(sp)
 3002e10:	6145                	addi	sp,sp,48
 3002e12:	8082                	ret

03002e14 <BASE_FUNC_DelaySeconds>:
  * @brief Delay number of seconds.
  * @param seconds The number of seconds to delay.
  * @retval None.
  */
void BASE_FUNC_DelaySeconds(unsigned int seconds)
{
 3002e14:	7179                	addi	sp,sp,-48
 3002e16:	d606                	sw	ra,44(sp)
 3002e18:	d422                	sw	s0,40(sp)
 3002e1a:	1800                	addi	s0,sp,48
 3002e1c:	fca42e23          	sw	a0,-36(s0)
    for (unsigned int i = 0; i < seconds; ++i) {
 3002e20:	fe042623          	sw	zero,-20(s0)
 3002e24:	a809                	j	3002e36 <BASE_FUNC_DelaySeconds+0x22>
        BASE_FUNC_DelayMs(BASE_DEFINE_DELAY_MS_IN_SEC);
 3002e26:	3e800513          	li	a0,1000
 3002e2a:	3f4d                	jal	ra,3002ddc <BASE_FUNC_DelayMs>
    for (unsigned int i = 0; i < seconds; ++i) {
 3002e2c:	fec42783          	lw	a5,-20(s0)
 3002e30:	0785                	addi	a5,a5,1
 3002e32:	fef42623          	sw	a5,-20(s0)
 3002e36:	fec42703          	lw	a4,-20(s0)
 3002e3a:	fdc42783          	lw	a5,-36(s0)
 3002e3e:	fef764e3          	bltu	a4,a5,3002e26 <BASE_FUNC_DelaySeconds+0x12>
    }
}
 3002e42:	0001                	nop
 3002e44:	50b2                	lw	ra,44(sp)
 3002e46:	5422                	lw	s0,40(sp)
 3002e48:	6145                	addi	sp,sp,48
 3002e4a:	8082                	ret

03002e4c <BASE_FUNC_Delay>:
  * @param delay The number of 'units' to delay.
  * @param units Specifies the delay unit.
  * @retval None.
  */
void BASE_FUNC_Delay(unsigned int delay, BASE_DelayUnit units)
{
 3002e4c:	1101                	addi	sp,sp,-32
 3002e4e:	ce06                	sw	ra,28(sp)
 3002e50:	cc22                	sw	s0,24(sp)
 3002e52:	1000                	addi	s0,sp,32
 3002e54:	fea42623          	sw	a0,-20(s0)
 3002e58:	feb42423          	sw	a1,-24(s0)
    switch (units) {
 3002e5c:	fe842783          	lw	a5,-24(s0)
 3002e60:	3e800713          	li	a4,1000
 3002e64:	02e78063          	beq	a5,a4,3002e84 <BASE_FUNC_Delay+0x38>
 3002e68:	000f4737          	lui	a4,0xf4
 3002e6c:	24070713          	addi	a4,a4,576 # f4240 <FLASH_SIZE+0xd4244>
 3002e70:	00e78e63          	beq	a5,a4,3002e8c <BASE_FUNC_Delay+0x40>
 3002e74:	4705                	li	a4,1
 3002e76:	00e78363          	beq	a5,a4,3002e7c <BASE_FUNC_Delay+0x30>
            break;
        case BASE_DEFINE_DELAY_MICROSECS:
            BASE_FUNC_DelayUs(delay);
            break;
        default:
            break;
 3002e7a:	a829                	j	3002e94 <BASE_FUNC_Delay+0x48>
            BASE_FUNC_DelaySeconds(delay);
 3002e7c:	fec42503          	lw	a0,-20(s0)
 3002e80:	3f51                	jal	ra,3002e14 <BASE_FUNC_DelaySeconds>
            break;
 3002e82:	a809                	j	3002e94 <BASE_FUNC_Delay+0x48>
            BASE_FUNC_DelayMs(delay);
 3002e84:	fec42503          	lw	a0,-20(s0)
 3002e88:	3f91                	jal	ra,3002ddc <BASE_FUNC_DelayMs>
            break;
 3002e8a:	a029                	j	3002e94 <BASE_FUNC_Delay+0x48>
            BASE_FUNC_DelayUs(delay);
 3002e8c:	fec42503          	lw	a0,-20(s0)
 3002e90:	3dc5                	jal	ra,3002d80 <BASE_FUNC_DelayUs>
            break;
 3002e92:	0001                	nop
    }
    return;
 3002e94:	0001                	nop
 3002e96:	40f2                	lw	ra,28(sp)
 3002e98:	4462                	lw	s0,24(sp)
 3002e9a:	6105                	addi	sp,sp,32
 3002e9c:	8082                	ret

03002e9e <IRQ_ClearN>:
  * @brief  Clear external interrupt
  * @param irqNum external interrupt number
  * @retval BASE_STATUS_OK or IRQ_ERRNO_NUM_INVALID or IRQ_ERRNO_NOT_CREATED
  */
static inline void IRQ_ClearN(unsigned int irqNum)
{
 3002e9e:	1101                	addi	sp,sp,-32
 3002ea0:	ce22                	sw	s0,28(sp)
 3002ea2:	1000                	addi	s0,sp,32
 3002ea4:	fea42623          	sw	a0,-20(s0)
    asm volatile("fence");
 3002ea8:	0ff0000f          	fence
    WRITE_CUSTOM_CSR_VAL(LOCIPCLR, irqNum);
 3002eac:	fec42783          	lw	a5,-20(s0)
 3002eb0:	82be                	mv	t0,a5
 3002eb2:	bf029073          	csrw	0xbf0,t0
}
 3002eb6:	0001                	nop
 3002eb8:	4472                	lw	s0,28(sp)
 3002eba:	6105                	addi	sp,sp,32
 3002ebc:	8082                	ret

03002ebe <InterruptEntry>:
  * @brief Exception/Interrupt Handler Entry.
  * @param irqNum external interrupt number.
  * @retval None
  */
void InterruptEntry(unsigned int irqNum)
{
 3002ebe:	1101                	addi	sp,sp,-32
 3002ec0:	ce06                	sw	ra,28(sp)
 3002ec2:	cc22                	sw	s0,24(sp)
 3002ec4:	1000                	addi	s0,sp,32
 3002ec6:	fea42623          	sw	a0,-20(s0)
    g_irqCallbackFunc[irqNum].pfnHandler(g_irqCallbackFunc[irqNum].param);
 3002eca:	040007b7          	lui	a5,0x4000
 3002ece:	18878713          	addi	a4,a5,392 # 4000188 <g_irqCallbackFunc>
 3002ed2:	fec42783          	lw	a5,-20(s0)
 3002ed6:	078e                	slli	a5,a5,0x3
 3002ed8:	97ba                	add	a5,a5,a4
 3002eda:	4394                	lw	a3,0(a5)
 3002edc:	040007b7          	lui	a5,0x4000
 3002ee0:	18878713          	addi	a4,a5,392 # 4000188 <g_irqCallbackFunc>
 3002ee4:	fec42783          	lw	a5,-20(s0)
 3002ee8:	078e                	slli	a5,a5,0x3
 3002eea:	97ba                	add	a5,a5,a4
 3002eec:	43dc                	lw	a5,4(a5)
 3002eee:	853e                	mv	a0,a5
 3002ef0:	9682                	jalr	a3
    IRQ_ClearN(irqNum);
 3002ef2:	fec42503          	lw	a0,-20(s0)
 3002ef6:	3765                	jal	ra,3002e9e <IRQ_ClearN>
}
 3002ef8:	0001                	nop
 3002efa:	40f2                	lw	ra,28(sp)
 3002efc:	4462                	lw	s0,24(sp)
 3002efe:	6105                	addi	sp,sp,32
 3002f00:	8082                	ret

03002f02 <IRQ_Init>:
  * @brief Irq initialization.
  * @param none.
  * @retval None
  */
void IRQ_Init(void)
{
 3002f02:	1101                	addi	sp,sp,-32
 3002f04:	ce22                	sw	s0,28(sp)
 3002f06:	1000                	addi	s0,sp,32
    unsigned int index;

    for (index = 0; index < IRQ_MAX; index++) {
 3002f08:	fe042623          	sw	zero,-20(s0)
 3002f0c:	a82d                	j	3002f46 <IRQ_Init+0x44>
        g_irqCallbackFunc[index].pfnHandler = IRQ_DummyHandler;
 3002f0e:	040007b7          	lui	a5,0x4000
 3002f12:	18878713          	addi	a4,a5,392 # 4000188 <g_irqCallbackFunc>
 3002f16:	fec42783          	lw	a5,-20(s0)
 3002f1a:	078e                	slli	a5,a5,0x3
 3002f1c:	97ba                	add	a5,a5,a4
 3002f1e:	03003737          	lui	a4,0x3003
 3002f22:	7ec70713          	addi	a4,a4,2028 # 30037ec <IRQ_DummyHandler>
 3002f26:	c398                	sw	a4,0(a5)
        g_irqCallbackFunc[index].param = NULL;
 3002f28:	040007b7          	lui	a5,0x4000
 3002f2c:	18878713          	addi	a4,a5,392 # 4000188 <g_irqCallbackFunc>
 3002f30:	fec42783          	lw	a5,-20(s0)
 3002f34:	078e                	slli	a5,a5,0x3
 3002f36:	97ba                	add	a5,a5,a4
 3002f38:	0007a223          	sw	zero,4(a5)
    for (index = 0; index < IRQ_MAX; index++) {
 3002f3c:	fec42783          	lw	a5,-20(s0)
 3002f40:	0785                	addi	a5,a5,1
 3002f42:	fef42623          	sw	a5,-20(s0)
 3002f46:	fec42703          	lw	a4,-20(s0)
 3002f4a:	07200793          	li	a5,114
 3002f4e:	fce7f0e3          	bgeu	a5,a4,3002f0e <IRQ_Init+0xc>
    }
}
 3002f52:	0001                	nop
 3002f54:	4472                	lw	s0,28(sp)
 3002f56:	6105                	addi	sp,sp,32
 3002f58:	8082                	ret

03002f5a <IRQ_Register>:
  * @note    In the corresponding interrupt handler, manually clear the interrupt source and the corresponding interrupt
  *          flag bit (call the IRQ_ClearN function to clear the interrupt), otherwise the interrupt will always be
  *          triggered.
  */
unsigned int IRQ_Register(unsigned int irqNum, IRQ_PROC_FUNC func, void *arg)
{
 3002f5a:	1101                	addi	sp,sp,-32
 3002f5c:	ce06                	sw	ra,28(sp)
 3002f5e:	cc22                	sw	s0,24(sp)
 3002f60:	1000                	addi	s0,sp,32
 3002f62:	fea42623          	sw	a0,-20(s0)
 3002f66:	feb42423          	sw	a1,-24(s0)
 3002f6a:	fec42223          	sw	a2,-28(s0)
    INTERRUPT_ASSERT_PARAM(func != NULL);
 3002f6e:	fe842783          	lw	a5,-24(s0)
 3002f72:	eb89                	bnez	a5,3002f84 <IRQ_Register+0x2a>
 3002f74:	06300593          	li	a1,99
 3002f78:	030107b7          	lui	a5,0x3010
 3002f7c:	7bc78513          	addi	a0,a5,1980 # 30107bc <g_crgIpMatch+0x2ac>
 3002f80:	3b7d                	jal	ra,3002d3e <AssertErrorLog>
 3002f82:	a001                	j	3002f82 <IRQ_Register+0x28>
    INTERRUPT_PARAM_CHECK_WITH_RET(irqNum < IRQ_MAX, IRQ_ERRNO_NUM_INVALID);
 3002f84:	fec42703          	lw	a4,-20(s0)
 3002f88:	07200793          	li	a5,114
 3002f8c:	00e7fb63          	bgeu	a5,a4,3002fa2 <IRQ_Register+0x48>
 3002f90:	06400593          	li	a1,100
 3002f94:	030107b7          	lui	a5,0x3010
 3002f98:	7bc78513          	addi	a0,a5,1980 # 30107bc <g_crgIpMatch+0x2ac>
 3002f9c:	334d                	jal	ra,3002d3e <AssertErrorLog>
 3002f9e:	4789                	li	a5,2
 3002fa0:	a81d                	j	3002fd6 <IRQ_Register+0x7c>

    if (g_irqCallbackFunc[irqNum].pfnHandler != IRQ_DummyHandler) {
 3002fa2:	040007b7          	lui	a5,0x4000
 3002fa6:	18878713          	addi	a4,a5,392 # 4000188 <g_irqCallbackFunc>
 3002faa:	fec42783          	lw	a5,-20(s0)
 3002fae:	078e                	slli	a5,a5,0x3
 3002fb0:	97ba                	add	a5,a5,a4
 3002fb2:	4398                	lw	a4,0(a5)
 3002fb4:	030037b7          	lui	a5,0x3003
 3002fb8:	7ec78793          	addi	a5,a5,2028 # 30037ec <IRQ_DummyHandler>
 3002fbc:	00f70463          	beq	a4,a5,3002fc4 <IRQ_Register+0x6a>
        return IRQ_ERRNO_ALREADY_CREATED;
 3002fc0:	478d                	li	a5,3
 3002fc2:	a811                	j	3002fd6 <IRQ_Register+0x7c>
    }
    IRQ_SetCallBack(irqNum, func, arg);
 3002fc4:	fe442603          	lw	a2,-28(s0)
 3002fc8:	fe842583          	lw	a1,-24(s0)
 3002fcc:	fec42503          	lw	a0,-20(s0)
 3002fd0:	02f000ef          	jal	ra,30037fe <IRQ_SetCallBack>
    return BASE_STATUS_OK;
 3002fd4:	4781                	li	a5,0
}
 3002fd6:	853e                	mv	a0,a5
 3002fd8:	40f2                	lw	ra,28(sp)
 3002fda:	4462                	lw	s0,24(sp)
 3002fdc:	6105                	addi	sp,sp,32
 3002fde:	8082                	ret

03002fe0 <IRQ_EnableN>:
  * @brief Enable the specified interrupt.
  * @param irqNum  External interrupt number.
  * @retval BASE_STATUS_OK or IRQ_ERRNO_NUM_INVALID.
  */
unsigned int IRQ_EnableN(unsigned int irqNum)
{
 3002fe0:	7139                	addi	sp,sp,-64
 3002fe2:	de06                	sw	ra,60(sp)
 3002fe4:	dc22                	sw	s0,56(sp)
 3002fe6:	0080                	addi	s0,sp,64
 3002fe8:	fca42623          	sw	a0,-52(s0)
    unsigned int irqOrder;
    unsigned int locienVal;
#if defined(USER_MODE_ENABLE) && (USER_MODE_ENABLE == 1)
    unsigned int priv = IRQ_GetCpuPrivilege();
 3002fec:	059000ef          	jal	ra,3003844 <IRQ_GetCpuPrivilege>
 3002ff0:	fea42623          	sw	a0,-20(s0)
#endif

    INTERRUPT_PARAM_CHECK_WITH_RET((irqNum >= IRQ_VECTOR_CNT && irqNum < IRQ_MAX), IRQ_ERRNO_NUM_INVALID);
 3002ff4:	fcc42703          	lw	a4,-52(s0)
 3002ff8:	47e5                	li	a5,25
 3002ffa:	00e7f863          	bgeu	a5,a4,300300a <IRQ_EnableN+0x2a>
 3002ffe:	fcc42703          	lw	a4,-52(s0)
 3003002:	07200793          	li	a5,114
 3003006:	00e7fb63          	bgeu	a5,a4,300301c <IRQ_EnableN+0x3c>
 300300a:	0c300593          	li	a1,195
 300300e:	030107b7          	lui	a5,0x3010
 3003012:	7bc78513          	addi	a0,a5,1980 # 30107bc <g_crgIpMatch+0x2ac>
 3003016:	3325                	jal	ra,3002d3e <AssertErrorLog>
 3003018:	4789                	li	a5,2
 300301a:	a239                	j	3003128 <IRQ_EnableN+0x148>

    /* The interrupt enable bits that can be controlled in the mie register (32 bits), up to 32
       can be controlled, and each bit corresponds to an interrupt enable */

    RISCV_PRIV_MODE_SWITCH(priv);
 300301c:	fec42703          	lw	a4,-20(s0)
 3003020:	47a1                	li	a5,8
 3003022:	00f71463          	bne	a4,a5,300302a <IRQ_EnableN+0x4a>
 3003026:	00000073          	ecall

    if (irqNum < IRQ_MIE_TOTAL_CNT) {
 300302a:	fcc42703          	lw	a4,-52(s0)
 300302e:	47fd                	li	a5,31
 3003030:	02e7e063          	bltu	a5,a4,3003050 <IRQ_EnableN+0x70>
        irqOrder = 1U << irqNum;
 3003034:	4705                	li	a4,1
 3003036:	fcc42783          	lw	a5,-52(s0)
 300303a:	00f717b3          	sll	a5,a4,a5
 300303e:	fef42423          	sw	a5,-24(s0)
        SET_CSR(mie, irqOrder);
 3003042:	fe842783          	lw	a5,-24(s0)
 3003046:	3047a7f3          	csrrs	a5,mie,a5
 300304a:	fcf42a23          	sw	a5,-44(s0)
 300304e:	a0e9                	j	3003118 <IRQ_EnableN+0x138>
    } else if (irqNum < IRQ_LOCIEN1_OFFSET) {
 3003050:	fcc42703          	lw	a4,-52(s0)
 3003054:	03f00793          	li	a5,63
 3003058:	02e7ef63          	bltu	a5,a4,3003096 <IRQ_EnableN+0xb6>
        irqOrder = irqNum - IRQ_MIE_TOTAL_CNT;
 300305c:	fcc42783          	lw	a5,-52(s0)
 3003060:	1781                	addi	a5,a5,-32
 3003062:	fef42423          	sw	a5,-24(s0)
        locienVal = READ_CUSTOM_CSR(LOCIEN0);
 3003066:	be0027f3          	csrr	a5,0xbe0
 300306a:	fcf42c23          	sw	a5,-40(s0)
 300306e:	fd842783          	lw	a5,-40(s0)
 3003072:	fef42023          	sw	a5,-32(s0)
        locienVal |= (1U << irqOrder);
 3003076:	4705                	li	a4,1
 3003078:	fe842783          	lw	a5,-24(s0)
 300307c:	00f717b3          	sll	a5,a4,a5
 3003080:	fe042703          	lw	a4,-32(s0)
 3003084:	8fd9                	or	a5,a5,a4
 3003086:	fef42023          	sw	a5,-32(s0)
        WRITE_CUSTOM_CSR_VAL(LOCIEN0, locienVal);
 300308a:	fe042783          	lw	a5,-32(s0)
 300308e:	82be                	mv	t0,a5
 3003090:	be029073          	csrw	0xbe0,t0
 3003094:	a051                	j	3003118 <IRQ_EnableN+0x138>
    } else if (irqNum < IRQ_LOCIEN2_OFFSET) {
 3003096:	fcc42703          	lw	a4,-52(s0)
 300309a:	05f00793          	li	a5,95
 300309e:	04e7e063          	bltu	a5,a4,30030de <IRQ_EnableN+0xfe>
        irqOrder = irqNum - IRQ_LOCIEN1_OFFSET;
 30030a2:	fcc42783          	lw	a5,-52(s0)
 30030a6:	fc078793          	addi	a5,a5,-64
 30030aa:	fef42423          	sw	a5,-24(s0)
        locienVal = READ_CUSTOM_CSR(LOCIEN1);
 30030ae:	be1027f3          	csrr	a5,0xbe1
 30030b2:	fcf42e23          	sw	a5,-36(s0)
 30030b6:	fdc42783          	lw	a5,-36(s0)
 30030ba:	fef42023          	sw	a5,-32(s0)
        locienVal |= (1U << irqOrder);
 30030be:	4705                	li	a4,1
 30030c0:	fe842783          	lw	a5,-24(s0)
 30030c4:	00f717b3          	sll	a5,a4,a5
 30030c8:	fe042703          	lw	a4,-32(s0)
 30030cc:	8fd9                	or	a5,a5,a4
 30030ce:	fef42023          	sw	a5,-32(s0)
        WRITE_CUSTOM_CSR_VAL(LOCIEN1, locienVal);
 30030d2:	fe042783          	lw	a5,-32(s0)
 30030d6:	82be                	mv	t0,a5
 30030d8:	be129073          	csrw	0xbe1,t0
 30030dc:	a835                	j	3003118 <IRQ_EnableN+0x138>
    } else {
        irqOrder = irqNum - IRQ_LOCIEN2_OFFSET;
 30030de:	fcc42783          	lw	a5,-52(s0)
 30030e2:	fa078793          	addi	a5,a5,-96
 30030e6:	fef42423          	sw	a5,-24(s0)
        locienVal = READ_CUSTOM_CSR(LOCIEN2);
 30030ea:	be2027f3          	csrr	a5,0xbe2
 30030ee:	fef42223          	sw	a5,-28(s0)
 30030f2:	fe442783          	lw	a5,-28(s0)
 30030f6:	fef42023          	sw	a5,-32(s0)
        locienVal |= (1U << irqOrder);
 30030fa:	4705                	li	a4,1
 30030fc:	fe842783          	lw	a5,-24(s0)
 3003100:	00f717b3          	sll	a5,a4,a5
 3003104:	fe042703          	lw	a4,-32(s0)
 3003108:	8fd9                	or	a5,a5,a4
 300310a:	fef42023          	sw	a5,-32(s0)
        WRITE_CUSTOM_CSR_VAL(LOCIEN2, locienVal);
 300310e:	fe042783          	lw	a5,-32(s0)
 3003112:	82be                	mv	t0,a5
 3003114:	be229073          	csrw	0xbe2,t0
    }

    RISCV_PRIV_MODE_SWITCH(priv);
 3003118:	fec42703          	lw	a4,-20(s0)
 300311c:	47a1                	li	a5,8
 300311e:	00f71463          	bne	a4,a5,3003126 <IRQ_EnableN+0x146>
 3003122:	00000073          	ecall

    return BASE_STATUS_OK;
 3003126:	4781                	li	a5,0
}
 3003128:	853e                	mv	a0,a5
 300312a:	50f2                	lw	ra,60(sp)
 300312c:	5462                	lw	s0,56(sp)
 300312e:	6121                	addi	sp,sp,64
 3003130:	8082                	ret

03003132 <SysErrPrint>:
  * @param context.
  * @note  The actual code is generated by IDE
  * @retval None.
  */
__weak void SysErrPrint(const SyserrContext *context)
{
 3003132:	1101                	addi	sp,sp,-32
 3003134:	ce22                	sw	s0,28(sp)
 3003136:	1000                	addi	s0,sp,32
 3003138:	fea42623          	sw	a0,-20(s0)
    BASE_FUNC_UNUSED(context);
}
 300313c:	0001                	nop
 300313e:	4472                	lw	s0,28(sp)
 3003140:	6105                	addi	sp,sp,32
 3003142:	8082                	ret

03003144 <SysErrFinish>:
  * @brief System error completion processing
  * @param None.
  * @retval None.
  */
static void SysErrFinish(void)
{
 3003144:	1141                	addi	sp,sp,-16
 3003146:	c622                	sw	s0,12(sp)
 3003148:	0800                	addi	s0,sp,16
}
 300314a:	0001                	nop
 300314c:	4432                	lw	s0,12(sp)
 300314e:	0141                	addi	sp,sp,16
 3003150:	8082                	ret

03003152 <SysErrExcEntry>:
  * @brief Exception Handler Entry.
  * @param context error context.
  * @retval None.
  */
void SysErrExcEntry(const SyserrContext *context)
{
 3003152:	1101                	addi	sp,sp,-32
 3003154:	ce06                	sw	ra,28(sp)
 3003156:	cc22                	sw	s0,24(sp)
 3003158:	1000                	addi	s0,sp,32
 300315a:	fea42623          	sw	a0,-20(s0)
    SysErrPrint(context);
 300315e:	fec42503          	lw	a0,-20(s0)
 3003162:	3fc1                	jal	ra,3003132 <SysErrPrint>
    SysErrFinish();
 3003164:	37c5                	jal	ra,3003144 <SysErrFinish>
}
 3003166:	0001                	nop
 3003168:	40f2                	lw	ra,28(sp)
 300316a:	4462                	lw	s0,24(sp)
 300316c:	6105                	addi	sp,sp,32
 300316e:	8082                	ret

03003170 <SysErrNmiEntry>:
  * @brief NMI Interrupt Handler Entry.
  * @param context error context.
  * @retval None.
  */
void SysErrNmiEntry(const SyserrContext *context)
{
 3003170:	1101                	addi	sp,sp,-32
 3003172:	ce06                	sw	ra,28(sp)
 3003174:	cc22                	sw	s0,24(sp)
 3003176:	1000                	addi	s0,sp,32
 3003178:	fea42623          	sw	a0,-20(s0)
    INTERRUPT_ASSERT_PARAM(context != NULL);
 300317c:	fec42783          	lw	a5,-20(s0)
 3003180:	eb89                	bnez	a5,3003192 <SysErrNmiEntry+0x22>
 3003182:	12d00593          	li	a1,301
 3003186:	030107b7          	lui	a5,0x3010
 300318a:	7bc78513          	addi	a0,a5,1980 # 30107bc <g_crgIpMatch+0x2ac>
 300318e:	3e45                	jal	ra,3002d3e <AssertErrorLog>
 3003190:	a001                	j	3003190 <SysErrNmiEntry+0x20>
    SysErrPrint(context);
 3003192:	fec42503          	lw	a0,-20(s0)
 3003196:	3f71                	jal	ra,3003132 <SysErrPrint>
    SysErrFinish();
 3003198:	3775                	jal	ra,3003144 <SysErrFinish>
}
 300319a:	0001                	nop
 300319c:	40f2                	lw	ra,28(sp)
 300319e:	4462                	lw	s0,24(sp)
 30031a0:	6105                	addi	sp,sp,32
 30031a2:	8082                	ret

030031a4 <SetLocalIntNumPri>:
  * @param interPriNum Local interrupt number, which equals external interrupt number - IRQ_VECTOR_CN.
  * @param prior local int prioroty.
  * @retval None
  */
static void SetLocalIntNumPri(unsigned int intNum, unsigned int interPriNum, unsigned int prior)
{
 30031a4:	711d                	addi	sp,sp,-96
 30031a6:	cea2                	sw	s0,92(sp)
 30031a8:	1080                	addi	s0,sp,96
 30031aa:	faa42623          	sw	a0,-84(s0)
 30031ae:	fab42423          	sw	a1,-88(s0)
 30031b2:	fac42223          	sw	a2,-92(s0)
    switch (intNum) {
 30031b6:	fac42783          	lw	a5,-84(s0)
 30031ba:	17e1                	addi	a5,a5,-8
 30031bc:	471d                	li	a4,7
 30031be:	2af76363          	bltu	a4,a5,3003464 <SetLocalIntNumPri+0x2c0>
 30031c2:	00279713          	slli	a4,a5,0x2
 30031c6:	030107b7          	lui	a5,0x3010
 30031ca:	7dc78793          	addi	a5,a5,2012 # 30107dc <g_crgIpMatch+0x2cc>
 30031ce:	97ba                	add	a5,a5,a4
 30031d0:	439c                	lw	a5,0(a5)
 30031d2:	8782                	jr	a5
        case 8:  /* GROUP8 */
            SET_LOCAL_INTER_NUM_PRI(8, interPriNum, prior);
 30031d4:	bc8027f3          	csrr	a5,0xbc8
 30031d8:	faf42a23          	sw	a5,-76(s0)
 30031dc:	fb442783          	lw	a5,-76(s0)
 30031e0:	faf42823          	sw	a5,-80(s0)
 30031e4:	fa842783          	lw	a5,-88(s0)
 30031e8:	078a                	slli	a5,a5,0x2
 30031ea:	8bf1                	andi	a5,a5,28
 30031ec:	473d                	li	a4,15
 30031ee:	00f717b3          	sll	a5,a4,a5
 30031f2:	fff7c793          	not	a5,a5
 30031f6:	fb042703          	lw	a4,-80(s0)
 30031fa:	8ff9                	and	a5,a5,a4
 30031fc:	faf42823          	sw	a5,-80(s0)
 3003200:	fa842783          	lw	a5,-88(s0)
 3003204:	078a                	slli	a5,a5,0x2
 3003206:	8bf1                	andi	a5,a5,28
 3003208:	fa442703          	lw	a4,-92(s0)
 300320c:	00f717b3          	sll	a5,a4,a5
 3003210:	fb042703          	lw	a4,-80(s0)
 3003214:	8fd9                	or	a5,a5,a4
 3003216:	faf42823          	sw	a5,-80(s0)
 300321a:	fb042783          	lw	a5,-80(s0)
 300321e:	82be                	mv	t0,a5
 3003220:	bc829073          	csrw	0xbc8,t0
            break;
 3003224:	a489                	j	3003466 <SetLocalIntNumPri+0x2c2>
        case 9:  /* GROUP9 */
            SET_LOCAL_INTER_NUM_PRI(9, interPriNum, prior);
 3003226:	bc9027f3          	csrr	a5,0xbc9
 300322a:	faf42e23          	sw	a5,-68(s0)
 300322e:	fbc42783          	lw	a5,-68(s0)
 3003232:	faf42c23          	sw	a5,-72(s0)
 3003236:	fa842783          	lw	a5,-88(s0)
 300323a:	078a                	slli	a5,a5,0x2
 300323c:	8bf1                	andi	a5,a5,28
 300323e:	473d                	li	a4,15
 3003240:	00f717b3          	sll	a5,a4,a5
 3003244:	fff7c793          	not	a5,a5
 3003248:	fb842703          	lw	a4,-72(s0)
 300324c:	8ff9                	and	a5,a5,a4
 300324e:	faf42c23          	sw	a5,-72(s0)
 3003252:	fa842783          	lw	a5,-88(s0)
 3003256:	078a                	slli	a5,a5,0x2
 3003258:	8bf1                	andi	a5,a5,28
 300325a:	fa442703          	lw	a4,-92(s0)
 300325e:	00f717b3          	sll	a5,a4,a5
 3003262:	fb842703          	lw	a4,-72(s0)
 3003266:	8fd9                	or	a5,a5,a4
 3003268:	faf42c23          	sw	a5,-72(s0)
 300326c:	fb842783          	lw	a5,-72(s0)
 3003270:	82be                	mv	t0,a5
 3003272:	bc929073          	csrw	0xbc9,t0
            break;
 3003276:	aac5                	j	3003466 <SetLocalIntNumPri+0x2c2>
        case 10:  /* GROUP10 */
            SET_LOCAL_INTER_NUM_PRI(10, interPriNum, prior);
 3003278:	bca027f3          	csrr	a5,0xbca
 300327c:	fcf42223          	sw	a5,-60(s0)
 3003280:	fc442783          	lw	a5,-60(s0)
 3003284:	fcf42023          	sw	a5,-64(s0)
 3003288:	fa842783          	lw	a5,-88(s0)
 300328c:	078a                	slli	a5,a5,0x2
 300328e:	8bf1                	andi	a5,a5,28
 3003290:	473d                	li	a4,15
 3003292:	00f717b3          	sll	a5,a4,a5
 3003296:	fff7c793          	not	a5,a5
 300329a:	fc042703          	lw	a4,-64(s0)
 300329e:	8ff9                	and	a5,a5,a4
 30032a0:	fcf42023          	sw	a5,-64(s0)
 30032a4:	fa842783          	lw	a5,-88(s0)
 30032a8:	078a                	slli	a5,a5,0x2
 30032aa:	8bf1                	andi	a5,a5,28
 30032ac:	fa442703          	lw	a4,-92(s0)
 30032b0:	00f717b3          	sll	a5,a4,a5
 30032b4:	fc042703          	lw	a4,-64(s0)
 30032b8:	8fd9                	or	a5,a5,a4
 30032ba:	fcf42023          	sw	a5,-64(s0)
 30032be:	fc042783          	lw	a5,-64(s0)
 30032c2:	82be                	mv	t0,a5
 30032c4:	bca29073          	csrw	0xbca,t0
            break;
 30032c8:	aa79                	j	3003466 <SetLocalIntNumPri+0x2c2>
        case 11:  /* GROUP11 */
            SET_LOCAL_INTER_NUM_PRI(11, interPriNum, prior);
 30032ca:	bcb027f3          	csrr	a5,0xbcb
 30032ce:	fcf42623          	sw	a5,-52(s0)
 30032d2:	fcc42783          	lw	a5,-52(s0)
 30032d6:	fcf42423          	sw	a5,-56(s0)
 30032da:	fa842783          	lw	a5,-88(s0)
 30032de:	078a                	slli	a5,a5,0x2
 30032e0:	8bf1                	andi	a5,a5,28
 30032e2:	473d                	li	a4,15
 30032e4:	00f717b3          	sll	a5,a4,a5
 30032e8:	fff7c793          	not	a5,a5
 30032ec:	fc842703          	lw	a4,-56(s0)
 30032f0:	8ff9                	and	a5,a5,a4
 30032f2:	fcf42423          	sw	a5,-56(s0)
 30032f6:	fa842783          	lw	a5,-88(s0)
 30032fa:	078a                	slli	a5,a5,0x2
 30032fc:	8bf1                	andi	a5,a5,28
 30032fe:	fa442703          	lw	a4,-92(s0)
 3003302:	00f717b3          	sll	a5,a4,a5
 3003306:	fc842703          	lw	a4,-56(s0)
 300330a:	8fd9                	or	a5,a5,a4
 300330c:	fcf42423          	sw	a5,-56(s0)
 3003310:	fc842783          	lw	a5,-56(s0)
 3003314:	82be                	mv	t0,a5
 3003316:	bcb29073          	csrw	0xbcb,t0
            break;
 300331a:	a2b1                	j	3003466 <SetLocalIntNumPri+0x2c2>
        case 12:  /* GROUP12 */
            SET_LOCAL_INTER_NUM_PRI(12, interPriNum, prior);
 300331c:	bcc027f3          	csrr	a5,0xbcc
 3003320:	fcf42a23          	sw	a5,-44(s0)
 3003324:	fd442783          	lw	a5,-44(s0)
 3003328:	fcf42823          	sw	a5,-48(s0)
 300332c:	fa842783          	lw	a5,-88(s0)
 3003330:	078a                	slli	a5,a5,0x2
 3003332:	8bf1                	andi	a5,a5,28
 3003334:	473d                	li	a4,15
 3003336:	00f717b3          	sll	a5,a4,a5
 300333a:	fff7c793          	not	a5,a5
 300333e:	fd042703          	lw	a4,-48(s0)
 3003342:	8ff9                	and	a5,a5,a4
 3003344:	fcf42823          	sw	a5,-48(s0)
 3003348:	fa842783          	lw	a5,-88(s0)
 300334c:	078a                	slli	a5,a5,0x2
 300334e:	8bf1                	andi	a5,a5,28
 3003350:	fa442703          	lw	a4,-92(s0)
 3003354:	00f717b3          	sll	a5,a4,a5
 3003358:	fd042703          	lw	a4,-48(s0)
 300335c:	8fd9                	or	a5,a5,a4
 300335e:	fcf42823          	sw	a5,-48(s0)
 3003362:	fd042783          	lw	a5,-48(s0)
 3003366:	82be                	mv	t0,a5
 3003368:	bcc29073          	csrw	0xbcc,t0
            break;
 300336c:	a8ed                	j	3003466 <SetLocalIntNumPri+0x2c2>
        case 13:  /* GROUP13 */
            SET_LOCAL_INTER_NUM_PRI(13, interPriNum, prior);
 300336e:	bcd027f3          	csrr	a5,0xbcd
 3003372:	fcf42e23          	sw	a5,-36(s0)
 3003376:	fdc42783          	lw	a5,-36(s0)
 300337a:	fcf42c23          	sw	a5,-40(s0)
 300337e:	fa842783          	lw	a5,-88(s0)
 3003382:	078a                	slli	a5,a5,0x2
 3003384:	8bf1                	andi	a5,a5,28
 3003386:	473d                	li	a4,15
 3003388:	00f717b3          	sll	a5,a4,a5
 300338c:	fff7c793          	not	a5,a5
 3003390:	fd842703          	lw	a4,-40(s0)
 3003394:	8ff9                	and	a5,a5,a4
 3003396:	fcf42c23          	sw	a5,-40(s0)
 300339a:	fa842783          	lw	a5,-88(s0)
 300339e:	078a                	slli	a5,a5,0x2
 30033a0:	8bf1                	andi	a5,a5,28
 30033a2:	fa442703          	lw	a4,-92(s0)
 30033a6:	00f717b3          	sll	a5,a4,a5
 30033aa:	fd842703          	lw	a4,-40(s0)
 30033ae:	8fd9                	or	a5,a5,a4
 30033b0:	fcf42c23          	sw	a5,-40(s0)
 30033b4:	fd842783          	lw	a5,-40(s0)
 30033b8:	82be                	mv	t0,a5
 30033ba:	bcd29073          	csrw	0xbcd,t0
            break;
 30033be:	a065                	j	3003466 <SetLocalIntNumPri+0x2c2>
        case 14:  /* GROUP14 */
            SET_LOCAL_INTER_NUM_PRI(14, interPriNum, prior);
 30033c0:	bce027f3          	csrr	a5,0xbce
 30033c4:	fef42223          	sw	a5,-28(s0)
 30033c8:	fe442783          	lw	a5,-28(s0)
 30033cc:	fef42023          	sw	a5,-32(s0)
 30033d0:	fa842783          	lw	a5,-88(s0)
 30033d4:	078a                	slli	a5,a5,0x2
 30033d6:	8bf1                	andi	a5,a5,28
 30033d8:	473d                	li	a4,15
 30033da:	00f717b3          	sll	a5,a4,a5
 30033de:	fff7c793          	not	a5,a5
 30033e2:	fe042703          	lw	a4,-32(s0)
 30033e6:	8ff9                	and	a5,a5,a4
 30033e8:	fef42023          	sw	a5,-32(s0)
 30033ec:	fa842783          	lw	a5,-88(s0)
 30033f0:	078a                	slli	a5,a5,0x2
 30033f2:	8bf1                	andi	a5,a5,28
 30033f4:	fa442703          	lw	a4,-92(s0)
 30033f8:	00f717b3          	sll	a5,a4,a5
 30033fc:	fe042703          	lw	a4,-32(s0)
 3003400:	8fd9                	or	a5,a5,a4
 3003402:	fef42023          	sw	a5,-32(s0)
 3003406:	fe042783          	lw	a5,-32(s0)
 300340a:	82be                	mv	t0,a5
 300340c:	bce29073          	csrw	0xbce,t0
            break;
 3003410:	a899                	j	3003466 <SetLocalIntNumPri+0x2c2>
        case 15:  /* GROUP15 */
            SET_LOCAL_INTER_NUM_PRI(15, interPriNum, prior);
 3003412:	bcf027f3          	csrr	a5,0xbcf
 3003416:	fef42623          	sw	a5,-20(s0)
 300341a:	fec42783          	lw	a5,-20(s0)
 300341e:	fef42423          	sw	a5,-24(s0)
 3003422:	fa842783          	lw	a5,-88(s0)
 3003426:	078a                	slli	a5,a5,0x2
 3003428:	8bf1                	andi	a5,a5,28
 300342a:	473d                	li	a4,15
 300342c:	00f717b3          	sll	a5,a4,a5
 3003430:	fff7c793          	not	a5,a5
 3003434:	fe842703          	lw	a4,-24(s0)
 3003438:	8ff9                	and	a5,a5,a4
 300343a:	fef42423          	sw	a5,-24(s0)
 300343e:	fa842783          	lw	a5,-88(s0)
 3003442:	078a                	slli	a5,a5,0x2
 3003444:	8bf1                	andi	a5,a5,28
 3003446:	fa442703          	lw	a4,-92(s0)
 300344a:	00f717b3          	sll	a5,a4,a5
 300344e:	fe842703          	lw	a4,-24(s0)
 3003452:	8fd9                	or	a5,a5,a4
 3003454:	fef42423          	sw	a5,-24(s0)
 3003458:	fe842783          	lw	a5,-24(s0)
 300345c:	82be                	mv	t0,a5
 300345e:	bcf29073          	csrw	0xbcf,t0
            break;
 3003462:	a011                	j	3003466 <SetLocalIntNumPri+0x2c2>
        default:
            break;
 3003464:	0001                	nop
    }
}
 3003466:	0001                	nop
 3003468:	4476                	lw	s0,92(sp)
 300346a:	6125                	addi	sp,sp,96
 300346c:	8082                	ret

0300346e <IRQ_SetLocalPriority>:
  * @param interPriNum Local interrupt number, which equals external interrupt number - IRQ_VECTOR_CN.
  * @param prior       Priority of this local interrupt to be set.
  * @retval None.
  */
static void IRQ_SetLocalPriority(unsigned int interPriNum, unsigned int prior)
{
 300346e:	7159                	addi	sp,sp,-112
 3003470:	d686                	sw	ra,108(sp)
 3003472:	d4a2                	sw	s0,104(sp)
 3003474:	1880                	addi	s0,sp,112
 3003476:	f8a42e23          	sw	a0,-100(s0)
 300347a:	f8b42c23          	sw	a1,-104(s0)
#if defined(USER_MODE_ENABLE) && (USER_MODE_ENABLE == 1)
    unsigned int priv = IRQ_GetCpuPrivilege();
 300347e:	26d9                	jal	ra,3003844 <IRQ_GetCpuPrivilege>
 3003480:	fea42623          	sw	a0,-20(s0)
#endif
    RISCV_PRIV_MODE_SWITCH(priv);
 3003484:	fec42703          	lw	a4,-20(s0)
 3003488:	47a1                	li	a5,8
 300348a:	00f71463          	bne	a4,a5,3003492 <IRQ_SetLocalPriority+0x24>
 300348e:	00000073          	ecall
    unsigned int intNum = GET_LOCAL_INTER_CONFIGREG_NUM(interPriNum);
 3003492:	f9c42783          	lw	a5,-100(s0)
 3003496:	838d                	srli	a5,a5,0x3
 3003498:	fef42423          	sw	a5,-24(s0)
    switch (intNum) {
 300349c:	fe842703          	lw	a4,-24(s0)
 30034a0:	479d                	li	a5,7
 30034a2:	2ae7e563          	bltu	a5,a4,300374c <IRQ_SetLocalPriority+0x2de>
 30034a6:	fe842783          	lw	a5,-24(s0)
 30034aa:	00279713          	slli	a4,a5,0x2
 30034ae:	030107b7          	lui	a5,0x3010
 30034b2:	7fc78793          	addi	a5,a5,2044 # 30107fc <g_crgIpMatch+0x2ec>
 30034b6:	97ba                	add	a5,a5,a4
 30034b8:	439c                	lw	a5,0(a5)
 30034ba:	8782                	jr	a5
        case 0:  /* GROUP0 */
            SET_LOCAL_INTER_NUM_PRI(0, interPriNum, prior);
 30034bc:	bc0027f3          	csrr	a5,0xbc0
 30034c0:	faf42623          	sw	a5,-84(s0)
 30034c4:	fac42783          	lw	a5,-84(s0)
 30034c8:	faf42423          	sw	a5,-88(s0)
 30034cc:	f9c42783          	lw	a5,-100(s0)
 30034d0:	078a                	slli	a5,a5,0x2
 30034d2:	8bf1                	andi	a5,a5,28
 30034d4:	473d                	li	a4,15
 30034d6:	00f717b3          	sll	a5,a4,a5
 30034da:	fff7c793          	not	a5,a5
 30034de:	fa842703          	lw	a4,-88(s0)
 30034e2:	8ff9                	and	a5,a5,a4
 30034e4:	faf42423          	sw	a5,-88(s0)
 30034e8:	f9c42783          	lw	a5,-100(s0)
 30034ec:	078a                	slli	a5,a5,0x2
 30034ee:	8bf1                	andi	a5,a5,28
 30034f0:	f9842703          	lw	a4,-104(s0)
 30034f4:	00f717b3          	sll	a5,a4,a5
 30034f8:	fa842703          	lw	a4,-88(s0)
 30034fc:	8fd9                	or	a5,a5,a4
 30034fe:	faf42423          	sw	a5,-88(s0)
 3003502:	fa842783          	lw	a5,-88(s0)
 3003506:	82be                	mv	t0,a5
 3003508:	bc029073          	csrw	0xbc0,t0
            break;
 300350c:	ac81                	j	300375c <IRQ_SetLocalPriority+0x2ee>
        case 1:  /* GROUP1 */
            SET_LOCAL_INTER_NUM_PRI(1, interPriNum, prior);
 300350e:	bc1027f3          	csrr	a5,0xbc1
 3003512:	faf42a23          	sw	a5,-76(s0)
 3003516:	fb442783          	lw	a5,-76(s0)
 300351a:	faf42823          	sw	a5,-80(s0)
 300351e:	f9c42783          	lw	a5,-100(s0)
 3003522:	078a                	slli	a5,a5,0x2
 3003524:	8bf1                	andi	a5,a5,28
 3003526:	473d                	li	a4,15
 3003528:	00f717b3          	sll	a5,a4,a5
 300352c:	fff7c793          	not	a5,a5
 3003530:	fb042703          	lw	a4,-80(s0)
 3003534:	8ff9                	and	a5,a5,a4
 3003536:	faf42823          	sw	a5,-80(s0)
 300353a:	f9c42783          	lw	a5,-100(s0)
 300353e:	078a                	slli	a5,a5,0x2
 3003540:	8bf1                	andi	a5,a5,28
 3003542:	f9842703          	lw	a4,-104(s0)
 3003546:	00f717b3          	sll	a5,a4,a5
 300354a:	fb042703          	lw	a4,-80(s0)
 300354e:	8fd9                	or	a5,a5,a4
 3003550:	faf42823          	sw	a5,-80(s0)
 3003554:	fb042783          	lw	a5,-80(s0)
 3003558:	82be                	mv	t0,a5
 300355a:	bc129073          	csrw	0xbc1,t0
            break;
 300355e:	aafd                	j	300375c <IRQ_SetLocalPriority+0x2ee>
        case 2:  /* GROUP2 */
            SET_LOCAL_INTER_NUM_PRI(2, interPriNum, prior);
 3003560:	bc2027f3          	csrr	a5,0xbc2
 3003564:	faf42e23          	sw	a5,-68(s0)
 3003568:	fbc42783          	lw	a5,-68(s0)
 300356c:	faf42c23          	sw	a5,-72(s0)
 3003570:	f9c42783          	lw	a5,-100(s0)
 3003574:	078a                	slli	a5,a5,0x2
 3003576:	8bf1                	andi	a5,a5,28
 3003578:	473d                	li	a4,15
 300357a:	00f717b3          	sll	a5,a4,a5
 300357e:	fff7c793          	not	a5,a5
 3003582:	fb842703          	lw	a4,-72(s0)
 3003586:	8ff9                	and	a5,a5,a4
 3003588:	faf42c23          	sw	a5,-72(s0)
 300358c:	f9c42783          	lw	a5,-100(s0)
 3003590:	078a                	slli	a5,a5,0x2
 3003592:	8bf1                	andi	a5,a5,28
 3003594:	f9842703          	lw	a4,-104(s0)
 3003598:	00f717b3          	sll	a5,a4,a5
 300359c:	fb842703          	lw	a4,-72(s0)
 30035a0:	8fd9                	or	a5,a5,a4
 30035a2:	faf42c23          	sw	a5,-72(s0)
 30035a6:	fb842783          	lw	a5,-72(s0)
 30035aa:	82be                	mv	t0,a5
 30035ac:	bc229073          	csrw	0xbc2,t0
            break;
 30035b0:	a275                	j	300375c <IRQ_SetLocalPriority+0x2ee>
        case 3:  /* GROUP3 */
            SET_LOCAL_INTER_NUM_PRI(3, interPriNum, prior);
 30035b2:	bc3027f3          	csrr	a5,0xbc3
 30035b6:	fcf42223          	sw	a5,-60(s0)
 30035ba:	fc442783          	lw	a5,-60(s0)
 30035be:	fcf42023          	sw	a5,-64(s0)
 30035c2:	f9c42783          	lw	a5,-100(s0)
 30035c6:	078a                	slli	a5,a5,0x2
 30035c8:	8bf1                	andi	a5,a5,28
 30035ca:	473d                	li	a4,15
 30035cc:	00f717b3          	sll	a5,a4,a5
 30035d0:	fff7c793          	not	a5,a5
 30035d4:	fc042703          	lw	a4,-64(s0)
 30035d8:	8ff9                	and	a5,a5,a4
 30035da:	fcf42023          	sw	a5,-64(s0)
 30035de:	f9c42783          	lw	a5,-100(s0)
 30035e2:	078a                	slli	a5,a5,0x2
 30035e4:	8bf1                	andi	a5,a5,28
 30035e6:	f9842703          	lw	a4,-104(s0)
 30035ea:	00f717b3          	sll	a5,a4,a5
 30035ee:	fc042703          	lw	a4,-64(s0)
 30035f2:	8fd9                	or	a5,a5,a4
 30035f4:	fcf42023          	sw	a5,-64(s0)
 30035f8:	fc042783          	lw	a5,-64(s0)
 30035fc:	82be                	mv	t0,a5
 30035fe:	bc329073          	csrw	0xbc3,t0
            break;
 3003602:	aaa9                	j	300375c <IRQ_SetLocalPriority+0x2ee>
        case 4:  /* GROUP4 */
            SET_LOCAL_INTER_NUM_PRI(4, interPriNum, prior);
 3003604:	bc4027f3          	csrr	a5,0xbc4
 3003608:	fcf42623          	sw	a5,-52(s0)
 300360c:	fcc42783          	lw	a5,-52(s0)
 3003610:	fcf42423          	sw	a5,-56(s0)
 3003614:	f9c42783          	lw	a5,-100(s0)
 3003618:	078a                	slli	a5,a5,0x2
 300361a:	8bf1                	andi	a5,a5,28
 300361c:	473d                	li	a4,15
 300361e:	00f717b3          	sll	a5,a4,a5
 3003622:	fff7c793          	not	a5,a5
 3003626:	fc842703          	lw	a4,-56(s0)
 300362a:	8ff9                	and	a5,a5,a4
 300362c:	fcf42423          	sw	a5,-56(s0)
 3003630:	f9c42783          	lw	a5,-100(s0)
 3003634:	078a                	slli	a5,a5,0x2
 3003636:	8bf1                	andi	a5,a5,28
 3003638:	f9842703          	lw	a4,-104(s0)
 300363c:	00f717b3          	sll	a5,a4,a5
 3003640:	fc842703          	lw	a4,-56(s0)
 3003644:	8fd9                	or	a5,a5,a4
 3003646:	fcf42423          	sw	a5,-56(s0)
 300364a:	fc842783          	lw	a5,-56(s0)
 300364e:	82be                	mv	t0,a5
 3003650:	bc429073          	csrw	0xbc4,t0
            break;
 3003654:	a221                	j	300375c <IRQ_SetLocalPriority+0x2ee>
        case 5:  /* GROUP5 */
            SET_LOCAL_INTER_NUM_PRI(5, interPriNum, prior);
 3003656:	bc5027f3          	csrr	a5,0xbc5
 300365a:	fcf42a23          	sw	a5,-44(s0)
 300365e:	fd442783          	lw	a5,-44(s0)
 3003662:	fcf42823          	sw	a5,-48(s0)
 3003666:	f9c42783          	lw	a5,-100(s0)
 300366a:	078a                	slli	a5,a5,0x2
 300366c:	8bf1                	andi	a5,a5,28
 300366e:	473d                	li	a4,15
 3003670:	00f717b3          	sll	a5,a4,a5
 3003674:	fff7c793          	not	a5,a5
 3003678:	fd042703          	lw	a4,-48(s0)
 300367c:	8ff9                	and	a5,a5,a4
 300367e:	fcf42823          	sw	a5,-48(s0)
 3003682:	f9c42783          	lw	a5,-100(s0)
 3003686:	078a                	slli	a5,a5,0x2
 3003688:	8bf1                	andi	a5,a5,28
 300368a:	f9842703          	lw	a4,-104(s0)
 300368e:	00f717b3          	sll	a5,a4,a5
 3003692:	fd042703          	lw	a4,-48(s0)
 3003696:	8fd9                	or	a5,a5,a4
 3003698:	fcf42823          	sw	a5,-48(s0)
 300369c:	fd042783          	lw	a5,-48(s0)
 30036a0:	82be                	mv	t0,a5
 30036a2:	bc529073          	csrw	0xbc5,t0
            break;
 30036a6:	a85d                	j	300375c <IRQ_SetLocalPriority+0x2ee>
        case 6:  /* GROUP6 */
            SET_LOCAL_INTER_NUM_PRI(6, interPriNum, prior);
 30036a8:	bc6027f3          	csrr	a5,0xbc6
 30036ac:	fcf42e23          	sw	a5,-36(s0)
 30036b0:	fdc42783          	lw	a5,-36(s0)
 30036b4:	fcf42c23          	sw	a5,-40(s0)
 30036b8:	f9c42783          	lw	a5,-100(s0)
 30036bc:	078a                	slli	a5,a5,0x2
 30036be:	8bf1                	andi	a5,a5,28
 30036c0:	473d                	li	a4,15
 30036c2:	00f717b3          	sll	a5,a4,a5
 30036c6:	fff7c793          	not	a5,a5
 30036ca:	fd842703          	lw	a4,-40(s0)
 30036ce:	8ff9                	and	a5,a5,a4
 30036d0:	fcf42c23          	sw	a5,-40(s0)
 30036d4:	f9c42783          	lw	a5,-100(s0)
 30036d8:	078a                	slli	a5,a5,0x2
 30036da:	8bf1                	andi	a5,a5,28
 30036dc:	f9842703          	lw	a4,-104(s0)
 30036e0:	00f717b3          	sll	a5,a4,a5
 30036e4:	fd842703          	lw	a4,-40(s0)
 30036e8:	8fd9                	or	a5,a5,a4
 30036ea:	fcf42c23          	sw	a5,-40(s0)
 30036ee:	fd842783          	lw	a5,-40(s0)
 30036f2:	82be                	mv	t0,a5
 30036f4:	bc629073          	csrw	0xbc6,t0
            break;
 30036f8:	a095                	j	300375c <IRQ_SetLocalPriority+0x2ee>
        case 7:  /* GROUP7 */
            SET_LOCAL_INTER_NUM_PRI(7, interPriNum, prior);
 30036fa:	bc7027f3          	csrr	a5,0xbc7
 30036fe:	fef42223          	sw	a5,-28(s0)
 3003702:	fe442783          	lw	a5,-28(s0)
 3003706:	fef42023          	sw	a5,-32(s0)
 300370a:	f9c42783          	lw	a5,-100(s0)
 300370e:	078a                	slli	a5,a5,0x2
 3003710:	8bf1                	andi	a5,a5,28
 3003712:	473d                	li	a4,15
 3003714:	00f717b3          	sll	a5,a4,a5
 3003718:	fff7c793          	not	a5,a5
 300371c:	fe042703          	lw	a4,-32(s0)
 3003720:	8ff9                	and	a5,a5,a4
 3003722:	fef42023          	sw	a5,-32(s0)
 3003726:	f9c42783          	lw	a5,-100(s0)
 300372a:	078a                	slli	a5,a5,0x2
 300372c:	8bf1                	andi	a5,a5,28
 300372e:	f9842703          	lw	a4,-104(s0)
 3003732:	00f717b3          	sll	a5,a4,a5
 3003736:	fe042703          	lw	a4,-32(s0)
 300373a:	8fd9                	or	a5,a5,a4
 300373c:	fef42023          	sw	a5,-32(s0)
 3003740:	fe042783          	lw	a5,-32(s0)
 3003744:	82be                	mv	t0,a5
 3003746:	bc729073          	csrw	0xbc7,t0
            break;
 300374a:	a809                	j	300375c <IRQ_SetLocalPriority+0x2ee>
        default:
            SetLocalIntNumPri(intNum, interPriNum, prior);
 300374c:	f9842603          	lw	a2,-104(s0)
 3003750:	f9c42583          	lw	a1,-100(s0)
 3003754:	fe842503          	lw	a0,-24(s0)
 3003758:	34b1                	jal	ra,30031a4 <SetLocalIntNumPri>
            break;
 300375a:	0001                	nop
    }
    RISCV_PRIV_MODE_SWITCH(priv);
 300375c:	fec42703          	lw	a4,-20(s0)
 3003760:	47a1                	li	a5,8
 3003762:	00f71463          	bne	a4,a5,300376a <IRQ_SetLocalPriority+0x2fc>
 3003766:	00000073          	ecall
}
 300376a:	0001                	nop
 300376c:	50b6                	lw	ra,108(sp)
 300376e:	5426                	lw	s0,104(sp)
 3003770:	6165                	addi	sp,sp,112
 3003772:	8082                	ret

03003774 <IRQ_SetPriority>:
  * @param irqNum  External interrupt number.
  * @param priority.
  * @retval IRQ_ERRNO_NUM_INVALID or IRQ_ERRNO_PRIORITY_INVALID or BASE_STATUS_OK.
  */
unsigned int IRQ_SetPriority(unsigned int irqNum, unsigned int priority)
{
 3003774:	1101                	addi	sp,sp,-32
 3003776:	ce06                	sw	ra,28(sp)
 3003778:	cc22                	sw	s0,24(sp)
 300377a:	1000                	addi	s0,sp,32
 300377c:	fea42623          	sw	a0,-20(s0)
 3003780:	feb42423          	sw	a1,-24(s0)
    INTERRUPT_PARAM_CHECK_WITH_RET((irqNum >= IRQ_VECTOR_CNT && irqNum < IRQ_MAX), IRQ_ERRNO_NUM_INVALID);
 3003784:	fec42703          	lw	a4,-20(s0)
 3003788:	47e5                	li	a5,25
 300378a:	00e7f863          	bgeu	a5,a4,300379a <IRQ_SetPriority+0x26>
 300378e:	fec42703          	lw	a4,-20(s0)
 3003792:	07200793          	li	a5,114
 3003796:	00e7fc63          	bgeu	a5,a4,30037ae <IRQ_SetPriority+0x3a>
 300379a:	18c00593          	li	a1,396
 300379e:	030107b7          	lui	a5,0x3010
 30037a2:	7bc78513          	addi	a0,a5,1980 # 30107bc <g_crgIpMatch+0x2ac>
 30037a6:	d98ff0ef          	jal	ra,3002d3e <AssertErrorLog>
 30037aa:	4789                	li	a5,2
 30037ac:	a81d                	j	30037e2 <IRQ_SetPriority+0x6e>
    INTERRUPT_PARAM_CHECK_WITH_RET((priority >= IRQ_PRIO_LOWEST && priority <= IRQ_PRIO_HIGHEST), \
 30037ae:	fe842783          	lw	a5,-24(s0)
 30037b2:	c791                	beqz	a5,30037be <IRQ_SetPriority+0x4a>
 30037b4:	fe842703          	lw	a4,-24(s0)
 30037b8:	47bd                	li	a5,15
 30037ba:	00e7fc63          	bgeu	a5,a4,30037d2 <IRQ_SetPriority+0x5e>
 30037be:	18d00593          	li	a1,397
 30037c2:	030107b7          	lui	a5,0x3010
 30037c6:	7bc78513          	addi	a0,a5,1980 # 30107bc <g_crgIpMatch+0x2ac>
 30037ca:	d74ff0ef          	jal	ra,3002d3e <AssertErrorLog>
 30037ce:	4795                	li	a5,5
 30037d0:	a809                	j	30037e2 <IRQ_SetPriority+0x6e>
                                   IRQ_ERRNO_PRIORITY_INVALID);

    /* The locipri register is specifically used to configure the priority of the
       external non-standard interrupts of the CPU, so the number of internal
       standard interrupts should be subtracted */
    IRQ_SetLocalPriority(irqNum - IRQ_VECTOR_CNT, priority);
 30037d2:	fec42783          	lw	a5,-20(s0)
 30037d6:	1799                	addi	a5,a5,-26
 30037d8:	fe842583          	lw	a1,-24(s0)
 30037dc:	853e                	mv	a0,a5
 30037de:	3941                	jal	ra,300346e <IRQ_SetLocalPriority>

    return BASE_STATUS_OK;
 30037e0:	4781                	li	a5,0
}
 30037e2:	853e                	mv	a0,a5
 30037e4:	40f2                	lw	ra,28(sp)
 30037e6:	4462                	lw	s0,24(sp)
 30037e8:	6105                	addi	sp,sp,32
 30037ea:	8082                	ret

030037ec <IRQ_DummyHandler>:
  * @brief Interrupt dummy handler
  * @param arg     Not used
  * @retval None.
  */
static void IRQ_DummyHandler(void *arg)
{
 30037ec:	1101                	addi	sp,sp,-32
 30037ee:	ce22                	sw	s0,28(sp)
 30037f0:	1000                	addi	s0,sp,32
 30037f2:	fea42623          	sw	a0,-20(s0)
    BASE_FUNC_UNUSED(arg);
}
 30037f6:	0001                	nop
 30037f8:	4472                	lw	s0,28(sp)
 30037fa:	6105                	addi	sp,sp,32
 30037fc:	8082                	ret

030037fe <IRQ_SetCallBack>:
  * @param func   callback function
  * @param arg    callback arg
  * @retval None.
  */
static inline void IRQ_SetCallBack(unsigned int irqNum, IRQ_PROC_FUNC func, void *arg)
{
 30037fe:	1101                	addi	sp,sp,-32
 3003800:	ce22                	sw	s0,28(sp)
 3003802:	1000                	addi	s0,sp,32
 3003804:	fea42623          	sw	a0,-20(s0)
 3003808:	feb42423          	sw	a1,-24(s0)
 300380c:	fec42223          	sw	a2,-28(s0)
    g_irqCallbackFunc[irqNum].param = arg;
 3003810:	040007b7          	lui	a5,0x4000
 3003814:	18878713          	addi	a4,a5,392 # 4000188 <g_irqCallbackFunc>
 3003818:	fec42783          	lw	a5,-20(s0)
 300381c:	078e                	slli	a5,a5,0x3
 300381e:	97ba                	add	a5,a5,a4
 3003820:	fe442703          	lw	a4,-28(s0)
 3003824:	c3d8                	sw	a4,4(a5)
    g_irqCallbackFunc[irqNum].pfnHandler = func;
 3003826:	040007b7          	lui	a5,0x4000
 300382a:	18878713          	addi	a4,a5,392 # 4000188 <g_irqCallbackFunc>
 300382e:	fec42783          	lw	a5,-20(s0)
 3003832:	078e                	slli	a5,a5,0x3
 3003834:	97ba                	add	a5,a5,a4
 3003836:	fe842703          	lw	a4,-24(s0)
 300383a:	c398                	sw	a4,0(a5)
}
 300383c:	0001                	nop
 300383e:	4472                	lw	s0,28(sp)
 3003840:	6105                	addi	sp,sp,32
 3003842:	8082                	ret

03003844 <IRQ_GetCpuPrivilege>:
  * @param none
  * @retval mcause value
  */
#if defined(USER_MODE_ENABLE) && (USER_MODE_ENABLE == 1)
static inline unsigned int IRQ_GetCpuPrivilege(void)
{
 3003844:	1141                	addi	sp,sp,-16
 3003846:	c622                	sw	s0,12(sp)
 3003848:	0800                	addi	s0,sp,16
    return (g_RiscvPrivMode == 0) ? RISCV_U_MODE : RISCV_M_MODE;
 300384a:	a881a783          	lw	a5,-1400(gp) # 4000184 <g_RiscvPrivMode>
 300384e:	e399                	bnez	a5,3003854 <IRQ_GetCpuPrivilege+0x10>
 3003850:	47a1                	li	a5,8
 3003852:	a011                	j	3003856 <IRQ_GetCpuPrivilege+0x12>
 3003854:	47ad                	li	a5,11
}
 3003856:	853e                	mv	a0,a5
 3003858:	4432                	lw	s0,12(sp)
 300385a:	0141                	addi	sp,sp,16
 300385c:	8082                	ret

0300385e <CAN_WaitTime>:
 * @brief Wait 11 CAN bit time.
 * @param canHandle CAN handle.
 * @retval void
 */
static void CAN_WaitTime(CAN_Handle *canHandle)
{
 300385e:	7179                	addi	sp,sp,-48
 3003860:	d606                	sw	ra,44(sp)
 3003862:	d422                	sw	s0,40(sp)
 3003864:	1800                	addi	s0,sp,48
 3003866:	fca42e23          	sw	a0,-36(s0)
    /* CAN clock frequency */
    unsigned int canFrep = HAL_CRG_GetIpFreq((void *)canHandle->baseAddress) / (canHandle->prescalser);
 300386a:	fdc42783          	lw	a5,-36(s0)
 300386e:	439c                	lw	a5,0(a5)
 3003870:	853e                	mv	a0,a5
 3003872:	680010ef          	jal	ra,3004ef2 <HAL_CRG_GetIpFreq>
 3003876:	872a                	mv	a4,a0
 3003878:	fdc42783          	lw	a5,-36(s0)
 300387c:	4bdc                	lw	a5,20(a5)
 300387e:	02f757b3          	divu	a5,a4,a5
 3003882:	fef42623          	sw	a5,-20(s0)
    unsigned int waitTime = canFrep / (1 + canHandle->seg1Phase + canHandle->seg2Phase);
 3003886:	fdc42783          	lw	a5,-36(s0)
 300388a:	47d8                	lw	a4,12(a5)
 300388c:	fdc42783          	lw	a5,-36(s0)
 3003890:	4b9c                	lw	a5,16(a5)
 3003892:	97ba                	add	a5,a5,a4
 3003894:	0785                	addi	a5,a5,1
 3003896:	fec42703          	lw	a4,-20(s0)
 300389a:	02f757b3          	divu	a5,a4,a5
 300389e:	fef42423          	sw	a5,-24(s0)
    /* 1000000 equals 1 us to wait for 11 time bits */
    unsigned int waitTimeCount = CAN_TIME_WAIT * ((1000000) / waitTime);
 30038a2:	000f47b7          	lui	a5,0xf4
 30038a6:	24078713          	addi	a4,a5,576 # f4240 <FLASH_SIZE+0xd4244>
 30038aa:	fe842783          	lw	a5,-24(s0)
 30038ae:	02f75733          	divu	a4,a4,a5
 30038b2:	47ad                	li	a5,11
 30038b4:	02f707b3          	mul	a5,a4,a5
 30038b8:	fef42223          	sw	a5,-28(s0)
    BASE_FUNC_DelayUs(waitTimeCount);
 30038bc:	fe442503          	lw	a0,-28(s0)
 30038c0:	cc0ff0ef          	jal	ra,3002d80 <BASE_FUNC_DelayUs>
}
 30038c4:	0001                	nop
 30038c6:	50b2                	lw	ra,44(sp)
 30038c8:	5422                	lw	s0,40(sp)
 30038ca:	6145                	addi	sp,sp,48
 30038cc:	8082                	ret

030038ce <CAN_AutoRetrans>:
 * @brief CAN Setting Automatic Retransmission.
 * @param canHandle CAN handle.
 * @retval void
 */
static void CAN_AutoRetrans(CAN_Handle *canHandle)
{
 30038ce:	1101                	addi	sp,sp,-32
 30038d0:	ce22                	sw	s0,28(sp)
 30038d2:	1000                	addi	s0,sp,32
 30038d4:	fea42623          	sw	a0,-20(s0)
    if (canHandle->autoRetrans == BASE_CFG_DISABLE) {
 30038d8:	fec42783          	lw	a5,-20(s0)
 30038dc:	02c7c783          	lbu	a5,44(a5)
 30038e0:	0017c793          	xori	a5,a5,1
 30038e4:	9f81                	uxtb	a5
 30038e6:	cb89                	beqz	a5,30038f8 <CAN_AutoRetrans+0x2a>
        /* Turn off auto retransmission */
        canHandle->baseAddress->CAN_CONTROL.BIT.DAR = BASE_CFG_ENABLE;
 30038e8:	fec42783          	lw	a5,-20(s0)
 30038ec:	4398                	lw	a4,0(a5)
 30038ee:	431c                	lw	a5,0(a4)
 30038f0:	0207e793          	ori	a5,a5,32
 30038f4:	c31c                	sw	a5,0(a4)
    } else {
        /* Turn on auto retransmission */
        canHandle->baseAddress->CAN_CONTROL.BIT.DAR = BASE_CFG_DISABLE;
    }
}
 30038f6:	a801                	j	3003906 <CAN_AutoRetrans+0x38>
        canHandle->baseAddress->CAN_CONTROL.BIT.DAR = BASE_CFG_DISABLE;
 30038f8:	fec42783          	lw	a5,-20(s0)
 30038fc:	4398                	lw	a4,0(a5)
 30038fe:	431c                	lw	a5,0(a4)
 3003900:	fdf7f793          	andi	a5,a5,-33
 3003904:	c31c                	sw	a5,0(a4)
}
 3003906:	0001                	nop
 3003908:	4472                	lw	s0,28(sp)
 300390a:	6105                	addi	sp,sp,32
 300390c:	8082                	ret

0300390e <HAL_CAN_Init>:
  * @brief Initialize the CAN hardware configuration and configure parameters based on the specified handle.
  * @param canHandle CAN handle.
  * @retval BASE status type: OK, ERROR, BUSY, TIMEOUT
  */
BASE_StatusType HAL_CAN_Init(CAN_Handle *canHandle)
{
 300390e:	7179                	addi	sp,sp,-48
 3003910:	d606                	sw	ra,44(sp)
 3003912:	d422                	sw	s0,40(sp)
 3003914:	1800                	addi	s0,sp,48
 3003916:	fca42e23          	sw	a0,-36(s0)
    CAN_PARAM_CHECK_WITH_RET(IsCanSeg1phase(canHandle->seg1Phase), BASE_STATUS_ERROR);
    CAN_PARAM_CHECK_WITH_RET(IsCanSeg2phase(canHandle->seg2Phase), BASE_STATUS_ERROR);
    CAN_PARAM_CHECK_WITH_RET(IsCanSJW(canHandle->sjw), BASE_STATUS_ERROR);
    unsigned int busy;
    /* Step1: init enable */
    canHandle->baseAddress->CAN_CONTROL.BIT.Init = BASE_CFG_ENABLE;
 300391a:	fdc42783          	lw	a5,-36(s0)
 300391e:	4398                	lw	a4,0(a5)
 3003920:	431c                	lw	a5,0(a4)
 3003922:	0017e793          	ori	a5,a5,1
 3003926:	c31c                	sw	a5,0(a4)
    /* Step2: configuration command mask register, set 0xF3 to write into packet objects */
    canHandle->baseAddress->IF1_COMMAND_MASK.reg = 0xF3;
 3003928:	fdc42783          	lw	a5,-36(s0)
 300392c:	439c                	lw	a5,0(a5)
 300392e:	0f300713          	li	a4,243
 3003932:	d3d8                	sw	a4,36(a5)
    /* Step3 ~ 4: init packet object 1 ~ 32 */
    for (int i = 1; i <= CAN_OBJ_MAXNUM; i++) {
 3003934:	4785                	li	a5,1
 3003936:	fef42623          	sw	a5,-20(s0)
 300393a:	a815                	j	300396e <HAL_CAN_Init+0x60>
        canHandle->baseAddress->IF1_COMMAND_REQUEST.reg = i;
 300393c:	fdc42783          	lw	a5,-36(s0)
 3003940:	439c                	lw	a5,0(a5)
 3003942:	fec42703          	lw	a4,-20(s0)
 3003946:	d398                	sw	a4,32(a5)
        do {
            busy = canHandle->baseAddress->IF1_COMMAND_REQUEST.BIT.BUSY;
 3003948:	fdc42783          	lw	a5,-36(s0)
 300394c:	439c                	lw	a5,0(a5)
 300394e:	539c                	lw	a5,32(a5)
 3003950:	83bd                	srli	a5,a5,0xf
 3003952:	8b85                	andi	a5,a5,1
 3003954:	9f81                	uxtb	a5
 3003956:	fef42023          	sw	a5,-32(s0)
        } while (busy == BASE_CFG_ENABLE);
 300395a:	fe042703          	lw	a4,-32(s0)
 300395e:	4785                	li	a5,1
 3003960:	fef704e3          	beq	a4,a5,3003948 <HAL_CAN_Init+0x3a>
    for (int i = 1; i <= CAN_OBJ_MAXNUM; i++) {
 3003964:	fec42783          	lw	a5,-20(s0)
 3003968:	0785                	addi	a5,a5,1
 300396a:	fef42623          	sw	a5,-20(s0)
 300396e:	fec42703          	lw	a4,-20(s0)
 3003972:	02000793          	li	a5,32
 3003976:	fce7d3e3          	bge	a5,a4,300393c <HAL_CAN_Init+0x2e>
    }
    /* Step5: Bit_Timing setting enable, [0]bit and [6]bit need are set, others clear */
    canHandle->baseAddress->CAN_CONTROL.reg = 0x41;
 300397a:	fdc42783          	lw	a5,-36(s0)
 300397e:	439c                	lw	a5,0(a5)
 3003980:	04100713          	li	a4,65
 3003984:	c398                	sw	a4,0(a5)
    /* Step6: Bit_Timing configuration */
    unsigned int val = canHandle->prescalser - 1;  /* The prescalser is set to the lower 6 bits, [5:0] */
 3003986:	fdc42783          	lw	a5,-36(s0)
 300398a:	4bdc                	lw	a5,20(a5)
 300398c:	17fd                	addi	a5,a5,-1
 300398e:	fef42223          	sw	a5,-28(s0)
    val |= (canHandle->sjw - 1) << 6;              /* The sjw needs to be shifted leftwards by 6 bits, [7:6] */
 3003992:	fdc42783          	lw	a5,-36(s0)
 3003996:	4f9c                	lw	a5,24(a5)
 3003998:	17fd                	addi	a5,a5,-1
 300399a:	079a                	slli	a5,a5,0x6
 300399c:	fe442703          	lw	a4,-28(s0)
 30039a0:	8fd9                	or	a5,a5,a4
 30039a2:	fef42223          	sw	a5,-28(s0)
    val |= (canHandle->seg1Phase - 1) << 8;        /* The seg1Phase needs to be shifted leftwards by 8 bits, [11:8] */
 30039a6:	fdc42783          	lw	a5,-36(s0)
 30039aa:	47dc                	lw	a5,12(a5)
 30039ac:	17fd                	addi	a5,a5,-1
 30039ae:	07a2                	slli	a5,a5,0x8
 30039b0:	fe442703          	lw	a4,-28(s0)
 30039b4:	8fd9                	or	a5,a5,a4
 30039b6:	fef42223          	sw	a5,-28(s0)
    val |= (canHandle->seg2Phase - 1) << 12;       /* The seg2Phase needs to be shifted leftwards by 12 bits, [14:12] */
 30039ba:	fdc42783          	lw	a5,-36(s0)
 30039be:	4b9c                	lw	a5,16(a5)
 30039c0:	17fd                	addi	a5,a5,-1
 30039c2:	07b2                	slli	a5,a5,0xc
 30039c4:	fe442703          	lw	a4,-28(s0)
 30039c8:	8fd9                	or	a5,a5,a4
 30039ca:	fef42223          	sw	a5,-28(s0)
    DBG_PRINTF("BAUD RATE: %d\r\n", val);
 30039ce:	fe442583          	lw	a1,-28(s0)
 30039d2:	030117b7          	lui	a5,0x3011
 30039d6:	81c78513          	addi	a0,a5,-2020 # 301081c <g_crgIpMatch+0x30c>
 30039da:	7cd020ef          	jal	ra,30069a6 <DBG_UartPrintf>
    canHandle->baseAddress->BIT_TIMING.reg = val;
 30039de:	fdc42783          	lw	a5,-36(s0)
 30039e2:	439c                	lw	a5,0(a5)
 30039e4:	fe442703          	lw	a4,-28(s0)
 30039e8:	c7d8                	sw	a4,12(a5)
    /* Step7: setting interrupt configuration, error interrupt and module interrupt */
    canHandle->baseAddress->CAN_CONTROL.reg = 0x0F;
 30039ea:	fdc42783          	lw	a5,-36(s0)
 30039ee:	439c                	lw	a5,0(a5)
 30039f0:	473d                	li	a4,15
 30039f2:	c398                	sw	a4,0(a5)
    /* Step8: setting automatic retransmission */
    CAN_AutoRetrans(canHandle);
 30039f4:	fdc42503          	lw	a0,-36(s0)
 30039f8:	3dd9                	jal	ra,30038ce <CAN_AutoRetrans>
    /* Step9: finish init */
    if (canHandle->typeMode == CAN_MODE_TEST && canHandle->testModeConfigure != NULL) {
 30039fa:	fdc42783          	lw	a5,-36(s0)
 30039fe:	43d8                	lw	a4,4(a5)
 3003a00:	4785                	li	a5,1
 3003a02:	08f71063          	bne	a4,a5,3003a82 <HAL_CAN_Init+0x174>
 3003a06:	fdc42783          	lw	a5,-36(s0)
 3003a0a:	479c                	lw	a5,8(a5)
 3003a0c:	cbbd                	beqz	a5,3003a82 <HAL_CAN_Init+0x174>
        canHandle->baseAddress->CAN_CONTROL.BIT.Test = BASE_CFG_ENABLE;
 3003a0e:	fdc42783          	lw	a5,-36(s0)
 3003a12:	4398                	lw	a4,0(a5)
 3003a14:	431c                	lw	a5,0(a4)
 3003a16:	0807e793          	ori	a5,a5,128
 3003a1a:	c31c                	sw	a5,0(a4)
        canHandle->baseAddress->CAN_TEST.BIT.Lback = canHandle->testModeConfigure->loopBack;
 3003a1c:	fdc42783          	lw	a5,-36(s0)
 3003a20:	479c                	lw	a5,8(a5)
 3003a22:	4394                	lw	a3,0(a5)
 3003a24:	fdc42783          	lw	a5,-36(s0)
 3003a28:	4398                	lw	a4,0(a5)
 3003a2a:	87b6                	mv	a5,a3
 3003a2c:	8b85                	andi	a5,a5,1
 3003a2e:	0ff7f693          	andi	a3,a5,255
 3003a32:	4b5c                	lw	a5,20(a4)
 3003a34:	8a85                	andi	a3,a3,1
 3003a36:	0692                	slli	a3,a3,0x4
 3003a38:	9bbd                	andi	a5,a5,-17
 3003a3a:	8fd5                	or	a5,a5,a3
 3003a3c:	cb5c                	sw	a5,20(a4)
        canHandle->baseAddress->CAN_TEST.BIT.Silent = canHandle->testModeConfigure->silent;
 3003a3e:	fdc42783          	lw	a5,-36(s0)
 3003a42:	479c                	lw	a5,8(a5)
 3003a44:	43d4                	lw	a3,4(a5)
 3003a46:	fdc42783          	lw	a5,-36(s0)
 3003a4a:	4398                	lw	a4,0(a5)
 3003a4c:	87b6                	mv	a5,a3
 3003a4e:	8b85                	andi	a5,a5,1
 3003a50:	0ff7f693          	andi	a3,a5,255
 3003a54:	4b5c                	lw	a5,20(a4)
 3003a56:	8a85                	andi	a3,a3,1
 3003a58:	068e                	slli	a3,a3,0x3
 3003a5a:	9bdd                	andi	a5,a5,-9
 3003a5c:	8fd5                	or	a5,a5,a3
 3003a5e:	cb5c                	sw	a5,20(a4)
        canHandle->baseAddress->CAN_TEST.BIT.Basic = canHandle->testModeConfigure->basic;
 3003a60:	fdc42783          	lw	a5,-36(s0)
 3003a64:	479c                	lw	a5,8(a5)
 3003a66:	4794                	lw	a3,8(a5)
 3003a68:	fdc42783          	lw	a5,-36(s0)
 3003a6c:	4398                	lw	a4,0(a5)
 3003a6e:	87b6                	mv	a5,a3
 3003a70:	8b85                	andi	a5,a5,1
 3003a72:	0ff7f693          	andi	a3,a5,255
 3003a76:	4b5c                	lw	a5,20(a4)
 3003a78:	8a85                	andi	a3,a3,1
 3003a7a:	068a                	slli	a3,a3,0x2
 3003a7c:	9bed                	andi	a5,a5,-5
 3003a7e:	8fd5                	or	a5,a5,a3
 3003a80:	cb5c                	sw	a5,20(a4)
    }
    canHandle->baseAddress->CAN_CONTROL.BIT.Init = BASE_CFG_DISABLE;
 3003a82:	fdc42783          	lw	a5,-36(s0)
 3003a86:	4398                	lw	a4,0(a5)
 3003a88:	431c                	lw	a5,0(a4)
 3003a8a:	9bf9                	andi	a5,a5,-2
 3003a8c:	c31c                	sw	a5,0(a4)
    /* Each packet object configuration before read CAN frame */
    for (int i = 1; i <= CAN_OBJ_MAXNUM; i++) {
 3003a8e:	4785                	li	a5,1
 3003a90:	fef42423          	sw	a5,-24(s0)
 3003a94:	a81d                	j	3003aca <HAL_CAN_Init+0x1bc>
        if (i <= BOUND_ID) {
 3003a96:	fe842703          	lw	a4,-24(s0)
 3003a9a:	47e1                	li	a5,24
 3003a9c:	00e7c963          	blt	a5,a4,3003aae <HAL_CAN_Init+0x1a0>
            CAN_ConfigReadReq(canHandle, i);  /* The default configuration is no filter receive */
 3003aa0:	fe842783          	lw	a5,-24(s0)
 3003aa4:	85be                	mv	a1,a5
 3003aa6:	fdc42503          	lw	a0,-36(s0)
 3003aaa:	02f000ef          	jal	ra,30042d8 <CAN_ConfigReadReq>
        }
        g_msgObj[i - 1] = 0;
 3003aae:	fe842783          	lw	a5,-24(s0)
 3003ab2:	17fd                	addi	a5,a5,-1
 3003ab4:	e2418713          	addi	a4,gp,-476 # 4000520 <g_msgObj>
 3003ab8:	078a                	slli	a5,a5,0x2
 3003aba:	97ba                	add	a5,a5,a4
 3003abc:	0007a023          	sw	zero,0(a5)
    for (int i = 1; i <= CAN_OBJ_MAXNUM; i++) {
 3003ac0:	fe842783          	lw	a5,-24(s0)
 3003ac4:	0785                	addi	a5,a5,1
 3003ac6:	fef42423          	sw	a5,-24(s0)
 3003aca:	fe842703          	lw	a4,-24(s0)
 3003ace:	02000793          	li	a5,32
 3003ad2:	fce7d2e3          	bge	a5,a4,3003a96 <HAL_CAN_Init+0x188>
    }
    CAN_WaitTime(canHandle);
 3003ad6:	fdc42503          	lw	a0,-36(s0)
 3003ada:	3351                	jal	ra,300385e <CAN_WaitTime>
    canHandle->state = CAN_STATE_READY;
 3003adc:	fdc42783          	lw	a5,-36(s0)
 3003ae0:	4705                	li	a4,1
 3003ae2:	cfd8                	sw	a4,28(a5)
    return BASE_STATUS_OK;
 3003ae4:	4781                	li	a5,0
}
 3003ae6:	853e                	mv	a0,a5
 3003ae8:	50b2                	lw	ra,44(sp)
 3003aea:	5422                	lw	s0,40(sp)
 3003aec:	6145                	addi	sp,sp,48
 3003aee:	8082                	ret

03003af0 <WriteData>:
  * @param canHandle CAN handle.
  * @param data Pointer address of the CAN data frame to be sent, @ref CANFrame
  * @retval None.
  */
static void WriteData(CAN_Handle *canHandle, CANFrame *data)
{   
 3003af0:	7179                	addi	sp,sp,-48
 3003af2:	d606                	sw	ra,44(sp)
 3003af4:	d422                	sw	s0,40(sp)
 3003af6:	1800                	addi	s0,sp,48
 3003af8:	fca42e23          	sw	a0,-36(s0)
 3003afc:	fcb42c23          	sw	a1,-40(s0)
    DBG_PRINTF("WriteData!\r\n");
 3003b00:	030117b7          	lui	a5,0x3011
 3003b04:	82c78513          	addi	a0,a5,-2004 # 301082c <g_crgIpMatch+0x31c>
 3003b08:	69f020ef          	jal	ra,30069a6 <DBG_UartPrintf>
    IF1_DATAA1_REG dataA1;
    dataA1.BIT.DATA0 = data->frame[0];  /* Data of bit 0 */
 3003b0c:	fd842783          	lw	a5,-40(s0)
 3003b10:	27d8                	lbu	a4,12(a5)
 3003b12:	fec42783          	lw	a5,-20(s0)
 3003b16:	0ff77713          	andi	a4,a4,255
 3003b1a:	f007f793          	andi	a5,a5,-256
 3003b1e:	8fd9                	or	a5,a5,a4
 3003b20:	fef42623          	sw	a5,-20(s0)
    dataA1.BIT.DATA1 = data->frame[1];  /* Data of bit 0 */
 3003b24:	fd842783          	lw	a5,-40(s0)
 3003b28:	37d8                	lbu	a4,13(a5)
 3003b2a:	fec42783          	lw	a5,-20(s0)
 3003b2e:	0ff77713          	andi	a4,a4,255
 3003b32:	0722                	slli	a4,a4,0x8
 3003b34:	76c1                	lui	a3,0xffff0
 3003b36:	0ff68693          	addi	a3,a3,255 # ffff00ff <RAM_END+0xfbfe80ff>
 3003b3a:	8ff5                	and	a5,a5,a3
 3003b3c:	8fd9                	or	a5,a5,a4
 3003b3e:	fef42623          	sw	a5,-20(s0)
    canHandle->baseAddress->IF1_DATAA1 = dataA1;
 3003b42:	fdc42783          	lw	a5,-36(s0)
 3003b46:	439c                	lw	a5,0(a5)
 3003b48:	fec42703          	lw	a4,-20(s0)
 3003b4c:	dfd8                	sw	a4,60(a5)
    IF1_DATAA2_REG dataA2;
    dataA2.BIT.DATA2 = data->frame[2];  /* Data of bit 2 */
 3003b4e:	fd842783          	lw	a5,-40(s0)
 3003b52:	27f8                	lbu	a4,14(a5)
 3003b54:	fe842783          	lw	a5,-24(s0)
 3003b58:	0ff77713          	andi	a4,a4,255
 3003b5c:	f007f793          	andi	a5,a5,-256
 3003b60:	8fd9                	or	a5,a5,a4
 3003b62:	fef42423          	sw	a5,-24(s0)
    dataA2.BIT.DATA3 = data->frame[3];  /* Data of bit 3 */
 3003b66:	fd842783          	lw	a5,-40(s0)
 3003b6a:	37f8                	lbu	a4,15(a5)
 3003b6c:	fe842783          	lw	a5,-24(s0)
 3003b70:	0ff77713          	andi	a4,a4,255
 3003b74:	0722                	slli	a4,a4,0x8
 3003b76:	76c1                	lui	a3,0xffff0
 3003b78:	0ff68693          	addi	a3,a3,255 # ffff00ff <RAM_END+0xfbfe80ff>
 3003b7c:	8ff5                	and	a5,a5,a3
 3003b7e:	8fd9                	or	a5,a5,a4
 3003b80:	fef42423          	sw	a5,-24(s0)
    canHandle->baseAddress->IF1_DATAA2 = dataA2;
 3003b84:	fdc42783          	lw	a5,-36(s0)
 3003b88:	439c                	lw	a5,0(a5)
 3003b8a:	fe842703          	lw	a4,-24(s0)
 3003b8e:	c3b8                	sw	a4,64(a5)
    IF1_DATAB1_REG dataB1;
    dataB1.BIT.DATA4 = data->frame[4];  /* Data of bit 4 */
 3003b90:	fd842783          	lw	a5,-40(s0)
 3003b94:	2b98                	lbu	a4,16(a5)
 3003b96:	fe442783          	lw	a5,-28(s0)
 3003b9a:	0ff77713          	andi	a4,a4,255
 3003b9e:	f007f793          	andi	a5,a5,-256
 3003ba2:	8fd9                	or	a5,a5,a4
 3003ba4:	fef42223          	sw	a5,-28(s0)
    dataB1.BIT.DATA5 = data->frame[5];  /* Data of bit 5 */
 3003ba8:	fd842783          	lw	a5,-40(s0)
 3003bac:	3b98                	lbu	a4,17(a5)
 3003bae:	fe442783          	lw	a5,-28(s0)
 3003bb2:	0ff77713          	andi	a4,a4,255
 3003bb6:	0722                	slli	a4,a4,0x8
 3003bb8:	76c1                	lui	a3,0xffff0
 3003bba:	0ff68693          	addi	a3,a3,255 # ffff00ff <RAM_END+0xfbfe80ff>
 3003bbe:	8ff5                	and	a5,a5,a3
 3003bc0:	8fd9                	or	a5,a5,a4
 3003bc2:	fef42223          	sw	a5,-28(s0)
    canHandle->baseAddress->IF1_DATAB1 = dataB1;
 3003bc6:	fdc42783          	lw	a5,-36(s0)
 3003bca:	439c                	lw	a5,0(a5)
 3003bcc:	fe442703          	lw	a4,-28(s0)
 3003bd0:	c3f8                	sw	a4,68(a5)
    IF1_DATAB2_REG dataB2;
    dataB2.BIT.DATA6 = data->frame[6];  /* Data of bit 6 */
 3003bd2:	fd842783          	lw	a5,-40(s0)
 3003bd6:	2bb8                	lbu	a4,18(a5)
 3003bd8:	fe042783          	lw	a5,-32(s0)
 3003bdc:	0ff77713          	andi	a4,a4,255
 3003be0:	f007f793          	andi	a5,a5,-256
 3003be4:	8fd9                	or	a5,a5,a4
 3003be6:	fef42023          	sw	a5,-32(s0)
    dataB2.BIT.DATA7 = data->frame[7];  /* Data of bit 7 */
 3003bea:	fd842783          	lw	a5,-40(s0)
 3003bee:	3bb8                	lbu	a4,19(a5)
 3003bf0:	fe042783          	lw	a5,-32(s0)
 3003bf4:	0ff77713          	andi	a4,a4,255
 3003bf8:	0722                	slli	a4,a4,0x8
 3003bfa:	76c1                	lui	a3,0xffff0
 3003bfc:	0ff68693          	addi	a3,a3,255 # ffff00ff <RAM_END+0xfbfe80ff>
 3003c00:	8ff5                	and	a5,a5,a3
 3003c02:	8fd9                	or	a5,a5,a4
 3003c04:	fef42023          	sw	a5,-32(s0)
    canHandle->baseAddress->IF1_DATAB2 = dataB2;
 3003c08:	fdc42783          	lw	a5,-36(s0)
 3003c0c:	439c                	lw	a5,0(a5)
 3003c0e:	fe042703          	lw	a4,-32(s0)
 3003c12:	c7b8                	sw	a4,72(a5)
}
 3003c14:	0001                	nop
 3003c16:	50b2                	lw	ra,44(sp)
 3003c18:	5422                	lw	s0,40(sp)
 3003c1a:	6145                	addi	sp,sp,48
 3003c1c:	8082                	ret

03003c1e <HAL_CAN_Write>:
  * @note:
  *      IF1 and IF2 have the same functions. To facilitate management,
  *      IF1 is used for sending and IF2 is used for receiving.
  */
BASE_StatusType HAL_CAN_Write(CAN_Handle *canHandle, CANFrame *data)
{
 3003c1e:	7179                	addi	sp,sp,-48
 3003c20:	d606                	sw	ra,44(sp)
 3003c22:	d422                	sw	s0,40(sp)
 3003c24:	1800                	addi	s0,sp,48
 3003c26:	fca42e23          	sw	a0,-36(s0)
 3003c2a:	fcb42c23          	sw	a1,-40(s0)
    CAN_ASSERT_PARAM(canHandle != NULL && data != NULL);
    CAN_ASSERT_PARAM(IsCANInstance(canHandle->baseAddress));
    CAN_PARAM_CHECK_WITH_RET(data->dataLength <= 8, BASE_STATUS_ERROR);  /* CAN frame length: 1 ~ 8 */
    if (canHandle->state != CAN_STATE_READY) {
 3003c2e:	fdc42783          	lw	a5,-36(s0)
 3003c32:	4fd8                	lw	a4,28(a5)
 3003c34:	4785                	li	a5,1
 3003c36:	00f70463          	beq	a4,a5,3003c3e <HAL_CAN_Write+0x20>
        return BASE_STATUS_BUSY;
 3003c3a:	4789                	li	a5,2
 3003c3c:	a2dd                	j	3003e22 <HAL_CAN_Write+0x204>
    }
    canHandle->state = CAN_STATE_BUSY_TX;
 3003c3e:	fdc42783          	lw	a5,-36(s0)
 3003c42:	4709                	li	a4,2
 3003c44:	cfd8                	sw	a4,28(a5)
    unsigned int objId = 0;
 3003c46:	fe042623          	sw	zero,-20(s0)
    unsigned int id;
    for (int i = BOUND_ID + 1; i <= CAN_OBJ_MAXNUM; i++) {
 3003c4a:	47e5                	li	a5,25
 3003c4c:	fef42223          	sw	a5,-28(s0)
 3003c50:	a82d                	j	3003c8a <HAL_CAN_Write+0x6c>
        if (g_msgObj[i - 1] == 0) {
 3003c52:	fe442783          	lw	a5,-28(s0)
 3003c56:	17fd                	addi	a5,a5,-1
 3003c58:	e2418713          	addi	a4,gp,-476 # 4000520 <g_msgObj>
 3003c5c:	078a                	slli	a5,a5,0x2
 3003c5e:	97ba                	add	a5,a5,a4
 3003c60:	439c                	lw	a5,0(a5)
 3003c62:	ef99                	bnez	a5,3003c80 <HAL_CAN_Write+0x62>
            g_msgObj[i - 1] = 1;
 3003c64:	fe442783          	lw	a5,-28(s0)
 3003c68:	17fd                	addi	a5,a5,-1
 3003c6a:	e2418713          	addi	a4,gp,-476 # 4000520 <g_msgObj>
 3003c6e:	078a                	slli	a5,a5,0x2
 3003c70:	97ba                	add	a5,a5,a4
 3003c72:	4705                	li	a4,1
 3003c74:	c398                	sw	a4,0(a5)
            objId = i;
 3003c76:	fe442783          	lw	a5,-28(s0)
 3003c7a:	fef42623          	sw	a5,-20(s0)
            break;
 3003c7e:	a821                	j	3003c96 <HAL_CAN_Write+0x78>
    for (int i = BOUND_ID + 1; i <= CAN_OBJ_MAXNUM; i++) {
 3003c80:	fe442783          	lw	a5,-28(s0)
 3003c84:	0785                	addi	a5,a5,1
 3003c86:	fef42223          	sw	a5,-28(s0)
 3003c8a:	fe442703          	lw	a4,-28(s0)
 3003c8e:	02000793          	li	a5,32
 3003c92:	fce7d0e3          	bge	a5,a4,3003c52 <HAL_CAN_Write+0x34>
        }
    }
    if (objId == 0) {
 3003c96:	fec42783          	lw	a5,-20(s0)
 3003c9a:	e399                	bnez	a5,3003ca0 <HAL_CAN_Write+0x82>
        return BASE_STATUS_ERROR;
 3003c9c:	4785                	li	a5,1
 3003c9e:	a251                	j	3003e22 <HAL_CAN_Write+0x204>
    }
    /* Step1: write id into register arbitration according frame type */
    switch (data->type) {
 3003ca0:	fd842783          	lw	a5,-40(s0)
 3003ca4:	439c                	lw	a5,0(a5)
 3003ca6:	4705                	li	a4,1
 3003ca8:	04e78263          	beq	a5,a4,3003cec <HAL_CAN_Write+0xce>
 3003cac:	4705                	li	a4,1
 3003cae:	00e7e963          	bltu	a5,a4,3003cc0 <HAL_CAN_Write+0xa2>
 3003cb2:	4709                	li	a4,2
 3003cb4:	06e78763          	beq	a5,a4,3003d22 <HAL_CAN_Write+0x104>
 3003cb8:	470d                	li	a4,3
 3003cba:	08e78c63          	beq	a5,a4,3003d52 <HAL_CAN_Write+0x134>
 3003cbe:	a0e9                	j	3003d88 <HAL_CAN_Write+0x16a>
        case CAN_TYPEFRAME_STD_DATA:                                /* Standard data frame */
            id = (data->CANId & CAN_STD_MASK) << 2;                 /* Bit[12:2] = CANId */
 3003cc0:	fd842783          	lw	a5,-40(s0)
 3003cc4:	479c                	lw	a5,8(a5)
 3003cc6:	00279713          	slli	a4,a5,0x2
 3003cca:	6789                	lui	a5,0x2
 3003ccc:	17f1                	addi	a5,a5,-4 # 1ffc <__bss_size__+0x1388>
 3003cce:	8ff9                	and	a5,a5,a4
 3003cd0:	fef42423          	sw	a5,-24(s0)
            id |= 0xA000;                                           /* [15:13] = 0x05 */
 3003cd4:	fe842703          	lw	a4,-24(s0)
 3003cd8:	67a9                	lui	a5,0xa
 3003cda:	8fd9                	or	a5,a5,a4
 3003cdc:	fef42423          	sw	a5,-24(s0)
            canHandle->baseAddress->IF1_ARBITRATION1.reg = 0x00;
 3003ce0:	fdc42783          	lw	a5,-36(s0)
 3003ce4:	439c                	lw	a5,0(a5)
 3003ce6:	0207a823          	sw	zero,48(a5) # a030 <RAM_SIZE+0x5030>
            break;
 3003cea:	a04d                	j	3003d8c <HAL_CAN_Write+0x16e>
        case CAN_TYPEFRAME_EXT_DATA:                                /* Extended data frame */
            id = (data->CANId & CAN_EXT_MASK) >> 16;                /* Bit[12:0] = CANId(28bit~16bit) */
 3003cec:	fd842783          	lw	a5,-40(s0)
 3003cf0:	479c                	lw	a5,8(a5)
 3003cf2:	0107d713          	srli	a4,a5,0x10
 3003cf6:	6789                	lui	a5,0x2
 3003cf8:	17fd                	addi	a5,a5,-1 # 1fff <__bss_size__+0x138b>
 3003cfa:	8ff9                	and	a5,a5,a4
 3003cfc:	fef42423          	sw	a5,-24(s0)
            id |= 0xE000;                                           /* [15:13] = 0x07 */
 3003d00:	fe842703          	lw	a4,-24(s0)
 3003d04:	67b9                	lui	a5,0xe
 3003d06:	8fd9                	or	a5,a5,a4
 3003d08:	fef42423          	sw	a5,-24(s0)
            canHandle->baseAddress->IF1_ARBITRATION1.reg = (data->CANId & 0xFFFF);  /* write lower 16bits CANId */
 3003d0c:	fd842783          	lw	a5,-40(s0)
 3003d10:	4794                	lw	a3,8(a5)
 3003d12:	fdc42783          	lw	a5,-36(s0)
 3003d16:	439c                	lw	a5,0(a5)
 3003d18:	6741                	lui	a4,0x10
 3003d1a:	177d                	addi	a4,a4,-1 # ffff <RAM_SIZE+0xafff>
 3003d1c:	8f75                	and	a4,a4,a3
 3003d1e:	db98                	sw	a4,48(a5)
            break;
 3003d20:	a0b5                	j	3003d8c <HAL_CAN_Write+0x16e>
        case CAN_TYPEFRAME_STD_REMOTE:                              /* Standard remote frame */
            id = (data->CANId & CAN_EXT_MASK) << 2;                 /* Bit[12:2] = CANId */
 3003d22:	fd842783          	lw	a5,-40(s0)
 3003d26:	479c                	lw	a5,8(a5)
 3003d28:	00279713          	slli	a4,a5,0x2
 3003d2c:	800007b7          	lui	a5,0x80000
 3003d30:	ffc7c793          	xori	a5,a5,-4
 3003d34:	8ff9                	and	a5,a5,a4
 3003d36:	fef42423          	sw	a5,-24(s0)
            id |= 0x8000;                                           /* [15:13] = 0x04 */
 3003d3a:	fe842703          	lw	a4,-24(s0)
 3003d3e:	67a1                	lui	a5,0x8
 3003d40:	8fd9                	or	a5,a5,a4
 3003d42:	fef42423          	sw	a5,-24(s0)
            canHandle->baseAddress->IF1_ARBITRATION1.reg = 0x00;
 3003d46:	fdc42783          	lw	a5,-36(s0)
 3003d4a:	439c                	lw	a5,0(a5)
 3003d4c:	0207a823          	sw	zero,48(a5) # 8030 <RAM_SIZE+0x3030>
            break;
 3003d50:	a835                	j	3003d8c <HAL_CAN_Write+0x16e>
        case CAN_TYPEFRAME_EXT_REMOTE:                              /* Extended remote frame */
            id = (data->CANId & CAN_EXT_MASK) >> 16;                /* Bit[12:0] = CANId(28bit~16bit) */
 3003d52:	fd842783          	lw	a5,-40(s0)
 3003d56:	479c                	lw	a5,8(a5)
 3003d58:	0107d713          	srli	a4,a5,0x10
 3003d5c:	6789                	lui	a5,0x2
 3003d5e:	17fd                	addi	a5,a5,-1 # 1fff <__bss_size__+0x138b>
 3003d60:	8ff9                	and	a5,a5,a4
 3003d62:	fef42423          	sw	a5,-24(s0)
            id |= 0xC000;                                           /* [15:13] = 0x06 */
 3003d66:	fe842703          	lw	a4,-24(s0)
 3003d6a:	67b1                	lui	a5,0xc
 3003d6c:	8fd9                	or	a5,a5,a4
 3003d6e:	fef42423          	sw	a5,-24(s0)
            canHandle->baseAddress->IF1_ARBITRATION1.reg = (data->CANId & 0xFFFF);  /* write lower 16bits CANId */
 3003d72:	fd842783          	lw	a5,-40(s0)
 3003d76:	4794                	lw	a3,8(a5)
 3003d78:	fdc42783          	lw	a5,-36(s0)
 3003d7c:	439c                	lw	a5,0(a5)
 3003d7e:	6741                	lui	a4,0x10
 3003d80:	177d                	addi	a4,a4,-1 # ffff <RAM_SIZE+0xafff>
 3003d82:	8f75                	and	a4,a4,a3
 3003d84:	db98                	sw	a4,48(a5)
            break;
 3003d86:	a019                	j	3003d8c <HAL_CAN_Write+0x16e>
        default:
            return BASE_STATUS_ERROR;
 3003d88:	4785                	li	a5,1
 3003d8a:	a861                	j	3003e22 <HAL_CAN_Write+0x204>
    }
    canHandle->baseAddress->IF1_ARBITRATION2.reg = id;
 3003d8c:	fdc42783          	lw	a5,-36(s0)
 3003d90:	439c                	lw	a5,0(a5)
 3003d92:	fe842703          	lw	a4,-24(s0)
 3003d96:	dbd8                	sw	a4,52(a5)
    /* Step2: setting mask register 2 */
    canHandle->baseAddress->IF1_MASK2.reg = 0x8000;
 3003d98:	fdc42783          	lw	a5,-36(s0)
 3003d9c:	439c                	lw	a5,0(a5)
 3003d9e:	6721                	lui	a4,0x8
 3003da0:	d7d8                	sw	a4,44(a5)
    /* Step3: setting mask register 1 */
    canHandle->baseAddress->IF1_MASK1.reg = 0x0000;
 3003da2:	fdc42783          	lw	a5,-36(s0)
 3003da6:	439c                	lw	a5,0(a5)
 3003da8:	0207a423          	sw	zero,40(a5) # c028 <RAM_SIZE+0x7028>
    /* Step4: setting message control register */
    canHandle->baseAddress->IF1_MESSAGE_CONTROL.reg |= 0x8980;
 3003dac:	fdc42783          	lw	a5,-36(s0)
 3003db0:	439c                	lw	a5,0(a5)
 3003db2:	5f94                	lw	a3,56(a5)
 3003db4:	fdc42783          	lw	a5,-36(s0)
 3003db8:	439c                	lw	a5,0(a5)
 3003dba:	6725                	lui	a4,0x9
 3003dbc:	98070713          	addi	a4,a4,-1664 # 8980 <RAM_SIZE+0x3980>
 3003dc0:	8f55                	or	a4,a4,a3
 3003dc2:	df98                	sw	a4,56(a5)
    canHandle->baseAddress->IF1_MESSAGE_CONTROL.BIT.DLC = data->dataLength;
 3003dc4:	fd842783          	lw	a5,-40(s0)
 3003dc8:	43d4                	lw	a3,4(a5)
 3003dca:	fdc42783          	lw	a5,-36(s0)
 3003dce:	4398                	lw	a4,0(a5)
 3003dd0:	87b6                	mv	a5,a3
 3003dd2:	8bbd                	andi	a5,a5,15
 3003dd4:	0ff7f693          	andi	a3,a5,255
 3003dd8:	5f1c                	lw	a5,56(a4)
 3003dda:	8abd                	andi	a3,a3,15
 3003ddc:	9bc1                	andi	a5,a5,-16
 3003dde:	8fd5                	or	a5,a5,a3
 3003de0:	df1c                	sw	a5,56(a4)
    /* Step5: write data to be sent */
    WriteData(canHandle, data);
 3003de2:	fd842583          	lw	a1,-40(s0)
 3003de6:	fdc42503          	lw	a0,-36(s0)
 3003dea:	3319                	jal	ra,3003af0 <WriteData>
    /* Step6: send configuration to packet objects */
    canHandle->baseAddress->IF1_COMMAND_MASK.reg = 0xF3;
 3003dec:	fdc42783          	lw	a5,-36(s0)
 3003df0:	439c                	lw	a5,0(a5)
 3003df2:	0f300713          	li	a4,243
 3003df6:	d3d8                	sw	a4,36(a5)
    /* Step7: write IF1 request command */
    canHandle->baseAddress->IF1_COMMAND_REQUEST.BIT.MessageNumber = objId;
 3003df8:	fdc42783          	lw	a5,-36(s0)
 3003dfc:	4398                	lw	a4,0(a5)
 3003dfe:	fec42783          	lw	a5,-20(s0)
 3003e02:	03f7f793          	andi	a5,a5,63
 3003e06:	0ff7f693          	andi	a3,a5,255
 3003e0a:	531c                	lw	a5,32(a4)
 3003e0c:	03f6f693          	andi	a3,a3,63
 3003e10:	fc07f793          	andi	a5,a5,-64
 3003e14:	8fd5                	or	a5,a5,a3
 3003e16:	d31c                	sw	a5,32(a4)
    canHandle->state = CAN_STATE_READY;
 3003e18:	fdc42783          	lw	a5,-36(s0)
 3003e1c:	4705                	li	a4,1
 3003e1e:	cfd8                	sw	a4,28(a5)
    return BASE_STATUS_OK;
 3003e20:	4781                	li	a5,0
}
 3003e22:	853e                	mv	a0,a5
 3003e24:	50b2                	lw	ra,44(sp)
 3003e26:	5422                	lw	s0,40(sp)
 3003e28:	6145                	addi	sp,sp,48
 3003e2a:	8082                	ret

03003e2c <CAN_ReadCallback>:
  * @param canHandle CAN handle.
  * @param objId Indicates the packet object ID.
  * @retval BASE status type: OK, ERROR, BUSY, TIMEOUT.
  */
static BASE_StatusType CAN_ReadCallback(CAN_Handle *canHandle, unsigned int objId)
{   
 3003e2c:	7139                	addi	sp,sp,-64
 3003e2e:	de22                	sw	s0,60(sp)
 3003e30:	0080                	addi	s0,sp,64
 3003e32:	fca42623          	sw	a0,-52(s0)
 3003e36:	fcb42423          	sw	a1,-56(s0)
    CAN_ASSERT_PARAM(IsCANInstance(canHandle->baseAddress));
    CAN_PARAM_CHECK_WITH_RET(canHandle->rxFrame != NULL, BASE_STATUS_ERROR);
    CAN_PARAM_CHECK_WITH_RET((objID >= MESSAGE_NUMBER_MIN) && (objID <= MESSAGE_NUMBER_MAX), BASE_STATUS_ERROR);
    unsigned int busy, id, idLow, idHigh,  extendedFrame, remoteFrame;
    /* Step1: setting request transfer to packet object */
    canHandle->baseAddress->IF2_COMMAND_MASK.reg = 0x7F;  /* 0x7F indicates reading data from the packet object */
 3003e3a:	fcc42783          	lw	a5,-52(s0)
 3003e3e:	439c                	lw	a5,0(a5)
 3003e40:	07f00713          	li	a4,127
 3003e44:	08e7a223          	sw	a4,132(a5)
    /* Step2: Request specififed packet object */
    canHandle->baseAddress->IF2_COMMAND_REQUEST.BIT.MessageNumber = objId;
 3003e48:	fcc42783          	lw	a5,-52(s0)
 3003e4c:	4398                	lw	a4,0(a5)
 3003e4e:	fc842783          	lw	a5,-56(s0)
 3003e52:	03f7f793          	andi	a5,a5,63
 3003e56:	0ff7f693          	andi	a3,a5,255
 3003e5a:	08072783          	lw	a5,128(a4)
 3003e5e:	03f6f693          	andi	a3,a3,63
 3003e62:	fc07f793          	andi	a5,a5,-64
 3003e66:	8fd5                	or	a5,a5,a3
 3003e68:	08f72023          	sw	a5,128(a4)
    do {
        busy = canHandle->baseAddress->IF2_COMMAND_REQUEST.BIT.BUSY;
 3003e6c:	fcc42783          	lw	a5,-52(s0)
 3003e70:	439c                	lw	a5,0(a5)
 3003e72:	0807a783          	lw	a5,128(a5)
 3003e76:	83bd                	srli	a5,a5,0xf
 3003e78:	8b85                	andi	a5,a5,1
 3003e7a:	9f81                	uxtb	a5
 3003e7c:	fef42623          	sw	a5,-20(s0)
    } while (busy != 0x00);
 3003e80:	fec42783          	lw	a5,-20(s0)
 3003e84:	f7e5                	bnez	a5,3003e6c <CAN_ReadCallback+0x40>
    /* Step3: Obtains packet information */
    extendedFrame = canHandle->baseAddress->IF2_ARBITRATION2.BIT.Xtd;
 3003e86:	fcc42783          	lw	a5,-52(s0)
 3003e8a:	439c                	lw	a5,0(a5)
 3003e8c:	0947a783          	lw	a5,148(a5)
 3003e90:	83b9                	srli	a5,a5,0xe
 3003e92:	8b85                	andi	a5,a5,1
 3003e94:	9f81                	uxtb	a5
 3003e96:	fef42423          	sw	a5,-24(s0)
    remoteFrame = canHandle->baseAddress->IF2_ARBITRATION2.BIT.Dir;
 3003e9a:	fcc42783          	lw	a5,-52(s0)
 3003e9e:	439c                	lw	a5,0(a5)
 3003ea0:	0947a783          	lw	a5,148(a5)
 3003ea4:	83b5                	srli	a5,a5,0xd
 3003ea6:	8b85                	andi	a5,a5,1
 3003ea8:	9f81                	uxtb	a5
 3003eaa:	fef42223          	sw	a5,-28(s0)
    if (extendedFrame == BASE_CFG_ENABLE) {
 3003eae:	fe842703          	lw	a4,-24(s0)
 3003eb2:	4785                	li	a5,1
 3003eb4:	08f71b63          	bne	a4,a5,3003f4a <CAN_ReadCallback+0x11e>
        idLow = canHandle->baseAddress->IF2_ARBITRATION1.BIT.ID;
 3003eb8:	fcc42783          	lw	a5,-52(s0)
 3003ebc:	439c                	lw	a5,0(a5)
 3003ebe:	0907a783          	lw	a5,144(a5)
 3003ec2:	9fa1                	uxth	a5
 3003ec4:	fcf42e23          	sw	a5,-36(s0)
        idHigh = canHandle->baseAddress->IF2_ARBITRATION2.BIT.ID;
 3003ec8:	fcc42783          	lw	a5,-52(s0)
 3003ecc:	439c                	lw	a5,0(a5)
 3003ece:	0947a783          	lw	a5,148(a5)
 3003ed2:	873e                	mv	a4,a5
 3003ed4:	6789                	lui	a5,0x2
 3003ed6:	17fd                	addi	a5,a5,-1 # 1fff <__bss_size__+0x138b>
 3003ed8:	8ff9                	and	a5,a5,a4
 3003eda:	9fa1                	uxth	a5
 3003edc:	fcf42c23          	sw	a5,-40(s0)
        id = idLow;
 3003ee0:	fdc42783          	lw	a5,-36(s0)
 3003ee4:	fef42023          	sw	a5,-32(s0)
        idHigh <<= 16;  /* High 16 bits ID */
 3003ee8:	fd842783          	lw	a5,-40(s0)
 3003eec:	07c2                	slli	a5,a5,0x10
 3003eee:	fcf42c23          	sw	a5,-40(s0)
        id |= idHigh;
 3003ef2:	fe042703          	lw	a4,-32(s0)
 3003ef6:	fd842783          	lw	a5,-40(s0)
 3003efa:	8fd9                	or	a5,a5,a4
 3003efc:	fef42023          	sw	a5,-32(s0)
        canHandle->rxFrame->CANId = id;
 3003f00:	fcc42783          	lw	a5,-52(s0)
 3003f04:	539c                	lw	a5,32(a5)
 3003f06:	fe042703          	lw	a4,-32(s0)
 3003f0a:	c798                	sw	a4,8(a5)
        id |= CAN_EFF_FLAG;
 3003f0c:	fe042703          	lw	a4,-32(s0)
 3003f10:	800007b7          	lui	a5,0x80000
 3003f14:	8fd9                	or	a5,a5,a4
 3003f16:	fef42023          	sw	a5,-32(s0)
        if (remoteFrame == BASE_CFG_ENABLE) {
 3003f1a:	fe442703          	lw	a4,-28(s0)
 3003f1e:	4785                	li	a5,1
 3003f20:	00f71f63          	bne	a4,a5,3003f3e <CAN_ReadCallback+0x112>
            id |= CAN_RTR_FLAG;
 3003f24:	fe042703          	lw	a4,-32(s0)
 3003f28:	400007b7          	lui	a5,0x40000
 3003f2c:	8fd9                	or	a5,a5,a4
 3003f2e:	fef42023          	sw	a5,-32(s0)
            canHandle->rxFrame->type = CAN_TYPEFRAME_EXT_REMOTE;
 3003f32:	fcc42783          	lw	a5,-52(s0)
 3003f36:	539c                	lw	a5,32(a5)
 3003f38:	470d                	li	a4,3
 3003f3a:	c398                	sw	a4,0(a5)
 3003f3c:	a0ad                	j	3003fa6 <CAN_ReadCallback+0x17a>
        } else {
            canHandle->rxFrame->type = CAN_TYPEFRAME_EXT_DATA;
 3003f3e:	fcc42783          	lw	a5,-52(s0)
 3003f42:	539c                	lw	a5,32(a5)
 3003f44:	4705                	li	a4,1
 3003f46:	c398                	sw	a4,0(a5)
 3003f48:	a8b9                	j	3003fa6 <CAN_ReadCallback+0x17a>
        }
    } else {
        id = canHandle->baseAddress->IF2_ARBITRATION2.BIT.ID;
 3003f4a:	fcc42783          	lw	a5,-52(s0)
 3003f4e:	439c                	lw	a5,0(a5)
 3003f50:	0947a783          	lw	a5,148(a5) # 40000094 <RAM_END+0x3bff8094>
 3003f54:	873e                	mv	a4,a5
 3003f56:	6789                	lui	a5,0x2
 3003f58:	17fd                	addi	a5,a5,-1 # 1fff <__bss_size__+0x138b>
 3003f5a:	8ff9                	and	a5,a5,a4
 3003f5c:	9fa1                	uxth	a5
 3003f5e:	fef42023          	sw	a5,-32(s0)
        id >>= 2;  /* 2: Standard frame CAN id. */
 3003f62:	fe042783          	lw	a5,-32(s0)
 3003f66:	8389                	srli	a5,a5,0x2
 3003f68:	fef42023          	sw	a5,-32(s0)
        canHandle->rxFrame->CANId = id;
 3003f6c:	fcc42783          	lw	a5,-52(s0)
 3003f70:	539c                	lw	a5,32(a5)
 3003f72:	fe042703          	lw	a4,-32(s0)
 3003f76:	c798                	sw	a4,8(a5)
        if (remoteFrame == BASE_CFG_ENABLE) {
 3003f78:	fe442703          	lw	a4,-28(s0)
 3003f7c:	4785                	li	a5,1
 3003f7e:	00f71f63          	bne	a4,a5,3003f9c <CAN_ReadCallback+0x170>
            id |= CAN_RTR_FLAG;
 3003f82:	fe042703          	lw	a4,-32(s0)
 3003f86:	400007b7          	lui	a5,0x40000
 3003f8a:	8fd9                	or	a5,a5,a4
 3003f8c:	fef42023          	sw	a5,-32(s0)
            canHandle->rxFrame->type = CAN_TYPEFRAME_STD_REMOTE;
 3003f90:	fcc42783          	lw	a5,-52(s0)
 3003f94:	539c                	lw	a5,32(a5)
 3003f96:	4709                	li	a4,2
 3003f98:	c398                	sw	a4,0(a5)
 3003f9a:	a031                	j	3003fa6 <CAN_ReadCallback+0x17a>
        } else {
            canHandle->rxFrame->type = CAN_TYPEFRAME_STD_DATA;
 3003f9c:	fcc42783          	lw	a5,-52(s0)
 3003fa0:	539c                	lw	a5,32(a5)
 3003fa2:	0007a023          	sw	zero,0(a5) # 40000000 <RAM_END+0x3bff8000>
        }
    }
    canHandle->rxFrame->dataLength = canHandle->baseAddress->IF2_MESSAGE_CONTROL.BIT.DLC;
 3003fa6:	fcc42783          	lw	a5,-52(s0)
 3003faa:	439c                	lw	a5,0(a5)
 3003fac:	0987a783          	lw	a5,152(a5)
 3003fb0:	8bbd                	andi	a5,a5,15
 3003fb2:	0ff7f713          	andi	a4,a5,255
 3003fb6:	fcc42783          	lw	a5,-52(s0)
 3003fba:	539c                	lw	a5,32(a5)
 3003fbc:	c3d8                	sw	a4,4(a5)
    canHandle->rxFrame->frame[0] = canHandle->baseAddress->IF2_DATAA1.BIT.DATA0;  /* Data of bit 0 */
 3003fbe:	fcc42783          	lw	a5,-52(s0)
 3003fc2:	4398                	lw	a4,0(a5)
 3003fc4:	fcc42783          	lw	a5,-52(s0)
 3003fc8:	539c                	lw	a5,32(a5)
 3003fca:	09c72703          	lw	a4,156(a4)
 3003fce:	9f01                	uxtb	a4
 3003fd0:	a7d8                	sb	a4,12(a5)
    canHandle->rxFrame->frame[1] = canHandle->baseAddress->IF2_DATAA1.BIT.DATA1;  /* Data of bit 1 */
 3003fd2:	fcc42783          	lw	a5,-52(s0)
 3003fd6:	4398                	lw	a4,0(a5)
 3003fd8:	fcc42783          	lw	a5,-52(s0)
 3003fdc:	539c                	lw	a5,32(a5)
 3003fde:	09c72703          	lw	a4,156(a4)
 3003fe2:	8321                	srli	a4,a4,0x8
 3003fe4:	9b7d                	andi	a4,a4,-1
 3003fe6:	9f01                	uxtb	a4
 3003fe8:	b7d8                	sb	a4,13(a5)
    canHandle->rxFrame->frame[2] = canHandle->baseAddress->IF2_DATAA2.BIT.DATA2;  /* Data of bit 2 */
 3003fea:	fcc42783          	lw	a5,-52(s0)
 3003fee:	4398                	lw	a4,0(a5)
 3003ff0:	fcc42783          	lw	a5,-52(s0)
 3003ff4:	539c                	lw	a5,32(a5)
 3003ff6:	0a072703          	lw	a4,160(a4)
 3003ffa:	9f01                	uxtb	a4
 3003ffc:	a7f8                	sb	a4,14(a5)
    canHandle->rxFrame->frame[3] = canHandle->baseAddress->IF2_DATAA2.BIT.DATA3;  /* Data of bit 3 */
 3003ffe:	fcc42783          	lw	a5,-52(s0)
 3004002:	4398                	lw	a4,0(a5)
 3004004:	fcc42783          	lw	a5,-52(s0)
 3004008:	539c                	lw	a5,32(a5)
 300400a:	0a072703          	lw	a4,160(a4)
 300400e:	8321                	srli	a4,a4,0x8
 3004010:	9b7d                	andi	a4,a4,-1
 3004012:	9f01                	uxtb	a4
 3004014:	b7f8                	sb	a4,15(a5)
    canHandle->rxFrame->frame[4] = canHandle->baseAddress->IF2_DATAB1.BIT.DATA4;  /* Data of bit 4 */
 3004016:	fcc42783          	lw	a5,-52(s0)
 300401a:	4398                	lw	a4,0(a5)
 300401c:	fcc42783          	lw	a5,-52(s0)
 3004020:	539c                	lw	a5,32(a5)
 3004022:	0a472703          	lw	a4,164(a4)
 3004026:	9f01                	uxtb	a4
 3004028:	ab98                	sb	a4,16(a5)
    canHandle->rxFrame->frame[5] = canHandle->baseAddress->IF2_DATAB1.BIT.DATA5;  /* Data of bit 5 */
 300402a:	fcc42783          	lw	a5,-52(s0)
 300402e:	4398                	lw	a4,0(a5)
 3004030:	fcc42783          	lw	a5,-52(s0)
 3004034:	539c                	lw	a5,32(a5)
 3004036:	0a472703          	lw	a4,164(a4)
 300403a:	8321                	srli	a4,a4,0x8
 300403c:	9b7d                	andi	a4,a4,-1
 300403e:	9f01                	uxtb	a4
 3004040:	bb98                	sb	a4,17(a5)
    canHandle->rxFrame->frame[6] = canHandle->baseAddress->IF2_DATAB2.BIT.DATA6;  /* Data of bit 6 */
 3004042:	fcc42783          	lw	a5,-52(s0)
 3004046:	4398                	lw	a4,0(a5)
 3004048:	fcc42783          	lw	a5,-52(s0)
 300404c:	539c                	lw	a5,32(a5)
 300404e:	0a872703          	lw	a4,168(a4)
 3004052:	9f01                	uxtb	a4
 3004054:	abb8                	sb	a4,18(a5)
    canHandle->rxFrame->frame[7] = canHandle->baseAddress->IF2_DATAB2.BIT.DATA7;  /* Data of bit 7 */
 3004056:	fcc42783          	lw	a5,-52(s0)
 300405a:	4398                	lw	a4,0(a5)
 300405c:	fcc42783          	lw	a5,-52(s0)
 3004060:	539c                	lw	a5,32(a5)
 3004062:	0a872703          	lw	a4,168(a4)
 3004066:	8321                	srli	a4,a4,0x8
 3004068:	9b7d                	andi	a4,a4,-1
 300406a:	9f01                	uxtb	a4
 300406c:	bbb8                	sb	a4,19(a5)
    return BASE_STATUS_OK;
 300406e:	4781                	li	a5,0
}
 3004070:	853e                	mv	a0,a5
 3004072:	5472                	lw	s0,60(sp)
 3004074:	6121                	addi	sp,sp,64
 3004076:	8082                	ret

03004078 <CAN_ReceiveFilter>:
  * @param CAN_FilterConfigure handle of filtering configuration, @ref CAN_FilterConfigure
  * @param objId Indicates the packet object ID.
  * @retval BASE status type: OK, ERROR, BUSY, TIMEOUT.
  */
static void CAN_ReceiveFilter(CAN_Handle *canHandle, const CAN_FilterConfigure *filterConfigure, unsigned int objId)
{
 3004078:	7179                	addi	sp,sp,-48
 300407a:	d622                	sw	s0,44(sp)
 300407c:	1800                	addi	s0,sp,48
 300407e:	fca42e23          	sw	a0,-36(s0)
 3004082:	fcb42c23          	sw	a1,-40(s0)
 3004086:	fcc42a23          	sw	a2,-44(s0)
    unsigned int id, idChg;
    unsigned int mask, maskChg;
    idChg = filterConfigure->filterID & 0xFFFF;
 300408a:	fd842783          	lw	a5,-40(s0)
 300408e:	43d8                	lw	a4,4(a5)
 3004090:	67c1                	lui	a5,0x10
 3004092:	17fd                	addi	a5,a5,-1 # ffff <RAM_SIZE+0xafff>
 3004094:	8ff9                	and	a5,a5,a4
 3004096:	fef42423          	sw	a5,-24(s0)
    maskChg = filterConfigure->filterMask & 0xFFFF;
 300409a:	fd842783          	lw	a5,-40(s0)
 300409e:	4798                	lw	a4,8(a5)
 30040a0:	67c1                	lui	a5,0x10
 30040a2:	17fd                	addi	a5,a5,-1 # ffff <RAM_SIZE+0xafff>
 30040a4:	8ff9                	and	a5,a5,a4
 30040a6:	fef42023          	sw	a5,-32(s0)
    switch (filterConfigure->receiveType) {
 30040aa:	fd842783          	lw	a5,-40(s0)
 30040ae:	439c                	lw	a5,0(a5)
 30040b0:	4705                	li	a4,1
 30040b2:	04e78e63          	beq	a5,a4,300410e <CAN_ReceiveFilter+0x96>
 30040b6:	4705                	li	a4,1
 30040b8:	00e7e663          	bltu	a5,a4,30040c4 <CAN_ReceiveFilter+0x4c>
 30040bc:	4709                	li	a4,2
 30040be:	08e78963          	beq	a5,a4,3004150 <CAN_ReceiveFilter+0xd8>
            id |= 0xC000;
            mask = (filterConfigure->filterMask & CAN_EXT_MASK) >> 16;  /* Remove the lower 16 bits */
            mask |= 0x4000;                                             /* [15]MXtd = 0 */
            break;
        default:
            return;
 30040c2:	aa41                	j	3004252 <CAN_ReceiveFilter+0x1da>
            id = (filterConfigure->filterID & CAN_STD_MASK) << 2;       /* Bit[12:2] = CANId */
 30040c4:	fd842783          	lw	a5,-40(s0)
 30040c8:	43dc                	lw	a5,4(a5)
 30040ca:	00279713          	slli	a4,a5,0x2
 30040ce:	6789                	lui	a5,0x2
 30040d0:	17f1                	addi	a5,a5,-4 # 1ffc <__bss_size__+0x1388>
 30040d2:	8ff9                	and	a5,a5,a4
 30040d4:	fef42623          	sw	a5,-20(s0)
            id |= 0x8000;
 30040d8:	fec42703          	lw	a4,-20(s0)
 30040dc:	67a1                	lui	a5,0x8
 30040de:	8fd9                	or	a5,a5,a4
 30040e0:	fef42623          	sw	a5,-20(s0)
            idChg = 0x0000;
 30040e4:	fe042423          	sw	zero,-24(s0)
            mask = (filterConfigure->filterMask & CAN_STD_MASK) << 2;
 30040e8:	fd842783          	lw	a5,-40(s0)
 30040ec:	479c                	lw	a5,8(a5)
 30040ee:	00279713          	slli	a4,a5,0x2
 30040f2:	6789                	lui	a5,0x2
 30040f4:	17f1                	addi	a5,a5,-4 # 1ffc <__bss_size__+0x1388>
 30040f6:	8ff9                	and	a5,a5,a4
 30040f8:	fef42223          	sw	a5,-28(s0)
            mask |= 0xC000;
 30040fc:	fe442703          	lw	a4,-28(s0)
 3004100:	67b1                	lui	a5,0xc
 3004102:	8fd9                	or	a5,a5,a4
 3004104:	fef42223          	sw	a5,-28(s0)
            maskChg = 0x0000;
 3004108:	fe042023          	sw	zero,-32(s0)
            break;
 300410c:	a059                	j	3004192 <CAN_ReceiveFilter+0x11a>
            id = (filterConfigure->filterID & CAN_EXT_MASK) >> 16;              /* Bit[12:0] = CANId(28bit ~ 16bit) */
 300410e:	fd842783          	lw	a5,-40(s0)
 3004112:	43dc                	lw	a5,4(a5)
 3004114:	0107d713          	srli	a4,a5,0x10
 3004118:	6789                	lui	a5,0x2
 300411a:	17fd                	addi	a5,a5,-1 # 1fff <__bss_size__+0x138b>
 300411c:	8ff9                	and	a5,a5,a4
 300411e:	fef42623          	sw	a5,-20(s0)
            id |= 0xC000;
 3004122:	fec42703          	lw	a4,-20(s0)
 3004126:	67b1                	lui	a5,0xc
 3004128:	8fd9                	or	a5,a5,a4
 300412a:	fef42623          	sw	a5,-20(s0)
            mask = (filterConfigure->filterMask & CAN_EXT_MASK) >> 16;  /* Remove the lower 16 bits */
 300412e:	fd842783          	lw	a5,-40(s0)
 3004132:	479c                	lw	a5,8(a5)
 3004134:	0107d713          	srli	a4,a5,0x10
 3004138:	6789                	lui	a5,0x2
 300413a:	17fd                	addi	a5,a5,-1 # 1fff <__bss_size__+0x138b>
 300413c:	8ff9                	and	a5,a5,a4
 300413e:	fef42223          	sw	a5,-28(s0)
            mask |= 0xC000;
 3004142:	fe442703          	lw	a4,-28(s0)
 3004146:	67b1                	lui	a5,0xc
 3004148:	8fd9                	or	a5,a5,a4
 300414a:	fef42223          	sw	a5,-28(s0)
            break;
 300414e:	a091                	j	3004192 <CAN_ReceiveFilter+0x11a>
            id = (filterConfigure->filterID & CAN_EXT_MASK) >> 16;       /* Remove the lower 16 bits */
 3004150:	fd842783          	lw	a5,-40(s0)
 3004154:	43dc                	lw	a5,4(a5)
 3004156:	0107d713          	srli	a4,a5,0x10
 300415a:	6789                	lui	a5,0x2
 300415c:	17fd                	addi	a5,a5,-1 # 1fff <__bss_size__+0x138b>
 300415e:	8ff9                	and	a5,a5,a4
 3004160:	fef42623          	sw	a5,-20(s0)
            id |= 0xC000;
 3004164:	fec42703          	lw	a4,-20(s0)
 3004168:	67b1                	lui	a5,0xc
 300416a:	8fd9                	or	a5,a5,a4
 300416c:	fef42623          	sw	a5,-20(s0)
            mask = (filterConfigure->filterMask & CAN_EXT_MASK) >> 16;  /* Remove the lower 16 bits */
 3004170:	fd842783          	lw	a5,-40(s0)
 3004174:	479c                	lw	a5,8(a5)
 3004176:	0107d713          	srli	a4,a5,0x10
 300417a:	6789                	lui	a5,0x2
 300417c:	17fd                	addi	a5,a5,-1 # 1fff <__bss_size__+0x138b>
 300417e:	8ff9                	and	a5,a5,a4
 3004180:	fef42223          	sw	a5,-28(s0)
            mask |= 0x4000;                                             /* [15]MXtd = 0 */
 3004184:	fe442703          	lw	a4,-28(s0)
 3004188:	6791                	lui	a5,0x4
 300418a:	8fd9                	or	a5,a5,a4
 300418c:	fef42223          	sw	a5,-28(s0)
            break;
 3004190:	0001                	nop
    }
    canHandle->baseAddress->IF2_ARBITRATION2.reg = id;
 3004192:	fdc42783          	lw	a5,-36(s0)
 3004196:	439c                	lw	a5,0(a5)
 3004198:	fec42703          	lw	a4,-20(s0)
 300419c:	08e7aa23          	sw	a4,148(a5) # 4094 <STACK_SIZE+0x1494>
    canHandle->baseAddress->IF2_ARBITRATION1.reg = idChg;
 30041a0:	fdc42783          	lw	a5,-36(s0)
 30041a4:	439c                	lw	a5,0(a5)
 30041a6:	fe842703          	lw	a4,-24(s0)
 30041aa:	08e7a823          	sw	a4,144(a5)
    canHandle->baseAddress->IF2_MASK2.reg = mask;
 30041ae:	fdc42783          	lw	a5,-36(s0)
 30041b2:	439c                	lw	a5,0(a5)
 30041b4:	fe442703          	lw	a4,-28(s0)
 30041b8:	08e7a623          	sw	a4,140(a5)
    canHandle->baseAddress->IF2_MASK1.reg = maskChg;
 30041bc:	fdc42783          	lw	a5,-36(s0)
 30041c0:	439c                	lw	a5,0(a5)
 30041c2:	fe042703          	lw	a4,-32(s0)
 30041c6:	08e7a423          	sw	a4,136(a5)
    if (canHandle->rxFIFODepth > BOUND_ID) {
 30041ca:	fdc42783          	lw	a5,-36(s0)
 30041ce:	5798                	lw	a4,40(a5)
 30041d0:	47e1                	li	a5,24
 30041d2:	00e7f663          	bgeu	a5,a4,30041de <CAN_ReceiveFilter+0x166>
        canHandle->rxFIFODepth = BOUND_ID;
 30041d6:	fdc42783          	lw	a5,-36(s0)
 30041da:	4761                	li	a4,24
 30041dc:	d798                	sw	a4,40(a5)
    }
    if (objId < canHandle->rxFIFODepth) {  /* packet objects form the receiving FIFO */
 30041de:	fdc42783          	lw	a5,-36(s0)
 30041e2:	579c                	lw	a5,40(a5)
 30041e4:	fd442703          	lw	a4,-44(s0)
 30041e8:	00f77b63          	bgeu	a4,a5,30041fe <CAN_ReceiveFilter+0x186>
        canHandle->baseAddress->IF2_MESSAGE_CONTROL.reg = 0x1408;   /* EOB is set 0 */
 30041ec:	fdc42783          	lw	a5,-36(s0)
 30041f0:	439c                	lw	a5,0(a5)
 30041f2:	6705                	lui	a4,0x1
 30041f4:	40870713          	addi	a4,a4,1032 # 1408 <__bss_size__+0x794>
 30041f8:	08e7ac23          	sw	a4,152(a5)
 30041fc:	a809                	j	300420e <CAN_ReceiveFilter+0x196>
    } else {
        canHandle->baseAddress->IF2_MESSAGE_CONTROL.reg = 0x1488;   /* EOB is set 1 */
 30041fe:	fdc42783          	lw	a5,-36(s0)
 3004202:	439c                	lw	a5,0(a5)
 3004204:	6705                	lui	a4,0x1
 3004206:	48870713          	addi	a4,a4,1160 # 1488 <__bss_size__+0x814>
 300420a:	08e7ac23          	sw	a4,152(a5)
    }
    /* Step5: send configuration to packet objects */
    canHandle->baseAddress->IF2_COMMAND_MASK.reg = 0x00F3;
 300420e:	fdc42783          	lw	a5,-36(s0)
 3004212:	439c                	lw	a5,0(a5)
 3004214:	0f300713          	li	a4,243
 3004218:	08e7a223          	sw	a4,132(a5)
    /* Step6: write IF2 request command */
    canHandle->baseAddress->IF2_COMMAND_REQUEST.BIT.MessageNumber = objId;
 300421c:	fdc42783          	lw	a5,-36(s0)
 3004220:	4398                	lw	a4,0(a5)
 3004222:	fd442783          	lw	a5,-44(s0)
 3004226:	03f7f793          	andi	a5,a5,63
 300422a:	0ff7f693          	andi	a3,a5,255
 300422e:	08072783          	lw	a5,128(a4)
 3004232:	03f6f693          	andi	a3,a3,63
 3004236:	fc07f793          	andi	a5,a5,-64
 300423a:	8fd5                	or	a5,a5,a3
 300423c:	08f72023          	sw	a5,128(a4)
    canHandle->baseAddress->IF2_COMMAND_REQUEST.BIT.BUSY = 0x01;
 3004240:	fdc42783          	lw	a5,-36(s0)
 3004244:	4398                	lw	a4,0(a5)
 3004246:	08072783          	lw	a5,128(a4)
 300424a:	66a1                	lui	a3,0x8
 300424c:	8fd5                	or	a5,a5,a3
 300424e:	08f72023          	sw	a5,128(a4)
}
 3004252:	5432                	lw	s0,44(sp)
 3004254:	6145                	addi	sp,sp,48
 3004256:	8082                	ret

03004258 <HAL_CAN_ReadIT>:
  * @param data Address for storing CAN data frames, @ref CANFrame
  * @param filterConfigure handle of filtering configuration, @ref CAN_FilterConfigure
  * @retval BASE status type: OK, ERROR, BUSY, TIMEOUT.
  */
BASE_StatusType HAL_CAN_ReadIT(CAN_Handle *canHandle, CANFrame *data, CAN_FilterConfigure *filterConfigure)
{
 3004258:	7179                	addi	sp,sp,-48
 300425a:	d606                	sw	ra,44(sp)
 300425c:	d422                	sw	s0,40(sp)
 300425e:	1800                	addi	s0,sp,48
 3004260:	fca42e23          	sw	a0,-36(s0)
 3004264:	fcb42c23          	sw	a1,-40(s0)
 3004268:	fcc42a23          	sw	a2,-44(s0)
    CAN_ASSERT_PARAM(canHandle != NULL);
    CAN_ASSERT_PARAM(IsCANInstance(canHandle->baseAddress));
    CAN_PARAM_CHECK_WITH_RET(data != NULL, BASE_STATUS_ERROR);
    CAN_PARAM_CHECK_WITH_RET(filterConfigure != NULL, BASE_STATUS_ERROR);
    if (canHandle->state != CAN_STATE_READY) {
 300426c:	fdc42783          	lw	a5,-36(s0)
 3004270:	4fd8                	lw	a4,28(a5)
 3004272:	4785                	li	a5,1
 3004274:	00f70463          	beq	a4,a5,300427c <HAL_CAN_ReadIT+0x24>
        return BASE_STATUS_BUSY;
 3004278:	4789                	li	a5,2
 300427a:	a891                	j	30042ce <HAL_CAN_ReadIT+0x76>
    }
    canHandle->state = CAN_STATE_BUSY_RX;
 300427c:	fdc42783          	lw	a5,-36(s0)
 3004280:	470d                	li	a4,3
 3004282:	cfd8                	sw	a4,28(a5)
    canHandle->rxFrame = data;
 3004284:	fdc42783          	lw	a5,-36(s0)
 3004288:	fd842703          	lw	a4,-40(s0)
 300428c:	d398                	sw	a4,32(a5)
    canHandle->rxFilter = filterConfigure;
 300428e:	fdc42783          	lw	a5,-36(s0)
 3004292:	fd442703          	lw	a4,-44(s0)
 3004296:	d3d8                	sw	a4,36(a5)
    for (int i = 1; i <= BOUND_ID; i++) {
 3004298:	4785                	li	a5,1
 300429a:	fef42623          	sw	a5,-20(s0)
 300429e:	a831                	j	30042ba <HAL_CAN_ReadIT+0x62>
        CAN_ReceiveFilter(canHandle, filterConfigure, i);
 30042a0:	fec42783          	lw	a5,-20(s0)
 30042a4:	863e                	mv	a2,a5
 30042a6:	fd442583          	lw	a1,-44(s0)
 30042aa:	fdc42503          	lw	a0,-36(s0)
 30042ae:	33e9                	jal	ra,3004078 <CAN_ReceiveFilter>
    for (int i = 1; i <= BOUND_ID; i++) {
 30042b0:	fec42783          	lw	a5,-20(s0)
 30042b4:	0785                	addi	a5,a5,1
 30042b6:	fef42623          	sw	a5,-20(s0)
 30042ba:	fec42703          	lw	a4,-20(s0)
 30042be:	47e1                	li	a5,24
 30042c0:	fee7d0e3          	bge	a5,a4,30042a0 <HAL_CAN_ReadIT+0x48>
    }
    canHandle->state = CAN_STATE_READY;
 30042c4:	fdc42783          	lw	a5,-36(s0)
 30042c8:	4705                	li	a4,1
 30042ca:	cfd8                	sw	a4,28(a5)
    return BASE_STATUS_OK;
 30042cc:	4781                	li	a5,0
}
 30042ce:	853e                	mv	a0,a5
 30042d0:	50b2                	lw	ra,44(sp)
 30042d2:	5422                	lw	s0,40(sp)
 30042d4:	6145                	addi	sp,sp,48
 30042d6:	8082                	ret

030042d8 <CAN_ConfigReadReq>:
  * @param canHandle CAN handle.
  * @param objId Indicates the packet object ID.
  * @retval BASE status type: OK, ERROR, BUSY, TIMEOUT.
  */
static BASE_StatusType CAN_ConfigReadReq(CAN_Handle *canHandle, unsigned int objId)
{
 30042d8:	7179                	addi	sp,sp,-48
 30042da:	d622                	sw	s0,44(sp)
 30042dc:	1800                	addi	s0,sp,48
 30042de:	fca42e23          	sw	a0,-36(s0)
 30042e2:	fcb42c23          	sw	a1,-40(s0)
    CAN_ASSERT_PARAM(canHandle != NULL);
    CAN_ASSERT_PARAM(IsCANInstance(canHandle->baseAddress));
    unsigned int map = 1;
 30042e6:	4785                	li	a5,1
 30042e8:	fef42623          	sw	a5,-20(s0)
    map <<= objId - 1;
 30042ec:	fd842783          	lw	a5,-40(s0)
 30042f0:	17fd                	addi	a5,a5,-1
 30042f2:	fec42703          	lw	a4,-20(s0)
 30042f6:	00f717b3          	sll	a5,a4,a5
 30042fa:	fef42623          	sw	a5,-20(s0)
    /* Step1: write id into register arbitration according frame type */
    if ((map & g_stdRecvMap) != 0) {            /* STD DATA FRAME */
 30042fe:	9081a703          	lw	a4,-1784(gp) # 4000004 <g_stdRecvMap>
 3004302:	fec42783          	lw	a5,-20(s0)
 3004306:	8ff9                	and	a5,a5,a4
 3004308:	cf89                	beqz	a5,3004322 <CAN_ConfigReadReq+0x4a>
        canHandle->baseAddress->IF2_ARBITRATION2.reg = 0x8000;
 300430a:	fdc42783          	lw	a5,-36(s0)
 300430e:	439c                	lw	a5,0(a5)
 3004310:	6721                	lui	a4,0x8
 3004312:	08e7aa23          	sw	a4,148(a5)
        canHandle->baseAddress->IF2_ARBITRATION1.reg = 0x0000;
 3004316:	fdc42783          	lw	a5,-36(s0)
 300431a:	439c                	lw	a5,0(a5)
 300431c:	0807a823          	sw	zero,144(a5)
 3004320:	a02d                	j	300434a <CAN_ConfigReadReq+0x72>
    } else if ((map & g_extRecvMap) != 0) {     /* EXTENDED DATA FRAME */
 3004322:	90c1a703          	lw	a4,-1780(gp) # 4000008 <g_extRecvMap>
 3004326:	fec42783          	lw	a5,-20(s0)
 300432a:	8ff9                	and	a5,a5,a4
 300432c:	cf89                	beqz	a5,3004346 <CAN_ConfigReadReq+0x6e>
        canHandle->baseAddress->IF2_ARBITRATION2.reg = 0xC000;
 300432e:	fdc42783          	lw	a5,-36(s0)
 3004332:	439c                	lw	a5,0(a5)
 3004334:	6731                	lui	a4,0xc
 3004336:	08e7aa23          	sw	a4,148(a5)
        canHandle->baseAddress->IF2_ARBITRATION1.reg = 0x0000;
 300433a:	fdc42783          	lw	a5,-36(s0)
 300433e:	439c                	lw	a5,0(a5)
 3004340:	0807a823          	sw	zero,144(a5)
 3004344:	a019                	j	300434a <CAN_ConfigReadReq+0x72>
    } else {
        return BASE_STATUS_ERROR;
 3004346:	4785                	li	a5,1
 3004348:	a0bd                	j	30043b6 <CAN_ConfigReadReq+0xde>
    }
    /* Step2: setting mask register 2 */
    canHandle->baseAddress->IF2_MASK2.reg = 0xC000;
 300434a:	fdc42783          	lw	a5,-36(s0)
 300434e:	439c                	lw	a5,0(a5)
 3004350:	6731                	lui	a4,0xc
 3004352:	08e7a623          	sw	a4,140(a5)
    /* Step3: setting mask register 1 */
    canHandle->baseAddress->IF2_MASK1.reg = 0x0000;
 3004356:	fdc42783          	lw	a5,-36(s0)
 300435a:	439c                	lw	a5,0(a5)
 300435c:	0807a423          	sw	zero,136(a5)
    /* Step4: setting message control register. By default, there is no RX FIFO and no filtering is performed */
    canHandle->baseAddress->IF2_MESSAGE_CONTROL.reg = 0x1488;
 3004360:	fdc42783          	lw	a5,-36(s0)
 3004364:	439c                	lw	a5,0(a5)
 3004366:	6705                	lui	a4,0x1
 3004368:	48870713          	addi	a4,a4,1160 # 1488 <__bss_size__+0x814>
 300436c:	08e7ac23          	sw	a4,152(a5)
    /* Step5: send configuration to packet objects */
    canHandle->baseAddress->IF2_COMMAND_MASK.reg = 0x00F3;
 3004370:	fdc42783          	lw	a5,-36(s0)
 3004374:	439c                	lw	a5,0(a5)
 3004376:	0f300713          	li	a4,243
 300437a:	08e7a223          	sw	a4,132(a5)
    /* Step6: write IF2 request command */
    canHandle->baseAddress->IF2_COMMAND_REQUEST.BIT.MessageNumber = objId;
 300437e:	fdc42783          	lw	a5,-36(s0)
 3004382:	4398                	lw	a4,0(a5)
 3004384:	fd842783          	lw	a5,-40(s0)
 3004388:	03f7f793          	andi	a5,a5,63
 300438c:	0ff7f693          	andi	a3,a5,255
 3004390:	08072783          	lw	a5,128(a4)
 3004394:	03f6f693          	andi	a3,a3,63
 3004398:	fc07f793          	andi	a5,a5,-64
 300439c:	8fd5                	or	a5,a5,a3
 300439e:	08f72023          	sw	a5,128(a4)
    canHandle->baseAddress->IF2_COMMAND_REQUEST.BIT.BUSY = BASE_CFG_ENABLE;
 30043a2:	fdc42783          	lw	a5,-36(s0)
 30043a6:	4398                	lw	a4,0(a5)
 30043a8:	08072783          	lw	a5,128(a4)
 30043ac:	66a1                	lui	a3,0x8
 30043ae:	8fd5                	or	a5,a5,a3
 30043b0:	08f72023          	sw	a5,128(a4)
    return BASE_STATUS_OK;
 30043b4:	4781                	li	a5,0
}
 30043b6:	853e                	mv	a0,a5
 30043b8:	5432                	lw	s0,44(sp)
 30043ba:	6145                	addi	sp,sp,48
 30043bc:	8082                	ret

030043be <WriteFinishClear>:
  * @param canHandle CAN handle.
  * @param objId Indicates the packet object ID.
  * @retval BASE status type: OK, ERROR, BUSY, TIMEOUT.
  */
static BASE_StatusType WriteFinishClear(CAN_Handle *canHandle, unsigned int objId)
{
 30043be:	7179                	addi	sp,sp,-48
 30043c0:	d622                	sw	s0,44(sp)
 30043c2:	1800                	addi	s0,sp,48
 30043c4:	fca42e23          	sw	a0,-36(s0)
 30043c8:	fcb42c23          	sw	a1,-40(s0)
    CAN_ASSERT_PARAM(canHandle != NULL);
    CAN_ASSERT_PARAM(IsCANInstance(canHandle->baseAddress));
    unsigned int busy;
    canHandle->baseAddress->IF2_COMMAND_MASK.reg = 0x7F;
 30043cc:	fdc42783          	lw	a5,-36(s0)
 30043d0:	439c                	lw	a5,0(a5)
 30043d2:	07f00713          	li	a4,127
 30043d6:	08e7a223          	sw	a4,132(a5)
    canHandle->baseAddress->IF2_COMMAND_REQUEST.BIT.MessageNumber = objId;
 30043da:	fdc42783          	lw	a5,-36(s0)
 30043de:	4398                	lw	a4,0(a5)
 30043e0:	fd842783          	lw	a5,-40(s0)
 30043e4:	03f7f793          	andi	a5,a5,63
 30043e8:	0ff7f693          	andi	a3,a5,255
 30043ec:	08072783          	lw	a5,128(a4)
 30043f0:	03f6f693          	andi	a3,a3,63
 30043f4:	fc07f793          	andi	a5,a5,-64
 30043f8:	8fd5                	or	a5,a5,a3
 30043fa:	08f72023          	sw	a5,128(a4)
    do {
        busy = canHandle->baseAddress->IF2_COMMAND_REQUEST.BIT.BUSY;
 30043fe:	fdc42783          	lw	a5,-36(s0)
 3004402:	439c                	lw	a5,0(a5)
 3004404:	0807a783          	lw	a5,128(a5)
 3004408:	83bd                	srli	a5,a5,0xf
 300440a:	8b85                	andi	a5,a5,1
 300440c:	9f81                	uxtb	a5
 300440e:	fef42623          	sw	a5,-20(s0)
    } while (busy != 0x00);
 3004412:	fec42783          	lw	a5,-20(s0)
 3004416:	f7e5                	bnez	a5,30043fe <WriteFinishClear+0x40>
    return BASE_STATUS_OK;
 3004418:	4781                	li	a5,0
}
 300441a:	853e                	mv	a0,a5
 300441c:	5432                	lw	s0,44(sp)
 300441e:	6145                	addi	sp,sp,48
 3004420:	8082                	ret

03004422 <WriteIrqService>:
  * @param canHandle CAN handle.
  * @param irqIndex Packet object interrupt ID.
  * @retval None.
  */
static void WriteIrqService(CAN_Handle *canHandle, unsigned int irqIndex)
{
 3004422:	1101                	addi	sp,sp,-32
 3004424:	ce06                	sw	ra,28(sp)
 3004426:	cc22                	sw	s0,24(sp)
 3004428:	1000                	addi	s0,sp,32
 300442a:	fea42623          	sw	a0,-20(s0)
 300442e:	feb42423          	sw	a1,-24(s0)
    // DBG_PRINTF("Transmit Successfully!\r\n");
    WriteFinishClear(canHandle, irqIndex);
 3004432:	fe842583          	lw	a1,-24(s0)
 3004436:	fec42503          	lw	a0,-20(s0)
 300443a:	3751                	jal	ra,30043be <WriteFinishClear>
    g_msgObj[irqIndex - 1] = 0;
 300443c:	fe842783          	lw	a5,-24(s0)
 3004440:	17fd                	addi	a5,a5,-1
 3004442:	e2418713          	addi	a4,gp,-476 # 4000520 <g_msgObj>
 3004446:	078a                	slli	a5,a5,0x2
 3004448:	97ba                	add	a5,a5,a4
 300444a:	0007a023          	sw	zero,0(a5)
    if (canHandle->userCallBack.WriteFinishCallBack != NULL) {
 300444e:	fec42783          	lw	a5,-20(s0)
 3004452:	5b9c                	lw	a5,48(a5)
 3004454:	c799                	beqz	a5,3004462 <WriteIrqService+0x40>
        canHandle->userCallBack.WriteFinishCallBack(canHandle);
 3004456:	fec42783          	lw	a5,-20(s0)
 300445a:	5b9c                	lw	a5,48(a5)
 300445c:	fec42503          	lw	a0,-20(s0)
 3004460:	9782                	jalr	a5
    }
}
 3004462:	0001                	nop
 3004464:	40f2                	lw	ra,28(sp)
 3004466:	4462                	lw	s0,24(sp)
 3004468:	6105                	addi	sp,sp,32
 300446a:	8082                	ret

0300446c <ReadIrqService>:
  * @param canHandle CAN handle.
  * @param irqIndex Packet object interrupt ID.
  * @retval None.
  */
static void ReadIrqService(CAN_Handle *canHandle, unsigned int irqIndex)
{
 300446c:	1101                	addi	sp,sp,-32
 300446e:	ce06                	sw	ra,28(sp)
 3004470:	cc22                	sw	s0,24(sp)
 3004472:	1000                	addi	s0,sp,32
 3004474:	fea42623          	sw	a0,-20(s0)
 3004478:	feb42423          	sw	a1,-24(s0)
    //DBG_PRINTF("Receive Successfully!\r\n");
    CAN_ReadCallback(canHandle, irqIndex);
 300447c:	fe842583          	lw	a1,-24(s0)
 3004480:	fec42503          	lw	a0,-20(s0)
 3004484:	3265                	jal	ra,3003e2c <CAN_ReadCallback>
    if (canHandle->userCallBack.ReadFinishCallBack != NULL) {
 3004486:	fec42783          	lw	a5,-20(s0)
 300448a:	5bdc                	lw	a5,52(a5)
 300448c:	c799                	beqz	a5,300449a <ReadIrqService+0x2e>
        canHandle->userCallBack.ReadFinishCallBack(canHandle);
 300448e:	fec42783          	lw	a5,-20(s0)
 3004492:	5bdc                	lw	a5,52(a5)
 3004494:	fec42503          	lw	a0,-20(s0)
 3004498:	9782                	jalr	a5
    }
}
 300449a:	0001                	nop
 300449c:	40f2                	lw	ra,28(sp)
 300449e:	4462                	lw	s0,24(sp)
 30044a0:	6105                	addi	sp,sp,32
 30044a2:	8082                	ret

030044a4 <HAL_CAN_IrqHandler>:
  * @brief CAN interrupt service processing function.
  * @param handle CAN handle.
  * @retval None.
  */
void HAL_CAN_IrqHandler(void *handle)
{
 30044a4:	7139                	addi	sp,sp,-64
 30044a6:	de06                	sw	ra,60(sp)
 30044a8:	dc22                	sw	s0,56(sp)
 30044aa:	0080                	addi	s0,sp,64
 30044ac:	fca42623          	sw	a0,-52(s0)
    //DBG_PRINTF("Interrupt!\r\n");
    CAN_ASSERT_PARAM(handle != NULL);
    CAN_Handle *canHandle = (CAN_Handle *)handle;
 30044b0:	fcc42783          	lw	a5,-52(s0)
 30044b4:	fef42623          	sw	a5,-20(s0)
    CAN_ASSERT_PARAM(IsCANInstance(canHandle->baseAddress));
    unsigned int irqIndex;
    unsigned int idLow, idHigh, id;
    irqIndex = canHandle->baseAddress->CAN_INTERRUPT.reg;
 30044b8:	fec42783          	lw	a5,-20(s0)
 30044bc:	439c                	lw	a5,0(a5)
 30044be:	4b9c                	lw	a5,16(a5)
 30044c0:	fef42423          	sw	a5,-24(s0)
    /* Status interrupt ID: 0x8000 */
    if (irqIndex == 0x8000) {
 30044c4:	fe842703          	lw	a4,-24(s0)
 30044c8:	67a1                	lui	a5,0x8
 30044ca:	04f71963          	bne	a4,a5,300451c <HAL_CAN_IrqHandler+0x78>
        /* Offline status of the CAN bus. */
        unsigned int statusBusoff = canHandle->baseAddress->CAN_STATUS.BIT.Boff;
 30044ce:	fec42783          	lw	a5,-20(s0)
 30044d2:	439c                	lw	a5,0(a5)
 30044d4:	43dc                	lw	a5,4(a5)
 30044d6:	839d                	srli	a5,a5,0x7
 30044d8:	8b85                	andi	a5,a5,1
 30044da:	9f81                	uxtb	a5
 30044dc:	fcf42c23          	sw	a5,-40(s0)
        if (statusBusoff == BASE_CFG_ENABLE) {  /* true when the bus-off state is displayed. */
 30044e0:	fd842703          	lw	a4,-40(s0)
 30044e4:	4785                	li	a5,1
 30044e6:	02f71063          	bne	a4,a5,3004506 <HAL_CAN_IrqHandler+0x62>
            canHandle->baseAddress->CAN_CONTROL.BIT.Init = 0x01;
 30044ea:	fec42783          	lw	a5,-20(s0)
 30044ee:	4398                	lw	a4,0(a5)
 30044f0:	431c                	lw	a5,0(a4)
 30044f2:	0017e793          	ori	a5,a5,1
 30044f6:	c31c                	sw	a5,0(a4)
            __asm__ volatile ("nop");                   /* Hold-off time */
 30044f8:	0001                	nop
            canHandle->baseAddress->CAN_CONTROL.BIT.Init = 0x00;
 30044fa:	fec42783          	lw	a5,-20(s0)
 30044fe:	4398                	lw	a4,0(a5)
 3004500:	431c                	lw	a5,0(a4)
 3004502:	9bf9                	andi	a5,a5,-2
 3004504:	c31c                	sw	a5,0(a4)
        }
        if (canHandle->userCallBack.TransmitErrorCallBack != NULL) {
 3004506:	fec42783          	lw	a5,-20(s0)
 300450a:	5f9c                	lw	a5,56(a5)
 300450c:	c7c1                	beqz	a5,3004594 <HAL_CAN_IrqHandler+0xf0>
            canHandle->userCallBack.TransmitErrorCallBack(canHandle);
 300450e:	fec42783          	lw	a5,-20(s0)
 3004512:	5f9c                	lw	a5,56(a5)
 3004514:	fec42503          	lw	a0,-20(s0)
 3004518:	9782                	jalr	a5
        }
        if (id & g_allRecvMap) {
            ReadIrqService(canHandle, irqIndex);
        }
    }
    return;
 300451a:	a8ad                	j	3004594 <HAL_CAN_IrqHandler+0xf0>
    } else if (irqIndex >= 0x01 && irqIndex <= 0x20) { /* Packet object interrupt ID from 0x01 to 0x20 */
 300451c:	fe842783          	lw	a5,-24(s0)
 3004520:	cbb5                	beqz	a5,3004594 <HAL_CAN_IrqHandler+0xf0>
 3004522:	fe842703          	lw	a4,-24(s0)
 3004526:	02000793          	li	a5,32
 300452a:	06e7e563          	bltu	a5,a4,3004594 <HAL_CAN_IrqHandler+0xf0>
        idLow = canHandle->baseAddress->INTERRUPT_PENDING1.BIT.IntPnd16_1;
 300452e:	fec42783          	lw	a5,-20(s0)
 3004532:	439c                	lw	a5,0(a5)
 3004534:	1407a783          	lw	a5,320(a5) # 8140 <RAM_SIZE+0x3140>
 3004538:	9fa1                	uxth	a5
 300453a:	fef42223          	sw	a5,-28(s0)
        idHigh = canHandle->baseAddress->INTERRUPT_PENDING2.BIT.IntPnd32_17;
 300453e:	fec42783          	lw	a5,-20(s0)
 3004542:	439c                	lw	a5,0(a5)
 3004544:	1447a783          	lw	a5,324(a5)
 3004548:	9fa1                	uxth	a5
 300454a:	fef42023          	sw	a5,-32(s0)
        id = idLow;
 300454e:	fe442783          	lw	a5,-28(s0)
 3004552:	fcf42e23          	sw	a5,-36(s0)
        id |= idHigh << 16;          /* High 16 bits ID */
 3004556:	fe042783          	lw	a5,-32(s0)
 300455a:	07c2                	slli	a5,a5,0x10
 300455c:	fdc42703          	lw	a4,-36(s0)
 3004560:	8fd9                	or	a5,a5,a4
 3004562:	fcf42e23          	sw	a5,-36(s0)
        if (id & g_allSendMap) {     /* Write complete */
 3004566:	9101a703          	lw	a4,-1776(gp) # 400000c <g_allSendMap>
 300456a:	fdc42783          	lw	a5,-36(s0)
 300456e:	8ff9                	and	a5,a5,a4
 3004570:	c791                	beqz	a5,300457c <HAL_CAN_IrqHandler+0xd8>
            WriteIrqService(canHandle, irqIndex);
 3004572:	fe842583          	lw	a1,-24(s0)
 3004576:	fec42503          	lw	a0,-20(s0)
 300457a:	3565                	jal	ra,3004422 <WriteIrqService>
        if (id & g_allRecvMap) {
 300457c:	9141a703          	lw	a4,-1772(gp) # 4000010 <g_allRecvMap>
 3004580:	fdc42783          	lw	a5,-36(s0)
 3004584:	8ff9                	and	a5,a5,a4
 3004586:	c799                	beqz	a5,3004594 <HAL_CAN_IrqHandler+0xf0>
            ReadIrqService(canHandle, irqIndex);
 3004588:	fe842583          	lw	a1,-24(s0)
 300458c:	fec42503          	lw	a0,-20(s0)
 3004590:	3df1                	jal	ra,300446c <ReadIrqService>
    return;
 3004592:	0001                	nop
 3004594:	0001                	nop
}
 3004596:	50f2                	lw	ra,60(sp)
 3004598:	5462                	lw	s0,56(sp)
 300459a:	6121                	addi	sp,sp,64
 300459c:	8082                	ret

0300459e <HAL_CAN_RegisterCallBack>:
  * @param typeID Id of callback function type, @ref CAN_CallBackFunType
  * @param pCallback Pointer of the specified callbcak function, @ref CAN_CallbackType
  * @retval BASE_StatusType: BASE_STATUS_ERROR register error, BASE_STATUS_OK register success.
  */
BASE_StatusType HAL_CAN_RegisterCallBack(CAN_Handle *canHandle, CAN_CallBackFunType typeID, CAN_CallbackType pCallback)
{
 300459e:	1101                	addi	sp,sp,-32
 30045a0:	ce22                	sw	s0,28(sp)
 30045a2:	1000                	addi	s0,sp,32
 30045a4:	fea42623          	sw	a0,-20(s0)
 30045a8:	feb42423          	sw	a1,-24(s0)
 30045ac:	fec42223          	sw	a2,-28(s0)
    CAN_ASSERT_PARAM(canHandle != NULL);
    CAN_ASSERT_PARAM(IsCANInstance(canHandle->baseAddress));
    switch (typeID) {
 30045b0:	fe842783          	lw	a5,-24(s0)
 30045b4:	4705                	li	a4,1
 30045b6:	00e78f63          	beq	a5,a4,30045d4 <HAL_CAN_RegisterCallBack+0x36>
 30045ba:	4705                	li	a4,1
 30045bc:	00e7e663          	bltu	a5,a4,30045c8 <HAL_CAN_RegisterCallBack+0x2a>
 30045c0:	4709                	li	a4,2
 30045c2:	00e78f63          	beq	a5,a4,30045e0 <HAL_CAN_RegisterCallBack+0x42>
 30045c6:	a01d                	j	30045ec <HAL_CAN_RegisterCallBack+0x4e>
        case CAN_WRITE_FINISH:    /* CAN write finish call back. */
            canHandle->userCallBack.WriteFinishCallBack = pCallback;
 30045c8:	fec42783          	lw	a5,-20(s0)
 30045cc:	fe442703          	lw	a4,-28(s0)
 30045d0:	db98                	sw	a4,48(a5)
            break;
 30045d2:	a839                	j	30045f0 <HAL_CAN_RegisterCallBack+0x52>
        case CAN_READ_FINISH:    /* CAN read finish call back. */
            canHandle->userCallBack.ReadFinishCallBack = pCallback;
 30045d4:	fec42783          	lw	a5,-20(s0)
 30045d8:	fe442703          	lw	a4,-28(s0)
 30045dc:	dbd8                	sw	a4,52(a5)
            break;
 30045de:	a809                	j	30045f0 <HAL_CAN_RegisterCallBack+0x52>
        case CAN_TRNS_ERROR:     /* CAN transmit finish call back. */
            canHandle->userCallBack.TransmitErrorCallBack = pCallback;
 30045e0:	fec42783          	lw	a5,-20(s0)
 30045e4:	fe442703          	lw	a4,-28(s0)
 30045e8:	df98                	sw	a4,56(a5)
            break;
 30045ea:	a019                	j	30045f0 <HAL_CAN_RegisterCallBack+0x52>
        default:
            return BASE_STATUS_ERROR;
 30045ec:	4785                	li	a5,1
 30045ee:	a011                	j	30045f2 <HAL_CAN_RegisterCallBack+0x54>
    }
    return BASE_STATUS_OK;
 30045f0:	4781                	li	a5,0
 30045f2:	853e                	mv	a0,a5
 30045f4:	4472                	lw	s0,28(sp)
 30045f6:	6105                	addi	sp,sp,32
 30045f8:	8082                	ret

030045fa <DCL_SYSCTRL_CrgWriteProtectionDisable>:
  * @brief Set the write protection for CRG-related registers disable.
  * @param None
  * @retval None.
  */
static inline void DCL_SYSCTRL_CrgWriteProtectionDisable(void)
{
 30045fa:	1141                	addi	sp,sp,-16
 30045fc:	c622                	sw	s0,12(sp)
 30045fe:	0800                	addi	s0,sp,16
    /* Set the corresponding bit without affecting the other bits and set the high 16 bits to EA51 to write to. */
    SYSCTRL0->SC_LOCKEN.reg = (SYSCTRL0->SC_LOCKEN.reg & SC_LOCKEN_CRG_DISABLE_MASK) + SC_LOCKEN_VALID_HIGH_BIT;
 3004600:	101007b7          	lui	a5,0x10100
 3004604:	43f8                	lw	a4,68(a5)
 3004606:	67c1                	lui	a5,0x10
 3004608:	17f9                	addi	a5,a5,-2 # fffe <RAM_SIZE+0xaffe>
 300460a:	00f776b3          	and	a3,a4,a5
 300460e:	101007b7          	lui	a5,0x10100
 3004612:	ea510737          	lui	a4,0xea510
 3004616:	9736                	add	a4,a4,a3
 3004618:	c3f8                	sw	a4,68(a5)
}
 300461a:	0001                	nop
 300461c:	4432                	lw	s0,12(sp)
 300461e:	0141                	addi	sp,sp,16
 3004620:	8082                	ret

03004622 <DCL_SYSCTRL_CrgWriteProtectionEnable>:
  * @brief Set the Set the write protection for CRG-related registers enable.
  * @param None
  * @retval None.
  */
static inline void DCL_SYSCTRL_CrgWriteProtectionEnable(void)
{
 3004622:	1141                	addi	sp,sp,-16
 3004624:	c622                	sw	s0,12(sp)
 3004626:	0800                	addi	s0,sp,16
    /* Set the corresponding bit without affecting the other bits and set the high 16 bits to EA51 to write to. */
    SYSCTRL0->SC_LOCKEN.reg = ((SYSCTRL0->SC_LOCKEN.reg & SC_LOW_BIT_MASK) | SC_LOCKEN_CRG_ENABLE_MASK) +
 3004628:	101007b7          	lui	a5,0x10100
 300462c:	43f8                	lw	a4,68(a5)
 300462e:	67c1                	lui	a5,0x10
 3004630:	17fd                	addi	a5,a5,-1 # ffff <RAM_SIZE+0xafff>
 3004632:	8ff9                	and	a5,a5,a4
 3004634:	0017e693          	ori	a3,a5,1
 3004638:	101007b7          	lui	a5,0x10100
 300463c:	ea510737          	lui	a4,0xea510
 3004640:	9736                	add	a4,a4,a3
 3004642:	c3f8                	sw	a4,68(a5)
                              SC_LOCKEN_VALID_HIGH_BIT;
}
 3004644:	0001                	nop
 3004646:	4432                	lw	s0,12(sp)
 3004648:	0141                	addi	sp,sp,16
 300464a:	8082                	ret

0300464c <IsCrgPllRefClkSelect>:
  * @param clkSelect pll_ref_cksel
  * @retval true
  * @retval false
  */
static inline bool IsCrgPllRefClkSelect(CRG_PllRefClkSelect clkSelect)
{
 300464c:	1101                	addi	sp,sp,-32
 300464e:	ce22                	sw	s0,28(sp)
 3004650:	1000                	addi	s0,sp,32
 3004652:	fea42623          	sw	a0,-20(s0)
    return ((clkSelect == CRG_PLL_REF_CLK_SELECT_HOSC) ||
 3004656:	fec42783          	lw	a5,-20(s0)
 300465a:	c791                	beqz	a5,3004666 <IsCrgPllRefClkSelect+0x1a>
 300465c:	fec42703          	lw	a4,-20(s0)
 3004660:	4785                	li	a5,1
 3004662:	00f71463          	bne	a4,a5,300466a <IsCrgPllRefClkSelect+0x1e>
 3004666:	4785                	li	a5,1
 3004668:	a011                	j	300466c <IsCrgPllRefClkSelect+0x20>
 300466a:	4781                	li	a5,0
 300466c:	8b85                	andi	a5,a5,1
 300466e:	9f81                	uxtb	a5
            (clkSelect == CRG_PLL_REF_CLK_SELECT_XTAL));
}
 3004670:	853e                	mv	a0,a5
 3004672:	4472                	lw	s0,28(sp)
 3004674:	6105                	addi	sp,sp,32
 3004676:	8082                	ret

03004678 <IsCrgPllPreDiv>:
  * @param preDiv pll prediv value
  * @retval true
  * @retval false
  */
static inline bool IsCrgPllPreDiv(CRG_PllPreDiv preDiv)
{
 3004678:	1101                	addi	sp,sp,-32
 300467a:	ce22                	sw	s0,28(sp)
 300467c:	1000                	addi	s0,sp,32
 300467e:	fea42623          	sw	a0,-20(s0)
    return ((preDiv >= CRG_PLL_PREDIV_1) &&
 3004682:	fec42783          	lw	a5,-20(s0)
 3004686:	0087b793          	sltiu	a5,a5,8
 300468a:	9f81                	uxtb	a5
            (preDiv <= CRG_PLL_PREDIV_8));
}
 300468c:	853e                	mv	a0,a5
 300468e:	4472                	lw	s0,28(sp)
 3004690:	6105                	addi	sp,sp,32
 3004692:	8082                	ret

03004694 <IsCrgPllPostDiv>:
  * @param postDiv  pll_postdiv value
  * @retval true
  * @retval false
  */
static inline bool IsCrgPllPostDiv(CRG_PllPostDiv postDiv)
{
 3004694:	1101                	addi	sp,sp,-32
 3004696:	ce22                	sw	s0,28(sp)
 3004698:	1000                	addi	s0,sp,32
 300469a:	fea42623          	sw	a0,-20(s0)
    return ((postDiv >= CRG_PLL_POSTDIV_1) &&
 300469e:	fec42783          	lw	a5,-20(s0)
 30046a2:	0087b793          	sltiu	a5,a5,8
 30046a6:	9f81                	uxtb	a5
            (postDiv <= CRG_PLL_POSTDIV_8));
}
 30046a8:	853e                	mv	a0,a5
 30046aa:	4472                	lw	s0,28(sp)
 30046ac:	6105                	addi	sp,sp,32
 30046ae:	8082                	ret

030046b0 <IsCrgPllPostDiv2>:
  * @param postDiv  pll_postdiv2 value
  * @retval true
  * @retval false
  */
static inline bool IsCrgPllPostDiv2(CRG_PllPostDiv2 postDiv)
{
 30046b0:	1101                	addi	sp,sp,-32
 30046b2:	ce22                	sw	s0,28(sp)
 30046b4:	1000                	addi	s0,sp,32
 30046b6:	fea42623          	sw	a0,-20(s0)
    return ((postDiv >= CRG_PLL_POSTDIV2_1) &&
 30046ba:	fec42783          	lw	a5,-20(s0)
 30046be:	0087b793          	sltiu	a5,a5,8
 30046c2:	9f81                	uxtb	a5
            (postDiv <= CRG_PLL_POSTDIV2_8_MAX));
}
 30046c4:	853e                	mv	a0,a5
 30046c6:	4472                	lw	s0,28(sp)
 30046c8:	6105                	addi	sp,sp,32
 30046ca:	8082                	ret

030046cc <IsCrgPllFbDiv>:
  * @param fbDiv  pll fbdiv value
  * @retval true
  * @retval false
  */
static inline bool IsCrgPllFbDiv(unsigned int fbDiv)
{
 30046cc:	1101                	addi	sp,sp,-32
 30046ce:	ce22                	sw	s0,28(sp)
 30046d0:	1000                	addi	s0,sp,32
 30046d2:	fea42623          	sw	a0,-20(s0)
    return (fbDiv <= CRG_PLL_FBDIV_MAX);
 30046d6:	fec42783          	lw	a5,-20(s0)
 30046da:	0807b793          	sltiu	a5,a5,128
 30046de:	9f81                	uxtb	a5
}
 30046e0:	853e                	mv	a0,a5
 30046e2:	4472                	lw	s0,28(sp)
 30046e4:	6105                	addi	sp,sp,32
 30046e6:	8082                	ret

030046e8 <IsCrgCoreCkSel>:
  * @param select  core_cksel value
  * @retval true
  * @retval false
  */
static inline bool IsCrgCoreCkSel(CRG_CoreClkSelect select)
{
 30046e8:	1101                	addi	sp,sp,-32
 30046ea:	ce22                	sw	s0,28(sp)
 30046ec:	1000                	addi	s0,sp,32
 30046ee:	fea42623          	sw	a0,-20(s0)
    return ((select == CRG_CORE_CLK_SELECT_HOSC) ||
            (select == CRG_CORE_CLK_SELECT_TCXO) ||
 30046f2:	fec42783          	lw	a5,-20(s0)
 30046f6:	cb99                	beqz	a5,300470c <IsCrgCoreCkSel+0x24>
    return ((select == CRG_CORE_CLK_SELECT_HOSC) ||
 30046f8:	fec42703          	lw	a4,-20(s0)
 30046fc:	4785                	li	a5,1
 30046fe:	00f70763          	beq	a4,a5,300470c <IsCrgCoreCkSel+0x24>
            (select == CRG_CORE_CLK_SELECT_TCXO) ||
 3004702:	fec42703          	lw	a4,-20(s0)
 3004706:	4789                	li	a5,2
 3004708:	00f71463          	bne	a4,a5,3004710 <IsCrgCoreCkSel+0x28>
 300470c:	4785                	li	a5,1
 300470e:	a011                	j	3004712 <IsCrgCoreCkSel+0x2a>
 3004710:	4781                	li	a5,0
 3004712:	8b85                	andi	a5,a5,1
 3004714:	9f81                	uxtb	a5
            (select == CRG_CORE_CLK_SELECT_PLL));
}
 3004716:	853e                	mv	a0,a5
 3004718:	4472                	lw	s0,28(sp)
 300471a:	6105                	addi	sp,sp,32
 300471c:	8082                	ret

0300471e <IsCrg1MCkSel>:
  * @param select  1M clock selection
  * @retval true
  * @retval false
  */
static inline bool IsCrg1MCkSel(CRG_1MClkSelect select)
{
 300471e:	1101                	addi	sp,sp,-32
 3004720:	ce22                	sw	s0,28(sp)
 3004722:	1000                	addi	s0,sp,32
 3004724:	fea42623          	sw	a0,-20(s0)
    return ((select == CRG_1M_CLK_SELECT_HOSC) ||
 3004728:	fec42783          	lw	a5,-20(s0)
 300472c:	c791                	beqz	a5,3004738 <IsCrg1MCkSel+0x1a>
 300472e:	fec42703          	lw	a4,-20(s0)
 3004732:	4785                	li	a5,1
 3004734:	00f71463          	bne	a4,a5,300473c <IsCrg1MCkSel+0x1e>
 3004738:	4785                	li	a5,1
 300473a:	a011                	j	300473e <IsCrg1MCkSel+0x20>
 300473c:	4781                	li	a5,0
 300473e:	8b85                	andi	a5,a5,1
 3004740:	9f81                	uxtb	a5
            (select == CRG_1M_CLK_SELECT_TCXO));
}
 3004742:	853e                	mv	a0,a5
 3004744:	4472                	lw	s0,28(sp)
 3004746:	6105                	addi	sp,sp,32
 3004748:	8082                	ret

0300474a <IsCrg1MCkDiv>:
  * @param div  1M clock ratio
  * @retval true
  * @retval false
  */
static inline bool IsCrg1MCkDiv(unsigned int div)
{
 300474a:	1101                	addi	sp,sp,-32
 300474c:	ce22                	sw	s0,28(sp)
 300474e:	1000                	addi	s0,sp,32
 3004750:	fea42623          	sw	a0,-20(s0)
    return (div <= CRG_1MHZ_CLK_MAX_DIV);
 3004754:	fec42783          	lw	a5,-20(s0)
 3004758:	0407b793          	sltiu	a5,a5,64
 300475c:	9f81                	uxtb	a5
}
 300475e:	853e                	mv	a0,a5
 3004760:	4472                	lw	s0,28(sp)
 3004762:	6105                	addi	sp,sp,32
 3004764:	8082                	ret

03004766 <IsCrgAHBCkSel>:
  * @param select  AHB ip clock select value
  * @retval true
  * @retval false
  */
static inline bool IsCrgAHBCkSel(CRG_AHBClkSelect select)
{
 3004766:	1101                	addi	sp,sp,-32
 3004768:	ce22                	sw	s0,28(sp)
 300476a:	1000                	addi	s0,sp,32
 300476c:	fea42623          	sw	a0,-20(s0)
    return ((select == CRG_AHB_CLK_NO_PREDV) ||
            (select == CRG_AHB_CLK_PREDIV_2) ||
            (select == CRG_AHB_CLK_PREDIV_4) ||
 3004770:	fec42783          	lw	a5,-20(s0)
 3004774:	c385                	beqz	a5,3004794 <IsCrgAHBCkSel+0x2e>
    return ((select == CRG_AHB_CLK_NO_PREDV) ||
 3004776:	fec42703          	lw	a4,-20(s0)
 300477a:	4785                	li	a5,1
 300477c:	00f70c63          	beq	a4,a5,3004794 <IsCrgAHBCkSel+0x2e>
            (select == CRG_AHB_CLK_PREDIV_2) ||
 3004780:	fec42703          	lw	a4,-20(s0)
 3004784:	4789                	li	a5,2
 3004786:	00f70763          	beq	a4,a5,3004794 <IsCrgAHBCkSel+0x2e>
            (select == CRG_AHB_CLK_PREDIV_4) ||
 300478a:	fec42703          	lw	a4,-20(s0)
 300478e:	478d                	li	a5,3
 3004790:	00f71463          	bne	a4,a5,3004798 <IsCrgAHBCkSel+0x32>
 3004794:	4785                	li	a5,1
 3004796:	a011                	j	300479a <IsCrgAHBCkSel+0x34>
 3004798:	4781                	li	a5,0
 300479a:	8b85                	andi	a5,a5,1
 300479c:	9f81                	uxtb	a5
            (select == CRG_AHB_CLK_PREDIV_8));
}
 300479e:	853e                	mv	a0,a5
 30047a0:	4472                	lw	s0,28(sp)
 30047a2:	6105                	addi	sp,sp,32
 30047a4:	8082                	ret

030047a6 <IsCrgValidPreDiv>:
  * @param preDiv PLL Previous Divsion
  * @retval true
  * @retval false
  */
static inline bool IsCrgValidPreDiv(unsigned int pllRefFreq, unsigned int preDiv)
{
 30047a6:	7179                	addi	sp,sp,-48
 30047a8:	d622                	sw	s0,44(sp)
 30047aa:	1800                	addi	s0,sp,48
 30047ac:	fca42e23          	sw	a0,-36(s0)
 30047b0:	fcb42c23          	sw	a1,-40(s0)
    unsigned int freq = pllRefFreq;
 30047b4:	fdc42783          	lw	a5,-36(s0)
 30047b8:	fef42623          	sw	a5,-20(s0)
    if (preDiv != 0) {
 30047bc:	fd842783          	lw	a5,-40(s0)
 30047c0:	cb89                	beqz	a5,30047d2 <IsCrgValidPreDiv+0x2c>
        freq /= preDiv;
 30047c2:	fec42703          	lw	a4,-20(s0)
 30047c6:	fd842783          	lw	a5,-40(s0)
 30047ca:	02f757b3          	divu	a5,a4,a5
 30047ce:	fef42623          	sw	a5,-20(s0)
    }
    return (freq >= CRG_CLK_PFD_MIN_FREQ) && (freq <= CRG_CLK_PFD_MAX_FREQ);
 30047d2:	fec42703          	lw	a4,-20(s0)
 30047d6:	003d17b7          	lui	a5,0x3d1
 30047da:	8ff78793          	addi	a5,a5,-1793 # 3d08ff <FLASH_SIZE+0x3b0903>
 30047de:	00e7fc63          	bgeu	a5,a4,30047f6 <IsCrgValidPreDiv+0x50>
 30047e2:	fec42703          	lw	a4,-20(s0)
 30047e6:	007277b7          	lui	a5,0x727
 30047ea:	0e078793          	addi	a5,a5,224 # 7270e0 <FLASH_SIZE+0x7070e4>
 30047ee:	00e7e463          	bltu	a5,a4,30047f6 <IsCrgValidPreDiv+0x50>
 30047f2:	4785                	li	a5,1
 30047f4:	a011                	j	30047f8 <IsCrgValidPreDiv+0x52>
 30047f6:	4781                	li	a5,0
 30047f8:	8b85                	andi	a5,a5,1
 30047fa:	9f81                	uxtb	a5
}
 30047fc:	853e                	mv	a0,a5
 30047fe:	5432                	lw	s0,44(sp)
 3004800:	6145                	addi	sp,sp,48
 3004802:	8082                	ret

03004804 <IsCrgValidFdDiv>:
  * @param fdDiv PLL FD Divsion
  * @retval true
  * @retval false
  */
static inline bool IsCrgValidFdDiv(unsigned int clkPfdFreq, unsigned int fdDiv)
{
 3004804:	7179                	addi	sp,sp,-48
 3004806:	d622                	sw	s0,44(sp)
 3004808:	1800                	addi	s0,sp,48
 300480a:	fca42e23          	sw	a0,-36(s0)
 300480e:	fcb42c23          	sw	a1,-40(s0)
    if (clkPfdFreq > 30000000U) {  /* The maximum speed of the external clock source is 30000000U. */
 3004812:	fdc42703          	lw	a4,-36(s0)
 3004816:	01c9c7b7          	lui	a5,0x1c9c
 300481a:	38078793          	addi	a5,a5,896 # 1c9c380 <FLASH_SIZE+0x1c7c384>
 300481e:	00e7f463          	bgeu	a5,a4,3004826 <IsCrgValidFdDiv+0x22>
        return false;
 3004822:	4781                	li	a5,0
 3004824:	a08d                	j	3004886 <IsCrgValidFdDiv+0x82>
    } else if (fdDiv > CRG_PLL_FBDIV_MAX) {
 3004826:	fd842703          	lw	a4,-40(s0)
 300482a:	07f00793          	li	a5,127
 300482e:	00e7f463          	bgeu	a5,a4,3004836 <IsCrgValidFdDiv+0x32>
        return false;
 3004832:	4781                	li	a5,0
 3004834:	a889                	j	3004886 <IsCrgValidFdDiv+0x82>
    }

    unsigned int freq = (fdDiv > 0x6) ? (clkPfdFreq * fdDiv) : (clkPfdFreq * 0x6); /* 0x0-0x6: divided by 0x6 */
 3004836:	fd842703          	lw	a4,-40(s0)
 300483a:	4799                	li	a5,6
 300483c:	00e7f963          	bgeu	a5,a4,300484e <IsCrgValidFdDiv+0x4a>
 3004840:	fdc42703          	lw	a4,-36(s0)
 3004844:	fd842783          	lw	a5,-40(s0)
 3004848:	02f707b3          	mul	a5,a4,a5
 300484c:	a031                	j	3004858 <IsCrgValidFdDiv+0x54>
 300484e:	fdc42703          	lw	a4,-36(s0)
 3004852:	4799                	li	a5,6
 3004854:	02f707b3          	mul	a5,a4,a5
 3004858:	fef42623          	sw	a5,-20(s0)
    return (freq >= CRG_CLK_VCO_MIN_FREQ) && (freq <= CRG_CLK_VCO_MAX_FREQ);
 300485c:	fec42703          	lw	a4,-20(s0)
 3004860:	05f5e7b7          	lui	a5,0x5f5e
 3004864:	0ff78793          	addi	a5,a5,255 # 5f5e0ff <RAM_END+0x1f560ff>
 3004868:	00e7fc63          	bgeu	a5,a4,3004880 <IsCrgValidFdDiv+0x7c>
 300486c:	fec42703          	lw	a4,-20(s0)
 3004870:	11e1a7b7          	lui	a5,0x11e1a
 3004874:	30078793          	addi	a5,a5,768 # 11e1a300 <RAM_END+0xde12300>
 3004878:	00e7e463          	bltu	a5,a4,3004880 <IsCrgValidFdDiv+0x7c>
 300487c:	4785                	li	a5,1
 300487e:	a011                	j	3004882 <IsCrgValidFdDiv+0x7e>
 3004880:	4781                	li	a5,0
 3004882:	8b85                	andi	a5,a5,1
 3004884:	9f81                	uxtb	a5
}
 3004886:	853e                	mv	a0,a5
 3004888:	5432                	lw	s0,44(sp)
 300488a:	6145                	addi	sp,sp,48
 300488c:	8082                	ret

0300488e <IsCrgValidPostDiv>:
  * @param postDiv PLL Post Divsion
  * @retval true
  * @retval false
  */
static inline bool IsCrgValidPostDiv(unsigned int clkVcoFreq, unsigned int postDiv)
{
 300488e:	7179                	addi	sp,sp,-48
 3004890:	d622                	sw	s0,44(sp)
 3004892:	1800                	addi	s0,sp,48
 3004894:	fca42e23          	sw	a0,-36(s0)
 3004898:	fcb42c23          	sw	a1,-40(s0)
    unsigned int freq = clkVcoFreq;
 300489c:	fdc42783          	lw	a5,-36(s0)
 30048a0:	fef42623          	sw	a5,-20(s0)
    if (postDiv != 0) {
 30048a4:	fd842783          	lw	a5,-40(s0)
 30048a8:	cb91                	beqz	a5,30048bc <IsCrgValidPostDiv+0x2e>
        freq /= (postDiv + 1);
 30048aa:	fd842783          	lw	a5,-40(s0)
 30048ae:	0785                	addi	a5,a5,1
 30048b0:	fec42703          	lw	a4,-20(s0)
 30048b4:	02f757b3          	divu	a5,a4,a5
 30048b8:	fef42623          	sw	a5,-20(s0)
    }
    return (freq <= CRG_CLK_TARGET_MAX_FREQ);
 30048bc:	fec42703          	lw	a4,-20(s0)
 30048c0:	08f0d7b7          	lui	a5,0x8f0d
 30048c4:	18178793          	addi	a5,a5,385 # 8f0d181 <RAM_END+0x4f05181>
 30048c8:	00f737b3          	sltu	a5,a4,a5
 30048cc:	9f81                	uxtb	a5
}
 30048ce:	853e                	mv	a0,a5
 30048d0:	5432                	lw	s0,44(sp)
 30048d2:	6145                	addi	sp,sp,48
 30048d4:	8082                	ret

030048d6 <IsCrgValidPostDiv2>:
  * @param postDiv2 PLL Post Divsion2
  * @retval true
  * @retval false
  */
static inline bool IsCrgValidPostDiv2(unsigned int clkVcoFreq, unsigned int postDiv2)
{
 30048d6:	7179                	addi	sp,sp,-48
 30048d8:	d622                	sw	s0,44(sp)
 30048da:	1800                	addi	s0,sp,48
 30048dc:	fca42e23          	sw	a0,-36(s0)
 30048e0:	fcb42c23          	sw	a1,-40(s0)
    unsigned int freq = clkVcoFreq;
 30048e4:	fdc42783          	lw	a5,-36(s0)
 30048e8:	fef42623          	sw	a5,-20(s0)
    if (postDiv2 != 0) {
 30048ec:	fd842783          	lw	a5,-40(s0)
 30048f0:	cb91                	beqz	a5,3004904 <IsCrgValidPostDiv2+0x2e>
        freq /= (postDiv2 + 1);
 30048f2:	fd842783          	lw	a5,-40(s0)
 30048f6:	0785                	addi	a5,a5,1
 30048f8:	fec42703          	lw	a4,-20(s0)
 30048fc:	02f757b3          	divu	a5,a4,a5
 3004900:	fef42623          	sw	a5,-20(s0)
    }
    return (freq <= CRG_CLK_PST2_MAX_FREQ);
 3004904:	fec42703          	lw	a4,-20(s0)
 3004908:	05f5e7b7          	lui	a5,0x5f5e
 300490c:	10178793          	addi	a5,a5,257 # 5f5e101 <RAM_END+0x1f56101>
 3004910:	00f737b3          	sltu	a5,a4,a5
 3004914:	9f81                	uxtb	a5
}
 3004916:	853e                	mv	a0,a5
 3004918:	5432                	lw	s0,44(sp)
 300491a:	6145                	addi	sp,sp,48
 300491c:	8082                	ret

0300491e <IsCrgAdcClkModeSelect>:
  * @param adcClkSelect the value of adc clock select
  * @retval true
  * @retval false
  */
static inline bool IsCrgAdcClkModeSelect(CRG_AdcClkSelect adcClkSelect)
{
 300491e:	1101                	addi	sp,sp,-32
 3004920:	ce22                	sw	s0,28(sp)
 3004922:	1000                	addi	s0,sp,32
 3004924:	fea42623          	sw	a0,-20(s0)
    return (adcClkSelect == CRG_ADC_CLK_ASYN_HOSC || \
            adcClkSelect == CRG_ADC_CLK_ASYN_TCXO || \
            adcClkSelect == CRG_ADC_CLK_ASYN_PLL_DIV || \
 3004928:	fec42783          	lw	a5,-20(s0)
 300492c:	c385                	beqz	a5,300494c <IsCrgAdcClkModeSelect+0x2e>
    return (adcClkSelect == CRG_ADC_CLK_ASYN_HOSC || \
 300492e:	fec42703          	lw	a4,-20(s0)
 3004932:	4785                	li	a5,1
 3004934:	00f70c63          	beq	a4,a5,300494c <IsCrgAdcClkModeSelect+0x2e>
            adcClkSelect == CRG_ADC_CLK_ASYN_TCXO || \
 3004938:	fec42703          	lw	a4,-20(s0)
 300493c:	4789                	li	a5,2
 300493e:	00f70763          	beq	a4,a5,300494c <IsCrgAdcClkModeSelect+0x2e>
            adcClkSelect == CRG_ADC_CLK_ASYN_PLL_DIV || \
 3004942:	fec42703          	lw	a4,-20(s0)
 3004946:	478d                	li	a5,3
 3004948:	00f71463          	bne	a4,a5,3004950 <IsCrgAdcClkModeSelect+0x32>
 300494c:	4785                	li	a5,1
 300494e:	a011                	j	3004952 <IsCrgAdcClkModeSelect+0x34>
 3004950:	4781                	li	a5,0
 3004952:	8b85                	andi	a5,a5,1
 3004954:	9f81                	uxtb	a5
            adcClkSelect == CRG_ADC_CLK_SYN_CORE);
}
 3004956:	853e                	mv	a0,a5
 3004958:	4472                	lw	s0,28(sp)
 300495a:	6105                	addi	sp,sp,32
 300495c:	8082                	ret

0300495e <IsCrgAdcClkDiv>:
  * @param div the value of adc clock div
  * @retval true
  * @retval false
  */
static inline bool IsCrgAdcClkDiv(CRG_AdcDiv div)
{
 300495e:	1101                	addi	sp,sp,-32
 3004960:	ce22                	sw	s0,28(sp)
 3004962:	1000                	addi	s0,sp,32
 3004964:	fea42623          	sw	a0,-20(s0)
    return (div == CRG_ADC_DIV_1 || \
            div == CRG_ADC_DIV_2 || \
            div == CRG_ADC_DIV_3 || \
 3004968:	fec42783          	lw	a5,-20(s0)
 300496c:	c385                	beqz	a5,300498c <IsCrgAdcClkDiv+0x2e>
    return (div == CRG_ADC_DIV_1 || \
 300496e:	fec42703          	lw	a4,-20(s0)
 3004972:	4785                	li	a5,1
 3004974:	00f70c63          	beq	a4,a5,300498c <IsCrgAdcClkDiv+0x2e>
            div == CRG_ADC_DIV_2 || \
 3004978:	fec42703          	lw	a4,-20(s0)
 300497c:	4789                	li	a5,2
 300497e:	00f70763          	beq	a4,a5,300498c <IsCrgAdcClkDiv+0x2e>
            div == CRG_ADC_DIV_3 || \
 3004982:	fec42703          	lw	a4,-20(s0)
 3004986:	478d                	li	a5,3
 3004988:	00f71463          	bne	a4,a5,3004990 <IsCrgAdcClkDiv+0x32>
 300498c:	4785                	li	a5,1
 300498e:	a011                	j	3004992 <IsCrgAdcClkDiv+0x34>
 3004990:	4781                	li	a5,0
 3004992:	8b85                	andi	a5,a5,1
 3004994:	9f81                	uxtb	a5
            div == CRG_ADC_DIV_4);
}
 3004996:	853e                	mv	a0,a5
 3004998:	4472                	lw	s0,28(sp)
 300499a:	6105                	addi	sp,sp,32
 300499c:	8082                	ret

0300499e <DCL_CRG_SetCoreClkSel>:
  * @param clk  Clock register base address
  * @param select  Core clock selection
  * @retval None
  */
static inline void DCL_CRG_SetCoreClkSel(CRG_RegStruct *clk, CRG_CoreClkSelect select)
{
 300499e:	1101                	addi	sp,sp,-32
 30049a0:	ce06                	sw	ra,28(sp)
 30049a2:	cc22                	sw	s0,24(sp)
 30049a4:	1000                	addi	s0,sp,32
 30049a6:	fea42623          	sw	a0,-20(s0)
 30049aa:	feb42423          	sw	a1,-24(s0)
    CRG_ASSERT_PARAM(IsCRGInstance(clk));
 30049ae:	fec42703          	lw	a4,-20(s0)
 30049b2:	100007b7          	lui	a5,0x10000
 30049b6:	00f70a63          	beq	a4,a5,30049ca <DCL_CRG_SetCoreClkSel+0x2c>
 30049ba:	69900593          	li	a1,1689
 30049be:	030117b7          	lui	a5,0x3011
 30049c2:	83c78513          	addi	a0,a5,-1988 # 301083c <g_crgIpMatch+0x32c>
 30049c6:	2d21                	jal	ra,3004fde <AssertErrorLog.trans.2>
 30049c8:	a001                	j	30049c8 <DCL_CRG_SetCoreClkSel+0x2a>
    CRG_PARAM_CHECK_NO_RET(IsCrgCoreCkSel(select));
 30049ca:	fe842503          	lw	a0,-24(s0)
 30049ce:	3b29                	jal	ra,30046e8 <IsCrgCoreCkSel>
 30049d0:	87aa                	mv	a5,a0
 30049d2:	0017c793          	xori	a5,a5,1
 30049d6:	9f81                	uxtb	a5
 30049d8:	cb89                	beqz	a5,30049ea <DCL_CRG_SetCoreClkSel+0x4c>
 30049da:	69a00593          	li	a1,1690
 30049de:	030117b7          	lui	a5,0x3011
 30049e2:	83c78513          	addi	a0,a5,-1988 # 301083c <g_crgIpMatch+0x32c>
 30049e6:	2be5                	jal	ra,3004fde <AssertErrorLog.trans.2>
 30049e8:	a839                	j	3004a06 <DCL_CRG_SetCoreClkSel+0x68>
    clk->PERI_CRG64.BIT.clk_pst1_sw_sel = select;
 30049ea:	fe842783          	lw	a5,-24(s0)
 30049ee:	8b8d                	andi	a5,a5,3
 30049f0:	0ff7f693          	andi	a3,a5,255
 30049f4:	fec42703          	lw	a4,-20(s0)
 30049f8:	10072783          	lw	a5,256(a4) # ea510100 <RAM_END+0xe6508100>
 30049fc:	8a8d                	andi	a3,a3,3
 30049fe:	9bf1                	andi	a5,a5,-4
 3004a00:	8fd5                	or	a5,a5,a3
 3004a02:	10f72023          	sw	a5,256(a4)
}
 3004a06:	40f2                	lw	ra,28(sp)
 3004a08:	4462                	lw	s0,24(sp)
 3004a0a:	6105                	addi	sp,sp,32
 3004a0c:	8082                	ret

03004a0e <HAL_CRG_Init>:
  * @param handle CRG Handle
  * @retval BASE_STATUS_ERROR  Parameter Check fail
  * @retval BASE_STATUS_OK     Success
  */
BASE_StatusType HAL_CRG_Init(const CRG_Handle *handle)
{
 3004a0e:	7179                	addi	sp,sp,-48
 3004a10:	d606                	sw	ra,44(sp)
 3004a12:	d422                	sw	s0,40(sp)
 3004a14:	1800                	addi	s0,sp,48
 3004a16:	fca42e23          	sw	a0,-36(s0)
    CRG_ASSERT_PARAM(handle != NULL);
 3004a1a:	fdc42783          	lw	a5,-36(s0)
 3004a1e:	eb89                	bnez	a5,3004a30 <HAL_CRG_Init+0x22>
 3004a20:	07c00593          	li	a1,124
 3004a24:	030117b7          	lui	a5,0x3011
 3004a28:	85878513          	addi	a0,a5,-1960 # 3010858 <g_crgIpMatch+0x348>
 3004a2c:	2b4d                	jal	ra,3004fde <AssertErrorLog.trans.2>
 3004a2e:	a001                	j	3004a2e <HAL_CRG_Init+0x20>
    CRG_ASSERT_PARAM(IsCRGInstance(handle->baseAddress));
 3004a30:	fdc42783          	lw	a5,-36(s0)
 3004a34:	4398                	lw	a4,0(a5)
 3004a36:	100007b7          	lui	a5,0x10000
 3004a3a:	00f70a63          	beq	a4,a5,3004a4e <HAL_CRG_Init+0x40>
 3004a3e:	07d00593          	li	a1,125
 3004a42:	030117b7          	lui	a5,0x3011
 3004a46:	85878513          	addi	a0,a5,-1960 # 3010858 <g_crgIpMatch+0x348>
 3004a4a:	2b51                	jal	ra,3004fde <AssertErrorLog.trans.2>
 3004a4c:	a001                	j	3004a4c <HAL_CRG_Init+0x3e>
    /* Check the validity of PLL-related parameters. */
    CRG_PARAM_CHECK_WITH_RET(IsCrgPllRefClkSelect(handle->pllRefClkSelect), BASE_STATUS_ERROR);
 3004a4e:	fdc42783          	lw	a5,-36(s0)
 3004a52:	43dc                	lw	a5,4(a5)
 3004a54:	853e                	mv	a0,a5
 3004a56:	3edd                	jal	ra,300464c <IsCrgPllRefClkSelect>
 3004a58:	87aa                	mv	a5,a0
 3004a5a:	0017c793          	xori	a5,a5,1
 3004a5e:	9f81                	uxtb	a5
 3004a60:	cb91                	beqz	a5,3004a74 <HAL_CRG_Init+0x66>
 3004a62:	07f00593          	li	a1,127
 3004a66:	030117b7          	lui	a5,0x3011
 3004a6a:	85878513          	addi	a0,a5,-1960 # 3010858 <g_crgIpMatch+0x348>
 3004a6e:	2b85                	jal	ra,3004fde <AssertErrorLog.trans.2>
 3004a70:	4785                	li	a5,1
 3004a72:	ac99                	j	3004cc8 <HAL_CRG_Init+0x2ba>
    CRG_PARAM_CHECK_WITH_RET(IsCrgPllPreDiv(handle->pllPreDiv), BASE_STATUS_ERROR);
 3004a74:	fdc42783          	lw	a5,-36(s0)
 3004a78:	479c                	lw	a5,8(a5)
 3004a7a:	853e                	mv	a0,a5
 3004a7c:	3ef5                	jal	ra,3004678 <IsCrgPllPreDiv>
 3004a7e:	87aa                	mv	a5,a0
 3004a80:	0017c793          	xori	a5,a5,1
 3004a84:	9f81                	uxtb	a5
 3004a86:	cb91                	beqz	a5,3004a9a <HAL_CRG_Init+0x8c>
 3004a88:	08000593          	li	a1,128
 3004a8c:	030117b7          	lui	a5,0x3011
 3004a90:	85878513          	addi	a0,a5,-1960 # 3010858 <g_crgIpMatch+0x348>
 3004a94:	23a9                	jal	ra,3004fde <AssertErrorLog.trans.2>
 3004a96:	4785                	li	a5,1
 3004a98:	ac05                	j	3004cc8 <HAL_CRG_Init+0x2ba>
    CRG_PARAM_CHECK_WITH_RET(IsCrgPllFbDiv(handle->pllFbDiv), BASE_STATUS_ERROR);
 3004a9a:	fdc42783          	lw	a5,-36(s0)
 3004a9e:	47dc                	lw	a5,12(a5)
 3004aa0:	853e                	mv	a0,a5
 3004aa2:	312d                	jal	ra,30046cc <IsCrgPllFbDiv>
 3004aa4:	87aa                	mv	a5,a0
 3004aa6:	0017c793          	xori	a5,a5,1
 3004aaa:	9f81                	uxtb	a5
 3004aac:	cb91                	beqz	a5,3004ac0 <HAL_CRG_Init+0xb2>
 3004aae:	08100593          	li	a1,129
 3004ab2:	030117b7          	lui	a5,0x3011
 3004ab6:	85878513          	addi	a0,a5,-1960 # 3010858 <g_crgIpMatch+0x348>
 3004aba:	2315                	jal	ra,3004fde <AssertErrorLog.trans.2>
 3004abc:	4785                	li	a5,1
 3004abe:	a429                	j	3004cc8 <HAL_CRG_Init+0x2ba>
    CRG_PARAM_CHECK_WITH_RET(IsCrgPllPostDiv(handle->pllPostDiv), BASE_STATUS_ERROR);
 3004ac0:	fdc42783          	lw	a5,-36(s0)
 3004ac4:	4b9c                	lw	a5,16(a5)
 3004ac6:	853e                	mv	a0,a5
 3004ac8:	36f1                	jal	ra,3004694 <IsCrgPllPostDiv>
 3004aca:	87aa                	mv	a5,a0
 3004acc:	0017c793          	xori	a5,a5,1
 3004ad0:	9f81                	uxtb	a5
 3004ad2:	cb91                	beqz	a5,3004ae6 <HAL_CRG_Init+0xd8>
 3004ad4:	08200593          	li	a1,130
 3004ad8:	030117b7          	lui	a5,0x3011
 3004adc:	85878513          	addi	a0,a5,-1960 # 3010858 <g_crgIpMatch+0x348>
 3004ae0:	29fd                	jal	ra,3004fde <AssertErrorLog.trans.2>
 3004ae2:	4785                	li	a5,1
 3004ae4:	a2d5                	j	3004cc8 <HAL_CRG_Init+0x2ba>
    CRG_PARAM_CHECK_WITH_RET(IsCrgPllPostDiv2(handle->handleEx.pllPostDiv2), BASE_STATUS_ERROR);
 3004ae6:	fdc42783          	lw	a5,-36(s0)
 3004aea:	4fdc                	lw	a5,28(a5)
 3004aec:	853e                	mv	a0,a5
 3004aee:	36c9                	jal	ra,30046b0 <IsCrgPllPostDiv2>
 3004af0:	87aa                	mv	a5,a0
 3004af2:	0017c793          	xori	a5,a5,1
 3004af6:	9f81                	uxtb	a5
 3004af8:	cb91                	beqz	a5,3004b0c <HAL_CRG_Init+0xfe>
 3004afa:	08300593          	li	a1,131
 3004afe:	030117b7          	lui	a5,0x3011
 3004b02:	85878513          	addi	a0,a5,-1960 # 3010858 <g_crgIpMatch+0x348>
 3004b06:	29e1                	jal	ra,3004fde <AssertErrorLog.trans.2>
 3004b08:	4785                	li	a5,1
 3004b0a:	aa7d                	j	3004cc8 <HAL_CRG_Init+0x2ba>
    /* Check the Clock Source and Frequency Divider of the 1 MHz Clock. */
    CRG_PARAM_CHECK_WITH_RET(IsCrg1MCkSel(handle->handleEx.clk1MSelect), BASE_STATUS_ERROR);
 3004b0c:	fdc42783          	lw	a5,-36(s0)
 3004b10:	539c                	lw	a5,32(a5)
 3004b12:	853e                	mv	a0,a5
 3004b14:	3129                	jal	ra,300471e <IsCrg1MCkSel>
 3004b16:	87aa                	mv	a5,a0
 3004b18:	0017c793          	xori	a5,a5,1
 3004b1c:	9f81                	uxtb	a5
 3004b1e:	cb91                	beqz	a5,3004b32 <HAL_CRG_Init+0x124>
 3004b20:	08500593          	li	a1,133
 3004b24:	030117b7          	lui	a5,0x3011
 3004b28:	85878513          	addi	a0,a5,-1960 # 3010858 <g_crgIpMatch+0x348>
 3004b2c:	294d                	jal	ra,3004fde <AssertErrorLog.trans.2>
 3004b2e:	4785                	li	a5,1
 3004b30:	aa61                	j	3004cc8 <HAL_CRG_Init+0x2ba>
    CRG_PARAM_CHECK_WITH_RET(IsCrg1MCkDiv(handle->handleEx.clk1MDiv), BASE_STATUS_ERROR);
 3004b32:	fdc42783          	lw	a5,-36(s0)
 3004b36:	53dc                	lw	a5,36(a5)
 3004b38:	853e                	mv	a0,a5
 3004b3a:	3901                	jal	ra,300474a <IsCrg1MCkDiv>
 3004b3c:	87aa                	mv	a5,a0
 3004b3e:	0017c793          	xori	a5,a5,1
 3004b42:	9f81                	uxtb	a5
 3004b44:	cb91                	beqz	a5,3004b58 <HAL_CRG_Init+0x14a>
 3004b46:	08600593          	li	a1,134
 3004b4a:	030117b7          	lui	a5,0x3011
 3004b4e:	85878513          	addi	a0,a5,-1960 # 3010858 <g_crgIpMatch+0x348>
 3004b52:	2171                	jal	ra,3004fde <AssertErrorLog.trans.2>
 3004b54:	4785                	li	a5,1
 3004b56:	aa8d                	j	3004cc8 <HAL_CRG_Init+0x2ba>
    CRG_PARAM_CHECK_WITH_RET(IsCrgCoreCkSel(handle->coreClkSelect), BASE_STATUS_ERROR);
 3004b58:	fdc42783          	lw	a5,-36(s0)
 3004b5c:	4f9c                	lw	a5,24(a5)
 3004b5e:	853e                	mv	a0,a5
 3004b60:	3661                	jal	ra,30046e8 <IsCrgCoreCkSel>
 3004b62:	87aa                	mv	a5,a0
 3004b64:	0017c793          	xori	a5,a5,1
 3004b68:	9f81                	uxtb	a5
 3004b6a:	cb91                	beqz	a5,3004b7e <HAL_CRG_Init+0x170>
 3004b6c:	08700593          	li	a1,135
 3004b70:	030117b7          	lui	a5,0x3011
 3004b74:	85878513          	addi	a0,a5,-1960 # 3010858 <g_crgIpMatch+0x348>
 3004b78:	219d                	jal	ra,3004fde <AssertErrorLog.trans.2>
 3004b7a:	4785                	li	a5,1
 3004b7c:	a2b1                	j	3004cc8 <HAL_CRG_Init+0x2ba>

    *(unsigned int *)CRG_HOSC_CTRL2_ADDR = 0x306E; /* Optimized HOSC temperature drift performance parameter. */
 3004b7e:	100017b7          	lui	a5,0x10001
 3004b82:	f0478793          	addi	a5,a5,-252 # 10000f04 <RAM_END+0xbff8f04>
 3004b86:	670d                	lui	a4,0x3
 3004b88:	06e70713          	addi	a4,a4,110 # 306e <STACK_SIZE+0x46e>
 3004b8c:	c398                	sw	a4,0(a5)

    CRG_RegStruct *reg = handle->baseAddress;
 3004b8e:	fdc42783          	lw	a5,-36(s0)
 3004b92:	439c                	lw	a5,0(a5)
 3004b94:	fef42623          	sw	a5,-20(s0)
    g_crgBaseAddr = (void *)reg;
 3004b98:	fec42703          	lw	a4,-20(s0)
 3004b9c:	eae1a223          	sw	a4,-348(gp) # 40005a0 <g_crgBaseAddr>
    /* Check the validity of the PLL parameter configuration. */
    if (CRG_IsValidPllConfig(handle) != BASE_STATUS_OK) {
 3004ba0:	fdc42503          	lw	a0,-36(s0)
 3004ba4:	011000ef          	jal	ra,30053b4 <CRG_IsValidPllConfig>
 3004ba8:	87aa                	mv	a5,a0
 3004baa:	c399                	beqz	a5,3004bb0 <HAL_CRG_Init+0x1a2>
        return BASE_STATUS_ERROR;
 3004bac:	4785                	li	a5,1
 3004bae:	aa29                	j	3004cc8 <HAL_CRG_Init+0x2ba>
    }
    /* Disable the write protection function of the CRG register. */
    DCL_SYSCTRL_CrgWriteProtectionDisable();
 3004bb0:	34a9                	jal	ra,30045fa <DCL_SYSCTRL_CrgWriteProtectionDisable>

    reg->PERI_CRG0.BIT.pll_ref_cksel   = handle->pllRefClkSelect;
 3004bb2:	fdc42783          	lw	a5,-36(s0)
 3004bb6:	43dc                	lw	a5,4(a5)
 3004bb8:	8b85                	andi	a5,a5,1
 3004bba:	0ff7f693          	andi	a3,a5,255
 3004bbe:	fec42703          	lw	a4,-20(s0)
 3004bc2:	431c                	lw	a5,0(a4)
 3004bc4:	8a85                	andi	a3,a3,1
 3004bc6:	9bf9                	andi	a5,a5,-2
 3004bc8:	8fd5                	or	a5,a5,a3
 3004bca:	c31c                	sw	a5,0(a4)
    reg->PERI_CRG1.BIT.pll_prediv      = handle->pllPreDiv;
 3004bcc:	fdc42783          	lw	a5,-36(s0)
 3004bd0:	479c                	lw	a5,8(a5)
 3004bd2:	8bbd                	andi	a5,a5,15
 3004bd4:	0ff7f693          	andi	a3,a5,255
 3004bd8:	fec42703          	lw	a4,-20(s0)
 3004bdc:	435c                	lw	a5,4(a4)
 3004bde:	8abd                	andi	a3,a3,15
 3004be0:	9bc1                	andi	a5,a5,-16
 3004be2:	8fd5                	or	a5,a5,a3
 3004be4:	c35c                	sw	a5,4(a4)
    reg->PERI_CRG2.BIT.pll_fbdiv       = handle->pllFbDiv;
 3004be6:	fdc42783          	lw	a5,-36(s0)
 3004bea:	47dc                	lw	a5,12(a5)
 3004bec:	0ff7f693          	andi	a3,a5,255
 3004bf0:	fec42703          	lw	a4,-20(s0)
 3004bf4:	471c                	lw	a5,8(a4)
 3004bf6:	0ff6f693          	andi	a3,a3,255
 3004bfa:	f007f793          	andi	a5,a5,-256
 3004bfe:	8fd5                	or	a5,a5,a3
 3004c00:	c71c                	sw	a5,8(a4)
    reg->PERI_CRG3.BIT.pll_postdiv1    = handle->pllPostDiv;
 3004c02:	fdc42783          	lw	a5,-36(s0)
 3004c06:	4b9c                	lw	a5,16(a5)
 3004c08:	8bbd                	andi	a5,a5,15
 3004c0a:	0ff7f693          	andi	a3,a5,255
 3004c0e:	fec42703          	lw	a4,-20(s0)
 3004c12:	475c                	lw	a5,12(a4)
 3004c14:	8abd                	andi	a3,a3,15
 3004c16:	9bc1                	andi	a5,a5,-16
 3004c18:	8fd5                	or	a5,a5,a3
 3004c1a:	c75c                	sw	a5,12(a4)
    reg->PERI_CRG3.BIT.pll_postdiv2    = handle->handleEx.pllPostDiv2;
 3004c1c:	fdc42783          	lw	a5,-36(s0)
 3004c20:	4fdc                	lw	a5,28(a5)
 3004c22:	8bbd                	andi	a5,a5,15
 3004c24:	0ff7f693          	andi	a3,a5,255
 3004c28:	fec42703          	lw	a4,-20(s0)
 3004c2c:	475c                	lw	a5,12(a4)
 3004c2e:	8abd                	andi	a3,a3,15
 3004c30:	0692                	slli	a3,a3,0x4
 3004c32:	f0f7f793          	andi	a5,a5,-241
 3004c36:	8fd5                	or	a5,a5,a3
 3004c38:	c75c                	sw	a5,12(a4)
    reg->PERI_CRG4.BIT.pll_pd          = BASE_CFG_UNSET;
 3004c3a:	fec42703          	lw	a4,-20(s0)
 3004c3e:	4b1c                	lw	a5,16(a4)
 3004c40:	9bf9                	andi	a5,a5,-2
 3004c42:	cb1c                	sw	a5,16(a4)

    while (reg->PERI_CRG7.BIT.pll_lock != BASE_CFG_SET) {
 3004c44:	0001                	nop
 3004c46:	fec42783          	lw	a5,-20(s0)
 3004c4a:	4fdc                	lw	a5,28(a5)
 3004c4c:	8b85                	andi	a5,a5,1
 3004c4e:	0ff7f713          	andi	a4,a5,255
 3004c52:	4785                	li	a5,1
 3004c54:	fef719e3          	bne	a4,a5,3004c46 <HAL_CRG_Init+0x238>
        ;  /* Wait for PLL to lock */
    }

    DCL_SYSCTRL_CrgWriteProtectionEnable();
 3004c58:	32e9                	jal	ra,3004622 <DCL_SYSCTRL_CrgWriteProtectionEnable>
    /* Check the 1MHz clock parameter configuration. */
    if (CRG_IsValid1MHzConfig(handle) != BASE_STATUS_OK) {
 3004c5a:	fdc42503          	lw	a0,-36(s0)
 3004c5e:	019000ef          	jal	ra,3005476 <CRG_IsValid1MHzConfig>
 3004c62:	87aa                	mv	a5,a0
 3004c64:	c399                	beqz	a5,3004c6a <HAL_CRG_Init+0x25c>
        return BASE_STATUS_ERROR;
 3004c66:	4785                	li	a5,1
 3004c68:	a085                	j	3004cc8 <HAL_CRG_Init+0x2ba>
    }
    while (reg->HOSC_LOCK.BIT.hosc_lock != BASE_CFG_SET) {
 3004c6a:	0001                	nop
 3004c6c:	fec42703          	lw	a4,-20(s0)
 3004c70:	6785                	lui	a5,0x1
 3004c72:	97ba                	add	a5,a5,a4
 3004c74:	f107a783          	lw	a5,-240(a5) # f10 <__bss_size__+0x29c>
 3004c78:	8b85                	andi	a5,a5,1
 3004c7a:	0ff7f713          	andi	a4,a5,255
 3004c7e:	4785                	li	a5,1
 3004c80:	fef716e3          	bne	a4,a5,3004c6c <HAL_CRG_Init+0x25e>
        ; /* Wait for HOSC to lock */
    }
    /* Set the Clock Source and Frequency Divider of the 1 MHz Clock. */
    reg->PERI_CRG67.BIT.clk_1m_div = handle->handleEx.clk1MDiv;
 3004c84:	fdc42783          	lw	a5,-36(s0)
 3004c88:	53dc                	lw	a5,36(a5)
 3004c8a:	03f7f793          	andi	a5,a5,63
 3004c8e:	0ff7f693          	andi	a3,a5,255
 3004c92:	fec42703          	lw	a4,-20(s0)
 3004c96:	10c72783          	lw	a5,268(a4)
 3004c9a:	03f6f693          	andi	a3,a3,63
 3004c9e:	fc07f793          	andi	a5,a5,-64
 3004ca2:	8fd5                	or	a5,a5,a3
 3004ca4:	10f72623          	sw	a5,268(a4)
    reg->PERI_CRG66.BIT.clk_1m_ini_cksel = handle->handleEx.clk1MSelect;
 3004ca8:	fdc42783          	lw	a5,-36(s0)
 3004cac:	539c                	lw	a5,32(a5)
 3004cae:	8b85                	andi	a5,a5,1
 3004cb0:	0ff7f693          	andi	a3,a5,255
 3004cb4:	fec42703          	lw	a4,-20(s0)
 3004cb8:	10872783          	lw	a5,264(a4)
 3004cbc:	8a85                	andi	a3,a3,1
 3004cbe:	9bf9                	andi	a5,a5,-2
 3004cc0:	8fd5                	or	a5,a5,a3
 3004cc2:	10f72423          	sw	a5,264(a4)
    return BASE_STATUS_OK;
 3004cc6:	4781                	li	a5,0
}
 3004cc8:	853e                	mv	a0,a5
 3004cca:	50b2                	lw	ra,44(sp)
 3004ccc:	5422                	lw	s0,40(sp)
 3004cce:	6145                	addi	sp,sp,48
 3004cd0:	8082                	ret

03004cd2 <HAL_CRG_SetCoreClockSelect>:
  * @param handle CRG Handle
  * @retval BASE_STATUS_OK  Success
  * @retval BASE_STATUS_ERROR Paramter check fail
  */
BASE_StatusType HAL_CRG_SetCoreClockSelect(CRG_Handle *handle)
{
 3004cd2:	7179                	addi	sp,sp,-48
 3004cd4:	d606                	sw	ra,44(sp)
 3004cd6:	d422                	sw	s0,40(sp)
 3004cd8:	1800                	addi	s0,sp,48
 3004cda:	fca42e23          	sw	a0,-36(s0)
    CRG_ASSERT_PARAM(handle != 0);
 3004cde:	fdc42783          	lw	a5,-36(s0)
 3004ce2:	eb89                	bnez	a5,3004cf4 <HAL_CRG_SetCoreClockSelect+0x22>
 3004ce4:	10700593          	li	a1,263
 3004ce8:	030117b7          	lui	a5,0x3011
 3004cec:	85878513          	addi	a0,a5,-1960 # 3010858 <g_crgIpMatch+0x348>
 3004cf0:	24fd                	jal	ra,3004fde <AssertErrorLog.trans.2>
 3004cf2:	a001                	j	3004cf2 <HAL_CRG_SetCoreClockSelect+0x20>
    CRG_ASSERT_PARAM(IsCRGInstance(handle->baseAddress));
 3004cf4:	fdc42783          	lw	a5,-36(s0)
 3004cf8:	4398                	lw	a4,0(a5)
 3004cfa:	100007b7          	lui	a5,0x10000
 3004cfe:	00f70a63          	beq	a4,a5,3004d12 <HAL_CRG_SetCoreClockSelect+0x40>
 3004d02:	10800593          	li	a1,264
 3004d06:	030117b7          	lui	a5,0x3011
 3004d0a:	85878513          	addi	a0,a5,-1960 # 3010858 <g_crgIpMatch+0x348>
 3004d0e:	2cc1                	jal	ra,3004fde <AssertErrorLog.trans.2>
 3004d10:	a001                	j	3004d10 <HAL_CRG_SetCoreClockSelect+0x3e>
    CRG_PARAM_CHECK_WITH_RET(IsCrgCoreCkSel(handle->coreClkSelect), BASE_STATUS_ERROR);
 3004d12:	fdc42783          	lw	a5,-36(s0)
 3004d16:	4f9c                	lw	a5,24(a5)
 3004d18:	853e                	mv	a0,a5
 3004d1a:	32f9                	jal	ra,30046e8 <IsCrgCoreCkSel>
 3004d1c:	87aa                	mv	a5,a0
 3004d1e:	0017c793          	xori	a5,a5,1
 3004d22:	9f81                	uxtb	a5
 3004d24:	cb91                	beqz	a5,3004d38 <HAL_CRG_SetCoreClockSelect+0x66>
 3004d26:	10900593          	li	a1,265
 3004d2a:	030117b7          	lui	a5,0x3011
 3004d2e:	85878513          	addi	a0,a5,-1960 # 3010858 <g_crgIpMatch+0x348>
 3004d32:	2475                	jal	ra,3004fde <AssertErrorLog.trans.2>
 3004d34:	4785                	li	a5,1
 3004d36:	a005                	j	3004d56 <HAL_CRG_SetCoreClockSelect+0x84>

    CRG_RegStruct *reg = handle->baseAddress;
 3004d38:	fdc42783          	lw	a5,-36(s0)
 3004d3c:	439c                	lw	a5,0(a5)
 3004d3e:	fef42623          	sw	a5,-20(s0)
   /* The write protection of the CRG register needs to be disabled. */
    DCL_SYSCTRL_CrgWriteProtectionDisable();
 3004d42:	3865                	jal	ra,30045fa <DCL_SYSCTRL_CrgWriteProtectionDisable>
    DCL_CRG_SetCoreClkSel(reg, handle->coreClkSelect);
 3004d44:	fdc42783          	lw	a5,-36(s0)
 3004d48:	4f9c                	lw	a5,24(a5)
 3004d4a:	85be                	mv	a1,a5
 3004d4c:	fec42503          	lw	a0,-20(s0)
 3004d50:	31b9                	jal	ra,300499e <DCL_CRG_SetCoreClkSel>
    DCL_SYSCTRL_CrgWriteProtectionEnable();
 3004d52:	38c1                	jal	ra,3004622 <DCL_SYSCTRL_CrgWriteProtectionEnable>

    return BASE_STATUS_OK;
 3004d54:	4781                	li	a5,0
}
 3004d56:	853e                	mv	a0,a5
 3004d58:	50b2                	lw	ra,44(sp)
 3004d5a:	5422                	lw	s0,40(sp)
 3004d5c:	6145                	addi	sp,sp,48
 3004d5e:	8082                	ret

03004d60 <CRG_GetVcoFreq>:
 * @brief Get PLL Clock Frequence
 * @param None
 * @retval unsigned int PLL clock frequency
 */
static inline unsigned int CRG_GetVcoFreq(void)
{
 3004d60:	1101                	addi	sp,sp,-32
 3004d62:	ce06                	sw	ra,28(sp)
 3004d64:	cc22                	sw	s0,24(sp)
 3004d66:	1000                	addi	s0,sp,32
    unsigned int freq;
    unsigned int regFbdiv;
    CRG_RegStruct *crg = g_crgBaseAddr;
 3004d68:	ea41a783          	lw	a5,-348(gp) # 40005a0 <g_crgBaseAddr>
 3004d6c:	fef42623          	sw	a5,-20(s0)

    CRG_ASSERT_PARAM(IsCRGInstance(crg));
 3004d70:	fec42703          	lw	a4,-20(s0)
 3004d74:	100007b7          	lui	a5,0x10000
 3004d78:	00f70a63          	beq	a4,a5,3004d8c <CRG_GetVcoFreq+0x2c>
 3004d7c:	11f00593          	li	a1,287
 3004d80:	030117b7          	lui	a5,0x3011
 3004d84:	85878513          	addi	a0,a5,-1960 # 3010858 <g_crgIpMatch+0x348>
 3004d88:	2c99                	jal	ra,3004fde <AssertErrorLog.trans.2>
 3004d8a:	a001                	j	3004d8a <CRG_GetVcoFreq+0x2a>
    CRG_ASSERT_PARAM((XTRAIL_FREQ <= 30000000U)); /* The maximum of the external clock source is 30000000U. */

    freq = CRG_GetPllRefIni(crg->PERI_CRG0.BIT.pll_ref_cksel);
 3004d8c:	fec42783          	lw	a5,-20(s0)
 3004d90:	439c                	lw	a5,0(a5)
 3004d92:	8b85                	andi	a5,a5,1
 3004d94:	9f81                	uxtb	a5
 3004d96:	853e                	mv	a0,a5
 3004d98:	730000ef          	jal	ra,30054c8 <CRG_GetPllRefIni>
 3004d9c:	fea42423          	sw	a0,-24(s0)
    freq /= CRG_GetPreDivValue(crg->PERI_CRG1.BIT.pll_prediv);
 3004da0:	fec42783          	lw	a5,-20(s0)
 3004da4:	43dc                	lw	a5,4(a5)
 3004da6:	8bbd                	andi	a5,a5,15
 3004da8:	9f81                	uxtb	a5
 3004daa:	853e                	mv	a0,a5
 3004dac:	746000ef          	jal	ra,30054f2 <CRG_GetPreDivValue>
 3004db0:	872a                	mv	a4,a0
 3004db2:	fe842783          	lw	a5,-24(s0)
 3004db6:	02e7d7b3          	divu	a5,a5,a4
 3004dba:	fef42423          	sw	a5,-24(s0)
    regFbdiv = CRG_GetPllFbDivValue(crg->PERI_CRG2.BIT.pll_fbdiv); /* Get the value of the fbdiv register. */
 3004dbe:	fec42783          	lw	a5,-20(s0)
 3004dc2:	479c                	lw	a5,8(a5)
 3004dc4:	9f81                	uxtb	a5
 3004dc6:	853e                	mv	a0,a5
 3004dc8:	758000ef          	jal	ra,3005520 <CRG_GetPllFbDivValue>
 3004dcc:	fea42223          	sw	a0,-28(s0)
    freq *= (regFbdiv >= 0x06) ? regFbdiv : 0x06; /* 0x0-0x6: divided by 0x6 */
 3004dd0:	fe442783          	lw	a5,-28(s0)
 3004dd4:	4719                	li	a4,6
 3004dd6:	00e7f363          	bgeu	a5,a4,3004ddc <CRG_GetVcoFreq+0x7c>
 3004dda:	4799                	li	a5,6
 3004ddc:	fe842703          	lw	a4,-24(s0)
 3004de0:	02f707b3          	mul	a5,a4,a5
 3004de4:	fef42423          	sw	a5,-24(s0)
    return freq;
 3004de8:	fe842783          	lw	a5,-24(s0)
}
 3004dec:	853e                	mv	a0,a5
 3004dee:	40f2                	lw	ra,28(sp)
 3004df0:	4462                	lw	s0,24(sp)
 3004df2:	6105                	addi	sp,sp,32
 3004df4:	8082                	ret

03004df6 <HAL_CRG_GetPllFreq>:
 * @brief Get PLL Clock Frequence
 * @param None
 * @retval unsigned int PLL clock frequency
 */
unsigned int HAL_CRG_GetPllFreq(void)
{
 3004df6:	1101                	addi	sp,sp,-32
 3004df8:	ce06                	sw	ra,28(sp)
 3004dfa:	cc22                	sw	s0,24(sp)
 3004dfc:	1000                	addi	s0,sp,32
    unsigned int freq;
    unsigned int pllPostDivValue;
    CRG_RegStruct *crg = g_crgBaseAddr;
 3004dfe:	ea41a783          	lw	a5,-348(gp) # 40005a0 <g_crgBaseAddr>
 3004e02:	fef42423          	sw	a5,-24(s0)

    CRG_ASSERT_PARAM(IsCRGInstance(crg));
 3004e06:	fe842703          	lw	a4,-24(s0)
 3004e0a:	100007b7          	lui	a5,0x10000
 3004e0e:	00f70a63          	beq	a4,a5,3004e22 <HAL_CRG_GetPllFreq+0x2c>
 3004e12:	13400593          	li	a1,308
 3004e16:	030117b7          	lui	a5,0x3011
 3004e1a:	85878513          	addi	a0,a5,-1960 # 3010858 <g_crgIpMatch+0x348>
 3004e1e:	22c1                	jal	ra,3004fde <AssertErrorLog.trans.2>
 3004e20:	a001                	j	3004e20 <HAL_CRG_GetPllFreq+0x2a>
    freq = CRG_GetVcoFreq();
 3004e22:	3f3d                	jal	ra,3004d60 <CRG_GetVcoFreq>
 3004e24:	fea42623          	sw	a0,-20(s0)
    pllPostDivValue = CRG_GetPllPostDivValue((CRG_PllPostDiv)crg->PERI_CRG3.BIT.pll_postdiv1);
 3004e28:	fe842783          	lw	a5,-24(s0)
 3004e2c:	47dc                	lw	a5,12(a5)
 3004e2e:	8bbd                	andi	a5,a5,15
 3004e30:	9f81                	uxtb	a5
 3004e32:	853e                	mv	a0,a5
 3004e34:	72e000ef          	jal	ra,3005562 <CRG_GetPllPostDivValue>
 3004e38:	fea42223          	sw	a0,-28(s0)
    /* Calculate the PLL output clock frequency based on the VCO clock frequency and post-division coefficient. */
    if (pllPostDivValue != 0) {
 3004e3c:	fe442783          	lw	a5,-28(s0)
 3004e40:	cb89                	beqz	a5,3004e52 <HAL_CRG_GetPllFreq+0x5c>
        freq /= pllPostDivValue;
 3004e42:	fec42703          	lw	a4,-20(s0)
 3004e46:	fe442783          	lw	a5,-28(s0)
 3004e4a:	02f757b3          	divu	a5,a4,a5
 3004e4e:	fef42623          	sw	a5,-20(s0)
    }
    return freq;
 3004e52:	fec42783          	lw	a5,-20(s0)
}
 3004e56:	853e                	mv	a0,a5
 3004e58:	40f2                	lw	ra,28(sp)
 3004e5a:	4462                	lw	s0,24(sp)
 3004e5c:	6105                	addi	sp,sp,32
 3004e5e:	8082                	ret

03004e60 <HAL_CRG_GetCoreClkFreq>:
 * @brief Get Core Clock Frequence
 * @param None
 * @retval unsigned int  Core clock frequency
 */
unsigned int HAL_CRG_GetCoreClkFreq(void)
{
 3004e60:	1101                	addi	sp,sp,-32
 3004e62:	ce06                	sw	ra,28(sp)
 3004e64:	cc22                	sw	s0,24(sp)
 3004e66:	1000                	addi	s0,sp,32
    unsigned int freq;
    unsigned int coreClkSelect;
    CRG_RegStruct *crg = g_crgBaseAddr;
 3004e68:	ea41a783          	lw	a5,-348(gp) # 40005a0 <g_crgBaseAddr>
 3004e6c:	fef42423          	sw	a5,-24(s0)

    CRG_ASSERT_PARAM(IsCRGInstance(crg));
 3004e70:	fe842703          	lw	a4,-24(s0)
 3004e74:	100007b7          	lui	a5,0x10000
 3004e78:	00f70a63          	beq	a4,a5,3004e8c <HAL_CRG_GetCoreClkFreq+0x2c>
 3004e7c:	14900593          	li	a1,329
 3004e80:	030117b7          	lui	a5,0x3011
 3004e84:	85878513          	addi	a0,a5,-1960 # 3010858 <g_crgIpMatch+0x348>
 3004e88:	2a99                	jal	ra,3004fde <AssertErrorLog.trans.2>
 3004e8a:	a001                	j	3004e8a <HAL_CRG_GetCoreClkFreq+0x2a>
    coreClkSelect = crg->PERI_CRG64.BIT.clk_pst1_sw_sel;
 3004e8c:	fe842783          	lw	a5,-24(s0)
 3004e90:	1007a783          	lw	a5,256(a5)
 3004e94:	8b8d                	andi	a5,a5,3
 3004e96:	9f81                	uxtb	a5
 3004e98:	fef42223          	sw	a5,-28(s0)
    switch (coreClkSelect) {
 3004e9c:	fe442783          	lw	a5,-28(s0)
 3004ea0:	4705                	li	a4,1
 3004ea2:	02e78063          	beq	a5,a4,3004ec2 <HAL_CRG_GetCoreClkFreq+0x62>
 3004ea6:	4705                	li	a4,1
 3004ea8:	00e7e663          	bltu	a5,a4,3004eb4 <HAL_CRG_GetCoreClkFreq+0x54>
 3004eac:	4709                	li	a4,2
 3004eae:	02e78163          	beq	a5,a4,3004ed0 <HAL_CRG_GetCoreClkFreq+0x70>
 3004eb2:	a01d                	j	3004ed8 <HAL_CRG_GetCoreClkFreq+0x78>
        case CRG_CORE_CLK_SELECT_HOSC: /* The clock source is an internal high-speed clock. */
            freq = HOSC_FREQ;
 3004eb4:	017d87b7          	lui	a5,0x17d8
 3004eb8:	84078793          	addi	a5,a5,-1984 # 17d7840 <FLASH_SIZE+0x17b7844>
 3004ebc:	fef42623          	sw	a5,-20(s0)
            break;
 3004ec0:	a015                	j	3004ee4 <HAL_CRG_GetCoreClkFreq+0x84>

        case CRG_CORE_CLK_SELECT_TCXO: /* The clock source is the external crystal oscillator clock. */
            freq = XTRAIL_FREQ;
 3004ec2:	01c9c7b7          	lui	a5,0x1c9c
 3004ec6:	38078793          	addi	a5,a5,896 # 1c9c380 <FLASH_SIZE+0x1c7c384>
 3004eca:	fef42623          	sw	a5,-20(s0)
            break;
 3004ece:	a819                	j	3004ee4 <HAL_CRG_GetCoreClkFreq+0x84>

        case CRG_CORE_CLK_SELECT_PLL: /* The clock source is the PLL. */
            freq = HAL_CRG_GetPllFreq();
 3004ed0:	371d                	jal	ra,3004df6 <HAL_CRG_GetPllFreq>
 3004ed2:	fea42623          	sw	a0,-20(s0)
            break;
 3004ed6:	a039                	j	3004ee4 <HAL_CRG_GetCoreClkFreq+0x84>

        default:
            freq = LOSC_FREQ;
 3004ed8:	67a1                	lui	a5,0x8
 3004eda:	d0078793          	addi	a5,a5,-768 # 7d00 <RAM_SIZE+0x2d00>
 3004ede:	fef42623          	sw	a5,-20(s0)
            break;
 3004ee2:	0001                	nop
    }
    return freq;
 3004ee4:	fec42783          	lw	a5,-20(s0)
}
 3004ee8:	853e                	mv	a0,a5
 3004eea:	40f2                	lw	ra,28(sp)
 3004eec:	4462                	lw	s0,24(sp)
 3004eee:	6105                	addi	sp,sp,32
 3004ef0:	8082                	ret

03004ef2 <HAL_CRG_GetIpFreq>:
 * @brief Get Clock Frequence
 * @param handle CRG Handle
 * @retval Frequece of IP
 */
unsigned int HAL_CRG_GetIpFreq(const void *baseAddress)
{
 3004ef2:	7179                	addi	sp,sp,-48
 3004ef4:	d606                	sw	ra,44(sp)
 3004ef6:	d422                	sw	s0,40(sp)
 3004ef8:	1800                	addi	s0,sp,48
 3004efa:	fca42e23          	sw	a0,-36(s0)
    CRG_ASSERT_PARAM(baseAddress != NULL);
 3004efe:	fdc42783          	lw	a5,-36(s0)
 3004f02:	eb89                	bnez	a5,3004f14 <HAL_CRG_GetIpFreq+0x22>
 3004f04:	16600593          	li	a1,358
 3004f08:	030117b7          	lui	a5,0x3011
 3004f0c:	85878513          	addi	a0,a5,-1960 # 3010858 <g_crgIpMatch+0x348>
 3004f10:	20f9                	jal	ra,3004fde <AssertErrorLog.trans.2>
 3004f12:	a001                	j	3004f12 <HAL_CRG_GetIpFreq+0x20>
    CRG_ASSERT_PARAM(IsCRGInstance(g_crgBaseAddr));
 3004f14:	ea41a703          	lw	a4,-348(gp) # 40005a0 <g_crgBaseAddr>
 3004f18:	100007b7          	lui	a5,0x10000
 3004f1c:	00f70a63          	beq	a4,a5,3004f30 <HAL_CRG_GetIpFreq+0x3e>
 3004f20:	16700593          	li	a1,359
 3004f24:	030117b7          	lui	a5,0x3011
 3004f28:	85878513          	addi	a0,a5,-1960 # 3010858 <g_crgIpMatch+0x348>
 3004f2c:	284d                	jal	ra,3004fde <AssertErrorLog.trans.2>
 3004f2e:	a001                	j	3004f2e <HAL_CRG_GetIpFreq+0x3c>
#ifdef FPGA
    /* Use this function to obtain the clock frequency during the FPGA phase. */
    return CHIP_GetIpFreqHz(baseAddress);
#else
    unsigned int hclk = HAL_CRG_GetCoreClkFreq();
 3004f30:	3f05                	jal	ra,3004e60 <HAL_CRG_GetCoreClkFreq>
 3004f32:	fea42423          	sw	a0,-24(s0)
    unsigned int freq = LOSC_FREQ;
 3004f36:	67a1                	lui	a5,0x8
 3004f38:	d0078793          	addi	a5,a5,-768 # 7d00 <RAM_SIZE+0x2d00>
 3004f3c:	fef42623          	sw	a5,-20(s0)
    unsigned int coreClkFreq;
    /* Get the CRG type of the target IP. */
    CHIP_CrgIpMatchInfo *p = GetCrgIpMatchInfo(baseAddress);
 3004f40:	fdc42503          	lw	a0,-36(s0)
 3004f44:	2c7d                	jal	ra,3005202 <GetCrgIpMatchInfo.trans.38>
 3004f46:	fea42223          	sw	a0,-28(s0)
    if (p == NULL) {
 3004f4a:	fe442783          	lw	a5,-28(s0)
 3004f4e:	e781                	bnez	a5,3004f56 <HAL_CRG_GetIpFreq+0x64>
        return freq;
 3004f50:	fec42783          	lw	a5,-20(s0)
 3004f54:	a041                	j	3004fd4 <HAL_CRG_GetIpFreq+0xe2>
    }
    switch (p->type) {
 3004f56:	fe442783          	lw	a5,-28(s0)
 3004f5a:	43dc                	lw	a5,4(a5)
 3004f5c:	4719                	li	a4,6
 3004f5e:	06f76063          	bltu	a4,a5,3004fbe <HAL_CRG_GetIpFreq+0xcc>
 3004f62:	00279713          	slli	a4,a5,0x2
 3004f66:	030117b7          	lui	a5,0x3011
 3004f6a:	89478793          	addi	a5,a5,-1900 # 3010894 <g_crgIpMatch+0x384>
 3004f6e:	97ba                	add	a5,a5,a4
 3004f70:	439c                	lw	a5,0(a5)
 3004f72:	8782                	jr	a5
        case CRG_IP_WITH_CLK_SEL:
            /* Get the clock frequency of the module with the frequency division function. */
            freq = CRG_GetLsIpFreq(p, hclk);
 3004f74:	fe842583          	lw	a1,-24(s0)
 3004f78:	fe442503          	lw	a0,-28(s0)
 3004f7c:	2469                	jal	ra,3005206 <CRG_GetLsIpFreq>
 3004f7e:	fea42623          	sw	a0,-20(s0)
            break;
 3004f82:	a83d                	j	3004fc0 <HAL_CRG_GetIpFreq+0xce>

        case CRG_IP_NONE_CLK_SEL:
        case CRG_IP_EFC:
        case CRG_IP_ANA:
            freq = hclk; /* Returns the internal high speed clock frequency. */
 3004f84:	fe842783          	lw	a5,-24(s0)
 3004f88:	fef42623          	sw	a5,-20(s0)
            break;
 3004f8c:	a815                	j	3004fc0 <HAL_CRG_GetIpFreq+0xce>

        case CRG_IP_CAN:
            freq = CRG_GetPllRefIni(g_crgBaseAddr->PERI_CRG0.BIT.pll_ref_cksel);
 3004f8e:	ea41a783          	lw	a5,-348(gp) # 40005a0 <g_crgBaseAddr>
 3004f92:	439c                	lw	a5,0(a5)
 3004f94:	8b85                	andi	a5,a5,1
 3004f96:	9f81                	uxtb	a5
 3004f98:	853e                	mv	a0,a5
 3004f9a:	233d                	jal	ra,30054c8 <CRG_GetPllRefIni>
 3004f9c:	fea42623          	sw	a0,-20(s0)
            break;
 3004fa0:	a005                	j	3004fc0 <HAL_CRG_GetIpFreq+0xce>

        case CRG_IP_ADC:
            /* Get core clock frequence for calculating the ADC clock frequency. */
            coreClkFreq = HAL_CRG_GetCoreClkFreq();
 3004fa2:	3d7d                	jal	ra,3004e60 <HAL_CRG_GetCoreClkFreq>
 3004fa4:	fea42023          	sw	a0,-32(s0)
            freq = CRG_GetAdcIpFreq(p, CRG_GetVcoFreq(), coreClkFreq);
 3004fa8:	3b65                	jal	ra,3004d60 <CRG_GetVcoFreq>
 3004faa:	87aa                	mv	a5,a0
 3004fac:	fe042603          	lw	a2,-32(s0)
 3004fb0:	85be                	mv	a1,a5
 3004fb2:	fe442503          	lw	a0,-28(s0)
 3004fb6:	24d5                	jal	ra,300529a <CRG_GetAdcIpFreq>
 3004fb8:	fea42623          	sw	a0,-20(s0)
            break;
 3004fbc:	a011                	j	3004fc0 <HAL_CRG_GetIpFreq+0xce>

        case CRG_IP_IWDG: /* The IWDG clock frequency is an internal low-speed clock. */
        default:
            break;
 3004fbe:	0001                	nop
    }
    if (freq == 0) {
 3004fc0:	fec42783          	lw	a5,-20(s0)
 3004fc4:	e791                	bnez	a5,3004fd0 <HAL_CRG_GetIpFreq+0xde>
        freq = LOSC_FREQ;
 3004fc6:	67a1                	lui	a5,0x8
 3004fc8:	d0078793          	addi	a5,a5,-768 # 7d00 <RAM_SIZE+0x2d00>
 3004fcc:	fef42623          	sw	a5,-20(s0)
    }
    return freq;
 3004fd0:	fec42783          	lw	a5,-20(s0)
#endif
}
 3004fd4:	853e                	mv	a0,a5
 3004fd6:	50b2                	lw	ra,44(sp)
 3004fd8:	5422                	lw	s0,40(sp)
 3004fda:	6145                	addi	sp,sp,48
 3004fdc:	8082                	ret

03004fde <AssertErrorLog.trans.2>:
 3004fde:	d61fd06f          	j	3002d3e <AssertErrorLog>

03004fe2 <HAL_CRG_IpEnableSet>:
  * @param enable enable mask
  * @retval BASE_STATUS_ERROR       Can't find the Match or operation is not support
  * @retval BASE_STATUS_OK          Operation Success
  */
BASE_StatusType HAL_CRG_IpEnableSet(const void *baseAddress, unsigned int enable)
{
 3004fe2:	7179                	addi	sp,sp,-48
 3004fe4:	d606                	sw	ra,44(sp)
 3004fe6:	d422                	sw	s0,40(sp)
 3004fe8:	1800                	addi	s0,sp,48
 3004fea:	fca42e23          	sw	a0,-36(s0)
 3004fee:	fcb42c23          	sw	a1,-40(s0)
    CRG_ASSERT_PARAM(baseAddress != NULL);
 3004ff2:	fdc42783          	lw	a5,-36(s0)
 3004ff6:	eb89                	bnez	a5,3005008 <HAL_CRG_IpEnableSet+0x26>
 3004ff8:	19e00593          	li	a1,414
 3004ffc:	030117b7          	lui	a5,0x3011
 3005000:	85878513          	addi	a0,a5,-1960 # 3010858 <g_crgIpMatch+0x348>
 3005004:	3fe9                	jal	ra,3004fde <AssertErrorLog.trans.2>
 3005006:	a001                	j	3005006 <HAL_CRG_IpEnableSet+0x24>
    CRG_ASSERT_PARAM(IsCRGInstance(g_crgBaseAddr));
 3005008:	ea41a703          	lw	a4,-348(gp) # 40005a0 <g_crgBaseAddr>
 300500c:	100007b7          	lui	a5,0x10000
 3005010:	00f70a63          	beq	a4,a5,3005024 <HAL_CRG_IpEnableSet+0x42>
 3005014:	19f00593          	li	a1,415
 3005018:	030117b7          	lui	a5,0x3011
 300501c:	85878513          	addi	a0,a5,-1960 # 3010858 <g_crgIpMatch+0x348>
 3005020:	3f7d                	jal	ra,3004fde <AssertErrorLog.trans.2>
 3005022:	a001                	j	3005022 <HAL_CRG_IpEnableSet+0x40>
    /* Check the validity of the input parameters. */
    CRG_PARAM_CHECK_WITH_RET((enable == IP_CLK_ENABLE || enable == IP_CLK_DISABLE), BASE_STATUS_ERROR);
 3005024:	fd842703          	lw	a4,-40(s0)
 3005028:	4785                	li	a5,1
 300502a:	00f70e63          	beq	a4,a5,3005046 <HAL_CRG_IpEnableSet+0x64>
 300502e:	fd842783          	lw	a5,-40(s0)
 3005032:	cb91                	beqz	a5,3005046 <HAL_CRG_IpEnableSet+0x64>
 3005034:	1a100593          	li	a1,417
 3005038:	030117b7          	lui	a5,0x3011
 300503c:	85878513          	addi	a0,a5,-1960 # 3010858 <g_crgIpMatch+0x348>
 3005040:	3f79                	jal	ra,3004fde <AssertErrorLog.trans.2>
 3005042:	4785                	li	a5,1
 3005044:	a085                	j	30050a4 <HAL_CRG_IpEnableSet+0xc2>
    /* Get the CRG type of the target IP. */
    CHIP_CrgIpMatchInfo *p = GetCrgIpMatchInfo(baseAddress);
 3005046:	fdc42503          	lw	a0,-36(s0)
 300504a:	2a65                	jal	ra,3005202 <GetCrgIpMatchInfo.trans.38>
 300504c:	fea42623          	sw	a0,-20(s0)
    if ((p == NULL) || (p->type >= CRG_IP_MAX_TYPE)) {
 3005050:	fec42783          	lw	a5,-20(s0)
 3005054:	c799                	beqz	a5,3005062 <HAL_CRG_IpEnableSet+0x80>
 3005056:	fec42783          	lw	a5,-20(s0)
 300505a:	43d8                	lw	a4,4(a5)
 300505c:	4799                	li	a5,6
 300505e:	00e7f463          	bgeu	a5,a4,3005066 <HAL_CRG_IpEnableSet+0x84>
        return BASE_STATUS_ERROR;
 3005062:	4785                	li	a5,1
 3005064:	a081                	j	30050a4 <HAL_CRG_IpEnableSet+0xc2>
    }
    if (g_ipClkProc[p->type].enableSet == NULL) {
 3005066:	fec42783          	lw	a5,-20(s0)
 300506a:	43d4                	lw	a3,4(a5)
 300506c:	91818713          	addi	a4,gp,-1768 # 4000014 <g_ipClkProc>
 3005070:	02400793          	li	a5,36
 3005074:	02f687b3          	mul	a5,a3,a5
 3005078:	97ba                	add	a5,a5,a4
 300507a:	479c                	lw	a5,8(a5)
 300507c:	e399                	bnez	a5,3005082 <HAL_CRG_IpEnableSet+0xa0>
        return BASE_STATUS_ERROR;
 300507e:	4785                	li	a5,1
 3005080:	a015                	j	30050a4 <HAL_CRG_IpEnableSet+0xc2>
    }
    g_ipClkProc[p->type].enableSet(p, enable);
 3005082:	fec42783          	lw	a5,-20(s0)
 3005086:	43d4                	lw	a3,4(a5)
 3005088:	91818713          	addi	a4,gp,-1768 # 4000014 <g_ipClkProc>
 300508c:	02400793          	li	a5,36
 3005090:	02f687b3          	mul	a5,a3,a5
 3005094:	97ba                	add	a5,a5,a4
 3005096:	479c                	lw	a5,8(a5)
 3005098:	fd842583          	lw	a1,-40(s0)
 300509c:	fec42503          	lw	a0,-20(s0)
 30050a0:	9782                	jalr	a5
    return BASE_STATUS_OK;
 30050a2:	4781                	li	a5,0
}
 30050a4:	853e                	mv	a0,a5
 30050a6:	50b2                	lw	ra,44(sp)
 30050a8:	5422                	lw	s0,40(sp)
 30050aa:	6145                	addi	sp,sp,48
 30050ac:	8082                	ret

030050ae <HAL_CRG_IpClkSelectSet>:
  * @param select clock select, @see CRG_APBLsClkSelect for ip in apb_ls_subsys or CRG_AdcClkSelect for adc
  * @retval BASE_STATUS_OK    success
  * @retval BASE_STATUS_ERROR fail
  */
BASE_StatusType HAL_CRG_IpClkSelectSet(const void *baseAddress, unsigned int select)
{
 30050ae:	7179                	addi	sp,sp,-48
 30050b0:	d606                	sw	ra,44(sp)
 30050b2:	d422                	sw	s0,40(sp)
 30050b4:	1800                	addi	s0,sp,48
 30050b6:	fca42e23          	sw	a0,-36(s0)
 30050ba:	fcb42c23          	sw	a1,-40(s0)
    CRG_ASSERT_PARAM(baseAddress != NULL);
 30050be:	fdc42783          	lw	a5,-36(s0)
 30050c2:	eb89                	bnez	a5,30050d4 <HAL_CRG_IpClkSelectSet+0x26>
 30050c4:	1cf00593          	li	a1,463
 30050c8:	030117b7          	lui	a5,0x3011
 30050cc:	85878513          	addi	a0,a5,-1960 # 3010858 <g_crgIpMatch+0x348>
 30050d0:	3739                	jal	ra,3004fde <AssertErrorLog.trans.2>
 30050d2:	a001                	j	30050d2 <HAL_CRG_IpClkSelectSet+0x24>
    CRG_ASSERT_PARAM(IsCRGInstance(g_crgBaseAddr));
 30050d4:	ea41a703          	lw	a4,-348(gp) # 40005a0 <g_crgBaseAddr>
 30050d8:	100007b7          	lui	a5,0x10000
 30050dc:	00f70a63          	beq	a4,a5,30050f0 <HAL_CRG_IpClkSelectSet+0x42>
 30050e0:	1d000593          	li	a1,464
 30050e4:	030117b7          	lui	a5,0x3011
 30050e8:	85878513          	addi	a0,a5,-1960 # 3010858 <g_crgIpMatch+0x348>
 30050ec:	3dcd                	jal	ra,3004fde <AssertErrorLog.trans.2>
 30050ee:	a001                	j	30050ee <HAL_CRG_IpClkSelectSet+0x40>

    CHIP_CrgIpMatchInfo *p = GetCrgIpMatchInfo(baseAddress);
 30050f0:	fdc42503          	lw	a0,-36(s0)
 30050f4:	2239                	jal	ra,3005202 <GetCrgIpMatchInfo.trans.38>
 30050f6:	fea42623          	sw	a0,-20(s0)
    if ((p == NULL) || (p->type >= CRG_IP_MAX_TYPE)) {
 30050fa:	fec42783          	lw	a5,-20(s0)
 30050fe:	c799                	beqz	a5,300510c <HAL_CRG_IpClkSelectSet+0x5e>
 3005100:	fec42783          	lw	a5,-20(s0)
 3005104:	43d8                	lw	a4,4(a5)
 3005106:	4799                	li	a5,6
 3005108:	00e7f463          	bgeu	a5,a4,3005110 <HAL_CRG_IpClkSelectSet+0x62>
        return BASE_STATUS_ERROR;
 300510c:	4785                	li	a5,1
 300510e:	a081                	j	300514e <HAL_CRG_IpClkSelectSet+0xa0>
    }
    if (g_ipClkProc[p->type].clkSelSet == NULL) {
 3005110:	fec42783          	lw	a5,-20(s0)
 3005114:	43d4                	lw	a3,4(a5)
 3005116:	91818713          	addi	a4,gp,-1768 # 4000014 <g_ipClkProc>
 300511a:	02400793          	li	a5,36
 300511e:	02f687b3          	mul	a5,a3,a5
 3005122:	97ba                	add	a5,a5,a4
 3005124:	47dc                	lw	a5,12(a5)
 3005126:	e399                	bnez	a5,300512c <HAL_CRG_IpClkSelectSet+0x7e>
        return BASE_STATUS_ERROR;
 3005128:	4785                	li	a5,1
 300512a:	a015                	j	300514e <HAL_CRG_IpClkSelectSet+0xa0>
    }
    g_ipClkProc[p->type].clkSelSet(p, select); /* Clock selection of the configuration module. */
 300512c:	fec42783          	lw	a5,-20(s0)
 3005130:	43d4                	lw	a3,4(a5)
 3005132:	91818713          	addi	a4,gp,-1768 # 4000014 <g_ipClkProc>
 3005136:	02400793          	li	a5,36
 300513a:	02f687b3          	mul	a5,a3,a5
 300513e:	97ba                	add	a5,a5,a4
 3005140:	47dc                	lw	a5,12(a5)
 3005142:	fd842583          	lw	a1,-40(s0)
 3005146:	fec42503          	lw	a0,-20(s0)
 300514a:	9782                	jalr	a5
    return BASE_STATUS_OK;
 300514c:	4781                	li	a5,0
}
 300514e:	853e                	mv	a0,a5
 3005150:	50b2                	lw	ra,44(sp)
 3005152:	5422                	lw	s0,40(sp)
 3005154:	6145                	addi	sp,sp,48
 3005156:	8082                	ret

03005158 <HAL_CRG_IpClkDivSet>:
  * @param div set div value
  * @retval BASE_STATUS_OK     Success
  * @retval BASE_STATUS_ERROR  Match Fail or Not support
  */
BASE_StatusType HAL_CRG_IpClkDivSet(const void *baseAddress, unsigned int div)
{
 3005158:	7179                	addi	sp,sp,-48
 300515a:	d606                	sw	ra,44(sp)
 300515c:	d422                	sw	s0,40(sp)
 300515e:	1800                	addi	s0,sp,48
 3005160:	fca42e23          	sw	a0,-36(s0)
 3005164:	fcb42c23          	sw	a1,-40(s0)
    CRG_ASSERT_PARAM(baseAddress != NULL);
 3005168:	fdc42783          	lw	a5,-36(s0)
 300516c:	eb89                	bnez	a5,300517e <HAL_CRG_IpClkDivSet+0x26>
 300516e:	22e00593          	li	a1,558
 3005172:	030117b7          	lui	a5,0x3011
 3005176:	85878513          	addi	a0,a5,-1960 # 3010858 <g_crgIpMatch+0x348>
 300517a:	3595                	jal	ra,3004fde <AssertErrorLog.trans.2>
 300517c:	a001                	j	300517c <HAL_CRG_IpClkDivSet+0x24>
    CRG_ASSERT_PARAM(IsCRGInstance(g_crgBaseAddr));
 300517e:	ea41a703          	lw	a4,-348(gp) # 40005a0 <g_crgBaseAddr>
 3005182:	100007b7          	lui	a5,0x10000
 3005186:	00f70a63          	beq	a4,a5,300519a <HAL_CRG_IpClkDivSet+0x42>
 300518a:	22f00593          	li	a1,559
 300518e:	030117b7          	lui	a5,0x3011
 3005192:	85878513          	addi	a0,a5,-1960 # 3010858 <g_crgIpMatch+0x348>
 3005196:	35a1                	jal	ra,3004fde <AssertErrorLog.trans.2>
 3005198:	a001                	j	3005198 <HAL_CRG_IpClkDivSet+0x40>

    CHIP_CrgIpMatchInfo *p = GetCrgIpMatchInfo(baseAddress);
 300519a:	fdc42503          	lw	a0,-36(s0)
 300519e:	2095                	jal	ra,3005202 <GetCrgIpMatchInfo.trans.38>
 30051a0:	fea42623          	sw	a0,-20(s0)
    if ((p == NULL) || (p->type >= CRG_IP_MAX_TYPE)) {
 30051a4:	fec42783          	lw	a5,-20(s0)
 30051a8:	c799                	beqz	a5,30051b6 <HAL_CRG_IpClkDivSet+0x5e>
 30051aa:	fec42783          	lw	a5,-20(s0)
 30051ae:	43d8                	lw	a4,4(a5)
 30051b0:	4799                	li	a5,6
 30051b2:	00e7f463          	bgeu	a5,a4,30051ba <HAL_CRG_IpClkDivSet+0x62>
        return BASE_STATUS_ERROR;
 30051b6:	4785                	li	a5,1
 30051b8:	a081                	j	30051f8 <HAL_CRG_IpClkDivSet+0xa0>
    }
    if (g_ipClkProc[p->type].clkDivSet == NULL) {
 30051ba:	fec42783          	lw	a5,-20(s0)
 30051be:	43d4                	lw	a3,4(a5)
 30051c0:	91818713          	addi	a4,gp,-1768 # 4000014 <g_ipClkProc>
 30051c4:	02400793          	li	a5,36
 30051c8:	02f687b3          	mul	a5,a3,a5
 30051cc:	97ba                	add	a5,a5,a4
 30051ce:	4b9c                	lw	a5,16(a5)
 30051d0:	e399                	bnez	a5,30051d6 <HAL_CRG_IpClkDivSet+0x7e>
        return BASE_STATUS_ERROR;
 30051d2:	4785                	li	a5,1
 30051d4:	a015                	j	30051f8 <HAL_CRG_IpClkDivSet+0xa0>
    }
    g_ipClkProc[p->type].clkDivSet(p, div); /* Configure the clock frequency divider of the module. */
 30051d6:	fec42783          	lw	a5,-20(s0)
 30051da:	43d4                	lw	a3,4(a5)
 30051dc:	91818713          	addi	a4,gp,-1768 # 4000014 <g_ipClkProc>
 30051e0:	02400793          	li	a5,36
 30051e4:	02f687b3          	mul	a5,a3,a5
 30051e8:	97ba                	add	a5,a5,a4
 30051ea:	4b9c                	lw	a5,16(a5)
 30051ec:	fd842583          	lw	a1,-40(s0)
 30051f0:	fec42503          	lw	a0,-20(s0)
 30051f4:	9782                	jalr	a5
    return BASE_STATUS_OK;
 30051f6:	4781                	li	a5,0
}
 30051f8:	853e                	mv	a0,a5
 30051fa:	50b2                	lw	ra,44(sp)
 30051fc:	5422                	lw	s0,40(sp)
 30051fe:	6145                	addi	sp,sp,48
 3005200:	8082                	ret

03005202 <GetCrgIpMatchInfo.trans.38>:
 3005202:	fd7fb06f          	j	30011d8 <GetCrgIpMatchInfo>

03005206 <CRG_GetLsIpFreq>:
  * @param matchInfo match info
  * @param baseClkRate clock rate
  * @retval Ip Frequence
  */
static unsigned int CRG_GetLsIpFreq(const CHIP_CrgIpMatchInfo *matchInfo, unsigned int baseClkRate)
{
 3005206:	7179                	addi	sp,sp,-48
 3005208:	d606                	sw	ra,44(sp)
 300520a:	d422                	sw	s0,40(sp)
 300520c:	1800                	addi	s0,sp,48
 300520e:	fca42e23          	sw	a0,-36(s0)
 3005212:	fcb42c23          	sw	a1,-40(s0)
    CRG_ASSERT_PARAM(matchInfo != NULL);
 3005216:	fdc42783          	lw	a5,-36(s0)
 300521a:	eb89                	bnez	a5,300522c <CRG_GetLsIpFreq+0x26>
 300521c:	2af00593          	li	a1,687
 3005220:	030117b7          	lui	a5,0x3011
 3005224:	85878513          	addi	a0,a5,-1960 # 3010858 <g_crgIpMatch+0x348>
 3005228:	3b5d                	jal	ra,3004fde <AssertErrorLog.trans.2>
 300522a:	a001                	j	300522a <CRG_GetLsIpFreq+0x24>
    CRG_ASSERT_PARAM(g_crgBaseAddr != NULL);
 300522c:	ea41a783          	lw	a5,-348(gp) # 40005a0 <g_crgBaseAddr>
 3005230:	eb89                	bnez	a5,3005242 <CRG_GetLsIpFreq+0x3c>
 3005232:	2b000593          	li	a1,688
 3005236:	030117b7          	lui	a5,0x3011
 300523a:	85878513          	addi	a0,a5,-1960 # 3010858 <g_crgIpMatch+0x348>
 300523e:	3345                	jal	ra,3004fde <AssertErrorLog.trans.2>
 3005240:	a001                	j	3005240 <CRG_GetLsIpFreq+0x3a>

    unsigned int clkSel;
    CRG_IpProc *proc;
    
    if (matchInfo->type == CRG_IP_WITH_CLK_SEL) { /* type in legal scope */
 3005242:	fdc42783          	lw	a5,-36(s0)
 3005246:	43dc                	lw	a5,4(a5)
 3005248:	e395                	bnez	a5,300526c <CRG_GetLsIpFreq+0x66>
        proc = &g_ipClkProc[matchInfo->type];
 300524a:	fdc42783          	lw	a5,-36(s0)
 300524e:	43d8                	lw	a4,4(a5)
 3005250:	02400793          	li	a5,36
 3005254:	02f70733          	mul	a4,a4,a5
 3005258:	91818793          	addi	a5,gp,-1768 # 4000014 <g_ipClkProc>
 300525c:	97ba                	add	a5,a5,a4
 300525e:	fef42623          	sw	a5,-20(s0)
    } else {
        return 0;
    }

    if (proc->clkSelGet == NULL) {
 3005262:	fec42783          	lw	a5,-20(s0)
 3005266:	4fdc                	lw	a5,28(a5)
 3005268:	e791                	bnez	a5,3005274 <CRG_GetLsIpFreq+0x6e>
 300526a:	a019                	j	3005270 <CRG_GetLsIpFreq+0x6a>
        return 0;
 300526c:	4781                	li	a5,0
 300526e:	a00d                	j	3005290 <CRG_GetLsIpFreq+0x8a>
        return 0;
 3005270:	4781                	li	a5,0
 3005272:	a839                	j	3005290 <CRG_GetLsIpFreq+0x8a>
    }
    clkSel = proc->clkSelGet(matchInfo);
 3005274:	fec42783          	lw	a5,-20(s0)
 3005278:	4fdc                	lw	a5,28(a5)
 300527a:	fdc42503          	lw	a0,-36(s0)
 300527e:	9782                	jalr	a5
 3005280:	fea42423          	sw	a0,-24(s0)
    return (baseClkRate >> clkSel);
 3005284:	fd842703          	lw	a4,-40(s0)
 3005288:	fe842783          	lw	a5,-24(s0)
 300528c:	00f757b3          	srl	a5,a4,a5
}
 3005290:	853e                	mv	a0,a5
 3005292:	50b2                	lw	ra,44(sp)
 3005294:	5422                	lw	s0,40(sp)
 3005296:	6145                	addi	sp,sp,48
 3005298:	8082                	ret

0300529a <CRG_GetAdcIpFreq>:
  * @param coreClkFreq core clock rate
  * @retval Ip Frequence
  */
static unsigned int CRG_GetAdcIpFreq(const CHIP_CrgIpMatchInfo *matchInfo, unsigned int baseClkRate,
                                     unsigned int coreClkFreq)
{
 300529a:	7139                	addi	sp,sp,-64
 300529c:	de06                	sw	ra,60(sp)
 300529e:	dc22                	sw	s0,56(sp)
 30052a0:	0080                	addi	s0,sp,64
 30052a2:	fca42623          	sw	a0,-52(s0)
 30052a6:	fcb42423          	sw	a1,-56(s0)
 30052aa:	fcc42223          	sw	a2,-60(s0)
    CRG_ASSERT_PARAM(matchInfo != NULL);
 30052ae:	fcc42783          	lw	a5,-52(s0)
 30052b2:	eb89                	bnez	a5,30052c4 <CRG_GetAdcIpFreq+0x2a>
 30052b4:	2cc00593          	li	a1,716
 30052b8:	030117b7          	lui	a5,0x3011
 30052bc:	85878513          	addi	a0,a5,-1960 # 3010858 <g_crgIpMatch+0x348>
 30052c0:	3b39                	jal	ra,3004fde <AssertErrorLog.trans.2>
 30052c2:	a001                	j	30052c2 <CRG_GetAdcIpFreq+0x28>
    CRG_ASSERT_PARAM(g_crgBaseAddr != NULL);
 30052c4:	ea41a783          	lw	a5,-348(gp) # 40005a0 <g_crgBaseAddr>
 30052c8:	eb89                	bnez	a5,30052da <CRG_GetAdcIpFreq+0x40>
 30052ca:	2cd00593          	li	a1,717
 30052ce:	030117b7          	lui	a5,0x3011
 30052d2:	85878513          	addi	a0,a5,-1960 # 3010858 <g_crgIpMatch+0x348>
 30052d6:	3321                	jal	ra,3004fde <AssertErrorLog.trans.2>
 30052d8:	a001                	j	30052d8 <CRG_GetAdcIpFreq+0x3e>
    
    unsigned int clkSel;
    unsigned int clkDiv;
    unsigned int pst2Div;
    unsigned int freq = 0;
 30052da:	fe042623          	sw	zero,-20(s0)
    
    /* Obtains the clock source selection of the ADC. */
    const CRG_IpProc *proc = &g_ipClkProc[matchInfo->type];
 30052de:	fcc42783          	lw	a5,-52(s0)
 30052e2:	43d8                	lw	a4,4(a5)
 30052e4:	02400793          	li	a5,36
 30052e8:	02f70733          	mul	a4,a4,a5
 30052ec:	91818793          	addi	a5,gp,-1768 # 4000014 <g_ipClkProc>
 30052f0:	97ba                	add	a5,a5,a4
 30052f2:	fef42423          	sw	a5,-24(s0)
    if (proc->clkSelGet == NULL) {
 30052f6:	fe842783          	lw	a5,-24(s0)
 30052fa:	4fdc                	lw	a5,28(a5)
 30052fc:	e399                	bnez	a5,3005302 <CRG_GetAdcIpFreq+0x68>
        return 0;
 30052fe:	4781                	li	a5,0
 3005300:	a06d                	j	30053aa <CRG_GetAdcIpFreq+0x110>
    }
    clkSel = proc->clkSelGet(matchInfo);
 3005302:	fe842783          	lw	a5,-24(s0)
 3005306:	4fdc                	lw	a5,28(a5)
 3005308:	fcc42503          	lw	a0,-52(s0)
 300530c:	9782                	jalr	a5
 300530e:	fea42223          	sw	a0,-28(s0)
    /* Calculate the frequency from the ADC's clock source. */
    if (clkSel == CRG_ADC_CLK_SYN_CORE) {
 3005312:	fe442703          	lw	a4,-28(s0)
 3005316:	478d                	li	a5,3
 3005318:	00f71763          	bne	a4,a5,3005326 <CRG_GetAdcIpFreq+0x8c>
        freq = coreClkFreq;
 300531c:	fc442783          	lw	a5,-60(s0)
 3005320:	fef42623          	sw	a5,-20(s0)
 3005324:	a8b1                	j	3005380 <CRG_GetAdcIpFreq+0xe6>
    } else if (clkSel == CRG_ADC_CLK_ASYN_HOSC) {
 3005326:	fe442783          	lw	a5,-28(s0)
 300532a:	eb81                	bnez	a5,300533a <CRG_GetAdcIpFreq+0xa0>
        freq = HOSC_FREQ;
 300532c:	017d87b7          	lui	a5,0x17d8
 3005330:	84078793          	addi	a5,a5,-1984 # 17d7840 <FLASH_SIZE+0x17b7844>
 3005334:	fef42623          	sw	a5,-20(s0)
 3005338:	a0a1                	j	3005380 <CRG_GetAdcIpFreq+0xe6>
    } else if (clkSel == CRG_ADC_CLK_ASYN_TCXO) {
 300533a:	fe442703          	lw	a4,-28(s0)
 300533e:	4785                	li	a5,1
 3005340:	00f71963          	bne	a4,a5,3005352 <CRG_GetAdcIpFreq+0xb8>
        /* The maximum speed of the external clock source is 30000000U. */
        freq = (XTRAIL_FREQ > 30000000U) ? 0 : XTRAIL_FREQ;
 3005344:	01c9c7b7          	lui	a5,0x1c9c
 3005348:	38078793          	addi	a5,a5,896 # 1c9c380 <FLASH_SIZE+0x1c7c384>
 300534c:	fef42623          	sw	a5,-20(s0)
 3005350:	a805                	j	3005380 <CRG_GetAdcIpFreq+0xe6>
    } else if (clkSel == CRG_ADC_CLK_ASYN_PLL_DIV) {
 3005352:	fe442703          	lw	a4,-28(s0)
 3005356:	4789                	li	a5,2
 3005358:	02f71463          	bne	a4,a5,3005380 <CRG_GetAdcIpFreq+0xe6>
        pst2Div = CRG_GetPllPostDivValue((CRG_PllPostDiv)g_crgBaseAddr->PERI_CRG3.BIT.pll_postdiv2);
 300535c:	ea41a783          	lw	a5,-348(gp) # 40005a0 <g_crgBaseAddr>
 3005360:	47dc                	lw	a5,12(a5)
 3005362:	8391                	srli	a5,a5,0x4
 3005364:	8bbd                	andi	a5,a5,15
 3005366:	9f81                	uxtb	a5
 3005368:	853e                	mv	a0,a5
 300536a:	2ae5                	jal	ra,3005562 <CRG_GetPllPostDivValue>
 300536c:	fea42023          	sw	a0,-32(s0)
        freq = baseClkRate / pst2Div;
 3005370:	fc842703          	lw	a4,-56(s0)
 3005374:	fe042783          	lw	a5,-32(s0)
 3005378:	02f757b3          	divu	a5,a4,a5
 300537c:	fef42623          	sw	a5,-20(s0)
    }

    /* Obtain the frequency divider based on the ADC clock source. */
    if (proc->clkDivGet == NULL) {
 3005380:	fe842783          	lw	a5,-24(s0)
 3005384:	539c                	lw	a5,32(a5)
 3005386:	e399                	bnez	a5,300538c <CRG_GetAdcIpFreq+0xf2>
        return 0;
 3005388:	4781                	li	a5,0
 300538a:	a005                	j	30053aa <CRG_GetAdcIpFreq+0x110>
    }
    clkDiv = proc->clkDivGet(matchInfo);
 300538c:	fe842783          	lw	a5,-24(s0)
 3005390:	539c                	lw	a5,32(a5)
 3005392:	fcc42503          	lw	a0,-52(s0)
 3005396:	9782                	jalr	a5
 3005398:	fca42e23          	sw	a0,-36(s0)
    /* Calculate the clock frequency of the ADC. */
    return (freq / (clkDiv + 1));
 300539c:	fdc42783          	lw	a5,-36(s0)
 30053a0:	0785                	addi	a5,a5,1
 30053a2:	fec42703          	lw	a4,-20(s0)
 30053a6:	02f757b3          	divu	a5,a4,a5
}
 30053aa:	853e                	mv	a0,a5
 30053ac:	50f2                	lw	ra,60(sp)
 30053ae:	5462                	lw	s0,56(sp)
 30053b0:	6121                	addi	sp,sp,64
 30053b2:	8082                	ret

030053b4 <CRG_IsValidPllConfig>:
 * @param  CRG_Handle CRG handle
  * @retval BASE_STATUS_OK     Check Success
  * @retval BASE_STATUS_ERROR  Check Fail
 */
static BASE_StatusType CRG_IsValidPllConfig(const CRG_Handle *handle)
{
 30053b4:	7179                	addi	sp,sp,-48
 30053b6:	d606                	sw	ra,44(sp)
 30053b8:	d422                	sw	s0,40(sp)
 30053ba:	1800                	addi	s0,sp,48
 30053bc:	fca42e23          	sw	a0,-36(s0)
    unsigned int preDiv;
    unsigned int freq;

    freq = CRG_GetPllRefIni(handle->pllRefClkSelect);
 30053c0:	fdc42783          	lw	a5,-36(s0)
 30053c4:	43dc                	lw	a5,4(a5)
 30053c6:	853e                	mv	a0,a5
 30053c8:	2201                	jal	ra,30054c8 <CRG_GetPllRefIni>
 30053ca:	fea42623          	sw	a0,-20(s0)
    preDiv = CRG_GetPreDivValue(handle->pllPreDiv);
 30053ce:	fdc42783          	lw	a5,-36(s0)
 30053d2:	479c                	lw	a5,8(a5)
 30053d4:	853e                	mv	a0,a5
 30053d6:	2a31                	jal	ra,30054f2 <CRG_GetPreDivValue>
 30053d8:	fea42423          	sw	a0,-24(s0)
    /* Check the validity of the prescaled clock frequency. */
    if (!IsCrgValidPreDiv(freq, preDiv)) {
 30053dc:	fe842583          	lw	a1,-24(s0)
 30053e0:	fec42503          	lw	a0,-20(s0)
 30053e4:	bc2ff0ef          	jal	ra,30047a6 <IsCrgValidPreDiv>
 30053e8:	87aa                	mv	a5,a0
 30053ea:	0017c793          	xori	a5,a5,1
 30053ee:	9f81                	uxtb	a5
 30053f0:	c399                	beqz	a5,30053f6 <CRG_IsValidPllConfig+0x42>
        return BASE_STATUS_ERROR;
 30053f2:	4785                	li	a5,1
 30053f4:	a8a5                	j	300546c <CRG_IsValidPllConfig+0xb8>
    }
    freq /= preDiv;
 30053f6:	fec42703          	lw	a4,-20(s0)
 30053fa:	fe842783          	lw	a5,-24(s0)
 30053fe:	02f757b3          	divu	a5,a4,a5
 3005402:	fef42623          	sw	a5,-20(s0)
    /* Check the validity of the clock frequency after frequency multiplication. */
    if (!IsCrgValidFdDiv(freq, handle->pllFbDiv)) {
 3005406:	fdc42783          	lw	a5,-36(s0)
 300540a:	47dc                	lw	a5,12(a5)
 300540c:	85be                	mv	a1,a5
 300540e:	fec42503          	lw	a0,-20(s0)
 3005412:	bf2ff0ef          	jal	ra,3004804 <IsCrgValidFdDiv>
 3005416:	87aa                	mv	a5,a0
 3005418:	0017c793          	xori	a5,a5,1
 300541c:	9f81                	uxtb	a5
 300541e:	c399                	beqz	a5,3005424 <CRG_IsValidPllConfig+0x70>
        return BASE_STATUS_ERROR;
 3005420:	4785                	li	a5,1
 3005422:	a0a9                	j	300546c <CRG_IsValidPllConfig+0xb8>
    }
    freq *= (handle->pllFbDiv > 0x06) ? handle->pllFbDiv : 0x06; /* 0x0-0x6: divided by 0x6 */
 3005424:	fdc42783          	lw	a5,-36(s0)
 3005428:	47dc                	lw	a5,12(a5)
 300542a:	4719                	li	a4,6
 300542c:	00e7f363          	bgeu	a5,a4,3005432 <CRG_IsValidPllConfig+0x7e>
 3005430:	4799                	li	a5,6
 3005432:	fec42703          	lw	a4,-20(s0)
 3005436:	02f707b3          	mul	a5,a4,a5
 300543a:	fef42623          	sw	a5,-20(s0)
    /* Check whether the PLL output frequency is valid. */
    if (IsCrgValidPostDiv(freq, handle->pllPostDiv) && IsCrgValidPostDiv2(freq, handle->handleEx.pllPostDiv2)) {
 300543e:	fdc42783          	lw	a5,-36(s0)
 3005442:	4b9c                	lw	a5,16(a5)
 3005444:	85be                	mv	a1,a5
 3005446:	fec42503          	lw	a0,-20(s0)
 300544a:	c44ff0ef          	jal	ra,300488e <IsCrgValidPostDiv>
 300544e:	87aa                	mv	a5,a0
 3005450:	cf89                	beqz	a5,300546a <CRG_IsValidPllConfig+0xb6>
 3005452:	fdc42783          	lw	a5,-36(s0)
 3005456:	4fdc                	lw	a5,28(a5)
 3005458:	85be                	mv	a1,a5
 300545a:	fec42503          	lw	a0,-20(s0)
 300545e:	c78ff0ef          	jal	ra,30048d6 <IsCrgValidPostDiv2>
 3005462:	87aa                	mv	a5,a0
 3005464:	c399                	beqz	a5,300546a <CRG_IsValidPllConfig+0xb6>
        return BASE_STATUS_OK;
 3005466:	4781                	li	a5,0
 3005468:	a011                	j	300546c <CRG_IsValidPllConfig+0xb8>
    }
    return BASE_STATUS_ERROR;
 300546a:	4785                	li	a5,1
}
 300546c:	853e                	mv	a0,a5
 300546e:	50b2                	lw	ra,44(sp)
 3005470:	5422                	lw	s0,40(sp)
 3005472:	6145                	addi	sp,sp,48
 3005474:	8082                	ret

03005476 <CRG_IsValid1MHzConfig>:
 * @param  CRG_Handle CRG handle
  * @retval BASE_STATUS_OK     Check Success
  * @retval BASE_STATUS_ERROR  Check Fail
 */
static BASE_StatusType CRG_IsValid1MHzConfig(const CRG_Handle *handle)
{
 3005476:	7179                	addi	sp,sp,-48
 3005478:	d622                	sw	s0,44(sp)
 300547a:	1800                	addi	s0,sp,48
 300547c:	fca42e23          	sw	a0,-36(s0)
    unsigned int freq;
    /* Get the ref frequency of the 1 MHz clock. */
    freq = (handle->handleEx.clk1MSelect == CRG_1M_CLK_SELECT_HOSC) ? HOSC_FREQ : XTRAIL_FREQ;
 3005480:	fdc42783          	lw	a5,-36(s0)
 3005484:	539c                	lw	a5,32(a5)
 3005486:	e791                	bnez	a5,3005492 <CRG_IsValid1MHzConfig+0x1c>
 3005488:	017d87b7          	lui	a5,0x17d8
 300548c:	84078793          	addi	a5,a5,-1984 # 17d7840 <FLASH_SIZE+0x17b7844>
 3005490:	a029                	j	300549a <CRG_IsValid1MHzConfig+0x24>
 3005492:	01c9c7b7          	lui	a5,0x1c9c
 3005496:	38078793          	addi	a5,a5,896 # 1c9c380 <FLASH_SIZE+0x1c7c384>
 300549a:	fef42623          	sw	a5,-20(s0)
    /* Check whether the 1MHz output frequency is valid. */
    if ((freq / (handle->handleEx.clk1MDiv + 1)) == CRG_FREQ_1MHz) {
 300549e:	fdc42783          	lw	a5,-36(s0)
 30054a2:	53dc                	lw	a5,36(a5)
 30054a4:	0785                	addi	a5,a5,1
 30054a6:	fec42703          	lw	a4,-20(s0)
 30054aa:	02f75733          	divu	a4,a4,a5
 30054ae:	000f47b7          	lui	a5,0xf4
 30054b2:	24078793          	addi	a5,a5,576 # f4240 <FLASH_SIZE+0xd4244>
 30054b6:	00f71463          	bne	a4,a5,30054be <CRG_IsValid1MHzConfig+0x48>
        return BASE_STATUS_OK;
 30054ba:	4781                	li	a5,0
 30054bc:	a011                	j	30054c0 <CRG_IsValid1MHzConfig+0x4a>
    }
    return BASE_STATUS_ERROR;
 30054be:	4785                	li	a5,1
}
 30054c0:	853e                	mv	a0,a5
 30054c2:	5432                	lw	s0,44(sp)
 30054c4:	6145                	addi	sp,sp,48
 30054c6:	8082                	ret

030054c8 <CRG_GetPllRefIni>:
 * @brief Get clock frequence
 * @param  crg CRG_RegStruct
 * @retval The frequence fo clock
 */
static inline unsigned int CRG_GetPllRefIni(CRG_PllRefClkSelect pllRefClkSelect)
{
 30054c8:	1101                	addi	sp,sp,-32
 30054ca:	ce22                	sw	s0,28(sp)
 30054cc:	1000                	addi	s0,sp,32
 30054ce:	fea42623          	sw	a0,-20(s0)
    /* The maximum speed of the external clock source is 30000000U. */
    if (pllRefClkSelect == CRG_PLL_REF_CLK_SELECT_XTAL && XTRAIL_FREQ > 30000000U) {
        return 0;
    }
    return (pllRefClkSelect == (unsigned int)CRG_PLL_REF_CLK_SELECT_HOSC) ? HOSC_FREQ : XTRAIL_FREQ;
 30054d2:	fec42783          	lw	a5,-20(s0)
 30054d6:	e791                	bnez	a5,30054e2 <CRG_GetPllRefIni+0x1a>
 30054d8:	017d87b7          	lui	a5,0x17d8
 30054dc:	84078793          	addi	a5,a5,-1984 # 17d7840 <FLASH_SIZE+0x17b7844>
 30054e0:	a029                	j	30054ea <CRG_GetPllRefIni+0x22>
 30054e2:	01c9c7b7          	lui	a5,0x1c9c
 30054e6:	38078793          	addi	a5,a5,896 # 1c9c380 <FLASH_SIZE+0x1c7c384>
}
 30054ea:	853e                	mv	a0,a5
 30054ec:	4472                	lw	s0,28(sp)
 30054ee:	6105                	addi	sp,sp,32
 30054f0:	8082                	ret

030054f2 <CRG_GetPreDivValue>:
 * @brief Get previous division Value before PLL
 * @param  crg CRG_RegStruct
 * @retval Previous Div value
 */
static inline unsigned int CRG_GetPreDivValue(CRG_PllPreDiv pllPredDiv)
{
 30054f2:	7179                	addi	sp,sp,-48
 30054f4:	d622                	sw	s0,44(sp)
 30054f6:	1800                	addi	s0,sp,48
 30054f8:	fca42e23          	sw	a0,-36(s0)
    unsigned int preDiv;
    if (pllPredDiv <= CRG_PLL_PREDIV_1) { /* 0 or 1 returns PLL_PREDIV_OUT_1. */
 30054fc:	fdc42783          	lw	a5,-36(s0)
 3005500:	e789                	bnez	a5,300550a <CRG_GetPreDivValue+0x18>
        preDiv = PLL_PREDIV_OUT_1;
 3005502:	4785                	li	a5,1
 3005504:	fef42623          	sw	a5,-20(s0)
 3005508:	a031                	j	3005514 <CRG_GetPreDivValue+0x22>
    } else {
        preDiv = pllPredDiv + 1;
 300550a:	fdc42783          	lw	a5,-36(s0)
 300550e:	0785                	addi	a5,a5,1
 3005510:	fef42623          	sw	a5,-20(s0)
    }
    return preDiv;
 3005514:	fec42783          	lw	a5,-20(s0)
}
 3005518:	853e                	mv	a0,a5
 300551a:	5432                	lw	s0,44(sp)
 300551c:	6145                	addi	sp,sp,48
 300551e:	8082                	ret

03005520 <CRG_GetPllFbDivValue>:
 * @brief Get PLL loop divider ratio
 * @param  crg CRG_RegStruct
 * @retval PLL loop divider ratio
 */
static inline unsigned int CRG_GetPllFbDivValue(unsigned int pllFbDiv)
{
 3005520:	7179                	addi	sp,sp,-48
 3005522:	d622                	sw	s0,44(sp)
 3005524:	1800                	addi	s0,sp,48
 3005526:	fca42e23          	sw	a0,-36(s0)
    unsigned int div = pllFbDiv;
 300552a:	fdc42783          	lw	a5,-36(s0)
 300552e:	fef42623          	sw	a5,-20(s0)
    /* Check the validity of the minimum frequency multiplication parameter. */
    if (div < CRG_PLL_FBDIV_MIN) {
 3005532:	fec42703          	lw	a4,-20(s0)
 3005536:	4795                	li	a5,5
 3005538:	00e7e563          	bltu	a5,a4,3005542 <CRG_GetPllFbDivValue+0x22>
        div = CRG_PLL_FBDIV_MIN;
 300553c:	4799                	li	a5,6
 300553e:	fef42623          	sw	a5,-20(s0)
    }
    /* Check the validity of the maximum frequency multiplication parameter. */
    if (div > CRG_PLL_FBDIV_MAX) {
 3005542:	fec42703          	lw	a4,-20(s0)
 3005546:	07f00793          	li	a5,127
 300554a:	00e7f663          	bgeu	a5,a4,3005556 <CRG_GetPllFbDivValue+0x36>
        div = CRG_PLL_FBDIV_MAX;
 300554e:	07f00793          	li	a5,127
 3005552:	fef42623          	sw	a5,-20(s0)
    }
    return div;
 3005556:	fec42783          	lw	a5,-20(s0)
}
 300555a:	853e                	mv	a0,a5
 300555c:	5432                	lw	s0,44(sp)
 300555e:	6145                	addi	sp,sp,48
 3005560:	8082                	ret

03005562 <CRG_GetPllPostDivValue>:
 * @brief Get post division Value after PLL
 * @param  crg CRG_RegStruct
 * @retval Previous Div value
 */
static inline unsigned int CRG_GetPllPostDivValue(unsigned int pllPostDiv)
{
 3005562:	7179                	addi	sp,sp,-48
 3005564:	d622                	sw	s0,44(sp)
 3005566:	1800                	addi	s0,sp,48
 3005568:	fca42e23          	sw	a0,-36(s0)
    unsigned int div = pllPostDiv;
 300556c:	fdc42783          	lw	a5,-36(s0)
 3005570:	fef42623          	sw	a5,-20(s0)
    if (div > CRG_PLL_POSTDIV_8) {
 3005574:	fec42703          	lw	a4,-20(s0)
 3005578:	479d                	li	a5,7
 300557a:	00e7f663          	bgeu	a5,a4,3005586 <CRG_GetPllPostDivValue+0x24>
        div = (CRG_PLL_POSTDIV_8 + 1); /* If the postdiv is greater than 8, set this postdiv to 8. */
 300557e:	47a1                	li	a5,8
 3005580:	fef42623          	sw	a5,-20(s0)
 3005584:	a031                	j	3005590 <CRG_GetPllPostDivValue+0x2e>
    } else {
        div += 1;
 3005586:	fec42783          	lw	a5,-20(s0)
 300558a:	0785                	addi	a5,a5,1
 300558c:	fef42623          	sw	a5,-20(s0)
    }
    return div;
 3005590:	fec42783          	lw	a5,-20(s0)
}
 3005594:	853e                	mv	a0,a5
 3005596:	5432                	lw	s0,44(sp)
 3005598:	6145                	addi	sp,sp,48
 300559a:	8082                	ret

0300559c <CRG_IpWithClkSelEnableSet>:
 * @param matchInfo IP with Clock select match info
 * @param enable  BASE_CFG_SET or BASE_CFG_UNSET
 * @retval None
 */
static void CRG_IpWithClkSelEnableSet(const CHIP_CrgIpMatchInfo *matchInfo, unsigned int enable)
{
 300559c:	7179                	addi	sp,sp,-48
 300559e:	d606                	sw	ra,44(sp)
 30055a0:	d422                	sw	s0,40(sp)
 30055a2:	1800                	addi	s0,sp,48
 30055a4:	fca42e23          	sw	a0,-36(s0)
 30055a8:	fcb42c23          	sw	a1,-40(s0)
    CRG_ASSERT_PARAM(matchInfo != NULL);
 30055ac:	fdc42783          	lw	a5,-36(s0)
 30055b0:	eb89                	bnez	a5,30055c2 <CRG_IpWithClkSelEnableSet+0x26>
 30055b2:	36a00593          	li	a1,874
 30055b6:	030117b7          	lui	a5,0x3011
 30055ba:	85878513          	addi	a0,a5,-1960 # 3010858 <g_crgIpMatch+0x348>
 30055be:	3405                	jal	ra,3004fde <AssertErrorLog.trans.2>
 30055c0:	a001                	j	30055c0 <CRG_IpWithClkSelEnableSet+0x24>
    CRG_ASSERT_PARAM(g_crgBaseAddr != NULL);
 30055c2:	ea41a783          	lw	a5,-348(gp) # 40005a0 <g_crgBaseAddr>
 30055c6:	eb89                	bnez	a5,30055d8 <CRG_IpWithClkSelEnableSet+0x3c>
 30055c8:	36b00593          	li	a1,875
 30055cc:	030117b7          	lui	a5,0x3011
 30055d0:	85878513          	addi	a0,a5,-1960 # 3010858 <g_crgIpMatch+0x348>
 30055d4:	3429                	jal	ra,3004fde <AssertErrorLog.trans.2>
 30055d6:	a001                	j	30055d6 <CRG_IpWithClkSelEnableSet+0x3a>

    uintptr_t base = (uintptr_t)(void *)g_crgBaseAddr;
 30055d8:	ea41a783          	lw	a5,-348(gp) # 40005a0 <g_crgBaseAddr>
 30055dc:	fef42623          	sw	a5,-20(s0)
    CRG_IpWithClkSelectCfg *p = (CRG_IpWithClkSelectCfg *)(void *)(base + matchInfo->regOffset);
 30055e0:	fdc42783          	lw	a5,-36(s0)
 30055e4:	279e                	lhu	a5,8(a5)
 30055e6:	873e                	mv	a4,a5
 30055e8:	fec42783          	lw	a5,-20(s0)
 30055ec:	97ba                	add	a5,a5,a4
 30055ee:	fef42423          	sw	a5,-24(s0)
    if ((enable & IP_CLK_ENABLE) == IP_CLK_ENABLE) {
 30055f2:	fd842783          	lw	a5,-40(s0)
 30055f6:	8b85                	andi	a5,a5,1
 30055f8:	cf99                	beqz	a5,3005616 <CRG_IpWithClkSelEnableSet+0x7a>
        p->BIT.cken = BASE_CFG_SET;
 30055fa:	fe842703          	lw	a4,-24(s0)
 30055fe:	431c                	lw	a5,0(a4)
 3005600:	0017e793          	ori	a5,a5,1
 3005604:	c31c                	sw	a5,0(a4)
        p->BIT.srst_req = BASE_CFG_UNSET;   /* Enable with soft reset disable */
 3005606:	fe842703          	lw	a4,-24(s0)
 300560a:	431c                	lw	a5,0(a4)
 300560c:	76c1                	lui	a3,0xffff0
 300560e:	16fd                	addi	a3,a3,-1 # fffeffff <RAM_END+0xfbfe7fff>
 3005610:	8ff5                	and	a5,a5,a3
 3005612:	c31c                	sw	a5,0(a4)
    } else {
        p->BIT.cken = BASE_CFG_UNSET;
        p->BIT.srst_req = BASE_CFG_SET;   /* Enable with soft reset disable */
    }
}
 3005614:	a821                	j	300562c <CRG_IpWithClkSelEnableSet+0x90>
        p->BIT.cken = BASE_CFG_UNSET;
 3005616:	fe842703          	lw	a4,-24(s0)
 300561a:	431c                	lw	a5,0(a4)
 300561c:	9bf9                	andi	a5,a5,-2
 300561e:	c31c                	sw	a5,0(a4)
        p->BIT.srst_req = BASE_CFG_SET;   /* Enable with soft reset disable */
 3005620:	fe842703          	lw	a4,-24(s0)
 3005624:	431c                	lw	a5,0(a4)
 3005626:	66c1                	lui	a3,0x10
 3005628:	8fd5                	or	a5,a5,a3
 300562a:	c31c                	sw	a5,0(a4)
}
 300562c:	0001                	nop
 300562e:	50b2                	lw	ra,44(sp)
 3005630:	5422                	lw	s0,40(sp)
 3005632:	6145                	addi	sp,sp,48
 3005634:	8082                	ret

03005636 <CRG_IpWithClkSelEnableGet>:
 * @param matchInfo IP with Clock select match info
 * @param unsigned int 0: disable, 1: enable
 * @retval Clock enable status
 */
static unsigned int CRG_IpWithClkSelEnableGet(const CHIP_CrgIpMatchInfo *matchInfo)
{
 3005636:	7179                	addi	sp,sp,-48
 3005638:	d606                	sw	ra,44(sp)
 300563a:	d422                	sw	s0,40(sp)
 300563c:	1800                	addi	s0,sp,48
 300563e:	fca42e23          	sw	a0,-36(s0)
    CRG_ASSERT_PARAM(matchInfo != NULL);
 3005642:	fdc42783          	lw	a5,-36(s0)
 3005646:	eb89                	bnez	a5,3005658 <CRG_IpWithClkSelEnableGet+0x22>
 3005648:	38000593          	li	a1,896
 300564c:	030117b7          	lui	a5,0x3011
 3005650:	85878513          	addi	a0,a5,-1960 # 3010858 <g_crgIpMatch+0x348>
 3005654:	3269                	jal	ra,3004fde <AssertErrorLog.trans.2>
 3005656:	a001                	j	3005656 <CRG_IpWithClkSelEnableGet+0x20>
    CRG_ASSERT_PARAM(g_crgBaseAddr != NULL);
 3005658:	ea41a783          	lw	a5,-348(gp) # 40005a0 <g_crgBaseAddr>
 300565c:	eb89                	bnez	a5,300566e <CRG_IpWithClkSelEnableGet+0x38>
 300565e:	38100593          	li	a1,897
 3005662:	030117b7          	lui	a5,0x3011
 3005666:	85878513          	addi	a0,a5,-1960 # 3010858 <g_crgIpMatch+0x348>
 300566a:	3a95                	jal	ra,3004fde <AssertErrorLog.trans.2>
 300566c:	a001                	j	300566c <CRG_IpWithClkSelEnableGet+0x36>
    /* Get Clock enable status or undo for target ip. */
    uintptr_t base = (uintptr_t)(void *)g_crgBaseAddr;
 300566e:	ea41a783          	lw	a5,-348(gp) # 40005a0 <g_crgBaseAddr>
 3005672:	fef42623          	sw	a5,-20(s0)
    CRG_IpWithClkSelectCfg *p = (CRG_IpWithClkSelectCfg *)(void *)(base + matchInfo->regOffset);
 3005676:	fdc42783          	lw	a5,-36(s0)
 300567a:	279e                	lhu	a5,8(a5)
 300567c:	873e                	mv	a4,a5
 300567e:	fec42783          	lw	a5,-20(s0)
 3005682:	97ba                	add	a5,a5,a4
 3005684:	fef42423          	sw	a5,-24(s0)
    return p->BIT.cken;
 3005688:	fe842783          	lw	a5,-24(s0)
 300568c:	439c                	lw	a5,0(a5)
 300568e:	8b85                	andi	a5,a5,1
 3005690:	9f81                	uxtb	a5
}
 3005692:	853e                	mv	a0,a5
 3005694:	50b2                	lw	ra,44(sp)
 3005696:	5422                	lw	s0,40(sp)
 3005698:	6145                	addi	sp,sp,48
 300569a:	8082                	ret

0300569c <CRG_IpWithClkSelResetSet>:
 * @param matchInfo IP with Clock select match info
 * @param reset  BASE_CFG_SET or BASE_CFG_UNSET
 * @retval None
 */
static void CRG_IpWithClkSelResetSet(const CHIP_CrgIpMatchInfo *matchInfo, unsigned int reset)
{
 300569c:	7179                	addi	sp,sp,-48
 300569e:	d606                	sw	ra,44(sp)
 30056a0:	d422                	sw	s0,40(sp)
 30056a2:	1800                	addi	s0,sp,48
 30056a4:	fca42e23          	sw	a0,-36(s0)
 30056a8:	fcb42c23          	sw	a1,-40(s0)
    CRG_ASSERT_PARAM(matchInfo != NULL);
 30056ac:	fdc42783          	lw	a5,-36(s0)
 30056b0:	eb89                	bnez	a5,30056c2 <CRG_IpWithClkSelResetSet+0x26>
 30056b2:	39000593          	li	a1,912
 30056b6:	030117b7          	lui	a5,0x3011
 30056ba:	85878513          	addi	a0,a5,-1960 # 3010858 <g_crgIpMatch+0x348>
 30056be:	3205                	jal	ra,3004fde <AssertErrorLog.trans.2>
 30056c0:	a001                	j	30056c0 <CRG_IpWithClkSelResetSet+0x24>
    CRG_ASSERT_PARAM(g_crgBaseAddr != NULL);
 30056c2:	ea41a783          	lw	a5,-348(gp) # 40005a0 <g_crgBaseAddr>
 30056c6:	eb89                	bnez	a5,30056d8 <CRG_IpWithClkSelResetSet+0x3c>
 30056c8:	39100593          	li	a1,913
 30056cc:	030117b7          	lui	a5,0x3011
 30056d0:	85878513          	addi	a0,a5,-1960 # 3010858 <g_crgIpMatch+0x348>
 30056d4:	3229                	jal	ra,3004fde <AssertErrorLog.trans.2>
 30056d6:	a001                	j	30056d6 <CRG_IpWithClkSelResetSet+0x3a>
    /* Set Clock reset or undo for target ip. */
    uintptr_t base = (uintptr_t)(void *)g_crgBaseAddr;
 30056d8:	ea41a783          	lw	a5,-348(gp) # 40005a0 <g_crgBaseAddr>
 30056dc:	fef42623          	sw	a5,-20(s0)
    CRG_IpWithClkSelectCfg *p = (CRG_IpWithClkSelectCfg *)(void *)(base + matchInfo->regOffset);
 30056e0:	fdc42783          	lw	a5,-36(s0)
 30056e4:	279e                	lhu	a5,8(a5)
 30056e6:	873e                	mv	a4,a5
 30056e8:	fec42783          	lw	a5,-20(s0)
 30056ec:	97ba                	add	a5,a5,a4
 30056ee:	fef42423          	sw	a5,-24(s0)
    p->BIT.srst_req = (reset & BASE_CFG_SET) ? BASE_CFG_SET : BASE_CFG_UNSET;
 30056f2:	fd842783          	lw	a5,-40(s0)
 30056f6:	8b85                	andi	a5,a5,1
 30056f8:	0ff7f693          	andi	a3,a5,255
 30056fc:	fe842703          	lw	a4,-24(s0)
 3005700:	431c                	lw	a5,0(a4)
 3005702:	8a85                	andi	a3,a3,1
 3005704:	06c2                	slli	a3,a3,0x10
 3005706:	7641                	lui	a2,0xffff0
 3005708:	167d                	addi	a2,a2,-1 # fffeffff <RAM_END+0xfbfe7fff>
 300570a:	8ff1                	and	a5,a5,a2
 300570c:	8fd5                	or	a5,a5,a3
 300570e:	c31c                	sw	a5,0(a4)
}
 3005710:	0001                	nop
 3005712:	50b2                	lw	ra,44(sp)
 3005714:	5422                	lw	s0,40(sp)
 3005716:	6145                	addi	sp,sp,48
 3005718:	8082                	ret

0300571a <CRG_IpWithClkSelResetGet>:
 * @param matchInfo IP with Clock select match info
 * @param unsigned int 0: disable, 1: enable
 * @retval Clock reset status
 */
static unsigned int CRG_IpWithClkSelResetGet(const CHIP_CrgIpMatchInfo *matchInfo)
{
 300571a:	7179                	addi	sp,sp,-48
 300571c:	d606                	sw	ra,44(sp)
 300571e:	d422                	sw	s0,40(sp)
 3005720:	1800                	addi	s0,sp,48
 3005722:	fca42e23          	sw	a0,-36(s0)
    CRG_ASSERT_PARAM(matchInfo != NULL);
 3005726:	fdc42783          	lw	a5,-36(s0)
 300572a:	eb89                	bnez	a5,300573c <CRG_IpWithClkSelResetGet+0x22>
 300572c:	3a000593          	li	a1,928
 3005730:	030117b7          	lui	a5,0x3011
 3005734:	85878513          	addi	a0,a5,-1960 # 3010858 <g_crgIpMatch+0x348>
 3005738:	2501                	jal	ra,3005d38 <AssertErrorLog.trans.3>
 300573a:	a001                	j	300573a <CRG_IpWithClkSelResetGet+0x20>
    CRG_ASSERT_PARAM(g_crgBaseAddr != NULL);
 300573c:	ea41a783          	lw	a5,-348(gp) # 40005a0 <g_crgBaseAddr>
 3005740:	eb89                	bnez	a5,3005752 <CRG_IpWithClkSelResetGet+0x38>
 3005742:	3a100593          	li	a1,929
 3005746:	030117b7          	lui	a5,0x3011
 300574a:	85878513          	addi	a0,a5,-1960 # 3010858 <g_crgIpMatch+0x348>
 300574e:	23ed                	jal	ra,3005d38 <AssertErrorLog.trans.3>
 3005750:	a001                	j	3005750 <CRG_IpWithClkSelResetGet+0x36>
    /* Get Clock reset status for target ip. */
    uintptr_t base = (uintptr_t)(void *)g_crgBaseAddr;
 3005752:	ea41a783          	lw	a5,-348(gp) # 40005a0 <g_crgBaseAddr>
 3005756:	fef42623          	sw	a5,-20(s0)
    CRG_IpWithClkSelectCfg *p = (CRG_IpWithClkSelectCfg *)(void *)(base + matchInfo->regOffset);
 300575a:	fdc42783          	lw	a5,-36(s0)
 300575e:	279e                	lhu	a5,8(a5)
 3005760:	873e                	mv	a4,a5
 3005762:	fec42783          	lw	a5,-20(s0)
 3005766:	97ba                	add	a5,a5,a4
 3005768:	fef42423          	sw	a5,-24(s0)
    return p->BIT.srst_req;
 300576c:	fe842783          	lw	a5,-24(s0)
 3005770:	439c                	lw	a5,0(a5)
 3005772:	83c1                	srli	a5,a5,0x10
 3005774:	8b85                	andi	a5,a5,1
 3005776:	9f81                	uxtb	a5
}
 3005778:	853e                	mv	a0,a5
 300577a:	50b2                	lw	ra,44(sp)
 300577c:	5422                	lw	s0,40(sp)
 300577e:	6145                	addi	sp,sp,48
 3005780:	8082                	ret

03005782 <CRG_IpWithClkSelClkSelSet>:
 * @param clkSelect @see CRG_APBLsClkSelect
 * @param unsigned int BASE_CFG_SET or BASE_CFG_UNSET
 * @retval None
 */
static void CRG_IpWithClkSelClkSelSet(const CHIP_CrgIpMatchInfo *matchInfo, unsigned int clkSelect)
{
 3005782:	7179                	addi	sp,sp,-48
 3005784:	d606                	sw	ra,44(sp)
 3005786:	d422                	sw	s0,40(sp)
 3005788:	1800                	addi	s0,sp,48
 300578a:	fca42e23          	sw	a0,-36(s0)
 300578e:	fcb42c23          	sw	a1,-40(s0)
    CRG_ASSERT_PARAM(matchInfo != NULL);
 3005792:	fdc42783          	lw	a5,-36(s0)
 3005796:	eb89                	bnez	a5,30057a8 <CRG_IpWithClkSelClkSelSet+0x26>
 3005798:	3b100593          	li	a1,945
 300579c:	030117b7          	lui	a5,0x3011
 30057a0:	85878513          	addi	a0,a5,-1960 # 3010858 <g_crgIpMatch+0x348>
 30057a4:	2b51                	jal	ra,3005d38 <AssertErrorLog.trans.3>
 30057a6:	a001                	j	30057a6 <CRG_IpWithClkSelClkSelSet+0x24>
    CRG_ASSERT_PARAM(g_crgBaseAddr != NULL);
 30057a8:	ea41a783          	lw	a5,-348(gp) # 40005a0 <g_crgBaseAddr>
 30057ac:	eb89                	bnez	a5,30057be <CRG_IpWithClkSelClkSelSet+0x3c>
 30057ae:	3b200593          	li	a1,946
 30057b2:	030117b7          	lui	a5,0x3011
 30057b6:	85878513          	addi	a0,a5,-1960 # 3010858 <g_crgIpMatch+0x348>
 30057ba:	2bbd                	jal	ra,3005d38 <AssertErrorLog.trans.3>
 30057bc:	a001                	j	30057bc <CRG_IpWithClkSelClkSelSet+0x3a>
    CRG_PARAM_CHECK_NO_RET(IsCrgAHBCkSel(clkSelect));
 30057be:	fd842503          	lw	a0,-40(s0)
 30057c2:	fa5fe0ef          	jal	ra,3004766 <IsCrgAHBCkSel>
 30057c6:	87aa                	mv	a5,a0
 30057c8:	0017c793          	xori	a5,a5,1
 30057cc:	9f81                	uxtb	a5
 30057ce:	cb89                	beqz	a5,30057e0 <CRG_IpWithClkSelClkSelSet+0x5e>
 30057d0:	3b300593          	li	a1,947
 30057d4:	030117b7          	lui	a5,0x3011
 30057d8:	85878513          	addi	a0,a5,-1960 # 3010858 <g_crgIpMatch+0x348>
 30057dc:	2bb1                	jal	ra,3005d38 <AssertErrorLog.trans.3>
 30057de:	a835                	j	300581a <CRG_IpWithClkSelClkSelSet+0x98>
    /* Set Clock Select for target ip. */
    uintptr_t base = (uintptr_t)(void *)g_crgBaseAddr;
 30057e0:	ea41a783          	lw	a5,-348(gp) # 40005a0 <g_crgBaseAddr>
 30057e4:	fef42623          	sw	a5,-20(s0)
    CRG_IpWithClkSelectCfg *p = (CRG_IpWithClkSelectCfg *)(void *)(base + matchInfo->regOffset);
 30057e8:	fdc42783          	lw	a5,-36(s0)
 30057ec:	279e                	lhu	a5,8(a5)
 30057ee:	873e                	mv	a4,a5
 30057f0:	fec42783          	lw	a5,-20(s0)
 30057f4:	97ba                	add	a5,a5,a4
 30057f6:	fef42423          	sw	a5,-24(s0)
    p->BIT.cksel = clkSelect;
 30057fa:	fd842783          	lw	a5,-40(s0)
 30057fe:	8b8d                	andi	a5,a5,3
 3005800:	0ff7f693          	andi	a3,a5,255
 3005804:	fe842703          	lw	a4,-24(s0)
 3005808:	431c                	lw	a5,0(a4)
 300580a:	8a8d                	andi	a3,a3,3
 300580c:	06e2                	slli	a3,a3,0x18
 300580e:	fd000637          	lui	a2,0xfd000
 3005812:	167d                	addi	a2,a2,-1 # fcffffff <RAM_END+0xf8ff7fff>
 3005814:	8ff1                	and	a5,a5,a2
 3005816:	8fd5                	or	a5,a5,a3
 3005818:	c31c                	sw	a5,0(a4)
}
 300581a:	50b2                	lw	ra,44(sp)
 300581c:	5422                	lw	s0,40(sp)
 300581e:	6145                	addi	sp,sp,48
 3005820:	8082                	ret

03005822 <CRG_IpWithClkSelClkSelGet>:
 * @brief Get Clock Select for IP in APB_LS_SUBSYS
 * @param matchInfo IP with Clock select match info
 * @retval Clock Select @see CRG_APBLsClkSelect
 */
static unsigned int CRG_IpWithClkSelClkSelGet(const CHIP_CrgIpMatchInfo *matchInfo)
{
 3005822:	7179                	addi	sp,sp,-48
 3005824:	d606                	sw	ra,44(sp)
 3005826:	d422                	sw	s0,40(sp)
 3005828:	1800                	addi	s0,sp,48
 300582a:	fca42e23          	sw	a0,-36(s0)
    CRG_ASSERT_PARAM(matchInfo != NULL);
 300582e:	fdc42783          	lw	a5,-36(s0)
 3005832:	eb89                	bnez	a5,3005844 <CRG_IpWithClkSelClkSelGet+0x22>
 3005834:	3c100593          	li	a1,961
 3005838:	030117b7          	lui	a5,0x3011
 300583c:	85878513          	addi	a0,a5,-1960 # 3010858 <g_crgIpMatch+0x348>
 3005840:	29e5                	jal	ra,3005d38 <AssertErrorLog.trans.3>
 3005842:	a001                	j	3005842 <CRG_IpWithClkSelClkSelGet+0x20>
    CRG_ASSERT_PARAM(g_crgBaseAddr != NULL);
 3005844:	ea41a783          	lw	a5,-348(gp) # 40005a0 <g_crgBaseAddr>
 3005848:	eb89                	bnez	a5,300585a <CRG_IpWithClkSelClkSelGet+0x38>
 300584a:	3c200593          	li	a1,962
 300584e:	030117b7          	lui	a5,0x3011
 3005852:	85878513          	addi	a0,a5,-1960 # 3010858 <g_crgIpMatch+0x348>
 3005856:	21cd                	jal	ra,3005d38 <AssertErrorLog.trans.3>
 3005858:	a001                	j	3005858 <CRG_IpWithClkSelClkSelGet+0x36>
    /* Get Clock Select for target ip. */
    uintptr_t base = (uintptr_t)(void *)g_crgBaseAddr;
 300585a:	ea41a783          	lw	a5,-348(gp) # 40005a0 <g_crgBaseAddr>
 300585e:	fef42623          	sw	a5,-20(s0)
    CRG_IpWithClkSelectCfg *p = (CRG_IpWithClkSelectCfg *)(void *)(base + matchInfo->regOffset);
 3005862:	fdc42783          	lw	a5,-36(s0)
 3005866:	279e                	lhu	a5,8(a5)
 3005868:	873e                	mv	a4,a5
 300586a:	fec42783          	lw	a5,-20(s0)
 300586e:	97ba                	add	a5,a5,a4
 3005870:	fef42423          	sw	a5,-24(s0)
    return p->BIT.cksel;
 3005874:	fe842783          	lw	a5,-24(s0)
 3005878:	439c                	lw	a5,0(a5)
 300587a:	83e1                	srli	a5,a5,0x18
 300587c:	8b8d                	andi	a5,a5,3
 300587e:	9f81                	uxtb	a5
}
 3005880:	853e                	mv	a0,a5
 3005882:	50b2                	lw	ra,44(sp)
 3005884:	5422                	lw	s0,40(sp)
 3005886:	6145                	addi	sp,sp,48
 3005888:	8082                	ret

0300588a <CRG_IpWoClkSelEnableSet>:
 * @param matchInfo IP without Clock select match info
 * @param enable BASE_CFG_SET or BASE_CFG_UNSET
 * @retval None
 */
static void CRG_IpWoClkSelEnableSet(const CHIP_CrgIpMatchInfo *matchInfo, unsigned int enable)
{
 300588a:	7179                	addi	sp,sp,-48
 300588c:	d606                	sw	ra,44(sp)
 300588e:	d422                	sw	s0,40(sp)
 3005890:	1800                	addi	s0,sp,48
 3005892:	fca42e23          	sw	a0,-36(s0)
 3005896:	fcb42c23          	sw	a1,-40(s0)
    CRG_ASSERT_PARAM(matchInfo != NULL);
 300589a:	fdc42783          	lw	a5,-36(s0)
 300589e:	eb89                	bnez	a5,30058b0 <CRG_IpWoClkSelEnableSet+0x26>
 30058a0:	3d100593          	li	a1,977
 30058a4:	030117b7          	lui	a5,0x3011
 30058a8:	85878513          	addi	a0,a5,-1960 # 3010858 <g_crgIpMatch+0x348>
 30058ac:	2171                	jal	ra,3005d38 <AssertErrorLog.trans.3>
 30058ae:	a001                	j	30058ae <CRG_IpWoClkSelEnableSet+0x24>
    CRG_ASSERT_PARAM(g_crgBaseAddr != NULL);
 30058b0:	ea41a783          	lw	a5,-348(gp) # 40005a0 <g_crgBaseAddr>
 30058b4:	eb89                	bnez	a5,30058c6 <CRG_IpWoClkSelEnableSet+0x3c>
 30058b6:	3d200593          	li	a1,978
 30058ba:	030117b7          	lui	a5,0x3011
 30058be:	85878513          	addi	a0,a5,-1960 # 3010858 <g_crgIpMatch+0x348>
 30058c2:	299d                	jal	ra,3005d38 <AssertErrorLog.trans.3>
 30058c4:	a001                	j	30058c4 <CRG_IpWoClkSelEnableSet+0x3a>

    uintptr_t base = (uintptr_t)(void *)g_crgBaseAddr;
 30058c6:	ea41a783          	lw	a5,-348(gp) # 40005a0 <g_crgBaseAddr>
 30058ca:	fef42623          	sw	a5,-20(s0)
    CRG_IpWoClkSelectCfg *p = (CRG_IpWoClkSelectCfg *)(void *)(base + matchInfo->regOffset);
 30058ce:	fdc42783          	lw	a5,-36(s0)
 30058d2:	279e                	lhu	a5,8(a5)
 30058d4:	873e                	mv	a4,a5
 30058d6:	fec42783          	lw	a5,-20(s0)
 30058da:	97ba                	add	a5,a5,a4
 30058dc:	fef42423          	sw	a5,-24(s0)
    CRG_IpWoClkSelectCfg cfg;
    cfg.value = p->value;
 30058e0:	fe842783          	lw	a5,-24(s0)
 30058e4:	439c                	lw	a5,0(a5)
 30058e6:	fef42223          	sw	a5,-28(s0)
    if (enable & IP_CLK_ENABLE) {     /* Set enable of target ip. */
 30058ea:	fd842783          	lw	a5,-40(s0)
 30058ee:	8b85                	andi	a5,a5,1
 30058f0:	c7c1                	beqz	a5,3005978 <CRG_IpWoClkSelEnableSet+0xee>
        cfg.BIT.clkEnMask |= 1 << matchInfo->bitOffset;
 30058f2:	fe442783          	lw	a5,-28(s0)
 30058f6:	9fa1                	uxth	a5
 30058f8:	01079713          	slli	a4,a5,0x10
 30058fc:	8741                	srai	a4,a4,0x10
 30058fe:	fdc42783          	lw	a5,-36(s0)
 3005902:	27bc                	lbu	a5,10(a5)
 3005904:	86be                	mv	a3,a5
 3005906:	4785                	li	a5,1
 3005908:	00d797b3          	sll	a5,a5,a3
 300590c:	07c2                	slli	a5,a5,0x10
 300590e:	87c1                	srai	a5,a5,0x10
 3005910:	8fd9                	or	a5,a5,a4
 3005912:	07c2                	slli	a5,a5,0x10
 3005914:	87c1                	srai	a5,a5,0x10
 3005916:	01079693          	slli	a3,a5,0x10
 300591a:	82c1                	srli	a3,a3,0x10
 300591c:	fe442783          	lw	a5,-28(s0)
 3005920:	6741                	lui	a4,0x10
 3005922:	177d                	addi	a4,a4,-1 # ffff <RAM_SIZE+0xafff>
 3005924:	8f75                	and	a4,a4,a3
 3005926:	76c1                	lui	a3,0xffff0
 3005928:	8ff5                	and	a5,a5,a3
 300592a:	8fd9                	or	a5,a5,a4
 300592c:	fef42223          	sw	a5,-28(s0)
        cfg.BIT.softResetReq &= ~(1 << matchInfo->bitOffset);
 3005930:	fe442783          	lw	a5,-28(s0)
 3005934:	83c1                	srli	a5,a5,0x10
 3005936:	9fa1                	uxth	a5
 3005938:	01079713          	slli	a4,a5,0x10
 300593c:	8741                	srai	a4,a4,0x10
 300593e:	fdc42783          	lw	a5,-36(s0)
 3005942:	27bc                	lbu	a5,10(a5)
 3005944:	86be                	mv	a3,a5
 3005946:	4785                	li	a5,1
 3005948:	00d797b3          	sll	a5,a5,a3
 300594c:	07c2                	slli	a5,a5,0x10
 300594e:	87c1                	srai	a5,a5,0x10
 3005950:	fff7c793          	not	a5,a5
 3005954:	07c2                	slli	a5,a5,0x10
 3005956:	87c1                	srai	a5,a5,0x10
 3005958:	8ff9                	and	a5,a5,a4
 300595a:	07c2                	slli	a5,a5,0x10
 300595c:	87c1                	srai	a5,a5,0x10
 300595e:	01079713          	slli	a4,a5,0x10
 3005962:	8341                	srli	a4,a4,0x10
 3005964:	fe442783          	lw	a5,-28(s0)
 3005968:	0742                	slli	a4,a4,0x10
 300596a:	66c1                	lui	a3,0x10
 300596c:	16fd                	addi	a3,a3,-1 # ffff <RAM_SIZE+0xafff>
 300596e:	8ff5                	and	a5,a5,a3
 3005970:	8fd9                	or	a5,a5,a4
 3005972:	fef42223          	sw	a5,-28(s0)
 3005976:	a059                	j	30059fc <CRG_IpWoClkSelEnableSet+0x172>
    } else {
        cfg.BIT.clkEnMask &= ~(1 << matchInfo->bitOffset); /* Disable of target ip. */
 3005978:	fe442783          	lw	a5,-28(s0)
 300597c:	9fa1                	uxth	a5
 300597e:	01079713          	slli	a4,a5,0x10
 3005982:	8741                	srai	a4,a4,0x10
 3005984:	fdc42783          	lw	a5,-36(s0)
 3005988:	27bc                	lbu	a5,10(a5)
 300598a:	86be                	mv	a3,a5
 300598c:	4785                	li	a5,1
 300598e:	00d797b3          	sll	a5,a5,a3
 3005992:	07c2                	slli	a5,a5,0x10
 3005994:	87c1                	srai	a5,a5,0x10
 3005996:	fff7c793          	not	a5,a5
 300599a:	07c2                	slli	a5,a5,0x10
 300599c:	87c1                	srai	a5,a5,0x10
 300599e:	8ff9                	and	a5,a5,a4
 30059a0:	07c2                	slli	a5,a5,0x10
 30059a2:	87c1                	srai	a5,a5,0x10
 30059a4:	01079693          	slli	a3,a5,0x10
 30059a8:	82c1                	srli	a3,a3,0x10
 30059aa:	fe442783          	lw	a5,-28(s0)
 30059ae:	6741                	lui	a4,0x10
 30059b0:	177d                	addi	a4,a4,-1 # ffff <RAM_SIZE+0xafff>
 30059b2:	8f75                	and	a4,a4,a3
 30059b4:	76c1                	lui	a3,0xffff0
 30059b6:	8ff5                	and	a5,a5,a3
 30059b8:	8fd9                	or	a5,a5,a4
 30059ba:	fef42223          	sw	a5,-28(s0)
        cfg.BIT.softResetReq |= (1 << matchInfo->bitOffset);
 30059be:	fe442783          	lw	a5,-28(s0)
 30059c2:	83c1                	srli	a5,a5,0x10
 30059c4:	9fa1                	uxth	a5
 30059c6:	01079713          	slli	a4,a5,0x10
 30059ca:	8741                	srai	a4,a4,0x10
 30059cc:	fdc42783          	lw	a5,-36(s0)
 30059d0:	27bc                	lbu	a5,10(a5)
 30059d2:	86be                	mv	a3,a5
 30059d4:	4785                	li	a5,1
 30059d6:	00d797b3          	sll	a5,a5,a3
 30059da:	07c2                	slli	a5,a5,0x10
 30059dc:	87c1                	srai	a5,a5,0x10
 30059de:	8fd9                	or	a5,a5,a4
 30059e0:	07c2                	slli	a5,a5,0x10
 30059e2:	87c1                	srai	a5,a5,0x10
 30059e4:	01079713          	slli	a4,a5,0x10
 30059e8:	8341                	srli	a4,a4,0x10
 30059ea:	fe442783          	lw	a5,-28(s0)
 30059ee:	0742                	slli	a4,a4,0x10
 30059f0:	66c1                	lui	a3,0x10
 30059f2:	16fd                	addi	a3,a3,-1 # ffff <RAM_SIZE+0xafff>
 30059f4:	8ff5                	and	a5,a5,a3
 30059f6:	8fd9                	or	a5,a5,a4
 30059f8:	fef42223          	sw	a5,-28(s0)
    }
    p->value = cfg.value;
 30059fc:	fe442703          	lw	a4,-28(s0)
 3005a00:	fe842783          	lw	a5,-24(s0)
 3005a04:	c398                	sw	a4,0(a5)
}
 3005a06:	0001                	nop
 3005a08:	50b2                	lw	ra,44(sp)
 3005a0a:	5422                	lw	s0,40(sp)
 3005a0c:	6145                	addi	sp,sp,48
 3005a0e:	8082                	ret

03005a10 <CRG_IpWoClkSelEnableGet>:
 * @brief Get Enable status of IP in APB_HS_SUBSYS
 * @param matchInfo IP without Clock select match info
 * @retval Clock Enable status
 */
static unsigned int CRG_IpWoClkSelEnableGet(const CHIP_CrgIpMatchInfo *matchInfo)
{
 3005a10:	7179                	addi	sp,sp,-48
 3005a12:	d606                	sw	ra,44(sp)
 3005a14:	d422                	sw	s0,40(sp)
 3005a16:	1800                	addi	s0,sp,48
 3005a18:	fca42e23          	sw	a0,-36(s0)
    CRG_ASSERT_PARAM(matchInfo != NULL);
 3005a1c:	fdc42783          	lw	a5,-36(s0)
 3005a20:	eb89                	bnez	a5,3005a32 <CRG_IpWoClkSelEnableGet+0x22>
 3005a22:	3e900593          	li	a1,1001
 3005a26:	030117b7          	lui	a5,0x3011
 3005a2a:	85878513          	addi	a0,a5,-1960 # 3010858 <g_crgIpMatch+0x348>
 3005a2e:	2629                	jal	ra,3005d38 <AssertErrorLog.trans.3>
 3005a30:	a001                	j	3005a30 <CRG_IpWoClkSelEnableGet+0x20>
    CRG_ASSERT_PARAM(g_crgBaseAddr != NULL);
 3005a32:	ea41a783          	lw	a5,-348(gp) # 40005a0 <g_crgBaseAddr>
 3005a36:	eb89                	bnez	a5,3005a48 <CRG_IpWoClkSelEnableGet+0x38>
 3005a38:	3ea00593          	li	a1,1002
 3005a3c:	030117b7          	lui	a5,0x3011
 3005a40:	85878513          	addi	a0,a5,-1960 # 3010858 <g_crgIpMatch+0x348>
 3005a44:	2cd5                	jal	ra,3005d38 <AssertErrorLog.trans.3>
 3005a46:	a001                	j	3005a46 <CRG_IpWoClkSelEnableGet+0x36>

    uintptr_t base = (uintptr_t)(void *)g_crgBaseAddr;
 3005a48:	ea41a783          	lw	a5,-348(gp) # 40005a0 <g_crgBaseAddr>
 3005a4c:	fef42623          	sw	a5,-20(s0)
    /* Get enable status of target ip. */
    CRG_IpWoClkSelectCfg *p = (CRG_IpWoClkSelectCfg *)(void *)(base + matchInfo->regOffset);
 3005a50:	fdc42783          	lw	a5,-36(s0)
 3005a54:	279e                	lhu	a5,8(a5)
 3005a56:	873e                	mv	a4,a5
 3005a58:	fec42783          	lw	a5,-20(s0)
 3005a5c:	97ba                	add	a5,a5,a4
 3005a5e:	fef42423          	sw	a5,-24(s0)
    CRG_IpWoClkSelectCfg cfg;

    cfg.value = p->value;
 3005a62:	fe842783          	lw	a5,-24(s0)
 3005a66:	439c                	lw	a5,0(a5)
 3005a68:	fef42223          	sw	a5,-28(s0)
    return (cfg.BIT.clkEnMask & (1 << matchInfo->bitOffset)) == 0 ? false : true;
 3005a6c:	fe442783          	lw	a5,-28(s0)
 3005a70:	9fa1                	uxth	a5
 3005a72:	873e                	mv	a4,a5
 3005a74:	fdc42783          	lw	a5,-36(s0)
 3005a78:	27bc                	lbu	a5,10(a5)
 3005a7a:	40f757b3          	sra	a5,a4,a5
 3005a7e:	8b85                	andi	a5,a5,1
 3005a80:	00f037b3          	snez	a5,a5
 3005a84:	9f81                	uxtb	a5
}
 3005a86:	853e                	mv	a0,a5
 3005a88:	50b2                	lw	ra,44(sp)
 3005a8a:	5422                	lw	s0,40(sp)
 3005a8c:	6145                	addi	sp,sp,48
 3005a8e:	8082                	ret

03005a90 <CRG_IpWoClkSelResetSet>:
 * @param matchInfo IP without Clock select match info
 * @param reset BASE_CFG_SET or BASE_CFG_UNSET
 * @retval None
 */
static void CRG_IpWoClkSelResetSet(const CHIP_CrgIpMatchInfo *matchInfo, unsigned int reset)
{
 3005a90:	7179                	addi	sp,sp,-48
 3005a92:	d606                	sw	ra,44(sp)
 3005a94:	d422                	sw	s0,40(sp)
 3005a96:	1800                	addi	s0,sp,48
 3005a98:	fca42e23          	sw	a0,-36(s0)
 3005a9c:	fcb42c23          	sw	a1,-40(s0)
    CRG_ASSERT_PARAM(matchInfo != NULL);
 3005aa0:	fdc42783          	lw	a5,-36(s0)
 3005aa4:	eb89                	bnez	a5,3005ab6 <CRG_IpWoClkSelResetSet+0x26>
 3005aa6:	3fd00593          	li	a1,1021
 3005aaa:	030117b7          	lui	a5,0x3011
 3005aae:	85878513          	addi	a0,a5,-1960 # 3010858 <g_crgIpMatch+0x348>
 3005ab2:	2459                	jal	ra,3005d38 <AssertErrorLog.trans.3>
 3005ab4:	a001                	j	3005ab4 <CRG_IpWoClkSelResetSet+0x24>
    CRG_ASSERT_PARAM(g_crgBaseAddr != NULL);
 3005ab6:	ea41a783          	lw	a5,-348(gp) # 40005a0 <g_crgBaseAddr>
 3005aba:	eb89                	bnez	a5,3005acc <CRG_IpWoClkSelResetSet+0x3c>
 3005abc:	3fe00593          	li	a1,1022
 3005ac0:	030117b7          	lui	a5,0x3011
 3005ac4:	85878513          	addi	a0,a5,-1960 # 3010858 <g_crgIpMatch+0x348>
 3005ac8:	2c85                	jal	ra,3005d38 <AssertErrorLog.trans.3>
 3005aca:	a001                	j	3005aca <CRG_IpWoClkSelResetSet+0x3a>

    uintptr_t base = (uintptr_t)(void *)g_crgBaseAddr;
 3005acc:	ea41a783          	lw	a5,-348(gp) # 40005a0 <g_crgBaseAddr>
 3005ad0:	fef42623          	sw	a5,-20(s0)
    CRG_IpWoClkSelectCfg *p = (CRG_IpWoClkSelectCfg *)(void *)(base + matchInfo->regOffset);
 3005ad4:	fdc42783          	lw	a5,-36(s0)
 3005ad8:	279e                	lhu	a5,8(a5)
 3005ada:	873e                	mv	a4,a5
 3005adc:	fec42783          	lw	a5,-20(s0)
 3005ae0:	97ba                	add	a5,a5,a4
 3005ae2:	fef42423          	sw	a5,-24(s0)
    CRG_IpWoClkSelectCfg cfg;
    cfg.value = p->value;
 3005ae6:	fe842783          	lw	a5,-24(s0)
 3005aea:	439c                	lw	a5,0(a5)
 3005aec:	fef42223          	sw	a5,-28(s0)
    if (reset & BASE_CFG_SET) {
 3005af0:	fd842783          	lw	a5,-40(s0)
 3005af4:	8b85                	andi	a5,a5,1
 3005af6:	c3a9                	beqz	a5,3005b38 <CRG_IpWoClkSelResetSet+0xa8>
        cfg.BIT.softResetReq |= 1 << matchInfo->bitOffset; /* reset of target ip. */
 3005af8:	fe442783          	lw	a5,-28(s0)
 3005afc:	83c1                	srli	a5,a5,0x10
 3005afe:	9fa1                	uxth	a5
 3005b00:	01079713          	slli	a4,a5,0x10
 3005b04:	8741                	srai	a4,a4,0x10
 3005b06:	fdc42783          	lw	a5,-36(s0)
 3005b0a:	27bc                	lbu	a5,10(a5)
 3005b0c:	86be                	mv	a3,a5
 3005b0e:	4785                	li	a5,1
 3005b10:	00d797b3          	sll	a5,a5,a3
 3005b14:	07c2                	slli	a5,a5,0x10
 3005b16:	87c1                	srai	a5,a5,0x10
 3005b18:	8fd9                	or	a5,a5,a4
 3005b1a:	07c2                	slli	a5,a5,0x10
 3005b1c:	87c1                	srai	a5,a5,0x10
 3005b1e:	01079713          	slli	a4,a5,0x10
 3005b22:	8341                	srli	a4,a4,0x10
 3005b24:	fe442783          	lw	a5,-28(s0)
 3005b28:	0742                	slli	a4,a4,0x10
 3005b2a:	66c1                	lui	a3,0x10
 3005b2c:	16fd                	addi	a3,a3,-1 # ffff <RAM_SIZE+0xafff>
 3005b2e:	8ff5                	and	a5,a5,a3
 3005b30:	8fd9                	or	a5,a5,a4
 3005b32:	fef42223          	sw	a5,-28(s0)
 3005b36:	a0a1                	j	3005b7e <CRG_IpWoClkSelResetSet+0xee>
    } else {
        cfg.BIT.softResetReq &= ~(1 << matchInfo->bitOffset);  /* Undo reset of target ip. */
 3005b38:	fe442783          	lw	a5,-28(s0)
 3005b3c:	83c1                	srli	a5,a5,0x10
 3005b3e:	9fa1                	uxth	a5
 3005b40:	01079713          	slli	a4,a5,0x10
 3005b44:	8741                	srai	a4,a4,0x10
 3005b46:	fdc42783          	lw	a5,-36(s0)
 3005b4a:	27bc                	lbu	a5,10(a5)
 3005b4c:	86be                	mv	a3,a5
 3005b4e:	4785                	li	a5,1
 3005b50:	00d797b3          	sll	a5,a5,a3
 3005b54:	07c2                	slli	a5,a5,0x10
 3005b56:	87c1                	srai	a5,a5,0x10
 3005b58:	fff7c793          	not	a5,a5
 3005b5c:	07c2                	slli	a5,a5,0x10
 3005b5e:	87c1                	srai	a5,a5,0x10
 3005b60:	8ff9                	and	a5,a5,a4
 3005b62:	07c2                	slli	a5,a5,0x10
 3005b64:	87c1                	srai	a5,a5,0x10
 3005b66:	01079713          	slli	a4,a5,0x10
 3005b6a:	8341                	srli	a4,a4,0x10
 3005b6c:	fe442783          	lw	a5,-28(s0)
 3005b70:	0742                	slli	a4,a4,0x10
 3005b72:	66c1                	lui	a3,0x10
 3005b74:	16fd                	addi	a3,a3,-1 # ffff <RAM_SIZE+0xafff>
 3005b76:	8ff5                	and	a5,a5,a3
 3005b78:	8fd9                	or	a5,a5,a4
 3005b7a:	fef42223          	sw	a5,-28(s0)
    }
    p->value = cfg.value;
 3005b7e:	fe442703          	lw	a4,-28(s0)
 3005b82:	fe842783          	lw	a5,-24(s0)
 3005b86:	c398                	sw	a4,0(a5)
}
 3005b88:	0001                	nop
 3005b8a:	50b2                	lw	ra,44(sp)
 3005b8c:	5422                	lw	s0,40(sp)
 3005b8e:	6145                	addi	sp,sp,48
 3005b90:	8082                	ret

03005b92 <CRG_IpWoClkSelResetGet>:
 * @brief Get Reset status of IP in APB_HS_SUBSYS
 * @param matchInfo IP without Clock select match info
 * @retval Clock select reset status
 */
static unsigned int CRG_IpWoClkSelResetGet(const CHIP_CrgIpMatchInfo *matchInfo)
{
 3005b92:	7179                	addi	sp,sp,-48
 3005b94:	d606                	sw	ra,44(sp)
 3005b96:	d422                	sw	s0,40(sp)
 3005b98:	1800                	addi	s0,sp,48
 3005b9a:	fca42e23          	sw	a0,-36(s0)
    CRG_ASSERT_PARAM(matchInfo != NULL);
 3005b9e:	fdc42783          	lw	a5,-36(s0)
 3005ba2:	eb89                	bnez	a5,3005bb4 <CRG_IpWoClkSelResetGet+0x22>
 3005ba4:	41300593          	li	a1,1043
 3005ba8:	030117b7          	lui	a5,0x3011
 3005bac:	85878513          	addi	a0,a5,-1960 # 3010858 <g_crgIpMatch+0x348>
 3005bb0:	2261                	jal	ra,3005d38 <AssertErrorLog.trans.3>
 3005bb2:	a001                	j	3005bb2 <CRG_IpWoClkSelResetGet+0x20>
    CRG_ASSERT_PARAM(g_crgBaseAddr != NULL);
 3005bb4:	ea41a783          	lw	a5,-348(gp) # 40005a0 <g_crgBaseAddr>
 3005bb8:	eb89                	bnez	a5,3005bca <CRG_IpWoClkSelResetGet+0x38>
 3005bba:	41400593          	li	a1,1044
 3005bbe:	030117b7          	lui	a5,0x3011
 3005bc2:	85878513          	addi	a0,a5,-1960 # 3010858 <g_crgIpMatch+0x348>
 3005bc6:	2a8d                	jal	ra,3005d38 <AssertErrorLog.trans.3>
 3005bc8:	a001                	j	3005bc8 <CRG_IpWoClkSelResetGet+0x36>

    uintptr_t base = (uintptr_t)(void *)g_crgBaseAddr;
 3005bca:	ea41a783          	lw	a5,-348(gp) # 40005a0 <g_crgBaseAddr>
 3005bce:	fef42623          	sw	a5,-20(s0)
    /* Get the reset status of target ip. */
    CRG_IpWoClkSelectCfg *p = (CRG_IpWoClkSelectCfg *)(void *)(base + matchInfo->regOffset);
 3005bd2:	fdc42783          	lw	a5,-36(s0)
 3005bd6:	279e                	lhu	a5,8(a5)
 3005bd8:	873e                	mv	a4,a5
 3005bda:	fec42783          	lw	a5,-20(s0)
 3005bde:	97ba                	add	a5,a5,a4
 3005be0:	fef42423          	sw	a5,-24(s0)
    CRG_IpWoClkSelectCfg cfg;
    cfg.value = p->value;
 3005be4:	fe842783          	lw	a5,-24(s0)
 3005be8:	439c                	lw	a5,0(a5)
 3005bea:	fef42223          	sw	a5,-28(s0)
    return (cfg.BIT.softResetReq & (1 << matchInfo->bitOffset)) ? BASE_CFG_SET : BASE_CFG_UNSET;
 3005bee:	fe442783          	lw	a5,-28(s0)
 3005bf2:	83c1                	srli	a5,a5,0x10
 3005bf4:	9fa1                	uxth	a5
 3005bf6:	873e                	mv	a4,a5
 3005bf8:	fdc42783          	lw	a5,-36(s0)
 3005bfc:	27bc                	lbu	a5,10(a5)
 3005bfe:	40f757b3          	sra	a5,a4,a5
 3005c02:	8b85                	andi	a5,a5,1
 3005c04:	00f037b3          	snez	a5,a5
 3005c08:	9f81                	uxtb	a5
}
 3005c0a:	853e                	mv	a0,a5
 3005c0c:	50b2                	lw	ra,44(sp)
 3005c0e:	5422                	lw	s0,40(sp)
 3005c10:	6145                	addi	sp,sp,48
 3005c12:	8082                	ret

03005c14 <CRG_AdcEnableSet>:
 * @param matchInfo ADC match info
 * @param enable IP_CLK_ENABLE
 * @retval None
 */
static void CRG_AdcEnableSet(const CHIP_CrgIpMatchInfo *matchInfo, unsigned int enable)
{
 3005c14:	7179                	addi	sp,sp,-48
 3005c16:	d606                	sw	ra,44(sp)
 3005c18:	d422                	sw	s0,40(sp)
 3005c1a:	1800                	addi	s0,sp,48
 3005c1c:	fca42e23          	sw	a0,-36(s0)
 3005c20:	fcb42c23          	sw	a1,-40(s0)
    CRG_ASSERT_PARAM(matchInfo != NULL);
 3005c24:	fdc42783          	lw	a5,-36(s0)
 3005c28:	eb89                	bnez	a5,3005c3a <CRG_AdcEnableSet+0x26>
 3005c2a:	42600593          	li	a1,1062
 3005c2e:	030117b7          	lui	a5,0x3011
 3005c32:	85878513          	addi	a0,a5,-1960 # 3010858 <g_crgIpMatch+0x348>
 3005c36:	2209                	jal	ra,3005d38 <AssertErrorLog.trans.3>
 3005c38:	a001                	j	3005c38 <CRG_AdcEnableSet+0x24>
    CRG_ASSERT_PARAM(g_crgBaseAddr != NULL);
 3005c3a:	ea41a783          	lw	a5,-348(gp) # 40005a0 <g_crgBaseAddr>
 3005c3e:	eb89                	bnez	a5,3005c50 <CRG_AdcEnableSet+0x3c>
 3005c40:	42700593          	li	a1,1063
 3005c44:	030117b7          	lui	a5,0x3011
 3005c48:	85878513          	addi	a0,a5,-1960 # 3010858 <g_crgIpMatch+0x348>
 3005c4c:	20f5                	jal	ra,3005d38 <AssertErrorLog.trans.3>
 3005c4e:	a001                	j	3005c4e <CRG_AdcEnableSet+0x3a>

    uintptr_t base = (uintptr_t)(void *)g_crgBaseAddr;
 3005c50:	ea41a783          	lw	a5,-348(gp) # 40005a0 <g_crgBaseAddr>
 3005c54:	fef42623          	sw	a5,-20(s0)
    CRG_AdcIpCfg *p = (CRG_AdcIpCfg *)(void *)(base + matchInfo->regOffset);
 3005c58:	fdc42783          	lw	a5,-36(s0)
 3005c5c:	279e                	lhu	a5,8(a5)
 3005c5e:	873e                	mv	a4,a5
 3005c60:	fec42783          	lw	a5,-20(s0)
 3005c64:	97ba                	add	a5,a5,a4
 3005c66:	fef42423          	sw	a5,-24(s0)
    CRG_AdcIpCfg cfg;
    cfg.value[1] = p->value[1];
 3005c6a:	fe842783          	lw	a5,-24(s0)
 3005c6e:	43dc                	lw	a5,4(a5)
 3005c70:	fef42223          	sw	a5,-28(s0)
    if (enable) {     /* Enables and Deassert reset the ADC clock. */
 3005c74:	fd842783          	lw	a5,-40(s0)
 3005c78:	cf99                	beqz	a5,3005c96 <CRG_AdcEnableSet+0x82>
        cfg.BIT.clk_adc_cken = BASE_CFG_SET;
 3005c7a:	fe442783          	lw	a5,-28(s0)
 3005c7e:	0017e793          	ori	a5,a5,1
 3005c82:	fef42223          	sw	a5,-28(s0)
        cfg.BIT.adc_srst_req = BASE_CFG_UNSET;
 3005c86:	fe442783          	lw	a5,-28(s0)
 3005c8a:	7741                	lui	a4,0xffff0
 3005c8c:	177d                	addi	a4,a4,-1 # fffeffff <RAM_END+0xfbfe7fff>
 3005c8e:	8ff9                	and	a5,a5,a4
 3005c90:	fef42223          	sw	a5,-28(s0)
 3005c94:	a829                	j	3005cae <CRG_AdcEnableSet+0x9a>
    } else {     /* Disable and reset the ADC clock. */
        cfg.BIT.clk_adc_cken = BASE_CFG_UNSET;
 3005c96:	fe442783          	lw	a5,-28(s0)
 3005c9a:	9bf9                	andi	a5,a5,-2
 3005c9c:	fef42223          	sw	a5,-28(s0)
        cfg.BIT.adc_srst_req = BASE_CFG_UNSET;
 3005ca0:	fe442783          	lw	a5,-28(s0)
 3005ca4:	7741                	lui	a4,0xffff0
 3005ca6:	177d                	addi	a4,a4,-1 # fffeffff <RAM_END+0xfbfe7fff>
 3005ca8:	8ff9                	and	a5,a5,a4
 3005caa:	fef42223          	sw	a5,-28(s0)
    }
    p->value[1] = cfg.value[1];
 3005cae:	fe442703          	lw	a4,-28(s0)
 3005cb2:	fe842783          	lw	a5,-24(s0)
 3005cb6:	c3d8                	sw	a4,4(a5)
}
 3005cb8:	0001                	nop
 3005cba:	50b2                	lw	ra,44(sp)
 3005cbc:	5422                	lw	s0,40(sp)
 3005cbe:	6145                	addi	sp,sp,48
 3005cc0:	8082                	ret

03005cc2 <CRG_AdcEnableGet>:
 * @brief Get Enable status of ADC
 * @param matchInfo ADC match info
 * @retval Cken of ADC
 */
static unsigned int CRG_AdcEnableGet(const CHIP_CrgIpMatchInfo *matchInfo)
{
 3005cc2:	7179                	addi	sp,sp,-48
 3005cc4:	d606                	sw	ra,44(sp)
 3005cc6:	d422                	sw	s0,40(sp)
 3005cc8:	1800                	addi	s0,sp,48
 3005cca:	fca42e23          	sw	a0,-36(s0)
    CRG_ASSERT_PARAM(matchInfo != NULL);
 3005cce:	fdc42783          	lw	a5,-36(s0)
 3005cd2:	eb89                	bnez	a5,3005ce4 <CRG_AdcEnableGet+0x22>
 3005cd4:	43e00593          	li	a1,1086
 3005cd8:	030117b7          	lui	a5,0x3011
 3005cdc:	85878513          	addi	a0,a5,-1960 # 3010858 <g_crgIpMatch+0x348>
 3005ce0:	28a1                	jal	ra,3005d38 <AssertErrorLog.trans.3>
 3005ce2:	a001                	j	3005ce2 <CRG_AdcEnableGet+0x20>
    CRG_ASSERT_PARAM(g_crgBaseAddr != NULL);
 3005ce4:	ea41a783          	lw	a5,-348(gp) # 40005a0 <g_crgBaseAddr>
 3005ce8:	eb89                	bnez	a5,3005cfa <CRG_AdcEnableGet+0x38>
 3005cea:	43f00593          	li	a1,1087
 3005cee:	030117b7          	lui	a5,0x3011
 3005cf2:	85878513          	addi	a0,a5,-1960 # 3010858 <g_crgIpMatch+0x348>
 3005cf6:	2089                	jal	ra,3005d38 <AssertErrorLog.trans.3>
 3005cf8:	a001                	j	3005cf8 <CRG_AdcEnableGet+0x36>
    unsigned int enable;
    /* Get the enable status of the ADC clock gating. */
    uintptr_t base = (uintptr_t)(void *)g_crgBaseAddr;
 3005cfa:	ea41a783          	lw	a5,-348(gp) # 40005a0 <g_crgBaseAddr>
 3005cfe:	fef42623          	sw	a5,-20(s0)
    CRG_AdcIpCfg *p = (CRG_AdcIpCfg *)(void *)(base + matchInfo->regOffset);
 3005d02:	fdc42783          	lw	a5,-36(s0)
 3005d06:	279e                	lhu	a5,8(a5)
 3005d08:	873e                	mv	a4,a5
 3005d0a:	fec42783          	lw	a5,-20(s0)
 3005d0e:	97ba                	add	a5,a5,a4
 3005d10:	fef42423          	sw	a5,-24(s0)
    enable = ((p->BIT.clk_adc_cken != 0)) ? IP_CLK_ENABLE : IP_CLK_DISABLE;
 3005d14:	fe842783          	lw	a5,-24(s0)
 3005d18:	43dc                	lw	a5,4(a5)
 3005d1a:	8b85                	andi	a5,a5,1
 3005d1c:	9f81                	uxtb	a5
 3005d1e:	c399                	beqz	a5,3005d24 <CRG_AdcEnableGet+0x62>
 3005d20:	4785                	li	a5,1
 3005d22:	a011                	j	3005d26 <CRG_AdcEnableGet+0x64>
 3005d24:	4781                	li	a5,0
 3005d26:	fef42223          	sw	a5,-28(s0)
    return enable;
 3005d2a:	fe442783          	lw	a5,-28(s0)
}
 3005d2e:	853e                	mv	a0,a5
 3005d30:	50b2                	lw	ra,44(sp)
 3005d32:	5422                	lw	s0,40(sp)
 3005d34:	6145                	addi	sp,sp,48
 3005d36:	8082                	ret

03005d38 <AssertErrorLog.trans.3>:
 3005d38:	806fd06f          	j	3002d3e <AssertErrorLog>

03005d3c <CRG_AdcClkSelectSet>:
 * @param matchInfo ADC match info
 * @param clkSelect @see CRG_AdcClkSelect
 * @retval None
 */
static void CRG_AdcClkSelectSet(const CHIP_CrgIpMatchInfo *matchInfo, unsigned int clkSelect)
{
 3005d3c:	7179                	addi	sp,sp,-48
 3005d3e:	d606                	sw	ra,44(sp)
 3005d40:	d422                	sw	s0,40(sp)
 3005d42:	1800                	addi	s0,sp,48
 3005d44:	fca42e23          	sw	a0,-36(s0)
 3005d48:	fcb42c23          	sw	a1,-40(s0)
    CRG_ASSERT_PARAM(matchInfo != NULL);
 3005d4c:	fdc42783          	lw	a5,-36(s0)
 3005d50:	eb89                	bnez	a5,3005d62 <CRG_AdcClkSelectSet+0x26>
 3005d52:	45000593          	li	a1,1104
 3005d56:	030117b7          	lui	a5,0x3011
 3005d5a:	85878513          	addi	a0,a5,-1960 # 3010858 <g_crgIpMatch+0x348>
 3005d5e:	3fe9                	jal	ra,3005d38 <AssertErrorLog.trans.3>
 3005d60:	a001                	j	3005d60 <CRG_AdcClkSelectSet+0x24>
    CRG_ASSERT_PARAM(g_crgBaseAddr != NULL);
 3005d62:	ea41a783          	lw	a5,-348(gp) # 40005a0 <g_crgBaseAddr>
 3005d66:	eb89                	bnez	a5,3005d78 <CRG_AdcClkSelectSet+0x3c>
 3005d68:	45100593          	li	a1,1105
 3005d6c:	030117b7          	lui	a5,0x3011
 3005d70:	85878513          	addi	a0,a5,-1960 # 3010858 <g_crgIpMatch+0x348>
 3005d74:	37d1                	jal	ra,3005d38 <AssertErrorLog.trans.3>
 3005d76:	a001                	j	3005d76 <CRG_AdcClkSelectSet+0x3a>
    CRG_ASSERT_PARAM(IsCRGInstance(g_crgBaseAddr));
 3005d78:	ea41a703          	lw	a4,-348(gp) # 40005a0 <g_crgBaseAddr>
 3005d7c:	100007b7          	lui	a5,0x10000
 3005d80:	00f70a63          	beq	a4,a5,3005d94 <CRG_AdcClkSelectSet+0x58>
 3005d84:	45200593          	li	a1,1106
 3005d88:	030117b7          	lui	a5,0x3011
 3005d8c:	85878513          	addi	a0,a5,-1960 # 3010858 <g_crgIpMatch+0x348>
 3005d90:	3765                	jal	ra,3005d38 <AssertErrorLog.trans.3>
 3005d92:	a001                	j	3005d92 <CRG_AdcClkSelectSet+0x56>
    CRG_PARAM_CHECK_NO_RET(IsCrgAdcClkModeSelect(clkSelect));
 3005d94:	fd842503          	lw	a0,-40(s0)
 3005d98:	b87fe0ef          	jal	ra,300491e <IsCrgAdcClkModeSelect>
 3005d9c:	87aa                	mv	a5,a0
 3005d9e:	0017c793          	xori	a5,a5,1
 3005da2:	9f81                	uxtb	a5
 3005da4:	cb89                	beqz	a5,3005db6 <CRG_AdcClkSelectSet+0x7a>
 3005da6:	45300593          	li	a1,1107
 3005daa:	030117b7          	lui	a5,0x3011
 3005dae:	85878513          	addi	a0,a5,-1960 # 3010858 <g_crgIpMatch+0x348>
 3005db2:	3759                	jal	ra,3005d38 <AssertErrorLog.trans.3>
 3005db4:	a0bd                	j	3005e22 <CRG_AdcClkSelectSet+0xe6>

    uintptr_t base = (uintptr_t)(void *)g_crgBaseAddr;
 3005db6:	ea41a783          	lw	a5,-348(gp) # 40005a0 <g_crgBaseAddr>
 3005dba:	fef42623          	sw	a5,-20(s0)
    CRG_AdcIpCfg *p = (CRG_AdcIpCfg *)(void *)(base + matchInfo->regOffset);
 3005dbe:	fdc42783          	lw	a5,-36(s0)
 3005dc2:	279e                	lhu	a5,8(a5)
 3005dc4:	873e                	mv	a4,a5
 3005dc6:	fec42783          	lw	a5,-20(s0)
 3005dca:	97ba                	add	a5,a5,a4
 3005dcc:	fef42423          	sw	a5,-24(s0)
    if (clkSelect == CRG_ADC_CLK_SYN_CORE) {
 3005dd0:	fd842703          	lw	a4,-40(s0)
 3005dd4:	478d                	li	a5,3
 3005dd6:	00f71a63          	bne	a4,a5,3005dea <CRG_AdcClkSelectSet+0xae>
        p->BIT.cfg_adc_ckmode_sel = BASE_CFG_SET; /* use sync clock */
 3005dda:	fe842703          	lw	a4,-24(s0)
 3005dde:	435c                	lw	a5,4(a4)
 3005de0:	010006b7          	lui	a3,0x1000
 3005de4:	8fd5                	or	a5,a5,a3
 3005de6:	c35c                	sw	a5,4(a4)
 3005de8:	a82d                	j	3005e22 <CRG_AdcClkSelectSet+0xe6>
    } else {
        DCL_SYSCTRL_CrgWriteProtectionDisable();
 3005dea:	811fe0ef          	jal	ra,30045fa <DCL_SYSCTRL_CrgWriteProtectionDisable>
        g_crgBaseAddr->PERI_CRG64.BIT.clk_pst2_sw_sel = clkSelect; /* write clock selection */
 3005dee:	ea41a703          	lw	a4,-348(gp) # 40005a0 <g_crgBaseAddr>
 3005df2:	fd842783          	lw	a5,-40(s0)
 3005df6:	8b8d                	andi	a5,a5,3
 3005df8:	0ff7f693          	andi	a3,a5,255
 3005dfc:	10072783          	lw	a5,256(a4)
 3005e00:	8a8d                	andi	a3,a3,3
 3005e02:	0692                	slli	a3,a3,0x4
 3005e04:	fcf7f793          	andi	a5,a5,-49
 3005e08:	8fd5                	or	a5,a5,a3
 3005e0a:	10f72023          	sw	a5,256(a4)
        DCL_SYSCTRL_CrgWriteProtectionEnable();
 3005e0e:	815fe0ef          	jal	ra,3004622 <DCL_SYSCTRL_CrgWriteProtectionEnable>
        p->BIT.cfg_adc_ckmode_sel = BASE_CFG_UNSET;
 3005e12:	fe842703          	lw	a4,-24(s0)
 3005e16:	435c                	lw	a5,4(a4)
 3005e18:	ff0006b7          	lui	a3,0xff000
 3005e1c:	16fd                	addi	a3,a3,-1 # feffffff <RAM_END+0xfaff7fff>
 3005e1e:	8ff5                	and	a5,a5,a3
 3005e20:	c35c                	sw	a5,4(a4)
    }
}
 3005e22:	50b2                	lw	ra,44(sp)
 3005e24:	5422                	lw	s0,40(sp)
 3005e26:	6145                	addi	sp,sp,48
 3005e28:	8082                	ret

03005e2a <CRG_AdcClkSelectGet>:
 * @brief Get ADC Clock Select
 * @param matchInfo ADC match info
 * @retval Adc Clock select @see CRG_AdcClkSelect
 */
static unsigned int CRG_AdcClkSelectGet(const CHIP_CrgIpMatchInfo *matchInfo)
{
 3005e2a:	7179                	addi	sp,sp,-48
 3005e2c:	d606                	sw	ra,44(sp)
 3005e2e:	d422                	sw	s0,40(sp)
 3005e30:	1800                	addi	s0,sp,48
 3005e32:	fca42e23          	sw	a0,-36(s0)
    CRG_ASSERT_PARAM(matchInfo != NULL);
 3005e36:	fdc42783          	lw	a5,-36(s0)
 3005e3a:	eb89                	bnez	a5,3005e4c <CRG_AdcClkSelectGet+0x22>
 3005e3c:	46800593          	li	a1,1128
 3005e40:	030117b7          	lui	a5,0x3011
 3005e44:	85878513          	addi	a0,a5,-1960 # 3010858 <g_crgIpMatch+0x348>
 3005e48:	3dc5                	jal	ra,3005d38 <AssertErrorLog.trans.3>
 3005e4a:	a001                	j	3005e4a <CRG_AdcClkSelectGet+0x20>
    CRG_ASSERT_PARAM(g_crgBaseAddr != NULL);
 3005e4c:	ea41a783          	lw	a5,-348(gp) # 40005a0 <g_crgBaseAddr>
 3005e50:	eb89                	bnez	a5,3005e62 <CRG_AdcClkSelectGet+0x38>
 3005e52:	46900593          	li	a1,1129
 3005e56:	030117b7          	lui	a5,0x3011
 3005e5a:	85878513          	addi	a0,a5,-1960 # 3010858 <g_crgIpMatch+0x348>
 3005e5e:	3de9                	jal	ra,3005d38 <AssertErrorLog.trans.3>
 3005e60:	a001                	j	3005e60 <CRG_AdcClkSelectGet+0x36>

    uintptr_t base = (uintptr_t)(void *)g_crgBaseAddr;
 3005e62:	ea41a783          	lw	a5,-348(gp) # 40005a0 <g_crgBaseAddr>
 3005e66:	fef42623          	sw	a5,-20(s0)
    CRG_AdcIpCfg *p = (CRG_AdcIpCfg *)(void *)(base + matchInfo->regOffset);
 3005e6a:	fdc42783          	lw	a5,-36(s0)
 3005e6e:	279e                	lhu	a5,8(a5)
 3005e70:	873e                	mv	a4,a5
 3005e72:	fec42783          	lw	a5,-20(s0)
 3005e76:	97ba                	add	a5,a5,a4
 3005e78:	fef42423          	sw	a5,-24(s0)
    if (p->BIT.cfg_adc_ckmode_sel == BASE_CFG_SET) {
 3005e7c:	fe842783          	lw	a5,-24(s0)
 3005e80:	43dc                	lw	a5,4(a5)
 3005e82:	83e1                	srli	a5,a5,0x18
 3005e84:	8b85                	andi	a5,a5,1
 3005e86:	0ff7f713          	andi	a4,a5,255
 3005e8a:	4785                	li	a5,1
 3005e8c:	00f71463          	bne	a4,a5,3005e94 <CRG_AdcClkSelectGet+0x6a>
        return CRG_ADC_CLK_SYN_CORE;                        /* Synchronous clock signal */
 3005e90:	478d                	li	a5,3
 3005e92:	a801                	j	3005ea2 <CRG_AdcClkSelectGet+0x78>
    }
    return g_crgBaseAddr->PERI_CRG64.BIT.clk_pst2_sw_sel;  /* asynchronous clock signal */
 3005e94:	ea41a783          	lw	a5,-348(gp) # 40005a0 <g_crgBaseAddr>
 3005e98:	1007a783          	lw	a5,256(a5)
 3005e9c:	8391                	srli	a5,a5,0x4
 3005e9e:	8b8d                	andi	a5,a5,3
 3005ea0:	9f81                	uxtb	a5
}
 3005ea2:	853e                	mv	a0,a5
 3005ea4:	50b2                	lw	ra,44(sp)
 3005ea6:	5422                	lw	s0,40(sp)
 3005ea8:	6145                	addi	sp,sp,48
 3005eaa:	8082                	ret

03005eac <CRG_AdcDivSet>:
 * @param matchInfo ADC match info
 * @param div Adc clock division
 * @retval None
 */
static void CRG_AdcDivSet(const CHIP_CrgIpMatchInfo *matchInfo, unsigned int div)
{
 3005eac:	7179                	addi	sp,sp,-48
 3005eae:	d606                	sw	ra,44(sp)
 3005eb0:	d422                	sw	s0,40(sp)
 3005eb2:	1800                	addi	s0,sp,48
 3005eb4:	fca42e23          	sw	a0,-36(s0)
 3005eb8:	fcb42c23          	sw	a1,-40(s0)
    CRG_ASSERT_PARAM(matchInfo != NULL);
 3005ebc:	fdc42783          	lw	a5,-36(s0)
 3005ec0:	eb89                	bnez	a5,3005ed2 <CRG_AdcDivSet+0x26>
 3005ec2:	47b00593          	li	a1,1147
 3005ec6:	030117b7          	lui	a5,0x3011
 3005eca:	85878513          	addi	a0,a5,-1960 # 3010858 <g_crgIpMatch+0x348>
 3005ece:	35ad                	jal	ra,3005d38 <AssertErrorLog.trans.3>
 3005ed0:	a001                	j	3005ed0 <CRG_AdcDivSet+0x24>
    CRG_ASSERT_PARAM(g_crgBaseAddr != NULL);
 3005ed2:	ea41a783          	lw	a5,-348(gp) # 40005a0 <g_crgBaseAddr>
 3005ed6:	eb89                	bnez	a5,3005ee8 <CRG_AdcDivSet+0x3c>
 3005ed8:	47c00593          	li	a1,1148
 3005edc:	030117b7          	lui	a5,0x3011
 3005ee0:	85878513          	addi	a0,a5,-1960 # 3010858 <g_crgIpMatch+0x348>
 3005ee4:	3d91                	jal	ra,3005d38 <AssertErrorLog.trans.3>
 3005ee6:	a001                	j	3005ee6 <CRG_AdcDivSet+0x3a>
    CRG_PARAM_CHECK_NO_RET(IsCrgAdcClkDiv(div));
 3005ee8:	fd842503          	lw	a0,-40(s0)
 3005eec:	a73fe0ef          	jal	ra,300495e <IsCrgAdcClkDiv>
 3005ef0:	87aa                	mv	a5,a0
 3005ef2:	0017c793          	xori	a5,a5,1
 3005ef6:	9f81                	uxtb	a5
 3005ef8:	cb89                	beqz	a5,3005f0a <CRG_AdcDivSet+0x5e>
 3005efa:	47d00593          	li	a1,1149
 3005efe:	030117b7          	lui	a5,0x3011
 3005f02:	85878513          	addi	a0,a5,-1960 # 3010858 <g_crgIpMatch+0x348>
 3005f06:	3d0d                	jal	ra,3005d38 <AssertErrorLog.trans.3>
 3005f08:	a0b5                	j	3005f74 <CRG_AdcDivSet+0xc8>

    uintptr_t base = (uintptr_t)(void *)g_crgBaseAddr;
 3005f0a:	ea41a783          	lw	a5,-348(gp) # 40005a0 <g_crgBaseAddr>
 3005f0e:	fef42623          	sw	a5,-20(s0)
    CRG_AdcIpCfg *p = (CRG_AdcIpCfg *)(void *)(base + matchInfo->regOffset);
 3005f12:	fdc42783          	lw	a5,-36(s0)
 3005f16:	279e                	lhu	a5,8(a5)
 3005f18:	873e                	mv	a4,a5
 3005f1a:	fec42783          	lw	a5,-20(s0)
 3005f1e:	97ba                	add	a5,a5,a4
 3005f20:	fef42423          	sw	a5,-24(s0)
    unsigned int clkMode = p->BIT.cfg_adc_ckmode_sel;
 3005f24:	fe842783          	lw	a5,-24(s0)
 3005f28:	43dc                	lw	a5,4(a5)
 3005f2a:	83e1                	srli	a5,a5,0x18
 3005f2c:	8b85                	andi	a5,a5,1
 3005f2e:	9f81                	uxtb	a5
 3005f30:	fef42223          	sw	a5,-28(s0)
    if (clkMode == CRG_ADC_CLK_SYNCHRONOUS) {
 3005f34:	fe442703          	lw	a4,-28(s0)
 3005f38:	4785                	li	a5,1
 3005f3a:	02f71163          	bne	a4,a5,3005f5c <CRG_AdcDivSet+0xb0>
        p->BIT.clk_adc_div1 = div; /* write div to I1 */
 3005f3e:	fd842783          	lw	a5,-40(s0)
 3005f42:	8b8d                	andi	a5,a5,3
 3005f44:	0ff7f693          	andi	a3,a5,255
 3005f48:	fe842703          	lw	a4,-24(s0)
 3005f4c:	431c                	lw	a5,0(a4)
 3005f4e:	8a8d                	andi	a3,a3,3
 3005f50:	06a2                	slli	a3,a3,0x8
 3005f52:	cff7f793          	andi	a5,a5,-769
 3005f56:	8fd5                	or	a5,a5,a3
 3005f58:	c31c                	sw	a5,0(a4)
 3005f5a:	a829                	j	3005f74 <CRG_AdcDivSet+0xc8>
    } else {
        p->BIT.clk_adc_div0 = div; /* write div to I0 */
 3005f5c:	fd842783          	lw	a5,-40(s0)
 3005f60:	8b8d                	andi	a5,a5,3
 3005f62:	0ff7f693          	andi	a3,a5,255
 3005f66:	fe842703          	lw	a4,-24(s0)
 3005f6a:	431c                	lw	a5,0(a4)
 3005f6c:	8a8d                	andi	a3,a3,3
 3005f6e:	9bf1                	andi	a5,a5,-4
 3005f70:	8fd5                	or	a5,a5,a3
 3005f72:	c31c                	sw	a5,0(a4)
    }
}
 3005f74:	50b2                	lw	ra,44(sp)
 3005f76:	5422                	lw	s0,40(sp)
 3005f78:	6145                	addi	sp,sp,48
 3005f7a:	8082                	ret

03005f7c <CRG_AdcDivGet>:
 * @brief  Get ADC clock division
 * @param matchInfo  ADC match info
 * @retval Adc clock division
 */
static unsigned int CRG_AdcDivGet(const CHIP_CrgIpMatchInfo *matchInfo)
{
 3005f7c:	7179                	addi	sp,sp,-48
 3005f7e:	d606                	sw	ra,44(sp)
 3005f80:	d422                	sw	s0,40(sp)
 3005f82:	1800                	addi	s0,sp,48
 3005f84:	fca42e23          	sw	a0,-36(s0)
    CRG_ASSERT_PARAM(matchInfo != NULL);
 3005f88:	fdc42783          	lw	a5,-36(s0)
 3005f8c:	eb89                	bnez	a5,3005f9e <CRG_AdcDivGet+0x22>
 3005f8e:	49000593          	li	a1,1168
 3005f92:	030117b7          	lui	a5,0x3011
 3005f96:	85878513          	addi	a0,a5,-1960 # 3010858 <g_crgIpMatch+0x348>
 3005f9a:	3b79                	jal	ra,3005d38 <AssertErrorLog.trans.3>
 3005f9c:	a001                	j	3005f9c <CRG_AdcDivGet+0x20>
    CRG_ASSERT_PARAM(g_crgBaseAddr != NULL);
 3005f9e:	ea41a783          	lw	a5,-348(gp) # 40005a0 <g_crgBaseAddr>
 3005fa2:	eb89                	bnez	a5,3005fb4 <CRG_AdcDivGet+0x38>
 3005fa4:	49100593          	li	a1,1169
 3005fa8:	030117b7          	lui	a5,0x3011
 3005fac:	85878513          	addi	a0,a5,-1960 # 3010858 <g_crgIpMatch+0x348>
 3005fb0:	3361                	jal	ra,3005d38 <AssertErrorLog.trans.3>
 3005fb2:	a001                	j	3005fb2 <CRG_AdcDivGet+0x36>

    uintptr_t base = (uintptr_t)(void *)g_crgBaseAddr;
 3005fb4:	ea41a783          	lw	a5,-348(gp) # 40005a0 <g_crgBaseAddr>
 3005fb8:	fef42623          	sw	a5,-20(s0)
    CRG_AdcIpCfg *p = (CRG_AdcIpCfg *)(void *)(base + matchInfo->regOffset);
 3005fbc:	fdc42783          	lw	a5,-36(s0)
 3005fc0:	279e                	lhu	a5,8(a5)
 3005fc2:	873e                	mv	a4,a5
 3005fc4:	fec42783          	lw	a5,-20(s0)
 3005fc8:	97ba                	add	a5,a5,a4
 3005fca:	fef42423          	sw	a5,-24(s0)

    unsigned int clkMode = p->BIT.cfg_adc_ckmode_sel;
 3005fce:	fe842783          	lw	a5,-24(s0)
 3005fd2:	43dc                	lw	a5,4(a5)
 3005fd4:	83e1                	srli	a5,a5,0x18
 3005fd6:	8b85                	andi	a5,a5,1
 3005fd8:	9f81                	uxtb	a5
 3005fda:	fef42223          	sw	a5,-28(s0)

    if (clkMode == CRG_ADC_CLK_SYNCHRONOUS) {
 3005fde:	fe442703          	lw	a4,-28(s0)
 3005fe2:	4785                	li	a5,1
 3005fe4:	00f71963          	bne	a4,a5,3005ff6 <CRG_AdcDivGet+0x7a>
        return p->BIT.clk_adc_div1; /* return div value I1 */
 3005fe8:	fe842783          	lw	a5,-24(s0)
 3005fec:	439c                	lw	a5,0(a5)
 3005fee:	83a1                	srli	a5,a5,0x8
 3005ff0:	8b8d                	andi	a5,a5,3
 3005ff2:	9f81                	uxtb	a5
 3005ff4:	a031                	j	3006000 <CRG_AdcDivGet+0x84>
    }
    return p->BIT.clk_adc_div0; /* return div valye I0 */
 3005ff6:	fe842783          	lw	a5,-24(s0)
 3005ffa:	439c                	lw	a5,0(a5)
 3005ffc:	8b8d                	andi	a5,a5,3
 3005ffe:	9f81                	uxtb	a5
}
 3006000:	853e                	mv	a0,a5
 3006002:	50b2                	lw	ra,44(sp)
 3006004:	5422                	lw	s0,40(sp)
 3006006:	6145                	addi	sp,sp,48
 3006008:	8082                	ret

0300600a <CRG_EfcEnableSet>:
 * @brief Enable Clock of EFC
 * @param matchInfo EFC match Info
 * @param enable IP_CLK_ENABLE or IP_CRG_DISABLE
 */
static void CRG_EfcEnableSet(const CHIP_CrgIpMatchInfo *matchInfo, unsigned int enable)
{
 300600a:	7179                	addi	sp,sp,-48
 300600c:	d606                	sw	ra,44(sp)
 300600e:	d422                	sw	s0,40(sp)
 3006010:	1800                	addi	s0,sp,48
 3006012:	fca42e23          	sw	a0,-36(s0)
 3006016:	fcb42c23          	sw	a1,-40(s0)
    CRG_ASSERT_PARAM(matchInfo != NULL);
 300601a:	fdc42783          	lw	a5,-36(s0)
 300601e:	eb89                	bnez	a5,3006030 <CRG_EfcEnableSet+0x26>
 3006020:	4a500593          	li	a1,1189
 3006024:	030117b7          	lui	a5,0x3011
 3006028:	85878513          	addi	a0,a5,-1960 # 3010858 <g_crgIpMatch+0x348>
 300602c:	3331                	jal	ra,3005d38 <AssertErrorLog.trans.3>
 300602e:	a001                	j	300602e <CRG_EfcEnableSet+0x24>
    CRG_ASSERT_PARAM(g_crgBaseAddr != NULL);
 3006030:	ea41a783          	lw	a5,-348(gp) # 40005a0 <g_crgBaseAddr>
 3006034:	eb89                	bnez	a5,3006046 <CRG_EfcEnableSet+0x3c>
 3006036:	4a600593          	li	a1,1190
 300603a:	030117b7          	lui	a5,0x3011
 300603e:	85878513          	addi	a0,a5,-1960 # 3010858 <g_crgIpMatch+0x348>
 3006042:	39dd                	jal	ra,3005d38 <AssertErrorLog.trans.3>
 3006044:	a001                	j	3006044 <CRG_EfcEnableSet+0x3a>
    /* Enables or disables EFC clock gating. */
    uintptr_t base = (uintptr_t)(void *)g_crgBaseAddr;
 3006046:	ea41a783          	lw	a5,-348(gp) # 40005a0 <g_crgBaseAddr>
 300604a:	fef42623          	sw	a5,-20(s0)
    CRG_EfcIpCfg *p = (CRG_EfcIpCfg *)(void *)(base + matchInfo->regOffset);
 300604e:	fdc42783          	lw	a5,-36(s0)
 3006052:	279e                	lhu	a5,8(a5)
 3006054:	873e                	mv	a4,a5
 3006056:	fec42783          	lw	a5,-20(s0)
 300605a:	97ba                	add	a5,a5,a4
 300605c:	fef42423          	sw	a5,-24(s0)
    p->BIT.eflash_cken = (enable & IP_CLK_ENABLE) ? BASE_CFG_SET : BASE_CFG_UNSET;
 3006060:	fd842783          	lw	a5,-40(s0)
 3006064:	8b85                	andi	a5,a5,1
 3006066:	0ff7f693          	andi	a3,a5,255
 300606a:	fe842703          	lw	a4,-24(s0)
 300606e:	431c                	lw	a5,0(a4)
 3006070:	8a85                	andi	a3,a3,1
 3006072:	9bf9                	andi	a5,a5,-2
 3006074:	8fd5                	or	a5,a5,a3
 3006076:	c31c                	sw	a5,0(a4)
}
 3006078:	0001                	nop
 300607a:	50b2                	lw	ra,44(sp)
 300607c:	5422                	lw	s0,40(sp)
 300607e:	6145                	addi	sp,sp,48
 3006080:	8082                	ret

03006082 <CRG_EfcEnableGet>:
 * @brief Disable Clock of EFC
 * @param matchInfo EFC match Info
 * @return unsigned int IP_CLK_ENABLE or IP_CRG_DISABLE
 */
static unsigned int CRG_EfcEnableGet(const CHIP_CrgIpMatchInfo *matchInfo)
{
 3006082:	7179                	addi	sp,sp,-48
 3006084:	d606                	sw	ra,44(sp)
 3006086:	d422                	sw	s0,40(sp)
 3006088:	1800                	addi	s0,sp,48
 300608a:	fca42e23          	sw	a0,-36(s0)
    CRG_ASSERT_PARAM(matchInfo != NULL);
 300608e:	fdc42783          	lw	a5,-36(s0)
 3006092:	eb89                	bnez	a5,30060a4 <CRG_EfcEnableGet+0x22>
 3006094:	4b400593          	li	a1,1204
 3006098:	030117b7          	lui	a5,0x3011
 300609c:	85878513          	addi	a0,a5,-1960 # 3010858 <g_crgIpMatch+0x348>
 30060a0:	3961                	jal	ra,3005d38 <AssertErrorLog.trans.3>
 30060a2:	a001                	j	30060a2 <CRG_EfcEnableGet+0x20>
    CRG_ASSERT_PARAM(g_crgBaseAddr != NULL);
 30060a4:	ea41a783          	lw	a5,-348(gp) # 40005a0 <g_crgBaseAddr>
 30060a8:	eb89                	bnez	a5,30060ba <CRG_EfcEnableGet+0x38>
 30060aa:	4b500593          	li	a1,1205
 30060ae:	030117b7          	lui	a5,0x3011
 30060b2:	85878513          	addi	a0,a5,-1960 # 3010858 <g_crgIpMatch+0x348>
 30060b6:	3149                	jal	ra,3005d38 <AssertErrorLog.trans.3>
 30060b8:	a001                	j	30060b8 <CRG_EfcEnableGet+0x36>
    /* Get the value of the EFC register in the CRG. */
    uintptr_t base = (uintptr_t)(void *)g_crgBaseAddr;
 30060ba:	ea41a783          	lw	a5,-348(gp) # 40005a0 <g_crgBaseAddr>
 30060be:	fef42623          	sw	a5,-20(s0)
    CRG_EfcIpCfg *p = (CRG_EfcIpCfg *)(void *)(base + matchInfo->regOffset);
 30060c2:	fdc42783          	lw	a5,-36(s0)
 30060c6:	279e                	lhu	a5,8(a5)
 30060c8:	873e                	mv	a4,a5
 30060ca:	fec42783          	lw	a5,-20(s0)
 30060ce:	97ba                	add	a5,a5,a4
 30060d0:	fef42423          	sw	a5,-24(s0)
    return p->BIT.eflash_cken;
 30060d4:	fe842783          	lw	a5,-24(s0)
 30060d8:	439c                	lw	a5,0(a5)
 30060da:	8b85                	andi	a5,a5,1
 30060dc:	9f81                	uxtb	a5
}
 30060de:	853e                	mv	a0,a5
 30060e0:	50b2                	lw	ra,44(sp)
 30060e2:	5422                	lw	s0,40(sp)
 30060e4:	6145                	addi	sp,sp,48
 30060e6:	8082                	ret

030060e8 <CRG_AnaEnableSet>:
 * @brief Enable Clock of ANA
 * @param matchInfo ANA match Info
 * @param enable IP_CLK_ENABLE or IP_CRG_DISABLE
 */
static void CRG_AnaEnableSet(const CHIP_CrgIpMatchInfo *matchInfo, unsigned int enable)
{
 30060e8:	7179                	addi	sp,sp,-48
 30060ea:	d606                	sw	ra,44(sp)
 30060ec:	d422                	sw	s0,40(sp)
 30060ee:	1800                	addi	s0,sp,48
 30060f0:	fca42e23          	sw	a0,-36(s0)
 30060f4:	fcb42c23          	sw	a1,-40(s0)
    CRG_ASSERT_PARAM(matchInfo != NULL);
 30060f8:	fdc42783          	lw	a5,-36(s0)
 30060fc:	eb89                	bnez	a5,300610e <CRG_AnaEnableSet+0x26>
 30060fe:	4c400593          	li	a1,1220
 3006102:	030117b7          	lui	a5,0x3011
 3006106:	85878513          	addi	a0,a5,-1960 # 3010858 <g_crgIpMatch+0x348>
 300610a:	313d                	jal	ra,3005d38 <AssertErrorLog.trans.3>
 300610c:	a001                	j	300610c <CRG_AnaEnableSet+0x24>
    CRG_ASSERT_PARAM(g_crgBaseAddr != NULL);
 300610e:	ea41a783          	lw	a5,-348(gp) # 40005a0 <g_crgBaseAddr>
 3006112:	eb89                	bnez	a5,3006124 <CRG_AnaEnableSet+0x3c>
 3006114:	4c500593          	li	a1,1221
 3006118:	030117b7          	lui	a5,0x3011
 300611c:	85878513          	addi	a0,a5,-1960 # 3010858 <g_crgIpMatch+0x348>
 3006120:	3921                	jal	ra,3005d38 <AssertErrorLog.trans.3>
 3006122:	a001                	j	3006122 <CRG_AnaEnableSet+0x3a>
    CRG_PARAM_CHECK_NO_RET(enable == IP_CLK_ENABLE || enable == IP_CLK_DISABLE);
 3006124:	fd842703          	lw	a4,-40(s0)
 3006128:	4785                	li	a5,1
 300612a:	00f70d63          	beq	a4,a5,3006144 <CRG_AnaEnableSet+0x5c>
 300612e:	fd842783          	lw	a5,-40(s0)
 3006132:	cb89                	beqz	a5,3006144 <CRG_AnaEnableSet+0x5c>
 3006134:	4c600593          	li	a1,1222
 3006138:	030117b7          	lui	a5,0x3011
 300613c:	85878513          	addi	a0,a5,-1960 # 3010858 <g_crgIpMatch+0x348>
 3006140:	3ee5                	jal	ra,3005d38 <AssertErrorLog.trans.3>
 3006142:	a209                	j	3006244 <CRG_AnaEnableSet+0x15c>

    /* Get the value of the ANA IP register in the CRG. */
    uintptr_t base = (uintptr_t)(void *)g_crgBaseAddr;
 3006144:	ea41a783          	lw	a5,-348(gp) # 40005a0 <g_crgBaseAddr>
 3006148:	fef42623          	sw	a5,-20(s0)
    CRG_AnaIpCfg *p = (CRG_AnaIpCfg *)(void *)(base + matchInfo->regOffset + matchInfo->bitOffset);
 300614c:	fdc42783          	lw	a5,-36(s0)
 3006150:	279e                	lhu	a5,8(a5)
 3006152:	873e                	mv	a4,a5
 3006154:	fec42783          	lw	a5,-20(s0)
 3006158:	97ba                	add	a5,a5,a4
 300615a:	fdc42703          	lw	a4,-36(s0)
 300615e:	2738                	lbu	a4,10(a4)
 3006160:	97ba                	add	a5,a5,a4
 3006162:	fef42423          	sw	a5,-24(s0)

    if ((enable == IP_CLK_ENABLE) && (p->BIT.ip_srst_req == BASE_CFG_SET)) {
 3006166:	fd842703          	lw	a4,-40(s0)
 300616a:	4785                	li	a5,1
 300616c:	02f71b63          	bne	a4,a5,30061a2 <CRG_AnaEnableSet+0xba>
 3006170:	fe842783          	lw	a5,-24(s0)
 3006174:	439c                	lw	a5,0(a5)
 3006176:	83c1                	srli	a5,a5,0x10
 3006178:	8b85                	andi	a5,a5,1
 300617a:	0ff7f713          	andi	a4,a5,255
 300617e:	4785                	li	a5,1
 3006180:	02f71163          	bne	a4,a5,30061a2 <CRG_AnaEnableSet+0xba>
        p->BIT.ip_srst_req = BASE_CFG_UNSET;
 3006184:	fe842703          	lw	a4,-24(s0)
 3006188:	431c                	lw	a5,0(a4)
 300618a:	76c1                	lui	a3,0xffff0
 300618c:	16fd                	addi	a3,a3,-1 # fffeffff <RAM_END+0xfbfe7fff>
 300618e:	8ff5                	and	a5,a5,a3
 3006190:	c31c                	sw	a5,0(a4)
        g_anaEnableFlag++; /* count enable analog IP number */
 3006192:	ea81c783          	lbu	a5,-344(gp) # 40005a4 <g_anaEnableFlag>
 3006196:	0785                	addi	a5,a5,1
 3006198:	0ff7f713          	andi	a4,a5,255
 300619c:	eae18423          	sb	a4,-344(gp) # 40005a4 <g_anaEnableFlag>
 30061a0:	a81d                	j	30061d6 <CRG_AnaEnableSet+0xee>
    } else if ((enable == IP_CLK_DISABLE) && (p->BIT.ip_srst_req == BASE_CFG_UNSET)) {
 30061a2:	fd842783          	lw	a5,-40(s0)
 30061a6:	eb85                	bnez	a5,30061d6 <CRG_AnaEnableSet+0xee>
 30061a8:	fe842783          	lw	a5,-24(s0)
 30061ac:	439c                	lw	a5,0(a5)
 30061ae:	83c1                	srli	a5,a5,0x10
 30061b0:	8b85                	andi	a5,a5,1
 30061b2:	9f81                	uxtb	a5
 30061b4:	e38d                	bnez	a5,30061d6 <CRG_AnaEnableSet+0xee>
        p->BIT.ip_srst_req = BASE_CFG_SET;
 30061b6:	fe842703          	lw	a4,-24(s0)
 30061ba:	431c                	lw	a5,0(a4)
 30061bc:	66c1                	lui	a3,0x10
 30061be:	8fd5                	or	a5,a5,a3
 30061c0:	c31c                	sw	a5,0(a4)
        if (g_anaEnableFlag > 0) {
 30061c2:	ea81c783          	lbu	a5,-344(gp) # 40005a4 <g_anaEnableFlag>
 30061c6:	cb81                	beqz	a5,30061d6 <CRG_AnaEnableSet+0xee>
            g_anaEnableFlag--; /* Decreasing the count to enable the analog IP number. */
 30061c8:	ea81c783          	lbu	a5,-344(gp) # 40005a4 <g_anaEnableFlag>
 30061cc:	17fd                	addi	a5,a5,-1
 30061ce:	0ff7f713          	andi	a4,a5,255
 30061d2:	eae18423          	sb	a4,-344(gp) # 40005a4 <g_anaEnableFlag>
        }
    }

    if ((g_anaEnableFlag == 0) && (enable == IP_CLK_DISABLE)) { /* all analog clock disable */
 30061d6:	ea81c783          	lbu	a5,-344(gp) # 40005a4 <g_anaEnableFlag>
 30061da:	eb85                	bnez	a5,300620a <CRG_AnaEnableSet+0x122>
 30061dc:	fd842783          	lw	a5,-40(s0)
 30061e0:	e78d                	bnez	a5,300620a <CRG_AnaEnableSet+0x122>
        CRG->PERI_CRG660.BIT.clk_ana_cken = BASE_CFG_UNSET;
 30061e2:	10000737          	lui	a4,0x10000
 30061e6:	6785                	lui	a5,0x1
 30061e8:	973e                	add	a4,a4,a5
 30061ea:	a5072783          	lw	a5,-1456(a4) # ffffa50 <RAM_END+0xbff7a50>
 30061ee:	9bf9                	andi	a5,a5,-2
 30061f0:	a4f72823          	sw	a5,-1456(a4)
        CRG->PERI_CRG660.BIT.ana_srst_req = BASE_CFG_SET;
 30061f4:	10000737          	lui	a4,0x10000
 30061f8:	6785                	lui	a5,0x1
 30061fa:	973e                	add	a4,a4,a5
 30061fc:	a5072783          	lw	a5,-1456(a4) # ffffa50 <RAM_END+0xbff7a50>
 3006200:	66c1                	lui	a3,0x10
 3006202:	8fd5                	or	a5,a5,a3
 3006204:	a4f72823          	sw	a5,-1456(a4)
 3006208:	a835                	j	3006244 <CRG_AnaEnableSet+0x15c>
    } else if ((g_anaEnableFlag > 0) && (enable == IP_CLK_ENABLE)) {  /* all analog clock enable */
 300620a:	ea81c783          	lbu	a5,-344(gp) # 40005a4 <g_anaEnableFlag>
 300620e:	cb9d                	beqz	a5,3006244 <CRG_AnaEnableSet+0x15c>
 3006210:	fd842703          	lw	a4,-40(s0)
 3006214:	4785                	li	a5,1
 3006216:	02f71763          	bne	a4,a5,3006244 <CRG_AnaEnableSet+0x15c>
        CRG->PERI_CRG660.BIT.ana_srst_req = BASE_CFG_UNSET;
 300621a:	10000737          	lui	a4,0x10000
 300621e:	6785                	lui	a5,0x1
 3006220:	973e                	add	a4,a4,a5
 3006222:	a5072783          	lw	a5,-1456(a4) # ffffa50 <RAM_END+0xbff7a50>
 3006226:	76c1                	lui	a3,0xffff0
 3006228:	16fd                	addi	a3,a3,-1 # fffeffff <RAM_END+0xfbfe7fff>
 300622a:	8ff5                	and	a5,a5,a3
 300622c:	a4f72823          	sw	a5,-1456(a4)
        CRG->PERI_CRG660.BIT.clk_ana_cken = BASE_CFG_SET;
 3006230:	10000737          	lui	a4,0x10000
 3006234:	6785                	lui	a5,0x1
 3006236:	973e                	add	a4,a4,a5
 3006238:	a5072783          	lw	a5,-1456(a4) # ffffa50 <RAM_END+0xbff7a50>
 300623c:	0017e793          	ori	a5,a5,1
 3006240:	a4f72823          	sw	a5,-1456(a4)
    }
}
 3006244:	50b2                	lw	ra,44(sp)
 3006246:	5422                	lw	s0,40(sp)
 3006248:	6145                	addi	sp,sp,48
 300624a:	8082                	ret

0300624c <CRG_AnaEnableGet>:
 * @brief Get Clock of ANA
 * @param matchInfo ANA match Info
 * @return unsigned int IP_CLK_ENABLE or IP_CRG_DISABLE
 */
static unsigned int CRG_AnaEnableGet(const CHIP_CrgIpMatchInfo *matchInfo)
{
 300624c:	7179                	addi	sp,sp,-48
 300624e:	d606                	sw	ra,44(sp)
 3006250:	d422                	sw	s0,40(sp)
 3006252:	1800                	addi	s0,sp,48
 3006254:	fca42e23          	sw	a0,-36(s0)
    CRG_ASSERT_PARAM(matchInfo != NULL);
 3006258:	fdc42783          	lw	a5,-36(s0)
 300625c:	eb89                	bnez	a5,300626e <CRG_AnaEnableGet+0x22>
 300625e:	4e600593          	li	a1,1254
 3006262:	030117b7          	lui	a5,0x3011
 3006266:	85878513          	addi	a0,a5,-1960 # 3010858 <g_crgIpMatch+0x348>
 300626a:	34f9                	jal	ra,3005d38 <AssertErrorLog.trans.3>
 300626c:	a001                	j	300626c <CRG_AnaEnableGet+0x20>
    CRG_ASSERT_PARAM(g_crgBaseAddr != NULL);
 300626e:	ea41a783          	lw	a5,-348(gp) # 40005a0 <g_crgBaseAddr>
 3006272:	eb89                	bnez	a5,3006284 <CRG_AnaEnableGet+0x38>
 3006274:	4e700593          	li	a1,1255
 3006278:	030117b7          	lui	a5,0x3011
 300627c:	85878513          	addi	a0,a5,-1960 # 3010858 <g_crgIpMatch+0x348>
 3006280:	3c65                	jal	ra,3005d38 <AssertErrorLog.trans.3>
 3006282:	a001                	j	3006282 <CRG_AnaEnableGet+0x36>

    /* Get the value of the ANA IP register in the CRG. */
    uintptr_t base = (uintptr_t)(void *)g_crgBaseAddr;
 3006284:	ea41a783          	lw	a5,-348(gp) # 40005a0 <g_crgBaseAddr>
 3006288:	fef42623          	sw	a5,-20(s0)
    CRG_AnaIpCfg *p = (CRG_AnaIpCfg *)(void *)(base + matchInfo->regOffset + matchInfo->bitOffset);
 300628c:	fdc42783          	lw	a5,-36(s0)
 3006290:	279e                	lhu	a5,8(a5)
 3006292:	873e                	mv	a4,a5
 3006294:	fec42783          	lw	a5,-20(s0)
 3006298:	97ba                	add	a5,a5,a4
 300629a:	fdc42703          	lw	a4,-36(s0)
 300629e:	2738                	lbu	a4,10(a4)
 30062a0:	97ba                	add	a5,a5,a4
 30062a2:	fef42423          	sw	a5,-24(s0)
    /* The clock is enabled based on the IP reset status. */
    return (p->BIT.ip_srst_req) ? BASE_CFG_UNSET : BASE_CFG_SET;
 30062a6:	fe842783          	lw	a5,-24(s0)
 30062aa:	439c                	lw	a5,0(a5)
 30062ac:	83c1                	srli	a5,a5,0x10
 30062ae:	8b85                	andi	a5,a5,1
 30062b0:	9f81                	uxtb	a5
 30062b2:	0017c793          	xori	a5,a5,1
 30062b6:	9f81                	uxtb	a5
}
 30062b8:	853e                	mv	a0,a5
 30062ba:	50b2                	lw	ra,44(sp)
 30062bc:	5422                	lw	s0,40(sp)
 30062be:	6145                	addi	sp,sp,48
 30062c0:	8082                	ret

030062c2 <DBG_PrintCh>:
 * @brief   Write a character to the UART port.
 * @param   ch The int promotion of the character to be written.
 * @retval  None.
 */
static void DBG_PrintCh(unsigned int ch)
{
 30062c2:	1101                	addi	sp,sp,-32
 30062c4:	ce22                	sw	s0,28(sp)
 30062c6:	1000                	addi	s0,sp,32
 30062c8:	fea42623          	sw	a0,-20(s0)
    while (DBG_PRINTF_UART_PORT->UART_FR.BIT.txff == 1) {
 30062cc:	0001                	nop
 30062ce:	140027b7          	lui	a5,0x14002
 30062d2:	4f9c                	lw	a5,24(a5)
 30062d4:	8395                	srli	a5,a5,0x5
 30062d6:	8b85                	andi	a5,a5,1
 30062d8:	0ff7f713          	andi	a4,a5,255
 30062dc:	4785                	li	a5,1
 30062de:	fef708e3          	beq	a4,a5,30062ce <DBG_PrintCh+0xc>
        ;
    }
    DBG_PRINTF_UART_PORT->UART_DR.BIT.data = (unsigned char)ch;
 30062e2:	14002737          	lui	a4,0x14002
 30062e6:	fec42783          	lw	a5,-20(s0)
 30062ea:	0ff7f693          	andi	a3,a5,255
 30062ee:	431c                	lw	a5,0(a4)
 30062f0:	0ff6f693          	andi	a3,a3,255
 30062f4:	f007f793          	andi	a5,a5,-256
 30062f8:	8fd5                	or	a5,a5,a3
 30062fa:	c31c                	sw	a5,0(a4)
}
 30062fc:	0001                	nop
 30062fe:	4472                	lw	s0,28(sp)
 3006300:	6105                	addi	sp,sp,32
 3006302:	8082                	ret

03006304 <DBG_PrintStr>:
 * @param   str The string to be printed.
 * @retval  int If succeeded, the total number of characters printed is returned.
 *              If the input parameter is wrong, a BASE_STATUS_ERROR is returned.
 */
static int DBG_PrintStr(const char *str)
{
 3006304:	7179                	addi	sp,sp,-48
 3006306:	d606                	sw	ra,44(sp)
 3006308:	d422                	sw	s0,40(sp)
 300630a:	1800                	addi	s0,sp,48
 300630c:	fca42e23          	sw	a0,-36(s0)
    DEBUG_ASSERT_PARAM(str != NULL);
    int cnt = 0;
 3006310:	fe042623          	sw	zero,-20(s0)
    while (*str != '\0') {
 3006314:	a00d                	j	3006336 <DBG_PrintStr+0x32>
        DBG_PrintCh(*str);
 3006316:	fdc42783          	lw	a5,-36(s0)
 300631a:	00078783          	lb	a5,0(a5) # 14002000 <RAM_END+0xfffa000>
 300631e:	853e                	mv	a0,a5
 3006320:	374d                	jal	ra,30062c2 <DBG_PrintCh>
        str++;
 3006322:	fdc42783          	lw	a5,-36(s0)
 3006326:	0785                	addi	a5,a5,1
 3006328:	fcf42e23          	sw	a5,-36(s0)
        cnt++;
 300632c:	fec42783          	lw	a5,-20(s0)
 3006330:	0785                	addi	a5,a5,1
 3006332:	fef42623          	sw	a5,-20(s0)
    while (*str != '\0') {
 3006336:	fdc42783          	lw	a5,-36(s0)
 300633a:	00078783          	lb	a5,0(a5)
 300633e:	ffe1                	bnez	a5,3006316 <DBG_PrintStr+0x12>
    }
    return cnt;
 3006340:	fec42783          	lw	a5,-20(s0)
}
 3006344:	853e                	mv	a0,a5
 3006346:	50b2                	lw	ra,44(sp)
 3006348:	5422                	lw	s0,40(sp)
 300634a:	6145                	addi	sp,sp,48
 300634c:	8082                	ret

0300634e <DBG_Pow>:
 * @param   base Base value.
 * @param   exponent Exponent value.
 * @retval  unsigned long The result of raising base to the power exponent.
 */
static unsigned long DBG_Pow(unsigned int base, unsigned int exponent)
{
 300634e:	7179                	addi	sp,sp,-48
 3006350:	d622                	sw	s0,44(sp)
 3006352:	1800                	addi	s0,sp,48
 3006354:	fca42e23          	sw	a0,-36(s0)
 3006358:	fcb42c23          	sw	a1,-40(s0)
    unsigned long ret = 1;
 300635c:	4785                	li	a5,1
 300635e:	fef42623          	sw	a5,-20(s0)
    while (exponent--) {
 3006362:	a809                	j	3006374 <DBG_Pow+0x26>
        ret *= base;
 3006364:	fec42703          	lw	a4,-20(s0)
 3006368:	fdc42783          	lw	a5,-36(s0)
 300636c:	02f707b3          	mul	a5,a4,a5
 3006370:	fef42623          	sw	a5,-20(s0)
    while (exponent--) {
 3006374:	fd842783          	lw	a5,-40(s0)
 3006378:	fff78713          	addi	a4,a5,-1
 300637c:	fce42c23          	sw	a4,-40(s0)
 3006380:	f3f5                	bnez	a5,3006364 <DBG_Pow+0x16>
    }
    return ret; /* ret = base ^ exponent */
 3006382:	fec42783          	lw	a5,-20(s0)
}
 3006386:	853e                	mv	a0,a5
 3006388:	5432                	lw	s0,44(sp)
 300638a:	6145                	addi	sp,sp,48
 300638c:	8082                	ret

0300638e <DBG_CountDigits>:
 * @param   num The number to be counted.
 * @param   base The number base of num.
 * @retval  unsigned int The number of digits.
 */
static unsigned int DBG_CountDigits(int num, NumBase base)
{
 300638e:	7179                	addi	sp,sp,-48
 3006390:	d622                	sw	s0,44(sp)
 3006392:	1800                	addi	s0,sp,48
 3006394:	fca42e23          	sw	a0,-36(s0)
 3006398:	fcb42c23          	sw	a1,-40(s0)
    unsigned int cnt = 0;
 300639c:	fe042623          	sw	zero,-20(s0)
    if (base == 0) {
 30063a0:	fd842783          	lw	a5,-40(s0)
 30063a4:	e78d                	bnez	a5,30063ce <DBG_CountDigits+0x40>
        return 0;
 30063a6:	4781                	li	a5,0
 30063a8:	a099                	j	30063ee <DBG_CountDigits+0x60>
    }
    while (num != 0) {
        cnt++;
 30063aa:	fec42783          	lw	a5,-20(s0)
 30063ae:	0785                	addi	a5,a5,1
 30063b0:	fef42623          	sw	a5,-20(s0)
        if (cnt > MAX_DIV_TIMES) {
 30063b4:	fec42703          	lw	a4,-20(s0)
 30063b8:	47fd                	li	a5,31
 30063ba:	00e7ee63          	bltu	a5,a4,30063d6 <DBG_CountDigits+0x48>
            break;
        }
        num /= base;
 30063be:	fdc42703          	lw	a4,-36(s0)
 30063c2:	fd842783          	lw	a5,-40(s0)
 30063c6:	02f757b3          	divu	a5,a4,a5
 30063ca:	fcf42e23          	sw	a5,-36(s0)
    while (num != 0) {
 30063ce:	fdc42783          	lw	a5,-36(s0)
 30063d2:	ffe1                	bnez	a5,30063aa <DBG_CountDigits+0x1c>
 30063d4:	a011                	j	30063d8 <DBG_CountDigits+0x4a>
            break;
 30063d6:	0001                	nop
    }
    cnt = (cnt == 0) ? 1 : cnt;
 30063d8:	fec42783          	lw	a5,-20(s0)
 30063dc:	c781                	beqz	a5,30063e4 <DBG_CountDigits+0x56>
 30063de:	fec42783          	lw	a5,-20(s0)
 30063e2:	a011                	j	30063e6 <DBG_CountDigits+0x58>
 30063e4:	4785                	li	a5,1
 30063e6:	fef42623          	sw	a5,-20(s0)
    return cnt;
 30063ea:	fec42783          	lw	a5,-20(s0)
}
 30063ee:	853e                	mv	a0,a5
 30063f0:	5432                	lw	s0,44(sp)
 30063f2:	6145                	addi	sp,sp,48
 30063f4:	8082                	ret

030063f6 <DBG_PutUnsignedNum>:
 * @param   num The unsigned number to be printed.
 * @param   base The number base of num.
 * @param   digits The digits of num.
 */
static void DBG_PutUnsignedNum(unsigned int num, NumBase base, unsigned int digits)
{
 30063f6:	7179                	addi	sp,sp,-48
 30063f8:	d606                	sw	ra,44(sp)
 30063fa:	d422                	sw	s0,40(sp)
 30063fc:	1800                	addi	s0,sp,48
 30063fe:	fca42e23          	sw	a0,-36(s0)
 3006402:	fcb42c23          	sw	a1,-40(s0)
 3006406:	fcc42a23          	sw	a2,-44(s0)
    unsigned char ch;
    while (digits != 0) {
 300640a:	a069                	j	3006494 <DBG_PutUnsignedNum+0x9e>
        ch = num / DBG_Pow(base, digits - 1);
 300640c:	fd442783          	lw	a5,-44(s0)
 3006410:	17fd                	addi	a5,a5,-1
 3006412:	85be                	mv	a1,a5
 3006414:	fd842503          	lw	a0,-40(s0)
 3006418:	3f1d                	jal	ra,300634e <DBG_Pow>
 300641a:	872a                	mv	a4,a0
 300641c:	fdc42783          	lw	a5,-36(s0)
 3006420:	02e7d7b3          	divu	a5,a5,a4
 3006424:	fef407a3          	sb	a5,-17(s0)
        num %= DBG_Pow(base, digits - 1);
 3006428:	fd442783          	lw	a5,-44(s0)
 300642c:	17fd                	addi	a5,a5,-1
 300642e:	85be                	mv	a1,a5
 3006430:	fd842503          	lw	a0,-40(s0)
 3006434:	3f29                	jal	ra,300634e <DBG_Pow>
 3006436:	872a                	mv	a4,a0
 3006438:	fdc42783          	lw	a5,-36(s0)
 300643c:	02e7f7b3          	remu	a5,a5,a4
 3006440:	fcf42e23          	sw	a5,-36(s0)
        if (base == DECIMAL) {
 3006444:	fd842703          	lw	a4,-40(s0)
 3006448:	47a9                	li	a5,10
 300644a:	00f71963          	bne	a4,a5,300645c <DBG_PutUnsignedNum+0x66>
            DBG_PrintCh(ch + '0');
 300644e:	fef44783          	lbu	a5,-17(s0)
 3006452:	03078793          	addi	a5,a5,48
 3006456:	853e                	mv	a0,a5
 3006458:	35ad                	jal	ra,30062c2 <DBG_PrintCh>
 300645a:	a805                	j	300648a <DBG_PutUnsignedNum+0x94>
        } else if (base == HEXADECIMAL) {
 300645c:	fd842703          	lw	a4,-40(s0)
 3006460:	47c1                	li	a5,16
 3006462:	02f71d63          	bne	a4,a5,300649c <DBG_PutUnsignedNum+0xa6>
            if (ch < DECIMAL_BASE) {
 3006466:	fef44703          	lbu	a4,-17(s0)
 300646a:	47a5                	li	a5,9
 300646c:	00e7e963          	bltu	a5,a4,300647e <DBG_PutUnsignedNum+0x88>
                DBG_PrintCh(ch + '0');
 3006470:	fef44783          	lbu	a5,-17(s0)
 3006474:	03078793          	addi	a5,a5,48
 3006478:	853e                	mv	a0,a5
 300647a:	35a1                	jal	ra,30062c2 <DBG_PrintCh>
 300647c:	a039                	j	300648a <DBG_PutUnsignedNum+0x94>
            } else {
                DBG_PrintCh(ch - DECIMAL_BASE + 'A');
 300647e:	fef44783          	lbu	a5,-17(s0)
 3006482:	03778793          	addi	a5,a5,55
 3006486:	853e                	mv	a0,a5
 3006488:	3d2d                	jal	ra,30062c2 <DBG_PrintCh>
            }
        } else {
            break;
        }
        digits--;
 300648a:	fd442783          	lw	a5,-44(s0)
 300648e:	17fd                	addi	a5,a5,-1
 3006490:	fcf42a23          	sw	a5,-44(s0)
    while (digits != 0) {
 3006494:	fd442783          	lw	a5,-44(s0)
 3006498:	fbb5                	bnez	a5,300640c <DBG_PutUnsignedNum+0x16>
    }
}
 300649a:	a011                	j	300649e <DBG_PutUnsignedNum+0xa8>
            break;
 300649c:	0001                	nop
}
 300649e:	0001                	nop
 30064a0:	50b2                	lw	ra,44(sp)
 30064a2:	5422                	lw	s0,40(sp)
 30064a4:	6145                	addi	sp,sp,48
 30064a6:	8082                	ret

030064a8 <DBG_PrintInt>:
 * @brief   Print decimal number through UART port.
 * @param   intNum The decimal number to be printed.
 * @retval  unsigned int The total number of characters printed.
 */
static unsigned int DBG_PrintInt(int intNum)
{
 30064a8:	7179                	addi	sp,sp,-48
 30064aa:	d606                	sw	ra,44(sp)
 30064ac:	d422                	sw	s0,40(sp)
 30064ae:	1800                	addi	s0,sp,48
 30064b0:	fca42e23          	sw	a0,-36(s0)
    unsigned int cnt;
    if (intNum == 0) {
 30064b4:	fdc42783          	lw	a5,-36(s0)
 30064b8:	e791                	bnez	a5,30064c4 <DBG_PrintInt+0x1c>
        DBG_PrintCh('0');
 30064ba:	03000513          	li	a0,48
 30064be:	3511                	jal	ra,30062c2 <DBG_PrintCh>
        return 1;
 30064c0:	4785                	li	a5,1
 30064c2:	a82d                	j	30064fc <DBG_PrintInt+0x54>
    }
    if (intNum < 0) {
 30064c4:	fdc42783          	lw	a5,-36(s0)
 30064c8:	0007db63          	bgez	a5,30064de <DBG_PrintInt+0x36>
        DBG_PrintCh('-');
 30064cc:	02d00513          	li	a0,45
 30064d0:	3bcd                	jal	ra,30062c2 <DBG_PrintCh>
        intNum = -intNum;
 30064d2:	fdc42783          	lw	a5,-36(s0)
 30064d6:	40f007b3          	neg	a5,a5
 30064da:	fcf42e23          	sw	a5,-36(s0)
    }
    cnt = DBG_CountDigits(intNum, DECIMAL);
 30064de:	45a9                	li	a1,10
 30064e0:	fdc42503          	lw	a0,-36(s0)
 30064e4:	356d                	jal	ra,300638e <DBG_CountDigits>
 30064e6:	fea42623          	sw	a0,-20(s0)
    DBG_PutUnsignedNum(intNum, DECIMAL, cnt);
 30064ea:	fdc42783          	lw	a5,-36(s0)
 30064ee:	fec42603          	lw	a2,-20(s0)
 30064f2:	45a9                	li	a1,10
 30064f4:	853e                	mv	a0,a5
 30064f6:	3701                	jal	ra,30063f6 <DBG_PutUnsignedNum>
    return cnt;
 30064f8:	fec42783          	lw	a5,-20(s0)
}
 30064fc:	853e                	mv	a0,a5
 30064fe:	50b2                	lw	ra,44(sp)
 3006500:	5422                	lw	s0,40(sp)
 3006502:	6145                	addi	sp,sp,48
 3006504:	8082                	ret

03006506 <DBG_PrintHex>:
 * @brief   Print hexadecimal number through UART port.
 * @param   hexNum The hexadecimal number to be printed.
 * @retval  unsigned int The total number of characters printed.
 */
static unsigned int DBG_PrintHex(unsigned int hexNum)
{
 3006506:	7179                	addi	sp,sp,-48
 3006508:	d606                	sw	ra,44(sp)
 300650a:	d422                	sw	s0,40(sp)
 300650c:	1800                	addi	s0,sp,48
 300650e:	fca42e23          	sw	a0,-36(s0)
    unsigned int cnt;
    if (hexNum == 0) {
 3006512:	fdc42783          	lw	a5,-36(s0)
 3006516:	e791                	bnez	a5,3006522 <DBG_PrintHex+0x1c>
        DBG_PrintCh('0');
 3006518:	03000513          	li	a0,48
 300651c:	335d                	jal	ra,30062c2 <DBG_PrintCh>
        return 1;
 300651e:	4785                	li	a5,1
 3006520:	a005                	j	3006540 <DBG_PrintHex+0x3a>
    }
    cnt = DBG_CountDigits(hexNum, HEXADECIMAL);
 3006522:	fdc42783          	lw	a5,-36(s0)
 3006526:	45c1                	li	a1,16
 3006528:	853e                	mv	a0,a5
 300652a:	3595                	jal	ra,300638e <DBG_CountDigits>
 300652c:	fea42623          	sw	a0,-20(s0)
    DBG_PutUnsignedNum(hexNum, HEXADECIMAL, cnt);
 3006530:	fec42603          	lw	a2,-20(s0)
 3006534:	45c1                	li	a1,16
 3006536:	fdc42503          	lw	a0,-36(s0)
 300653a:	3d75                	jal	ra,30063f6 <DBG_PutUnsignedNum>
    return cnt;
 300653c:	fec42783          	lw	a5,-20(s0)
}
 3006540:	853e                	mv	a0,a5
 3006542:	50b2                	lw	ra,44(sp)
 3006544:	5422                	lw	s0,40(sp)
 3006546:	6145                	addi	sp,sp,48
 3006548:	8082                	ret

0300654a <DBG_PrintFlt>:
 * @brief   Print floating-point number through UART port.
 * @param   fltNum The floating-point number to be printed.
 * @retval  unsigned int The total number of characters printed.
 */
static unsigned int DBG_PrintFlt(float fltNum, unsigned int precision)
{
 300654a:	7139                	addi	sp,sp,-64
 300654c:	de06                	sw	ra,60(sp)
 300654e:	dc22                	sw	s0,56(sp)
 3006550:	0080                	addi	s0,sp,64
 3006552:	fca42627          	fsw	fa0,-52(s0)
 3006556:	fca42423          	sw	a0,-56(s0)
    unsigned int cnt = 0;
 300655a:	fe042623          	sw	zero,-20(s0)
    unsigned int floatScale;

    if (fltNum < 0) {
 300655e:	fcc42787          	flw	fa5,-52(s0)
 3006562:	f0000753          	fmv.w.x	fa4,zero
 3006566:	a0e797d3          	flt.s	a5,fa5,fa4
 300656a:	cf99                	beqz	a5,3006588 <DBG_PrintFlt+0x3e>
        DBG_PrintCh('-');
 300656c:	02d00513          	li	a0,45
 3006570:	3b89                	jal	ra,30062c2 <DBG_PrintCh>
        cnt += 1;
 3006572:	fec42783          	lw	a5,-20(s0)
 3006576:	0785                	addi	a5,a5,1
 3006578:	fef42623          	sw	a5,-20(s0)
        fltNum = -fltNum;
 300657c:	fcc42787          	flw	fa5,-52(s0)
 3006580:	20f797d3          	fneg.s	fa5,fa5
 3006584:	fcf42627          	fsw	fa5,-52(s0)
    }
    int integerVal = (int)fltNum;
 3006588:	fcc42787          	flw	fa5,-52(s0)
 300658c:	c00797d3          	fcvt.w.s	a5,fa5,rtz
 3006590:	fef42023          	sw	a5,-32(s0)
    floatScale = DBG_Pow(10, (precision + 1)); /* 10: decimal */
 3006594:	fc842783          	lw	a5,-56(s0)
 3006598:	0785                	addi	a5,a5,1
 300659a:	85be                	mv	a1,a5
 300659c:	4529                	li	a0,10
 300659e:	3b45                	jal	ra,300634e <DBG_Pow>
 30065a0:	fca42e23          	sw	a0,-36(s0)
    int floatVal = (long)(floatScale * (fltNum - integerVal));
 30065a4:	fdc42783          	lw	a5,-36(s0)
 30065a8:	d017f753          	fcvt.s.wu	fa4,a5
 30065ac:	fe042783          	lw	a5,-32(s0)
 30065b0:	d007f7d3          	fcvt.s.w	fa5,a5
 30065b4:	fcc42687          	flw	fa3,-52(s0)
 30065b8:	08f6f7d3          	fsub.s	fa5,fa3,fa5
 30065bc:	10f777d3          	fmul.s	fa5,fa4,fa5
 30065c0:	c00797d3          	fcvt.w.s	a5,fa5,rtz
 30065c4:	fef42423          	sw	a5,-24(s0)
    /* Half-adjust: round up or round down */
    if (floatVal % DECIMAL_BASE >= HALF_ADJUST_BOUNDARY) {
 30065c8:	fe842703          	lw	a4,-24(s0)
 30065cc:	47a9                	li	a5,10
 30065ce:	02f77733          	remu	a4,a4,a5
 30065d2:	4791                	li	a5,4
 30065d4:	00e7fb63          	bgeu	a5,a4,30065ea <DBG_PrintFlt+0xa0>
        floatVal = floatVal / DECIMAL_BASE + 1;
 30065d8:	fe842703          	lw	a4,-24(s0)
 30065dc:	47a9                	li	a5,10
 30065de:	02f757b3          	divu	a5,a4,a5
 30065e2:	0785                	addi	a5,a5,1
 30065e4:	fef42423          	sw	a5,-24(s0)
 30065e8:	a801                	j	30065f8 <DBG_PrintFlt+0xae>
    } else {
        floatVal = floatVal / DECIMAL_BASE;
 30065ea:	fe842703          	lw	a4,-24(s0)
 30065ee:	47a9                	li	a5,10
 30065f0:	02f757b3          	divu	a5,a4,a5
 30065f4:	fef42423          	sw	a5,-24(s0)
    }
    cnt += DBG_PrintInt(integerVal);
 30065f8:	fe042503          	lw	a0,-32(s0)
 30065fc:	3575                	jal	ra,30064a8 <DBG_PrintInt>
 30065fe:	872a                	mv	a4,a0
 3006600:	fec42783          	lw	a5,-20(s0)
 3006604:	97ba                	add	a5,a5,a4
 3006606:	fef42623          	sw	a5,-20(s0)
    DBG_PrintCh('.');
 300660a:	02e00513          	li	a0,46
 300660e:	3955                	jal	ra,30062c2 <DBG_PrintCh>
    cnt += 1;
 3006610:	fec42783          	lw	a5,-20(s0)
 3006614:	0785                	addi	a5,a5,1
 3006616:	fef42623          	sw	a5,-20(s0)
    /* Pad 0 in float part */
    unsigned int fltCnt = DBG_CountDigits(floatVal, DECIMAL);
 300661a:	45a9                	li	a1,10
 300661c:	fe842503          	lw	a0,-24(s0)
 3006620:	33bd                	jal	ra,300638e <DBG_CountDigits>
 3006622:	fca42c23          	sw	a0,-40(s0)
    if (precision > fltCnt) {
 3006626:	fc842703          	lw	a4,-56(s0)
 300662a:	fd842783          	lw	a5,-40(s0)
 300662e:	02e7f763          	bgeu	a5,a4,300665c <DBG_PrintFlt+0x112>
        for (unsigned int i = 0; i < precision - fltCnt; i++) {
 3006632:	fe042223          	sw	zero,-28(s0)
 3006636:	a809                	j	3006648 <DBG_PrintFlt+0xfe>
            DBG_PrintCh('0'); /* add '0' */
 3006638:	03000513          	li	a0,48
 300663c:	3159                	jal	ra,30062c2 <DBG_PrintCh>
        for (unsigned int i = 0; i < precision - fltCnt; i++) {
 300663e:	fe442783          	lw	a5,-28(s0)
 3006642:	0785                	addi	a5,a5,1
 3006644:	fef42223          	sw	a5,-28(s0)
 3006648:	fc842703          	lw	a4,-56(s0)
 300664c:	fd842783          	lw	a5,-40(s0)
 3006650:	40f707b3          	sub	a5,a4,a5
 3006654:	fe442703          	lw	a4,-28(s0)
 3006658:	fef760e3          	bltu	a4,a5,3006638 <DBG_PrintFlt+0xee>
        }
    }
    DBG_PutUnsignedNum(floatVal, DECIMAL, fltCnt); /* print unsigned number */
 300665c:	fe842783          	lw	a5,-24(s0)
 3006660:	fd842603          	lw	a2,-40(s0)
 3006664:	45a9                	li	a1,10
 3006666:	853e                	mv	a0,a5
 3006668:	3379                	jal	ra,30063f6 <DBG_PutUnsignedNum>
    cnt += precision;
 300666a:	fec42703          	lw	a4,-20(s0)
 300666e:	fc842783          	lw	a5,-56(s0)
 3006672:	97ba                	add	a5,a5,a4
 3006674:	fef42623          	sw	a5,-20(s0)
    return cnt;
 3006678:	fec42783          	lw	a5,-20(s0)
}
 300667c:	853e                	mv	a0,a5
 300667e:	50f2                	lw	ra,60(sp)
 3006680:	5462                	lw	s0,56(sp)
 3006682:	6121                	addi	sp,sp,64
 3006684:	8082                	ret

03006686 <ParseSpecifier>:
 * @param   ch The format specifier.
 * @param   paramList The pointer of the variable parameter list.
 * @retval  unsigned int The total number of characters printed.
 */
static unsigned int ParseSpecifier(const char ch, va_list *paramList)
{
 3006686:	7139                	addi	sp,sp,-64
 3006688:	de06                	sw	ra,60(sp)
 300668a:	dc22                	sw	s0,56(sp)
 300668c:	0080                	addi	s0,sp,64
 300668e:	87aa                	mv	a5,a0
 3006690:	fcb42423          	sw	a1,-56(s0)
 3006694:	fcf407a3          	sb	a5,-49(s0)
    unsigned int cnt = 0;
 3006698:	fe042623          	sw	zero,-20(s0)
    unsigned int tmpCnt;
    char chVal = 0;
 300669c:	fe0405a3          	sb	zero,-21(s0)
    const char *strVal = NULL;
 30066a0:	fe042223          	sw	zero,-28(s0)
    int intVal = 0;
 30066a4:	fe042023          	sw	zero,-32(s0)
    unsigned int unsignedVal = 0;
 30066a8:	fc042e23          	sw	zero,-36(s0)
    unsigned int hexVal = 0;
 30066ac:	fc042c23          	sw	zero,-40(s0)
    float fltVal = 0;
 30066b0:	fc042a23          	sw	zero,-44(s0)
    switch (ch) {
 30066b4:	fcf40783          	lb	a5,-49(s0)
 30066b8:	fa878793          	addi	a5,a5,-88
 30066bc:	02000713          	li	a4,32
 30066c0:	14f76063          	bltu	a4,a5,3006800 <ParseSpecifier+0x17a>
 30066c4:	00279713          	slli	a4,a5,0x2
 30066c8:	030117b7          	lui	a5,0x3011
 30066cc:	8b078793          	addi	a5,a5,-1872 # 30108b0 <g_crgIpMatch+0x3a0>
 30066d0:	97ba                	add	a5,a5,a4
 30066d2:	439c                	lw	a5,0(a5)
 30066d4:	8782                	jr	a5
        case 'c': /* Character format data. */
            chVal = VA_ARG(*paramList, int); /* Use type int because of byte alignment */
 30066d6:	fc842783          	lw	a5,-56(s0)
 30066da:	439c                	lw	a5,0(a5)
 30066dc:	00478693          	addi	a3,a5,4
 30066e0:	fc842703          	lw	a4,-56(s0)
 30066e4:	c314                	sw	a3,0(a4)
 30066e6:	439c                	lw	a5,0(a5)
 30066e8:	fef405a3          	sb	a5,-21(s0)
            DBG_PrintCh(chVal);
 30066ec:	feb40783          	lb	a5,-21(s0)
 30066f0:	853e                	mv	a0,a5
 30066f2:	3ec1                	jal	ra,30062c2 <DBG_PrintCh>
            cnt += 1;
 30066f4:	fec42783          	lw	a5,-20(s0)
 30066f8:	0785                	addi	a5,a5,1
 30066fa:	fef42623          	sw	a5,-20(s0)
            break;
 30066fe:	aa19                	j	3006814 <ParseSpecifier+0x18e>
        case 's': /* String format data. */
            strVal = VA_ARG(*paramList, const char *);
 3006700:	fc842783          	lw	a5,-56(s0)
 3006704:	439c                	lw	a5,0(a5)
 3006706:	00478693          	addi	a3,a5,4
 300670a:	fc842703          	lw	a4,-56(s0)
 300670e:	c314                	sw	a3,0(a4)
 3006710:	439c                	lw	a5,0(a5)
 3006712:	fef42223          	sw	a5,-28(s0)
            cnt += DBG_PrintStr(strVal);
 3006716:	fe442503          	lw	a0,-28(s0)
 300671a:	36ed                	jal	ra,3006304 <DBG_PrintStr>
 300671c:	87aa                	mv	a5,a0
 300671e:	873e                	mv	a4,a5
 3006720:	fec42783          	lw	a5,-20(s0)
 3006724:	97ba                	add	a5,a5,a4
 3006726:	fef42623          	sw	a5,-20(s0)
            break;
 300672a:	a0ed                	j	3006814 <ParseSpecifier+0x18e>
        case 'd': /* Integer decimal data. */
            intVal = VA_ARG(*paramList, int);
 300672c:	fc842783          	lw	a5,-56(s0)
 3006730:	439c                	lw	a5,0(a5)
 3006732:	00478693          	addi	a3,a5,4
 3006736:	fc842703          	lw	a4,-56(s0)
 300673a:	c314                	sw	a3,0(a4)
 300673c:	439c                	lw	a5,0(a5)
 300673e:	fef42023          	sw	a5,-32(s0)
            cnt += DBG_PrintInt(intVal);
 3006742:	fe042503          	lw	a0,-32(s0)
 3006746:	338d                	jal	ra,30064a8 <DBG_PrintInt>
 3006748:	872a                	mv	a4,a0
 300674a:	fec42783          	lw	a5,-20(s0)
 300674e:	97ba                	add	a5,a5,a4
 3006750:	fef42623          	sw	a5,-20(s0)
            break;
 3006754:	a0c1                	j	3006814 <ParseSpecifier+0x18e>
        case 'u': /* Unsigned decimal data. */
            unsignedVal = VA_ARG(*paramList, unsigned int);
 3006756:	fc842783          	lw	a5,-56(s0)
 300675a:	439c                	lw	a5,0(a5)
 300675c:	00478693          	addi	a3,a5,4
 3006760:	fc842703          	lw	a4,-56(s0)
 3006764:	c314                	sw	a3,0(a4)
 3006766:	439c                	lw	a5,0(a5)
 3006768:	fcf42e23          	sw	a5,-36(s0)
            tmpCnt = DBG_CountDigits(unsignedVal, DECIMAL);
 300676c:	fdc42783          	lw	a5,-36(s0)
 3006770:	45a9                	li	a1,10
 3006772:	853e                	mv	a0,a5
 3006774:	3929                	jal	ra,300638e <DBG_CountDigits>
 3006776:	fca42823          	sw	a0,-48(s0)
            DBG_PutUnsignedNum(unsignedVal, DECIMAL, tmpCnt);
 300677a:	fd042603          	lw	a2,-48(s0)
 300677e:	45a9                	li	a1,10
 3006780:	fdc42503          	lw	a0,-36(s0)
 3006784:	398d                	jal	ra,30063f6 <DBG_PutUnsignedNum>
            cnt += tmpCnt;
 3006786:	fec42703          	lw	a4,-20(s0)
 300678a:	fd042783          	lw	a5,-48(s0)
 300678e:	97ba                	add	a5,a5,a4
 3006790:	fef42623          	sw	a5,-20(s0)
            break;
 3006794:	a041                	j	3006814 <ParseSpecifier+0x18e>
        case 'x': /* Hexadecimal data. */
        case 'X':
        case 'p': /* Address data. */
            hexVal = VA_ARG(*paramList, unsigned int);
 3006796:	fc842783          	lw	a5,-56(s0)
 300679a:	439c                	lw	a5,0(a5)
 300679c:	00478693          	addi	a3,a5,4
 30067a0:	fc842703          	lw	a4,-56(s0)
 30067a4:	c314                	sw	a3,0(a4)
 30067a6:	439c                	lw	a5,0(a5)
 30067a8:	fcf42c23          	sw	a5,-40(s0)
            cnt += DBG_PrintHex(hexVal);
 30067ac:	fd842503          	lw	a0,-40(s0)
 30067b0:	3b99                	jal	ra,3006506 <DBG_PrintHex>
 30067b2:	872a                	mv	a4,a0
 30067b4:	fec42783          	lw	a5,-20(s0)
 30067b8:	97ba                	add	a5,a5,a4
 30067ba:	fef42623          	sw	a5,-20(s0)
            break;
 30067be:	a899                	j	3006814 <ParseSpecifier+0x18e>
        case 'f': /* Floating-point data. */
            fltVal = VA_ARG(*paramList, double);
 30067c0:	fc842783          	lw	a5,-56(s0)
 30067c4:	439c                	lw	a5,0(a5)
 30067c6:	079d                	addi	a5,a5,7
 30067c8:	9be1                	andi	a5,a5,-8
 30067ca:	00878693          	addi	a3,a5,8
 30067ce:	fc842703          	lw	a4,-56(s0)
 30067d2:	c314                	sw	a3,0(a4)
 30067d4:	0047a803          	lw	a6,4(a5)
 30067d8:	439c                	lw	a5,0(a5)
 30067da:	853e                	mv	a0,a5
 30067dc:	85c2                	mv	a1,a6
 30067de:	1a1090ef          	jal	ra,301017e <__truncdfsf2>
 30067e2:	20a507d3          	fmv.s	fa5,fa0
 30067e6:	fcf42a27          	fsw	fa5,-44(s0)
            cnt += DBG_PrintFlt(fltVal, 5); /* default precision: 5 */
 30067ea:	4515                	li	a0,5
 30067ec:	fd442507          	flw	fa0,-44(s0)
 30067f0:	3ba9                	jal	ra,300654a <DBG_PrintFlt>
 30067f2:	872a                	mv	a4,a0
 30067f4:	fec42783          	lw	a5,-20(s0)
 30067f8:	97ba                	add	a5,a5,a4
 30067fa:	fef42623          	sw	a5,-20(s0)
            break;
 30067fe:	a819                	j	3006814 <ParseSpecifier+0x18e>
        default:
            DBG_PrintCh(ch);
 3006800:	fcf40783          	lb	a5,-49(s0)
 3006804:	853e                	mv	a0,a5
 3006806:	3c75                	jal	ra,30062c2 <DBG_PrintCh>
            cnt += 1;
 3006808:	fec42783          	lw	a5,-20(s0)
 300680c:	0785                	addi	a5,a5,1
 300680e:	fef42623          	sw	a5,-20(s0)
            break;
 3006812:	0001                	nop
    }
    return cnt;
 3006814:	fec42783          	lw	a5,-20(s0)
}
 3006818:	853e                	mv	a0,a5
 300681a:	50f2                	lw	ra,60(sp)
 300681c:	5462                	lw	s0,56(sp)
 300681e:	6121                	addi	sp,sp,64
 3006820:	8082                	ret

03006822 <DBG_PrintIntWithField>:
 * @param   intNum The decimal number to be printed.
 * @param   fieldWidth Field width.
 * @retval  unsigned int The total number of characters printed.
 */
static unsigned int DBG_PrintIntWithField(int intNum, int fieldWidth)
{
 3006822:	7139                	addi	sp,sp,-64
 3006824:	de06                	sw	ra,60(sp)
 3006826:	dc22                	sw	s0,56(sp)
 3006828:	0080                	addi	s0,sp,64
 300682a:	fca42623          	sw	a0,-52(s0)
 300682e:	fcb42423          	sw	a1,-56(s0)
    int zeroCnt = 0;
 3006832:	fc042e23          	sw	zero,-36(s0)
    int digitsCnt = 0;
 3006836:	fe042623          	sw	zero,-20(s0)
    unsigned int cnt = 0;
 300683a:	fe042423          	sw	zero,-24(s0)

    if (intNum == 0) {
 300683e:	fcc42783          	lw	a5,-52(s0)
 3006842:	e791                	bnez	a5,300684e <DBG_PrintIntWithField+0x2c>
        DBG_PrintCh('0');
 3006844:	03000513          	li	a0,48
 3006848:	3cad                	jal	ra,30062c2 <DBG_PrintCh>
        return 1;
 300684a:	4785                	li	a5,1
 300684c:	a0dd                	j	3006932 <DBG_PrintIntWithField+0x110>
    }
    if (intNum < 0) {
 300684e:	fcc42783          	lw	a5,-52(s0)
 3006852:	0607dd63          	bgez	a5,30068cc <DBG_PrintIntWithField+0xaa>
        DBG_PrintCh('-'); /* add symbol */
 3006856:	02d00513          	li	a0,45
 300685a:	34a5                	jal	ra,30062c2 <DBG_PrintCh>
        cnt++;
 300685c:	fe842783          	lw	a5,-24(s0)
 3006860:	0785                	addi	a5,a5,1
 3006862:	fef42423          	sw	a5,-24(s0)
        intNum = -intNum;
 3006866:	fcc42783          	lw	a5,-52(s0)
 300686a:	40f007b3          	neg	a5,a5
 300686e:	fcf42623          	sw	a5,-52(s0)
        digitsCnt = DBG_CountDigits(intNum, DECIMAL); /* get int value's width */
 3006872:	45a9                	li	a1,10
 3006874:	fcc42503          	lw	a0,-52(s0)
 3006878:	3e19                	jal	ra,300638e <DBG_CountDigits>
 300687a:	87aa                	mv	a5,a0
 300687c:	fef42623          	sw	a5,-20(s0)
        zeroCnt = fieldWidth - digitsCnt;
 3006880:	fc842703          	lw	a4,-56(s0)
 3006884:	fec42783          	lw	a5,-20(s0)
 3006888:	40f707b3          	sub	a5,a4,a5
 300688c:	fcf42e23          	sw	a5,-36(s0)
        for (int i = 0; i < zeroCnt; i++) {
 3006890:	fe042223          	sw	zero,-28(s0)
 3006894:	a831                	j	30068b0 <DBG_PrintIntWithField+0x8e>
            DBG_PrintCh('0'); /* add '0' */
 3006896:	03000513          	li	a0,48
 300689a:	3425                	jal	ra,30062c2 <DBG_PrintCh>
            cnt++;
 300689c:	fe842783          	lw	a5,-24(s0)
 30068a0:	0785                	addi	a5,a5,1
 30068a2:	fef42423          	sw	a5,-24(s0)
        for (int i = 0; i < zeroCnt; i++) {
 30068a6:	fe442783          	lw	a5,-28(s0)
 30068aa:	0785                	addi	a5,a5,1
 30068ac:	fef42223          	sw	a5,-28(s0)
 30068b0:	fe442703          	lw	a4,-28(s0)
 30068b4:	fdc42783          	lw	a5,-36(s0)
 30068b8:	fcf74fe3          	blt	a4,a5,3006896 <DBG_PrintIntWithField+0x74>
        }
        cnt += digitsCnt;
 30068bc:	fec42783          	lw	a5,-20(s0)
 30068c0:	fe842703          	lw	a4,-24(s0)
 30068c4:	97ba                	add	a5,a5,a4
 30068c6:	fef42423          	sw	a5,-24(s0)
 30068ca:	a891                	j	300691e <DBG_PrintIntWithField+0xfc>
    } else {
        digitsCnt = DBG_CountDigits(intNum, DECIMAL); /* get int value's width */
 30068cc:	45a9                	li	a1,10
 30068ce:	fcc42503          	lw	a0,-52(s0)
 30068d2:	3c75                	jal	ra,300638e <DBG_CountDigits>
 30068d4:	87aa                	mv	a5,a0
 30068d6:	fef42623          	sw	a5,-20(s0)
        cnt = digitsCnt;
 30068da:	fec42783          	lw	a5,-20(s0)
 30068de:	fef42423          	sw	a5,-24(s0)
        zeroCnt = fieldWidth - digitsCnt;
 30068e2:	fc842703          	lw	a4,-56(s0)
 30068e6:	fec42783          	lw	a5,-20(s0)
 30068ea:	40f707b3          	sub	a5,a4,a5
 30068ee:	fcf42e23          	sw	a5,-36(s0)
        for (int i = 0; i < zeroCnt; i++) {
 30068f2:	fe042023          	sw	zero,-32(s0)
 30068f6:	a831                	j	3006912 <DBG_PrintIntWithField+0xf0>
            DBG_PrintCh('0'); /* add '0' */
 30068f8:	03000513          	li	a0,48
 30068fc:	32d9                	jal	ra,30062c2 <DBG_PrintCh>
            cnt++;
 30068fe:	fe842783          	lw	a5,-24(s0)
 3006902:	0785                	addi	a5,a5,1
 3006904:	fef42423          	sw	a5,-24(s0)
        for (int i = 0; i < zeroCnt; i++) {
 3006908:	fe042783          	lw	a5,-32(s0)
 300690c:	0785                	addi	a5,a5,1
 300690e:	fef42023          	sw	a5,-32(s0)
 3006912:	fe042703          	lw	a4,-32(s0)
 3006916:	fdc42783          	lw	a5,-36(s0)
 300691a:	fcf74fe3          	blt	a4,a5,30068f8 <DBG_PrintIntWithField+0xd6>
        }
    }
    DBG_PutUnsignedNum(intNum, DECIMAL, digitsCnt);
 300691e:	fcc42783          	lw	a5,-52(s0)
 3006922:	fec42703          	lw	a4,-20(s0)
 3006926:	863a                	mv	a2,a4
 3006928:	45a9                	li	a1,10
 300692a:	853e                	mv	a0,a5
 300692c:	34e9                	jal	ra,30063f6 <DBG_PutUnsignedNum>
    return cnt;
 300692e:	fe842783          	lw	a5,-24(s0)
}
 3006932:	853e                	mv	a0,a5
 3006934:	50f2                	lw	ra,60(sp)
 3006936:	5462                	lw	s0,56(sp)
 3006938:	6121                	addi	sp,sp,64
 300693a:	8082                	ret

0300693c <DBG_Atoi>:

static int DBG_Atoi(const char **s)
{
 300693c:	7179                	addi	sp,sp,-48
 300693e:	d622                	sw	s0,44(sp)
 3006940:	1800                	addi	s0,sp,48
 3006942:	fca42e23          	sw	a0,-36(s0)
    int i, c;

    for (i = 0; '0' <= (c = **s) && c <= '9'; ++*s) {
 3006946:	fe042623          	sw	zero,-20(s0)
 300694a:	a02d                	j	3006974 <DBG_Atoi+0x38>
        i = i * 10  + c - '0'; /* 10: decimal */
 300694c:	fec42703          	lw	a4,-20(s0)
 3006950:	47a9                	li	a5,10
 3006952:	02f70733          	mul	a4,a4,a5
 3006956:	fe842783          	lw	a5,-24(s0)
 300695a:	97ba                	add	a5,a5,a4
 300695c:	fd078793          	addi	a5,a5,-48
 3006960:	fef42623          	sw	a5,-20(s0)
    for (i = 0; '0' <= (c = **s) && c <= '9'; ++*s) {
 3006964:	fdc42783          	lw	a5,-36(s0)
 3006968:	439c                	lw	a5,0(a5)
 300696a:	00178713          	addi	a4,a5,1
 300696e:	fdc42783          	lw	a5,-36(s0)
 3006972:	c398                	sw	a4,0(a5)
 3006974:	fdc42783          	lw	a5,-36(s0)
 3006978:	439c                	lw	a5,0(a5)
 300697a:	00078783          	lb	a5,0(a5)
 300697e:	fef42423          	sw	a5,-24(s0)
 3006982:	fe842703          	lw	a4,-24(s0)
 3006986:	02f00793          	li	a5,47
 300698a:	00e7d863          	bge	a5,a4,300699a <DBG_Atoi+0x5e>
 300698e:	fe842703          	lw	a4,-24(s0)
 3006992:	03900793          	li	a5,57
 3006996:	fae7dbe3          	bge	a5,a4,300694c <DBG_Atoi+0x10>
    }
    return i;
 300699a:	fec42783          	lw	a5,-20(s0)
}
 300699e:	853e                	mv	a0,a5
 30069a0:	5432                	lw	s0,44(sp)
 30069a2:	6145                	addi	sp,sp,48
 30069a4:	8082                	ret

030069a6 <DBG_UartPrintf>:
 * @param   ...     Variable parameter list.
 * @retval  int     If succeeded, the total number of characters printed is returned.
 *                  If the input parameter is wrong, return BASE_STATUS_ERROR.
 */
int DBG_UartPrintf(const char *format, ...)
{
 30069a6:	711d                	addi	sp,sp,-96
 30069a8:	de06                	sw	ra,60(sp)
 30069aa:	dc22                	sw	s0,56(sp)
 30069ac:	0080                	addi	s0,sp,64
 30069ae:	fca42623          	sw	a0,-52(s0)
 30069b2:	c04c                	sw	a1,4(s0)
 30069b4:	c410                	sw	a2,8(s0)
 30069b6:	c454                	sw	a3,12(s0)
 30069b8:	c818                	sw	a4,16(s0)
 30069ba:	c85c                	sw	a5,20(s0)
 30069bc:	01042c23          	sw	a6,24(s0)
 30069c0:	01142e23          	sw	a7,28(s0)
    DEBUG_ASSERT_PARAM(format != NULL);
    int cnt = 0;
 30069c4:	fe042623          	sw	zero,-20(s0)
    int fieldWidth = 0;
 30069c8:	fe042423          	sw	zero,-24(s0)
    int floatPrecision = 0;
 30069cc:	fe042223          	sw	zero,-28(s0)
    float fltVal = 0;
 30069d0:	fe042023          	sw	zero,-32(s0)
    int intVal = 0;
 30069d4:	fc042e23          	sw	zero,-36(s0)
    va_list paramList;
    VA_START(paramList, format);
 30069d8:	02040793          	addi	a5,s0,32
 30069dc:	1791                	addi	a5,a5,-28
 30069de:	fcf42c23          	sw	a5,-40(s0)

    while (*format != '\0') {
 30069e2:	aa09                	j	3006af4 <DBG_UartPrintf+0x14e>
        if (*format != '%') {
 30069e4:	fcc42783          	lw	a5,-52(s0)
 30069e8:	00078703          	lb	a4,0(a5)
 30069ec:	02500793          	li	a5,37
 30069f0:	00f70e63          	beq	a4,a5,3006a0c <DBG_UartPrintf+0x66>
            DBG_PrintCh(*format);
 30069f4:	fcc42783          	lw	a5,-52(s0)
 30069f8:	00078783          	lb	a5,0(a5)
 30069fc:	853e                	mv	a0,a5
 30069fe:	30d1                	jal	ra,30062c2 <DBG_PrintCh>
            cnt += 1;
 3006a00:	fec42783          	lw	a5,-20(s0)
 3006a04:	0785                	addi	a5,a5,1
 3006a06:	fef42623          	sw	a5,-20(s0)
 3006a0a:	a0c5                	j	3006aea <DBG_UartPrintf+0x144>
        } else {
            format++;
 3006a0c:	fcc42783          	lw	a5,-52(s0)
 3006a10:	0785                	addi	a5,a5,1
 3006a12:	fcf42623          	sw	a5,-52(s0)
            if (*format == '0') {
 3006a16:	fcc42783          	lw	a5,-52(s0)
 3006a1a:	00078703          	lb	a4,0(a5)
 3006a1e:	03000793          	li	a5,48
 3006a22:	04f71263          	bne	a4,a5,3006a66 <DBG_UartPrintf+0xc0>
                format++;
 3006a26:	fcc42783          	lw	a5,-52(s0)
 3006a2a:	0785                	addi	a5,a5,1
 3006a2c:	fcf42623          	sw	a5,-52(s0)
                fieldWidth = DBG_Atoi(&format);
 3006a30:	fcc40793          	addi	a5,s0,-52
 3006a34:	853e                	mv	a0,a5
 3006a36:	3719                	jal	ra,300693c <DBG_Atoi>
 3006a38:	fea42423          	sw	a0,-24(s0)
                intVal = VA_ARG(paramList, int);
 3006a3c:	fd842783          	lw	a5,-40(s0)
 3006a40:	00478713          	addi	a4,a5,4
 3006a44:	fce42c23          	sw	a4,-40(s0)
 3006a48:	439c                	lw	a5,0(a5)
 3006a4a:	fcf42e23          	sw	a5,-36(s0)
                cnt += DBG_PrintIntWithField(intVal, fieldWidth);
 3006a4e:	fe842583          	lw	a1,-24(s0)
 3006a52:	fdc42503          	lw	a0,-36(s0)
 3006a56:	33f1                	jal	ra,3006822 <DBG_PrintIntWithField>
 3006a58:	872a                	mv	a4,a0
 3006a5a:	fec42783          	lw	a5,-20(s0)
 3006a5e:	97ba                	add	a5,a5,a4
 3006a60:	fef42623          	sw	a5,-20(s0)
 3006a64:	a059                	j	3006aea <DBG_UartPrintf+0x144>
            } else if (*format == '.') {
 3006a66:	fcc42783          	lw	a5,-52(s0)
 3006a6a:	00078703          	lb	a4,0(a5)
 3006a6e:	02e00793          	li	a5,46
 3006a72:	04f71d63          	bne	a4,a5,3006acc <DBG_UartPrintf+0x126>
                format++;
 3006a76:	fcc42783          	lw	a5,-52(s0)
 3006a7a:	0785                	addi	a5,a5,1
 3006a7c:	fcf42623          	sw	a5,-52(s0)
                floatPrecision = DBG_Atoi(&format);
 3006a80:	fcc40793          	addi	a5,s0,-52
 3006a84:	853e                	mv	a0,a5
 3006a86:	3d5d                	jal	ra,300693c <DBG_Atoi>
 3006a88:	fea42223          	sw	a0,-28(s0)
                fltVal = VA_ARG(paramList, double);
 3006a8c:	fd842783          	lw	a5,-40(s0)
 3006a90:	079d                	addi	a5,a5,7
 3006a92:	9be1                	andi	a5,a5,-8
 3006a94:	00878713          	addi	a4,a5,8
 3006a98:	fce42c23          	sw	a4,-40(s0)
 3006a9c:	0047a803          	lw	a6,4(a5)
 3006aa0:	439c                	lw	a5,0(a5)
 3006aa2:	853e                	mv	a0,a5
 3006aa4:	85c2                	mv	a1,a6
 3006aa6:	6d8090ef          	jal	ra,301017e <__truncdfsf2>
 3006aaa:	20a507d3          	fmv.s	fa5,fa0
 3006aae:	fef42027          	fsw	fa5,-32(s0)
                cnt += DBG_PrintFlt(fltVal, floatPrecision);
 3006ab2:	fe442783          	lw	a5,-28(s0)
 3006ab6:	853e                	mv	a0,a5
 3006ab8:	fe042507          	flw	fa0,-32(s0)
 3006abc:	3479                	jal	ra,300654a <DBG_PrintFlt>
 3006abe:	872a                	mv	a4,a0
 3006ac0:	fec42783          	lw	a5,-20(s0)
 3006ac4:	97ba                	add	a5,a5,a4
 3006ac6:	fef42623          	sw	a5,-20(s0)
 3006aca:	a005                	j	3006aea <DBG_UartPrintf+0x144>
            } else {
                cnt += ParseSpecifier(*format, &paramList);
 3006acc:	fcc42783          	lw	a5,-52(s0)
 3006ad0:	00078783          	lb	a5,0(a5)
 3006ad4:	fd840713          	addi	a4,s0,-40
 3006ad8:	85ba                	mv	a1,a4
 3006ada:	853e                	mv	a0,a5
 3006adc:	366d                	jal	ra,3006686 <ParseSpecifier>
 3006ade:	872a                	mv	a4,a0
 3006ae0:	fec42783          	lw	a5,-20(s0)
 3006ae4:	97ba                	add	a5,a5,a4
 3006ae6:	fef42623          	sw	a5,-20(s0)
            }
        }
        format++;
 3006aea:	fcc42783          	lw	a5,-52(s0)
 3006aee:	0785                	addi	a5,a5,1
 3006af0:	fcf42623          	sw	a5,-52(s0)
    while (*format != '\0') {
 3006af4:	fcc42783          	lw	a5,-52(s0)
 3006af8:	00078783          	lb	a5,0(a5)
 3006afc:	ee0794e3          	bnez	a5,30069e4 <DBG_UartPrintf+0x3e>
    }
    VA_END(paramList);
    return cnt;
 3006b00:	fec42783          	lw	a5,-20(s0)
}
 3006b04:	853e                	mv	a0,a5
 3006b06:	50f2                	lw	ra,60(sp)
 3006b08:	5462                	lw	s0,56(sp)
 3006b0a:	6125                	addi	sp,sp,96
 3006b0c:	8082                	ret

03006b0e <IsGpioValue>:
  * @brief Check gpio value parameter.
  * @param value Value of @ref GPIO_Value
  * @retval Bool.
  */
static inline bool IsGpioValue(GPIO_Value value)
{
 3006b0e:	1101                	addi	sp,sp,-32
 3006b10:	ce22                	sw	s0,28(sp)
 3006b12:	1000                	addi	s0,sp,32
 3006b14:	fea42623          	sw	a0,-20(s0)
    return (value == GPIO_LOW_LEVEL || value == GPIO_HIGH_LEVEL);
 3006b18:	fec42783          	lw	a5,-20(s0)
 3006b1c:	c791                	beqz	a5,3006b28 <IsGpioValue+0x1a>
 3006b1e:	fec42703          	lw	a4,-20(s0)
 3006b22:	4785                	li	a5,1
 3006b24:	00f71463          	bne	a4,a5,3006b2c <IsGpioValue+0x1e>
 3006b28:	4785                	li	a5,1
 3006b2a:	a011                	j	3006b2e <IsGpioValue+0x20>
 3006b2c:	4781                	li	a5,0
 3006b2e:	8b85                	andi	a5,a5,1
 3006b30:	9f81                	uxtb	a5
}
 3006b32:	853e                	mv	a0,a5
 3006b34:	4472                	lw	s0,28(sp)
 3006b36:	6105                	addi	sp,sp,32
 3006b38:	8082                	ret

03006b3a <IsGpioDirection>:
  * @brief Check gpio direction parameter.
  * @param dir Value of @ref GPIO_Direction.
  * @retval Bool.
  */
static inline bool IsGpioDirection(GPIO_Direction dir)
{
 3006b3a:	1101                	addi	sp,sp,-32
 3006b3c:	ce22                	sw	s0,28(sp)
 3006b3e:	1000                	addi	s0,sp,32
 3006b40:	fea42623          	sw	a0,-20(s0)
    return (dir == GPIO_INPUT_MODE || dir == GPIO_OUTPUT_MODE);
 3006b44:	fec42783          	lw	a5,-20(s0)
 3006b48:	c791                	beqz	a5,3006b54 <IsGpioDirection+0x1a>
 3006b4a:	fec42703          	lw	a4,-20(s0)
 3006b4e:	4785                	li	a5,1
 3006b50:	00f71463          	bne	a4,a5,3006b58 <IsGpioDirection+0x1e>
 3006b54:	4785                	li	a5,1
 3006b56:	a011                	j	3006b5a <IsGpioDirection+0x20>
 3006b58:	4781                	li	a5,0
 3006b5a:	8b85                	andi	a5,a5,1
 3006b5c:	9f81                	uxtb	a5
}
 3006b5e:	853e                	mv	a0,a5
 3006b60:	4472                	lw	s0,28(sp)
 3006b62:	6105                	addi	sp,sp,32
 3006b64:	8082                	ret

03006b66 <IsGpioPins>:
  * @brief Check gpio pins parameter.
  * @param pins OR logical combination of pin.
  * @retval Bool.
  */
static inline bool IsGpioPins(unsigned int pins)
{
 3006b66:	1101                	addi	sp,sp,-32
 3006b68:	ce22                	sw	s0,28(sp)
 3006b6a:	1000                	addi	s0,sp,32
 3006b6c:	fea42623          	sw	a0,-20(s0)
    return ((pins & GPIO_PIN_MASK) != BASE_CFG_UNSET) && ((pins & ~GPIO_PIN_MASK) == BASE_CFG_UNSET);
 3006b70:	fec42783          	lw	a5,-20(s0)
 3006b74:	0ff7f793          	andi	a5,a5,255
 3006b78:	cb81                	beqz	a5,3006b88 <IsGpioPins+0x22>
 3006b7a:	fec42783          	lw	a5,-20(s0)
 3006b7e:	f007f793          	andi	a5,a5,-256
 3006b82:	e399                	bnez	a5,3006b88 <IsGpioPins+0x22>
 3006b84:	4785                	li	a5,1
 3006b86:	a011                	j	3006b8a <IsGpioPins+0x24>
 3006b88:	4781                	li	a5,0
 3006b8a:	8b85                	andi	a5,a5,1
 3006b8c:	9f81                	uxtb	a5
}
 3006b8e:	853e                	mv	a0,a5
 3006b90:	4472                	lw	s0,28(sp)
 3006b92:	6105                	addi	sp,sp,32
 3006b94:	8082                	ret

03006b96 <IsGpioPin>:
  * @brief Check gpio pin parameter.
  * @param pin Value of @ref GPIO_PIN.
  * @retval Bool.
  */
static inline bool IsGpioPin(GPIO_PIN pin)
{
 3006b96:	1101                	addi	sp,sp,-32
 3006b98:	ce22                	sw	s0,28(sp)
 3006b9a:	1000                	addi	s0,sp,32
 3006b9c:	fea42623          	sw	a0,-20(s0)
    /* Check whether gpio pin */
    return (pin == GPIO_PIN_0 || pin == GPIO_PIN_1 || \
            pin == GPIO_PIN_2 || pin == GPIO_PIN_3 || \
            pin == GPIO_PIN_4 || pin == GPIO_PIN_5 || \
            pin == GPIO_PIN_6 || pin == GPIO_PIN_7 || \
 3006ba0:	fec42703          	lw	a4,-20(s0)
 3006ba4:	4785                	li	a5,1
 3006ba6:	04f70e63          	beq	a4,a5,3006c02 <IsGpioPin+0x6c>
    return (pin == GPIO_PIN_0 || pin == GPIO_PIN_1 || \
 3006baa:	fec42703          	lw	a4,-20(s0)
 3006bae:	4789                	li	a5,2
 3006bb0:	04f70963          	beq	a4,a5,3006c02 <IsGpioPin+0x6c>
 3006bb4:	fec42703          	lw	a4,-20(s0)
 3006bb8:	4791                	li	a5,4
 3006bba:	04f70463          	beq	a4,a5,3006c02 <IsGpioPin+0x6c>
            pin == GPIO_PIN_2 || pin == GPIO_PIN_3 || \
 3006bbe:	fec42703          	lw	a4,-20(s0)
 3006bc2:	47a1                	li	a5,8
 3006bc4:	02f70f63          	beq	a4,a5,3006c02 <IsGpioPin+0x6c>
 3006bc8:	fec42703          	lw	a4,-20(s0)
 3006bcc:	47c1                	li	a5,16
 3006bce:	02f70a63          	beq	a4,a5,3006c02 <IsGpioPin+0x6c>
            pin == GPIO_PIN_4 || pin == GPIO_PIN_5 || \
 3006bd2:	fec42703          	lw	a4,-20(s0)
 3006bd6:	02000793          	li	a5,32
 3006bda:	02f70463          	beq	a4,a5,3006c02 <IsGpioPin+0x6c>
 3006bde:	fec42703          	lw	a4,-20(s0)
 3006be2:	04000793          	li	a5,64
 3006be6:	00f70e63          	beq	a4,a5,3006c02 <IsGpioPin+0x6c>
            pin == GPIO_PIN_6 || pin == GPIO_PIN_7 || \
 3006bea:	fec42703          	lw	a4,-20(s0)
 3006bee:	08000793          	li	a5,128
 3006bf2:	00f70863          	beq	a4,a5,3006c02 <IsGpioPin+0x6c>
 3006bf6:	fec42703          	lw	a4,-20(s0)
 3006bfa:	0ff00793          	li	a5,255
 3006bfe:	00f71463          	bne	a4,a5,3006c06 <IsGpioPin+0x70>
 3006c02:	4785                	li	a5,1
 3006c04:	a011                	j	3006c08 <IsGpioPin+0x72>
 3006c06:	4781                	li	a5,0
 3006c08:	8b85                	andi	a5,a5,1
 3006c0a:	9f81                	uxtb	a5
            pin == GPIO_PIN_ALL);
}
 3006c0c:	853e                	mv	a0,a5
 3006c0e:	4472                	lw	s0,28(sp)
 3006c10:	6105                	addi	sp,sp,32
 3006c12:	8082                	ret

03006c14 <IsGpioITMode>:
  * @brief Check gpio interrupt mode parameter.
  * @param mode Value of @ref GPIO_InterruptMode.
  * @retval Bool.
  */
static inline bool IsGpioITMode(GPIO_InterruptMode mode)
{
 3006c14:	1101                	addi	sp,sp,-32
 3006c16:	ce22                	sw	s0,28(sp)
 3006c18:	1000                	addi	s0,sp,32
 3006c1a:	fea42623          	sw	a0,-20(s0)
    /* Check whether gpio interrupt mode */
    return (mode == GPIO_INT_TYPE_HIGH_LEVEL || \
            mode == GPIO_INT_TYPE_LOW_LEVEL || \
            mode == GPIO_INT_TYPE_RISE_EDGE || \
            mode == GPIO_INT_TYPE_FALL_EDGE || \
            mode == GPIO_INT_TYPE_BOTH_EDGE || \
 3006c1e:	fec42703          	lw	a4,-20(s0)
 3006c22:	478d                	li	a5,3
 3006c24:	02f70963          	beq	a4,a5,3006c56 <IsGpioITMode+0x42>
    return (mode == GPIO_INT_TYPE_HIGH_LEVEL || \
 3006c28:	fec42703          	lw	a4,-20(s0)
 3006c2c:	4789                	li	a5,2
 3006c2e:	02f70463          	beq	a4,a5,3006c56 <IsGpioITMode+0x42>
            mode == GPIO_INT_TYPE_LOW_LEVEL || \
 3006c32:	fec42703          	lw	a4,-20(s0)
 3006c36:	4785                	li	a5,1
 3006c38:	00f70f63          	beq	a4,a5,3006c56 <IsGpioITMode+0x42>
            mode == GPIO_INT_TYPE_RISE_EDGE || \
 3006c3c:	fec42783          	lw	a5,-20(s0)
 3006c40:	cb99                	beqz	a5,3006c56 <IsGpioITMode+0x42>
            mode == GPIO_INT_TYPE_FALL_EDGE || \
 3006c42:	fec42703          	lw	a4,-20(s0)
 3006c46:	4791                	li	a5,4
 3006c48:	00f70763          	beq	a4,a5,3006c56 <IsGpioITMode+0x42>
            mode == GPIO_INT_TYPE_BOTH_EDGE || \
 3006c4c:	fec42703          	lw	a4,-20(s0)
 3006c50:	4795                	li	a5,5
 3006c52:	00f71463          	bne	a4,a5,3006c5a <IsGpioITMode+0x46>
 3006c56:	4785                	li	a5,1
 3006c58:	a011                	j	3006c5c <IsGpioITMode+0x48>
 3006c5a:	4781                	li	a5,0
 3006c5c:	8b85                	andi	a5,a5,1
 3006c5e:	9f81                	uxtb	a5
            mode == GPIO_INT_TYPE_NONE);
}
 3006c60:	853e                	mv	a0,a5
 3006c62:	4472                	lw	s0,28(sp)
 3006c64:	6105                	addi	sp,sp,32
 3006c66:	8082                	ret

03006c68 <DCL_GPIO_SetValue>:
  * @param pins OR logical combination of pin.
  * @param value Value of @ref GPIO_Value.
  * @retval None.
  */
static inline void DCL_GPIO_SetValue(GPIO_RegStruct *gpiox, unsigned int pins, GPIO_Value value)
{
 3006c68:	1101                	addi	sp,sp,-32
 3006c6a:	ce06                	sw	ra,28(sp)
 3006c6c:	cc22                	sw	s0,24(sp)
 3006c6e:	1000                	addi	s0,sp,32
 3006c70:	fea42623          	sw	a0,-20(s0)
 3006c74:	feb42423          	sw	a1,-24(s0)
 3006c78:	fec42223          	sw	a2,-28(s0)
    GPIO_ASSERT_PARAM(IsGPIOInstance(gpiox));
 3006c7c:	fec42703          	lw	a4,-20(s0)
 3006c80:	145007b7          	lui	a5,0x14500
 3006c84:	04f70863          	beq	a4,a5,3006cd4 <DCL_GPIO_SetValue+0x6c>
 3006c88:	fec42703          	lw	a4,-20(s0)
 3006c8c:	145017b7          	lui	a5,0x14501
 3006c90:	04f70263          	beq	a4,a5,3006cd4 <DCL_GPIO_SetValue+0x6c>
 3006c94:	fec42703          	lw	a4,-20(s0)
 3006c98:	145027b7          	lui	a5,0x14502
 3006c9c:	02f70c63          	beq	a4,a5,3006cd4 <DCL_GPIO_SetValue+0x6c>
 3006ca0:	fec42703          	lw	a4,-20(s0)
 3006ca4:	145037b7          	lui	a5,0x14503
 3006ca8:	02f70663          	beq	a4,a5,3006cd4 <DCL_GPIO_SetValue+0x6c>
 3006cac:	fec42703          	lw	a4,-20(s0)
 3006cb0:	145047b7          	lui	a5,0x14504
 3006cb4:	02f70063          	beq	a4,a5,3006cd4 <DCL_GPIO_SetValue+0x6c>
 3006cb8:	fec42703          	lw	a4,-20(s0)
 3006cbc:	145057b7          	lui	a5,0x14505
 3006cc0:	00f70a63          	beq	a4,a5,3006cd4 <DCL_GPIO_SetValue+0x6c>
 3006cc4:	18e00593          	li	a1,398
 3006cc8:	030117b7          	lui	a5,0x3011
 3006ccc:	93478513          	addi	a0,a5,-1740 # 3010934 <g_crgIpMatch+0x424>
 3006cd0:	2d51                	jal	ra,3007364 <AssertErrorLog.trans.4>
 3006cd2:	a001                	j	3006cd2 <DCL_GPIO_SetValue+0x6a>
    GPIO_PARAM_CHECK_NO_RET(IsGpioPins(pins));
 3006cd4:	fe842503          	lw	a0,-24(s0)
 3006cd8:	3579                	jal	ra,3006b66 <IsGpioPins>
 3006cda:	87aa                	mv	a5,a0
 3006cdc:	0017c793          	xori	a5,a5,1
 3006ce0:	9f81                	uxtb	a5
 3006ce2:	cb89                	beqz	a5,3006cf4 <DCL_GPIO_SetValue+0x8c>
 3006ce4:	18f00593          	li	a1,399
 3006ce8:	030117b7          	lui	a5,0x3011
 3006cec:	93478513          	addi	a0,a5,-1740 # 3010934 <g_crgIpMatch+0x424>
 3006cf0:	2d95                	jal	ra,3007364 <AssertErrorLog.trans.4>
 3006cf2:	a089                	j	3006d34 <DCL_GPIO_SetValue+0xcc>
    GPIO_PARAM_CHECK_NO_RET(IsGpioValue(value));
 3006cf4:	fe442503          	lw	a0,-28(s0)
 3006cf8:	3d19                	jal	ra,3006b0e <IsGpioValue>
 3006cfa:	87aa                	mv	a5,a0
 3006cfc:	0017c793          	xori	a5,a5,1
 3006d00:	9f81                	uxtb	a5
 3006d02:	cb89                	beqz	a5,3006d14 <DCL_GPIO_SetValue+0xac>
 3006d04:	19000593          	li	a1,400
 3006d08:	030117b7          	lui	a5,0x3011
 3006d0c:	93478513          	addi	a0,a5,-1740 # 3010934 <g_crgIpMatch+0x424>
 3006d10:	2d91                	jal	ra,3007364 <AssertErrorLog.trans.4>
 3006d12:	a00d                	j	3006d34 <DCL_GPIO_SetValue+0xcc>
    gpiox->GPIO_DATA[pins].reg = (value == GPIO_HIGH_LEVEL ? pins : BASE_CFG_UNSET); /* Set GPIO pin level */
 3006d14:	fe442703          	lw	a4,-28(s0)
 3006d18:	4785                	li	a5,1
 3006d1a:	00f71563          	bne	a4,a5,3006d24 <DCL_GPIO_SetValue+0xbc>
 3006d1e:	fe842783          	lw	a5,-24(s0)
 3006d22:	a011                	j	3006d26 <DCL_GPIO_SetValue+0xbe>
 3006d24:	4781                	li	a5,0
 3006d26:	fec42683          	lw	a3,-20(s0)
 3006d2a:	fe842703          	lw	a4,-24(s0)
 3006d2e:	070a                	slli	a4,a4,0x2
 3006d30:	9736                	add	a4,a4,a3
 3006d32:	c31c                	sw	a5,0(a4)
}
 3006d34:	40f2                	lw	ra,28(sp)
 3006d36:	4462                	lw	s0,24(sp)
 3006d38:	6105                	addi	sp,sp,32
 3006d3a:	8082                	ret

03006d3c <DCL_GPIO_SetDirection>:
  * @param pins OR logical combination of pin.
  * @param dir Value of @ref GPIO_Direction.
  * @retval None.
  */
static inline void DCL_GPIO_SetDirection(GPIO_RegStruct *gpiox, unsigned int pins, GPIO_Direction dir)
{
 3006d3c:	1101                	addi	sp,sp,-32
 3006d3e:	ce06                	sw	ra,28(sp)
 3006d40:	cc22                	sw	s0,24(sp)
 3006d42:	1000                	addi	s0,sp,32
 3006d44:	fea42623          	sw	a0,-20(s0)
 3006d48:	feb42423          	sw	a1,-24(s0)
 3006d4c:	fec42223          	sw	a2,-28(s0)
    /* param check */
    GPIO_ASSERT_PARAM(IsGPIOInstance(gpiox));
 3006d50:	fec42703          	lw	a4,-20(s0)
 3006d54:	145007b7          	lui	a5,0x14500
 3006d58:	04f70863          	beq	a4,a5,3006da8 <DCL_GPIO_SetDirection+0x6c>
 3006d5c:	fec42703          	lw	a4,-20(s0)
 3006d60:	145017b7          	lui	a5,0x14501
 3006d64:	04f70263          	beq	a4,a5,3006da8 <DCL_GPIO_SetDirection+0x6c>
 3006d68:	fec42703          	lw	a4,-20(s0)
 3006d6c:	145027b7          	lui	a5,0x14502
 3006d70:	02f70c63          	beq	a4,a5,3006da8 <DCL_GPIO_SetDirection+0x6c>
 3006d74:	fec42703          	lw	a4,-20(s0)
 3006d78:	145037b7          	lui	a5,0x14503
 3006d7c:	02f70663          	beq	a4,a5,3006da8 <DCL_GPIO_SetDirection+0x6c>
 3006d80:	fec42703          	lw	a4,-20(s0)
 3006d84:	145047b7          	lui	a5,0x14504
 3006d88:	02f70063          	beq	a4,a5,3006da8 <DCL_GPIO_SetDirection+0x6c>
 3006d8c:	fec42703          	lw	a4,-20(s0)
 3006d90:	145057b7          	lui	a5,0x14505
 3006d94:	00f70a63          	beq	a4,a5,3006da8 <DCL_GPIO_SetDirection+0x6c>
 3006d98:	1b700593          	li	a1,439
 3006d9c:	030117b7          	lui	a5,0x3011
 3006da0:	93478513          	addi	a0,a5,-1740 # 3010934 <g_crgIpMatch+0x424>
 3006da4:	23c1                	jal	ra,3007364 <AssertErrorLog.trans.4>
 3006da6:	a001                	j	3006da6 <DCL_GPIO_SetDirection+0x6a>
    GPIO_PARAM_CHECK_NO_RET(IsGpioPins(pins));
 3006da8:	fe842503          	lw	a0,-24(s0)
 3006dac:	3b6d                	jal	ra,3006b66 <IsGpioPins>
 3006dae:	87aa                	mv	a5,a0
 3006db0:	0017c793          	xori	a5,a5,1
 3006db4:	9f81                	uxtb	a5
 3006db6:	cb89                	beqz	a5,3006dc8 <DCL_GPIO_SetDirection+0x8c>
 3006db8:	1b800593          	li	a1,440
 3006dbc:	030117b7          	lui	a5,0x3011
 3006dc0:	93478513          	addi	a0,a5,-1740 # 3010934 <g_crgIpMatch+0x424>
 3006dc4:	2345                	jal	ra,3007364 <AssertErrorLog.trans.4>
 3006dc6:	a095                	j	3006e2a <DCL_GPIO_SetDirection+0xee>
    GPIO_PARAM_CHECK_NO_RET(IsGpioDirection(dir));
 3006dc8:	fe442503          	lw	a0,-28(s0)
 3006dcc:	33bd                	jal	ra,3006b3a <IsGpioDirection>
 3006dce:	87aa                	mv	a5,a0
 3006dd0:	0017c793          	xori	a5,a5,1
 3006dd4:	9f81                	uxtb	a5
 3006dd6:	cb89                	beqz	a5,3006de8 <DCL_GPIO_SetDirection+0xac>
 3006dd8:	1b900593          	li	a1,441
 3006ddc:	030117b7          	lui	a5,0x3011
 3006de0:	93478513          	addi	a0,a5,-1740 # 3010934 <g_crgIpMatch+0x424>
 3006de4:	2341                	jal	ra,3007364 <AssertErrorLog.trans.4>
 3006de6:	a091                	j	3006e2a <DCL_GPIO_SetDirection+0xee>
    if (dir == GPIO_INPUT_MODE) { /* Set GPIO pin direction */
 3006de8:	fe442783          	lw	a5,-28(s0)
 3006dec:	ef99                	bnez	a5,3006e0a <DCL_GPIO_SetDirection+0xce>
        gpiox->GPIO_DIR.reg &= ~pins;
 3006dee:	fec42783          	lw	a5,-20(s0)
 3006df2:	4007a703          	lw	a4,1024(a5)
 3006df6:	fe842783          	lw	a5,-24(s0)
 3006dfa:	fff7c793          	not	a5,a5
 3006dfe:	8f7d                	and	a4,a4,a5
 3006e00:	fec42783          	lw	a5,-20(s0)
 3006e04:	40e7a023          	sw	a4,1024(a5)
 3006e08:	a00d                	j	3006e2a <DCL_GPIO_SetDirection+0xee>
    } else if (dir == GPIO_OUTPUT_MODE) {
 3006e0a:	fe442703          	lw	a4,-28(s0)
 3006e0e:	4785                	li	a5,1
 3006e10:	00f71d63          	bne	a4,a5,3006e2a <DCL_GPIO_SetDirection+0xee>
        gpiox->GPIO_DIR.reg |= pins;
 3006e14:	fec42783          	lw	a5,-20(s0)
 3006e18:	4007a703          	lw	a4,1024(a5)
 3006e1c:	fe842783          	lw	a5,-24(s0)
 3006e20:	8f5d                	or	a4,a4,a5
 3006e22:	fec42783          	lw	a5,-20(s0)
 3006e26:	40e7a023          	sw	a4,1024(a5)
    }
}
 3006e2a:	40f2                	lw	ra,28(sp)
 3006e2c:	4462                	lw	s0,24(sp)
 3006e2e:	6105                	addi	sp,sp,32
 3006e30:	8082                	ret

03006e32 <DCL_GPIO_ClearIrq>:
  * @param gpiox Value of @ref GPIO_RegStruct.
  * @param pins OR logical combination of pin.
  * @retval None.
  */
static inline void DCL_GPIO_ClearIrq(GPIO_RegStruct *gpiox, unsigned int pins)
{
 3006e32:	1101                	addi	sp,sp,-32
 3006e34:	ce06                	sw	ra,28(sp)
 3006e36:	cc22                	sw	s0,24(sp)
 3006e38:	1000                	addi	s0,sp,32
 3006e3a:	fea42623          	sw	a0,-20(s0)
 3006e3e:	feb42423          	sw	a1,-24(s0)
    GPIO_ASSERT_PARAM(IsGPIOInstance(gpiox));
 3006e42:	fec42703          	lw	a4,-20(s0)
 3006e46:	145007b7          	lui	a5,0x14500
 3006e4a:	04f70863          	beq	a4,a5,3006e9a <DCL_GPIO_ClearIrq+0x68>
 3006e4e:	fec42703          	lw	a4,-20(s0)
 3006e52:	145017b7          	lui	a5,0x14501
 3006e56:	04f70263          	beq	a4,a5,3006e9a <DCL_GPIO_ClearIrq+0x68>
 3006e5a:	fec42703          	lw	a4,-20(s0)
 3006e5e:	145027b7          	lui	a5,0x14502
 3006e62:	02f70c63          	beq	a4,a5,3006e9a <DCL_GPIO_ClearIrq+0x68>
 3006e66:	fec42703          	lw	a4,-20(s0)
 3006e6a:	145037b7          	lui	a5,0x14503
 3006e6e:	02f70663          	beq	a4,a5,3006e9a <DCL_GPIO_ClearIrq+0x68>
 3006e72:	fec42703          	lw	a4,-20(s0)
 3006e76:	145047b7          	lui	a5,0x14504
 3006e7a:	02f70063          	beq	a4,a5,3006e9a <DCL_GPIO_ClearIrq+0x68>
 3006e7e:	fec42703          	lw	a4,-20(s0)
 3006e82:	145057b7          	lui	a5,0x14505
 3006e86:	00f70a63          	beq	a4,a5,3006e9a <DCL_GPIO_ClearIrq+0x68>
 3006e8a:	25c00593          	li	a1,604
 3006e8e:	030117b7          	lui	a5,0x3011
 3006e92:	93478513          	addi	a0,a5,-1740 # 3010934 <g_crgIpMatch+0x424>
 3006e96:	21f9                	jal	ra,3007364 <AssertErrorLog.trans.4>
 3006e98:	a001                	j	3006e98 <DCL_GPIO_ClearIrq+0x66>
    GPIO_PARAM_CHECK_NO_RET(IsGpioPins(pins));
 3006e9a:	fe842503          	lw	a0,-24(s0)
 3006e9e:	31e1                	jal	ra,3006b66 <IsGpioPins>
 3006ea0:	87aa                	mv	a5,a0
 3006ea2:	0017c793          	xori	a5,a5,1
 3006ea6:	9f81                	uxtb	a5
 3006ea8:	cb89                	beqz	a5,3006eba <DCL_GPIO_ClearIrq+0x88>
 3006eaa:	25d00593          	li	a1,605
 3006eae:	030117b7          	lui	a5,0x3011
 3006eb2:	93478513          	addi	a0,a5,-1740 # 3010934 <g_crgIpMatch+0x424>
 3006eb6:	217d                	jal	ra,3007364 <AssertErrorLog.trans.4>
 3006eb8:	a821                	j	3006ed0 <DCL_GPIO_ClearIrq+0x9e>
    gpiox->GPIO_IC.reg |= pins;
 3006eba:	fec42783          	lw	a5,-20(s0)
 3006ebe:	41c7a703          	lw	a4,1052(a5)
 3006ec2:	fe842783          	lw	a5,-24(s0)
 3006ec6:	8f5d                	or	a4,a4,a5
 3006ec8:	fec42783          	lw	a5,-20(s0)
 3006ecc:	40e7ae23          	sw	a4,1052(a5)
}
 3006ed0:	40f2                	lw	ra,28(sp)
 3006ed2:	4462                	lw	s0,24(sp)
 3006ed4:	6105                	addi	sp,sp,32
 3006ed6:	8082                	ret

03006ed8 <DCL_GPIO_EnableIrq>:
  * @param gpiox Value of @ref GPIO_RegStruct.
  * @param pins OR logical combination of pins.
  * @retval None.
  */
static inline void DCL_GPIO_EnableIrq(GPIO_RegStruct *gpiox, unsigned int pins)
{
 3006ed8:	1101                	addi	sp,sp,-32
 3006eda:	ce06                	sw	ra,28(sp)
 3006edc:	cc22                	sw	s0,24(sp)
 3006ede:	1000                	addi	s0,sp,32
 3006ee0:	fea42623          	sw	a0,-20(s0)
 3006ee4:	feb42423          	sw	a1,-24(s0)
    GPIO_ASSERT_PARAM(IsGPIOInstance(gpiox));
 3006ee8:	fec42703          	lw	a4,-20(s0)
 3006eec:	145007b7          	lui	a5,0x14500
 3006ef0:	04f70863          	beq	a4,a5,3006f40 <DCL_GPIO_EnableIrq+0x68>
 3006ef4:	fec42703          	lw	a4,-20(s0)
 3006ef8:	145017b7          	lui	a5,0x14501
 3006efc:	04f70263          	beq	a4,a5,3006f40 <DCL_GPIO_EnableIrq+0x68>
 3006f00:	fec42703          	lw	a4,-20(s0)
 3006f04:	145027b7          	lui	a5,0x14502
 3006f08:	02f70c63          	beq	a4,a5,3006f40 <DCL_GPIO_EnableIrq+0x68>
 3006f0c:	fec42703          	lw	a4,-20(s0)
 3006f10:	145037b7          	lui	a5,0x14503
 3006f14:	02f70663          	beq	a4,a5,3006f40 <DCL_GPIO_EnableIrq+0x68>
 3006f18:	fec42703          	lw	a4,-20(s0)
 3006f1c:	145047b7          	lui	a5,0x14504
 3006f20:	02f70063          	beq	a4,a5,3006f40 <DCL_GPIO_EnableIrq+0x68>
 3006f24:	fec42703          	lw	a4,-20(s0)
 3006f28:	145057b7          	lui	a5,0x14505
 3006f2c:	00f70a63          	beq	a4,a5,3006f40 <DCL_GPIO_EnableIrq+0x68>
 3006f30:	26900593          	li	a1,617
 3006f34:	030117b7          	lui	a5,0x3011
 3006f38:	93478513          	addi	a0,a5,-1740 # 3010934 <g_crgIpMatch+0x424>
 3006f3c:	2125                	jal	ra,3007364 <AssertErrorLog.trans.4>
 3006f3e:	a001                	j	3006f3e <DCL_GPIO_EnableIrq+0x66>
    GPIO_PARAM_CHECK_NO_RET(IsGpioPins(pins));
 3006f40:	fe842503          	lw	a0,-24(s0)
 3006f44:	310d                	jal	ra,3006b66 <IsGpioPins>
 3006f46:	87aa                	mv	a5,a0
 3006f48:	0017c793          	xori	a5,a5,1
 3006f4c:	9f81                	uxtb	a5
 3006f4e:	cb89                	beqz	a5,3006f60 <DCL_GPIO_EnableIrq+0x88>
 3006f50:	26a00593          	li	a1,618
 3006f54:	030117b7          	lui	a5,0x3011
 3006f58:	93478513          	addi	a0,a5,-1740 # 3010934 <g_crgIpMatch+0x424>
 3006f5c:	2121                	jal	ra,3007364 <AssertErrorLog.trans.4>
 3006f5e:	a00d                	j	3006f80 <DCL_GPIO_EnableIrq+0xa8>
    /* must clear interrupt first, prevents interrupts triggered by previous output mode. */
    DCL_GPIO_ClearIrq(gpiox, pins);
 3006f60:	fe842583          	lw	a1,-24(s0)
 3006f64:	fec42503          	lw	a0,-20(s0)
 3006f68:	35e9                	jal	ra,3006e32 <DCL_GPIO_ClearIrq>
    gpiox->GPIO_IE.reg |= pins;
 3006f6a:	fec42783          	lw	a5,-20(s0)
 3006f6e:	4107a703          	lw	a4,1040(a5)
 3006f72:	fe842783          	lw	a5,-24(s0)
 3006f76:	8f5d                	or	a4,a4,a5
 3006f78:	fec42783          	lw	a5,-20(s0)
 3006f7c:	40e7a823          	sw	a4,1040(a5)
}
 3006f80:	40f2                	lw	ra,28(sp)
 3006f82:	4462                	lw	s0,24(sp)
 3006f84:	6105                	addi	sp,sp,32
 3006f86:	8082                	ret

03006f88 <DCL_GPIO_DisableIrq>:
  * @param gpiox Value of @ref GPIO_RegStruct.
  * @param pins OR logical combination of pin.
  * @retval None.
  */
static inline void DCL_GPIO_DisableIrq(GPIO_RegStruct *gpiox, unsigned int pins)
{
 3006f88:	1101                	addi	sp,sp,-32
 3006f8a:	ce06                	sw	ra,28(sp)
 3006f8c:	cc22                	sw	s0,24(sp)
 3006f8e:	1000                	addi	s0,sp,32
 3006f90:	fea42623          	sw	a0,-20(s0)
 3006f94:	feb42423          	sw	a1,-24(s0)
    GPIO_ASSERT_PARAM(IsGPIOInstance(gpiox));
 3006f98:	fec42703          	lw	a4,-20(s0)
 3006f9c:	145007b7          	lui	a5,0x14500
 3006fa0:	04f70863          	beq	a4,a5,3006ff0 <DCL_GPIO_DisableIrq+0x68>
 3006fa4:	fec42703          	lw	a4,-20(s0)
 3006fa8:	145017b7          	lui	a5,0x14501
 3006fac:	04f70263          	beq	a4,a5,3006ff0 <DCL_GPIO_DisableIrq+0x68>
 3006fb0:	fec42703          	lw	a4,-20(s0)
 3006fb4:	145027b7          	lui	a5,0x14502
 3006fb8:	02f70c63          	beq	a4,a5,3006ff0 <DCL_GPIO_DisableIrq+0x68>
 3006fbc:	fec42703          	lw	a4,-20(s0)
 3006fc0:	145037b7          	lui	a5,0x14503
 3006fc4:	02f70663          	beq	a4,a5,3006ff0 <DCL_GPIO_DisableIrq+0x68>
 3006fc8:	fec42703          	lw	a4,-20(s0)
 3006fcc:	145047b7          	lui	a5,0x14504
 3006fd0:	02f70063          	beq	a4,a5,3006ff0 <DCL_GPIO_DisableIrq+0x68>
 3006fd4:	fec42703          	lw	a4,-20(s0)
 3006fd8:	145057b7          	lui	a5,0x14505
 3006fdc:	00f70a63          	beq	a4,a5,3006ff0 <DCL_GPIO_DisableIrq+0x68>
 3006fe0:	27800593          	li	a1,632
 3006fe4:	030117b7          	lui	a5,0x3011
 3006fe8:	93478513          	addi	a0,a5,-1740 # 3010934 <g_crgIpMatch+0x424>
 3006fec:	2ea5                	jal	ra,3007364 <AssertErrorLog.trans.4>
 3006fee:	a001                	j	3006fee <DCL_GPIO_DisableIrq+0x66>
    GPIO_PARAM_CHECK_NO_RET(IsGpioPins(pins));
 3006ff0:	fe842503          	lw	a0,-24(s0)
 3006ff4:	3e8d                	jal	ra,3006b66 <IsGpioPins>
 3006ff6:	87aa                	mv	a5,a0
 3006ff8:	0017c793          	xori	a5,a5,1
 3006ffc:	9f81                	uxtb	a5
 3006ffe:	cb89                	beqz	a5,3007010 <DCL_GPIO_DisableIrq+0x88>
 3007000:	27900593          	li	a1,633
 3007004:	030117b7          	lui	a5,0x3011
 3007008:	93478513          	addi	a0,a5,-1740 # 3010934 <g_crgIpMatch+0x424>
 300700c:	2ea1                	jal	ra,3007364 <AssertErrorLog.trans.4>
 300700e:	a831                	j	300702a <DCL_GPIO_DisableIrq+0xa2>
    gpiox->GPIO_IE.reg &= ~pins;
 3007010:	fec42783          	lw	a5,-20(s0)
 3007014:	4107a703          	lw	a4,1040(a5)
 3007018:	fe842783          	lw	a5,-24(s0)
 300701c:	fff7c793          	not	a5,a5
 3007020:	8f7d                	and	a4,a4,a5
 3007022:	fec42783          	lw	a5,-20(s0)
 3007026:	40e7a823          	sw	a4,1040(a5)
}
 300702a:	40f2                	lw	ra,28(sp)
 300702c:	4462                	lw	s0,24(sp)
 300702e:	6105                	addi	sp,sp,32
 3007030:	8082                	ret

03007032 <DCL_GPIO_GetMIS>:
  * @brief Getting all values of GPIO MIS register.
  * @param gpiox Value of @ref GPIO_RegStruct.
  * @retval unsigned int All values of GPIO MIS register.
  */
static inline unsigned int DCL_GPIO_GetMIS(const GPIO_RegStruct *gpiox)
{
 3007032:	1101                	addi	sp,sp,-32
 3007034:	ce06                	sw	ra,28(sp)
 3007036:	cc22                	sw	s0,24(sp)
 3007038:	1000                	addi	s0,sp,32
 300703a:	fea42623          	sw	a0,-20(s0)
    GPIO_ASSERT_PARAM(IsGPIOInstance(gpiox));
 300703e:	fec42703          	lw	a4,-20(s0)
 3007042:	145007b7          	lui	a5,0x14500
 3007046:	04f70863          	beq	a4,a5,3007096 <DCL_GPIO_GetMIS+0x64>
 300704a:	fec42703          	lw	a4,-20(s0)
 300704e:	145017b7          	lui	a5,0x14501
 3007052:	04f70263          	beq	a4,a5,3007096 <DCL_GPIO_GetMIS+0x64>
 3007056:	fec42703          	lw	a4,-20(s0)
 300705a:	145027b7          	lui	a5,0x14502
 300705e:	02f70c63          	beq	a4,a5,3007096 <DCL_GPIO_GetMIS+0x64>
 3007062:	fec42703          	lw	a4,-20(s0)
 3007066:	145037b7          	lui	a5,0x14503
 300706a:	02f70663          	beq	a4,a5,3007096 <DCL_GPIO_GetMIS+0x64>
 300706e:	fec42703          	lw	a4,-20(s0)
 3007072:	145047b7          	lui	a5,0x14504
 3007076:	02f70063          	beq	a4,a5,3007096 <DCL_GPIO_GetMIS+0x64>
 300707a:	fec42703          	lw	a4,-20(s0)
 300707e:	145057b7          	lui	a5,0x14505
 3007082:	00f70a63          	beq	a4,a5,3007096 <DCL_GPIO_GetMIS+0x64>
 3007086:	29a00593          	li	a1,666
 300708a:	030117b7          	lui	a5,0x3011
 300708e:	93478513          	addi	a0,a5,-1740 # 3010934 <g_crgIpMatch+0x424>
 3007092:	2cc9                	jal	ra,3007364 <AssertErrorLog.trans.4>
 3007094:	a001                	j	3007094 <DCL_GPIO_GetMIS+0x62>
    return gpiox->GPIO_MIS.reg & GPIO_PIN_MASK;
 3007096:	fec42783          	lw	a5,-20(s0)
 300709a:	4187a783          	lw	a5,1048(a5)
 300709e:	0ff7f793          	andi	a5,a5,255
}
 30070a2:	853e                	mv	a0,a5
 30070a4:	40f2                	lw	ra,28(sp)
 30070a6:	4462                	lw	s0,24(sp)
 30070a8:	6105                	addi	sp,sp,32
 30070aa:	8082                	ret

030070ac <HAL_GPIO_Init>:
  * @brief Initializing GPIO register values.
  * @param handle Value of @ref GPIO_Handle.
  * @retval None.
  */
void HAL_GPIO_Init(GPIO_Handle *handle)
{
 30070ac:	7179                	addi	sp,sp,-48
 30070ae:	d606                	sw	ra,44(sp)
 30070b0:	d422                	sw	s0,40(sp)
 30070b2:	1800                	addi	s0,sp,48
 30070b4:	fca42e23          	sw	a0,-36(s0)
    GPIO_ASSERT_PARAM(handle != NULL);
 30070b8:	fdc42783          	lw	a5,-36(s0)
 30070bc:	eb89                	bnez	a5,30070ce <HAL_GPIO_Init+0x22>
 30070be:	02b00593          	li	a1,43
 30070c2:	030117b7          	lui	a5,0x3011
 30070c6:	95478513          	addi	a0,a5,-1708 # 3010954 <g_crgIpMatch+0x444>
 30070ca:	2c69                	jal	ra,3007364 <AssertErrorLog.trans.4>
 30070cc:	a001                	j	30070cc <HAL_GPIO_Init+0x20>
    GPIO_ASSERT_PARAM(IsGPIOInstance(handle->baseAddress));
 30070ce:	fdc42783          	lw	a5,-36(s0)
 30070d2:	4398                	lw	a4,0(a5)
 30070d4:	145007b7          	lui	a5,0x14500
 30070d8:	04f70d63          	beq	a4,a5,3007132 <HAL_GPIO_Init+0x86>
 30070dc:	fdc42783          	lw	a5,-36(s0)
 30070e0:	4398                	lw	a4,0(a5)
 30070e2:	145017b7          	lui	a5,0x14501
 30070e6:	04f70663          	beq	a4,a5,3007132 <HAL_GPIO_Init+0x86>
 30070ea:	fdc42783          	lw	a5,-36(s0)
 30070ee:	4398                	lw	a4,0(a5)
 30070f0:	145027b7          	lui	a5,0x14502
 30070f4:	02f70f63          	beq	a4,a5,3007132 <HAL_GPIO_Init+0x86>
 30070f8:	fdc42783          	lw	a5,-36(s0)
 30070fc:	4398                	lw	a4,0(a5)
 30070fe:	145037b7          	lui	a5,0x14503
 3007102:	02f70863          	beq	a4,a5,3007132 <HAL_GPIO_Init+0x86>
 3007106:	fdc42783          	lw	a5,-36(s0)
 300710a:	4398                	lw	a4,0(a5)
 300710c:	145047b7          	lui	a5,0x14504
 3007110:	02f70163          	beq	a4,a5,3007132 <HAL_GPIO_Init+0x86>
 3007114:	fdc42783          	lw	a5,-36(s0)
 3007118:	4398                	lw	a4,0(a5)
 300711a:	145057b7          	lui	a5,0x14505
 300711e:	00f70a63          	beq	a4,a5,3007132 <HAL_GPIO_Init+0x86>
 3007122:	02c00593          	li	a1,44
 3007126:	030117b7          	lui	a5,0x3011
 300712a:	95478513          	addi	a0,a5,-1708 # 3010954 <g_crgIpMatch+0x444>
 300712e:	2c1d                	jal	ra,3007364 <AssertErrorLog.trans.4>
 3007130:	a001                	j	3007130 <HAL_GPIO_Init+0x84>
    GPIO_PARAM_CHECK_NO_RET(IsGpioPins(handle->pins));
 3007132:	fdc42783          	lw	a5,-36(s0)
 3007136:	43dc                	lw	a5,4(a5)
 3007138:	853e                	mv	a0,a5
 300713a:	3435                	jal	ra,3006b66 <IsGpioPins>
 300713c:	87aa                	mv	a5,a0
 300713e:	0017c793          	xori	a5,a5,1
 3007142:	9f81                	uxtb	a5
 3007144:	cb89                	beqz	a5,3007156 <HAL_GPIO_Init+0xaa>
 3007146:	02d00593          	li	a1,45
 300714a:	030117b7          	lui	a5,0x3011
 300714e:	95478513          	addi	a0,a5,-1708 # 3010954 <g_crgIpMatch+0x444>
 3007152:	2c09                	jal	ra,3007364 <AssertErrorLog.trans.4>
 3007154:	a81d                	j	300718a <HAL_GPIO_Init+0xde>

    /* Register GPIO callback ID */
    for (unsigned int i = 0; i < GPIO_PIN_NUM; i++) {
 3007156:	fe042623          	sw	zero,-20(s0)
 300715a:	a01d                	j	3007180 <HAL_GPIO_Init+0xd4>
        handle->userCallBack.GPIO_CallbackFuncs[i].pin = (1 << i);
 300715c:	4705                	li	a4,1
 300715e:	fec42783          	lw	a5,-20(s0)
 3007162:	00f717b3          	sll	a5,a4,a5
 3007166:	86be                	mv	a3,a5
 3007168:	fdc42703          	lw	a4,-36(s0)
 300716c:	fec42783          	lw	a5,-20(s0)
 3007170:	078e                	slli	a5,a5,0x3
 3007172:	97ba                	add	a5,a5,a4
 3007174:	c794                	sw	a3,8(a5)
    for (unsigned int i = 0; i < GPIO_PIN_NUM; i++) {
 3007176:	fec42783          	lw	a5,-20(s0)
 300717a:	0785                	addi	a5,a5,1
 300717c:	fef42623          	sw	a5,-20(s0)
 3007180:	fec42703          	lw	a4,-20(s0)
 3007184:	479d                	li	a5,7
 3007186:	fce7fbe3          	bgeu	a5,a4,300715c <HAL_GPIO_Init+0xb0>
    }
}
 300718a:	50b2                	lw	ra,44(sp)
 300718c:	5422                	lw	s0,40(sp)
 300718e:	6145                	addi	sp,sp,48
 3007190:	8082                	ret

03007192 <HAL_GPIO_SetDirection>:
  * @param pins OR logical combination of pin.
  * @param dir GPIO pin direction.
  * @retval None.
  */
void HAL_GPIO_SetDirection(GPIO_Handle *handle, unsigned int pins, GPIO_Direction dir)
{
 3007192:	1101                	addi	sp,sp,-32
 3007194:	ce06                	sw	ra,28(sp)
 3007196:	cc22                	sw	s0,24(sp)
 3007198:	1000                	addi	s0,sp,32
 300719a:	fea42623          	sw	a0,-20(s0)
 300719e:	feb42423          	sw	a1,-24(s0)
 30071a2:	fec42223          	sw	a2,-28(s0)
    GPIO_ASSERT_PARAM(handle != NULL);
 30071a6:	fec42783          	lw	a5,-20(s0)
 30071aa:	eb89                	bnez	a5,30071bc <HAL_GPIO_SetDirection+0x2a>
 30071ac:	04f00593          	li	a1,79
 30071b0:	030117b7          	lui	a5,0x3011
 30071b4:	95478513          	addi	a0,a5,-1708 # 3010954 <g_crgIpMatch+0x444>
 30071b8:	2275                	jal	ra,3007364 <AssertErrorLog.trans.4>
 30071ba:	a001                	j	30071ba <HAL_GPIO_SetDirection+0x28>
    GPIO_ASSERT_PARAM(IsGPIOInstance(handle->baseAddress));
 30071bc:	fec42783          	lw	a5,-20(s0)
 30071c0:	4398                	lw	a4,0(a5)
 30071c2:	145007b7          	lui	a5,0x14500
 30071c6:	04f70d63          	beq	a4,a5,3007220 <HAL_GPIO_SetDirection+0x8e>
 30071ca:	fec42783          	lw	a5,-20(s0)
 30071ce:	4398                	lw	a4,0(a5)
 30071d0:	145017b7          	lui	a5,0x14501
 30071d4:	04f70663          	beq	a4,a5,3007220 <HAL_GPIO_SetDirection+0x8e>
 30071d8:	fec42783          	lw	a5,-20(s0)
 30071dc:	4398                	lw	a4,0(a5)
 30071de:	145027b7          	lui	a5,0x14502
 30071e2:	02f70f63          	beq	a4,a5,3007220 <HAL_GPIO_SetDirection+0x8e>
 30071e6:	fec42783          	lw	a5,-20(s0)
 30071ea:	4398                	lw	a4,0(a5)
 30071ec:	145037b7          	lui	a5,0x14503
 30071f0:	02f70863          	beq	a4,a5,3007220 <HAL_GPIO_SetDirection+0x8e>
 30071f4:	fec42783          	lw	a5,-20(s0)
 30071f8:	4398                	lw	a4,0(a5)
 30071fa:	145047b7          	lui	a5,0x14504
 30071fe:	02f70163          	beq	a4,a5,3007220 <HAL_GPIO_SetDirection+0x8e>
 3007202:	fec42783          	lw	a5,-20(s0)
 3007206:	4398                	lw	a4,0(a5)
 3007208:	145057b7          	lui	a5,0x14505
 300720c:	00f70a63          	beq	a4,a5,3007220 <HAL_GPIO_SetDirection+0x8e>
 3007210:	05000593          	li	a1,80
 3007214:	030117b7          	lui	a5,0x3011
 3007218:	95478513          	addi	a0,a5,-1708 # 3010954 <g_crgIpMatch+0x444>
 300721c:	22a1                	jal	ra,3007364 <AssertErrorLog.trans.4>
 300721e:	a001                	j	300721e <HAL_GPIO_SetDirection+0x8c>
    GPIO_PARAM_CHECK_NO_RET(IsGpioPins(pins));
 3007220:	fe842503          	lw	a0,-24(s0)
 3007224:	3289                	jal	ra,3006b66 <IsGpioPins>
 3007226:	87aa                	mv	a5,a0
 3007228:	0017c793          	xori	a5,a5,1
 300722c:	9f81                	uxtb	a5
 300722e:	cb89                	beqz	a5,3007240 <HAL_GPIO_SetDirection+0xae>
 3007230:	05100593          	li	a1,81
 3007234:	030117b7          	lui	a5,0x3011
 3007238:	95478513          	addi	a0,a5,-1708 # 3010954 <g_crgIpMatch+0x444>
 300723c:	2225                	jal	ra,3007364 <AssertErrorLog.trans.4>
 300723e:	a815                	j	3007272 <HAL_GPIO_SetDirection+0xe0>
    GPIO_PARAM_CHECK_NO_RET(IsGpioDirection(dir));
 3007240:	fe442503          	lw	a0,-28(s0)
 3007244:	38dd                	jal	ra,3006b3a <IsGpioDirection>
 3007246:	87aa                	mv	a5,a0
 3007248:	0017c793          	xori	a5,a5,1
 300724c:	9f81                	uxtb	a5
 300724e:	cb89                	beqz	a5,3007260 <HAL_GPIO_SetDirection+0xce>
 3007250:	05200593          	li	a1,82
 3007254:	030117b7          	lui	a5,0x3011
 3007258:	95478513          	addi	a0,a5,-1708 # 3010954 <g_crgIpMatch+0x444>
 300725c:	2221                	jal	ra,3007364 <AssertErrorLog.trans.4>
 300725e:	a811                	j	3007272 <HAL_GPIO_SetDirection+0xe0>
    DCL_GPIO_SetDirection(handle->baseAddress, pins, dir);
 3007260:	fec42783          	lw	a5,-20(s0)
 3007264:	439c                	lw	a5,0(a5)
 3007266:	fe442603          	lw	a2,-28(s0)
 300726a:	fe842583          	lw	a1,-24(s0)
 300726e:	853e                	mv	a0,a5
 3007270:	34f1                	jal	ra,3006d3c <DCL_GPIO_SetDirection>
}
 3007272:	40f2                	lw	ra,28(sp)
 3007274:	4462                	lw	s0,24(sp)
 3007276:	6105                	addi	sp,sp,32
 3007278:	8082                	ret

0300727a <HAL_GPIO_SetValue>:
  * @param pins OR logical combination of pin.
  * @param value Value of @ref GPIO_Value.
  * @retval None.
  */
void HAL_GPIO_SetValue(GPIO_Handle *handle, unsigned int pins, GPIO_Value value)
{
 300727a:	1101                	addi	sp,sp,-32
 300727c:	ce06                	sw	ra,28(sp)
 300727e:	cc22                	sw	s0,24(sp)
 3007280:	1000                	addi	s0,sp,32
 3007282:	fea42623          	sw	a0,-20(s0)
 3007286:	feb42423          	sw	a1,-24(s0)
 300728a:	fec42223          	sw	a2,-28(s0)
    GPIO_ASSERT_PARAM(handle != NULL);
 300728e:	fec42783          	lw	a5,-20(s0)
 3007292:	eb89                	bnez	a5,30072a4 <HAL_GPIO_SetValue+0x2a>
 3007294:	05f00593          	li	a1,95
 3007298:	030117b7          	lui	a5,0x3011
 300729c:	95478513          	addi	a0,a5,-1708 # 3010954 <g_crgIpMatch+0x444>
 30072a0:	20d1                	jal	ra,3007364 <AssertErrorLog.trans.4>
 30072a2:	a001                	j	30072a2 <HAL_GPIO_SetValue+0x28>
    GPIO_ASSERT_PARAM(IsGPIOInstance(handle->baseAddress));
 30072a4:	fec42783          	lw	a5,-20(s0)
 30072a8:	4398                	lw	a4,0(a5)
 30072aa:	145007b7          	lui	a5,0x14500
 30072ae:	04f70d63          	beq	a4,a5,3007308 <HAL_GPIO_SetValue+0x8e>
 30072b2:	fec42783          	lw	a5,-20(s0)
 30072b6:	4398                	lw	a4,0(a5)
 30072b8:	145017b7          	lui	a5,0x14501
 30072bc:	04f70663          	beq	a4,a5,3007308 <HAL_GPIO_SetValue+0x8e>
 30072c0:	fec42783          	lw	a5,-20(s0)
 30072c4:	4398                	lw	a4,0(a5)
 30072c6:	145027b7          	lui	a5,0x14502
 30072ca:	02f70f63          	beq	a4,a5,3007308 <HAL_GPIO_SetValue+0x8e>
 30072ce:	fec42783          	lw	a5,-20(s0)
 30072d2:	4398                	lw	a4,0(a5)
 30072d4:	145037b7          	lui	a5,0x14503
 30072d8:	02f70863          	beq	a4,a5,3007308 <HAL_GPIO_SetValue+0x8e>
 30072dc:	fec42783          	lw	a5,-20(s0)
 30072e0:	4398                	lw	a4,0(a5)
 30072e2:	145047b7          	lui	a5,0x14504
 30072e6:	02f70163          	beq	a4,a5,3007308 <HAL_GPIO_SetValue+0x8e>
 30072ea:	fec42783          	lw	a5,-20(s0)
 30072ee:	4398                	lw	a4,0(a5)
 30072f0:	145057b7          	lui	a5,0x14505
 30072f4:	00f70a63          	beq	a4,a5,3007308 <HAL_GPIO_SetValue+0x8e>
 30072f8:	06000593          	li	a1,96
 30072fc:	030117b7          	lui	a5,0x3011
 3007300:	95478513          	addi	a0,a5,-1708 # 3010954 <g_crgIpMatch+0x444>
 3007304:	2085                	jal	ra,3007364 <AssertErrorLog.trans.4>
 3007306:	a001                	j	3007306 <HAL_GPIO_SetValue+0x8c>
    GPIO_PARAM_CHECK_NO_RET(IsGpioPins(pins));
 3007308:	fe842503          	lw	a0,-24(s0)
 300730c:	38a9                	jal	ra,3006b66 <IsGpioPins>
 300730e:	87aa                	mv	a5,a0
 3007310:	0017c793          	xori	a5,a5,1
 3007314:	9f81                	uxtb	a5
 3007316:	cb89                	beqz	a5,3007328 <HAL_GPIO_SetValue+0xae>
 3007318:	06100593          	li	a1,97
 300731c:	030117b7          	lui	a5,0x3011
 3007320:	95478513          	addi	a0,a5,-1708 # 3010954 <g_crgIpMatch+0x444>
 3007324:	2081                	jal	ra,3007364 <AssertErrorLog.trans.4>
 3007326:	a81d                	j	300735c <HAL_GPIO_SetValue+0xe2>
    GPIO_PARAM_CHECK_NO_RET(IsGpioValue(value));
 3007328:	fe442503          	lw	a0,-28(s0)
 300732c:	fe2ff0ef          	jal	ra,3006b0e <IsGpioValue>
 3007330:	87aa                	mv	a5,a0
 3007332:	0017c793          	xori	a5,a5,1
 3007336:	9f81                	uxtb	a5
 3007338:	cb89                	beqz	a5,300734a <HAL_GPIO_SetValue+0xd0>
 300733a:	06200593          	li	a1,98
 300733e:	030117b7          	lui	a5,0x3011
 3007342:	95478513          	addi	a0,a5,-1708 # 3010954 <g_crgIpMatch+0x444>
 3007346:	2839                	jal	ra,3007364 <AssertErrorLog.trans.4>
 3007348:	a811                	j	300735c <HAL_GPIO_SetValue+0xe2>
    DCL_GPIO_SetValue(handle->baseAddress, pins, value);
 300734a:	fec42783          	lw	a5,-20(s0)
 300734e:	439c                	lw	a5,0(a5)
 3007350:	fe442603          	lw	a2,-28(s0)
 3007354:	fe842583          	lw	a1,-24(s0)
 3007358:	853e                	mv	a0,a5
 300735a:	3239                	jal	ra,3006c68 <DCL_GPIO_SetValue>
}
 300735c:	40f2                	lw	ra,28(sp)
 300735e:	4462                	lw	s0,24(sp)
 3007360:	6105                	addi	sp,sp,32
 3007362:	8082                	ret

03007364 <AssertErrorLog.trans.4>:
 3007364:	9dbfb06f          	j	3002d3e <AssertErrorLog>

03007368 <GPIO_SetLevelIrqType>:
  * @param pins OR logical combination of pin.
  * @param mode Value of @ref GPIO_InterruptMode.
  * @retval None.
  */
static void GPIO_SetLevelIrqType(GPIO_Handle *handle, unsigned int pins, GPIO_InterruptMode mode)
{
 3007368:	1101                	addi	sp,sp,-32
 300736a:	ce22                	sw	s0,28(sp)
 300736c:	1000                	addi	s0,sp,32
 300736e:	fea42623          	sw	a0,-20(s0)
 3007372:	feb42423          	sw	a1,-24(s0)
 3007376:	fec42223          	sw	a2,-28(s0)
    handle->baseAddress->GPIO_IBE.reg &= ~pins; /* Disable edge detection */
 300737a:	fec42783          	lw	a5,-20(s0)
 300737e:	439c                	lw	a5,0(a5)
 3007380:	4087a683          	lw	a3,1032(a5)
 3007384:	fe842783          	lw	a5,-24(s0)
 3007388:	fff7c713          	not	a4,a5
 300738c:	fec42783          	lw	a5,-20(s0)
 3007390:	439c                	lw	a5,0(a5)
 3007392:	8f75                	and	a4,a4,a3
 3007394:	40e7a423          	sw	a4,1032(a5)
    handle->baseAddress->GPIO_IS.reg |= pins; /* Enable level detection */
 3007398:	fec42783          	lw	a5,-20(s0)
 300739c:	439c                	lw	a5,0(a5)
 300739e:	4047a683          	lw	a3,1028(a5)
 30073a2:	fec42783          	lw	a5,-20(s0)
 30073a6:	439c                	lw	a5,0(a5)
 30073a8:	fe842703          	lw	a4,-24(s0)
 30073ac:	8f55                	or	a4,a4,a3
 30073ae:	40e7a223          	sw	a4,1028(a5)
    if (mode == GPIO_INT_TYPE_HIGH_LEVEL) {
 30073b2:	fe442703          	lw	a4,-28(s0)
 30073b6:	478d                	li	a5,3
 30073b8:	02f71063          	bne	a4,a5,30073d8 <GPIO_SetLevelIrqType+0x70>
        handle->baseAddress->GPIO_IEV.reg |= pins;
 30073bc:	fec42783          	lw	a5,-20(s0)
 30073c0:	439c                	lw	a5,0(a5)
 30073c2:	40c7a683          	lw	a3,1036(a5)
 30073c6:	fec42783          	lw	a5,-20(s0)
 30073ca:	439c                	lw	a5,0(a5)
 30073cc:	fe842703          	lw	a4,-24(s0)
 30073d0:	8f55                	or	a4,a4,a3
 30073d2:	40e7a623          	sw	a4,1036(a5)
    } else {
        handle->baseAddress->GPIO_IEV.reg &= ~pins;
    }
}
 30073d6:	a005                	j	30073f6 <GPIO_SetLevelIrqType+0x8e>
        handle->baseAddress->GPIO_IEV.reg &= ~pins;
 30073d8:	fec42783          	lw	a5,-20(s0)
 30073dc:	439c                	lw	a5,0(a5)
 30073de:	40c7a683          	lw	a3,1036(a5)
 30073e2:	fe842783          	lw	a5,-24(s0)
 30073e6:	fff7c713          	not	a4,a5
 30073ea:	fec42783          	lw	a5,-20(s0)
 30073ee:	439c                	lw	a5,0(a5)
 30073f0:	8f75                	and	a4,a4,a3
 30073f2:	40e7a623          	sw	a4,1036(a5)
}
 30073f6:	0001                	nop
 30073f8:	4472                	lw	s0,28(sp)
 30073fa:	6105                	addi	sp,sp,32
 30073fc:	8082                	ret

030073fe <GPIO_SetEdgeIrqType>:
  * @param pins OR logical combination of pin.
  * @param mode Value of @ref GPIO_InterruptMode.
  * @retval None.
  */
static void GPIO_SetEdgeIrqType(GPIO_Handle *handle, unsigned int pins, GPIO_InterruptMode mode)
{
 30073fe:	1101                	addi	sp,sp,-32
 3007400:	ce22                	sw	s0,28(sp)
 3007402:	1000                	addi	s0,sp,32
 3007404:	fea42623          	sw	a0,-20(s0)
 3007408:	feb42423          	sw	a1,-24(s0)
 300740c:	fec42223          	sw	a2,-28(s0)
    handle->baseAddress->GPIO_IS.reg &= ~pins; /* Disable level detection. */
 3007410:	fec42783          	lw	a5,-20(s0)
 3007414:	439c                	lw	a5,0(a5)
 3007416:	4047a683          	lw	a3,1028(a5)
 300741a:	fe842783          	lw	a5,-24(s0)
 300741e:	fff7c713          	not	a4,a5
 3007422:	fec42783          	lw	a5,-20(s0)
 3007426:	439c                	lw	a5,0(a5)
 3007428:	8f75                	and	a4,a4,a3
 300742a:	40e7a223          	sw	a4,1028(a5)
    handle->baseAddress->GPIO_IBE.reg &= ~pins; /* Clear detection on both edges. */
 300742e:	fec42783          	lw	a5,-20(s0)
 3007432:	439c                	lw	a5,0(a5)
 3007434:	4087a683          	lw	a3,1032(a5)
 3007438:	fe842783          	lw	a5,-24(s0)
 300743c:	fff7c713          	not	a4,a5
 3007440:	fec42783          	lw	a5,-20(s0)
 3007444:	439c                	lw	a5,0(a5)
 3007446:	8f75                	and	a4,a4,a3
 3007448:	40e7a423          	sw	a4,1032(a5)
    if (mode == GPIO_INT_TYPE_RISE_EDGE) {
 300744c:	fe442703          	lw	a4,-28(s0)
 3007450:	4785                	li	a5,1
 3007452:	02f71063          	bne	a4,a5,3007472 <GPIO_SetEdgeIrqType+0x74>
        handle->baseAddress->GPIO_IEV.reg |= pins;
 3007456:	fec42783          	lw	a5,-20(s0)
 300745a:	439c                	lw	a5,0(a5)
 300745c:	40c7a683          	lw	a3,1036(a5)
 3007460:	fec42783          	lw	a5,-20(s0)
 3007464:	439c                	lw	a5,0(a5)
 3007466:	fe842703          	lw	a4,-24(s0)
 300746a:	8f55                	or	a4,a4,a3
 300746c:	40e7a623          	sw	a4,1036(a5)
    } else {
        handle->baseAddress->GPIO_IEV.reg &= ~pins;
    }
}
 3007470:	a005                	j	3007490 <GPIO_SetEdgeIrqType+0x92>
        handle->baseAddress->GPIO_IEV.reg &= ~pins;
 3007472:	fec42783          	lw	a5,-20(s0)
 3007476:	439c                	lw	a5,0(a5)
 3007478:	40c7a683          	lw	a3,1036(a5)
 300747c:	fe842783          	lw	a5,-24(s0)
 3007480:	fff7c713          	not	a4,a5
 3007484:	fec42783          	lw	a5,-20(s0)
 3007488:	439c                	lw	a5,0(a5)
 300748a:	8f75                	and	a4,a4,a3
 300748c:	40e7a623          	sw	a4,1036(a5)
}
 3007490:	0001                	nop
 3007492:	4472                	lw	s0,28(sp)
 3007494:	6105                	addi	sp,sp,32
 3007496:	8082                	ret

03007498 <HAL_GPIO_SetIrqType>:
  * @param pins OR logical combination of pin.
  * @param mode Value of @ref GPIO_InterruptMode.
  * @retval Value of @ref BASE_StatusType.
  */
BASE_StatusType HAL_GPIO_SetIrqType(GPIO_Handle *handle, unsigned int pins, GPIO_InterruptMode mode)
{
 3007498:	1101                	addi	sp,sp,-32
 300749a:	ce06                	sw	ra,28(sp)
 300749c:	cc22                	sw	s0,24(sp)
 300749e:	1000                	addi	s0,sp,32
 30074a0:	fea42623          	sw	a0,-20(s0)
 30074a4:	feb42423          	sw	a1,-24(s0)
 30074a8:	fec42223          	sw	a2,-28(s0)
    GPIO_ASSERT_PARAM(handle != NULL);
 30074ac:	fec42783          	lw	a5,-20(s0)
 30074b0:	eb89                	bnez	a5,30074c2 <HAL_GPIO_SetIrqType+0x2a>
 30074b2:	0ef00593          	li	a1,239
 30074b6:	030117b7          	lui	a5,0x3011
 30074ba:	95478513          	addi	a0,a5,-1708 # 3010954 <g_crgIpMatch+0x444>
 30074be:	355d                	jal	ra,3007364 <AssertErrorLog.trans.4>
 30074c0:	a001                	j	30074c0 <HAL_GPIO_SetIrqType+0x28>
    GPIO_ASSERT_PARAM(IsGPIOInstance(handle->baseAddress));
 30074c2:	fec42783          	lw	a5,-20(s0)
 30074c6:	4398                	lw	a4,0(a5)
 30074c8:	145007b7          	lui	a5,0x14500
 30074cc:	04f70d63          	beq	a4,a5,3007526 <HAL_GPIO_SetIrqType+0x8e>
 30074d0:	fec42783          	lw	a5,-20(s0)
 30074d4:	4398                	lw	a4,0(a5)
 30074d6:	145017b7          	lui	a5,0x14501
 30074da:	04f70663          	beq	a4,a5,3007526 <HAL_GPIO_SetIrqType+0x8e>
 30074de:	fec42783          	lw	a5,-20(s0)
 30074e2:	4398                	lw	a4,0(a5)
 30074e4:	145027b7          	lui	a5,0x14502
 30074e8:	02f70f63          	beq	a4,a5,3007526 <HAL_GPIO_SetIrqType+0x8e>
 30074ec:	fec42783          	lw	a5,-20(s0)
 30074f0:	4398                	lw	a4,0(a5)
 30074f2:	145037b7          	lui	a5,0x14503
 30074f6:	02f70863          	beq	a4,a5,3007526 <HAL_GPIO_SetIrqType+0x8e>
 30074fa:	fec42783          	lw	a5,-20(s0)
 30074fe:	4398                	lw	a4,0(a5)
 3007500:	145047b7          	lui	a5,0x14504
 3007504:	02f70163          	beq	a4,a5,3007526 <HAL_GPIO_SetIrqType+0x8e>
 3007508:	fec42783          	lw	a5,-20(s0)
 300750c:	4398                	lw	a4,0(a5)
 300750e:	145057b7          	lui	a5,0x14505
 3007512:	00f70a63          	beq	a4,a5,3007526 <HAL_GPIO_SetIrqType+0x8e>
 3007516:	0f000593          	li	a1,240
 300751a:	030117b7          	lui	a5,0x3011
 300751e:	95478513          	addi	a0,a5,-1708 # 3010954 <g_crgIpMatch+0x444>
 3007522:	3589                	jal	ra,3007364 <AssertErrorLog.trans.4>
 3007524:	a001                	j	3007524 <HAL_GPIO_SetIrqType+0x8c>
    GPIO_PARAM_CHECK_WITH_RET(IsGpioPins(pins), BASE_STATUS_ERROR);
 3007526:	fe842503          	lw	a0,-24(s0)
 300752a:	e3cff0ef          	jal	ra,3006b66 <IsGpioPins>
 300752e:	87aa                	mv	a5,a0
 3007530:	0017c793          	xori	a5,a5,1
 3007534:	9f81                	uxtb	a5
 3007536:	cb91                	beqz	a5,300754a <HAL_GPIO_SetIrqType+0xb2>
 3007538:	0f100593          	li	a1,241
 300753c:	030117b7          	lui	a5,0x3011
 3007540:	95478513          	addi	a0,a5,-1708 # 3010954 <g_crgIpMatch+0x444>
 3007544:	3505                	jal	ra,3007364 <AssertErrorLog.trans.4>
 3007546:	4785                	li	a5,1
 3007548:	aa89                	j	300769a <HAL_GPIO_SetIrqType+0x202>
    GPIO_PARAM_CHECK_WITH_RET(IsGpioITMode(mode), BASE_STATUS_ERROR);
 300754a:	fe442503          	lw	a0,-28(s0)
 300754e:	ec6ff0ef          	jal	ra,3006c14 <IsGpioITMode>
 3007552:	87aa                	mv	a5,a0
 3007554:	0017c793          	xori	a5,a5,1
 3007558:	9f81                	uxtb	a5
 300755a:	cb91                	beqz	a5,300756e <HAL_GPIO_SetIrqType+0xd6>
 300755c:	0f200593          	li	a1,242
 3007560:	030117b7          	lui	a5,0x3011
 3007564:	95478513          	addi	a0,a5,-1708 # 3010954 <g_crgIpMatch+0x444>
 3007568:	3bf5                	jal	ra,3007364 <AssertErrorLog.trans.4>
 300756a:	4785                	li	a5,1
 300756c:	a23d                	j	300769a <HAL_GPIO_SetIrqType+0x202>

    /* It must be disabled to avoid triggering interrupts during configuration. */
    DCL_GPIO_DisableIrq(handle->baseAddress, pins);
 300756e:	fec42783          	lw	a5,-20(s0)
 3007572:	439c                	lw	a5,0(a5)
 3007574:	fe842583          	lw	a1,-24(s0)
 3007578:	853e                	mv	a0,a5
 300757a:	3439                	jal	ra,3006f88 <DCL_GPIO_DisableIrq>

    if ((mode == GPIO_INT_TYPE_HIGH_LEVEL) || (mode == GPIO_INT_TYPE_LOW_LEVEL)) {
 300757c:	fe442703          	lw	a4,-28(s0)
 3007580:	478d                	li	a5,3
 3007582:	00f70763          	beq	a4,a5,3007590 <HAL_GPIO_SetIrqType+0xf8>
 3007586:	fe442703          	lw	a4,-28(s0)
 300758a:	4789                	li	a5,2
 300758c:	00f71a63          	bne	a4,a5,30075a0 <HAL_GPIO_SetIrqType+0x108>
        GPIO_SetLevelIrqType(handle, pins, mode);
 3007590:	fe442603          	lw	a2,-28(s0)
 3007594:	fe842583          	lw	a1,-24(s0)
 3007598:	fec42503          	lw	a0,-20(s0)
 300759c:	33f1                	jal	ra,3007368 <GPIO_SetLevelIrqType>
 300759e:	a0f5                	j	300768a <HAL_GPIO_SetIrqType+0x1f2>
    } else if (mode == GPIO_INT_TYPE_BOTH_EDGE) {
 30075a0:	fe442703          	lw	a4,-28(s0)
 30075a4:	4791                	li	a5,4
 30075a6:	04f71e63          	bne	a4,a5,3007602 <HAL_GPIO_SetIrqType+0x16a>
        handle->baseAddress->GPIO_IEV.reg &= ~pins;
 30075aa:	fec42783          	lw	a5,-20(s0)
 30075ae:	439c                	lw	a5,0(a5)
 30075b0:	40c7a683          	lw	a3,1036(a5)
 30075b4:	fe842783          	lw	a5,-24(s0)
 30075b8:	fff7c713          	not	a4,a5
 30075bc:	fec42783          	lw	a5,-20(s0)
 30075c0:	439c                	lw	a5,0(a5)
 30075c2:	8f75                	and	a4,a4,a3
 30075c4:	40e7a623          	sw	a4,1036(a5)
        handle->baseAddress->GPIO_IS.reg &= ~pins;
 30075c8:	fec42783          	lw	a5,-20(s0)
 30075cc:	439c                	lw	a5,0(a5)
 30075ce:	4047a683          	lw	a3,1028(a5)
 30075d2:	fe842783          	lw	a5,-24(s0)
 30075d6:	fff7c713          	not	a4,a5
 30075da:	fec42783          	lw	a5,-20(s0)
 30075de:	439c                	lw	a5,0(a5)
 30075e0:	8f75                	and	a4,a4,a3
 30075e2:	40e7a223          	sw	a4,1028(a5)
        handle->baseAddress->GPIO_IBE.reg |= pins;
 30075e6:	fec42783          	lw	a5,-20(s0)
 30075ea:	439c                	lw	a5,0(a5)
 30075ec:	4087a683          	lw	a3,1032(a5)
 30075f0:	fec42783          	lw	a5,-20(s0)
 30075f4:	439c                	lw	a5,0(a5)
 30075f6:	fe842703          	lw	a4,-24(s0)
 30075fa:	8f55                	or	a4,a4,a3
 30075fc:	40e7a423          	sw	a4,1032(a5)
 3007600:	a069                	j	300768a <HAL_GPIO_SetIrqType+0x1f2>
    } else if ((mode == GPIO_INT_TYPE_RISE_EDGE) || (mode == GPIO_INT_TYPE_FALL_EDGE)) {
 3007602:	fe442703          	lw	a4,-28(s0)
 3007606:	4785                	li	a5,1
 3007608:	00f70563          	beq	a4,a5,3007612 <HAL_GPIO_SetIrqType+0x17a>
 300760c:	fe442783          	lw	a5,-28(s0)
 3007610:	eb89                	bnez	a5,3007622 <HAL_GPIO_SetIrqType+0x18a>
        GPIO_SetEdgeIrqType(handle, pins, mode);
 3007612:	fe442603          	lw	a2,-28(s0)
 3007616:	fe842583          	lw	a1,-24(s0)
 300761a:	fec42503          	lw	a0,-20(s0)
 300761e:	33c5                	jal	ra,30073fe <GPIO_SetEdgeIrqType>
 3007620:	a0ad                	j	300768a <HAL_GPIO_SetIrqType+0x1f2>
    } else if (mode == GPIO_INT_TYPE_NONE) {
 3007622:	fe442703          	lw	a4,-28(s0)
 3007626:	4795                	li	a5,5
 3007628:	06f71163          	bne	a4,a5,300768a <HAL_GPIO_SetIrqType+0x1f2>
        /* No interruptMode: disable everything. */
        handle->baseAddress->GPIO_IEV.reg &= ~pins;
 300762c:	fec42783          	lw	a5,-20(s0)
 3007630:	439c                	lw	a5,0(a5)
 3007632:	40c7a683          	lw	a3,1036(a5)
 3007636:	fe842783          	lw	a5,-24(s0)
 300763a:	fff7c713          	not	a4,a5
 300763e:	fec42783          	lw	a5,-20(s0)
 3007642:	439c                	lw	a5,0(a5)
 3007644:	8f75                	and	a4,a4,a3
 3007646:	40e7a623          	sw	a4,1036(a5)
        handle->baseAddress->GPIO_IS.reg &= ~pins;
 300764a:	fec42783          	lw	a5,-20(s0)
 300764e:	439c                	lw	a5,0(a5)
 3007650:	4047a683          	lw	a3,1028(a5)
 3007654:	fe842783          	lw	a5,-24(s0)
 3007658:	fff7c713          	not	a4,a5
 300765c:	fec42783          	lw	a5,-20(s0)
 3007660:	439c                	lw	a5,0(a5)
 3007662:	8f75                	and	a4,a4,a3
 3007664:	40e7a223          	sw	a4,1028(a5)
        handle->baseAddress->GPIO_IBE.reg &= ~pins;
 3007668:	fec42783          	lw	a5,-20(s0)
 300766c:	439c                	lw	a5,0(a5)
 300766e:	4087a683          	lw	a3,1032(a5)
 3007672:	fe842783          	lw	a5,-24(s0)
 3007676:	fff7c713          	not	a4,a5
 300767a:	fec42783          	lw	a5,-20(s0)
 300767e:	439c                	lw	a5,0(a5)
 3007680:	8f75                	and	a4,a4,a3
 3007682:	40e7a423          	sw	a4,1032(a5)
        return BASE_STATUS_ERROR;
 3007686:	4785                	li	a5,1
 3007688:	a809                	j	300769a <HAL_GPIO_SetIrqType+0x202>
    }

    DCL_GPIO_EnableIrq(handle->baseAddress, pins);
 300768a:	fec42783          	lw	a5,-20(s0)
 300768e:	439c                	lw	a5,0(a5)
 3007690:	fe842583          	lw	a1,-24(s0)
 3007694:	853e                	mv	a0,a5
 3007696:	3089                	jal	ra,3006ed8 <DCL_GPIO_EnableIrq>
    return BASE_STATUS_OK;
 3007698:	4781                	li	a5,0
}
 300769a:	853e                	mv	a0,a5
 300769c:	40f2                	lw	ra,28(sp)
 300769e:	4462                	lw	s0,24(sp)
 30076a0:	6105                	addi	sp,sp,32
 30076a2:	8082                	ret

030076a4 <GPIO_ExcuteCallBack>:
  * @param handle Value of @ref GPIO_Handle.
  * @param pin Value of @ref GPIO_PIN.
  * @retval None.
  */
static void GPIO_ExcuteCallBack(GPIO_Handle *handle, GPIO_PIN pin)
{
 30076a4:	7179                	addi	sp,sp,-48
 30076a6:	d606                	sw	ra,44(sp)
 30076a8:	d422                	sw	s0,40(sp)
 30076aa:	1800                	addi	s0,sp,48
 30076ac:	fca42e23          	sw	a0,-36(s0)
 30076b0:	fcb42c23          	sw	a1,-40(s0)
    GPIO_ASSERT_PARAM(handle != NULL);
 30076b4:	fdc42783          	lw	a5,-36(s0)
 30076b8:	eb89                	bnez	a5,30076ca <GPIO_ExcuteCallBack+0x26>
 30076ba:	11300593          	li	a1,275
 30076be:	030117b7          	lui	a5,0x3011
 30076c2:	95478513          	addi	a0,a5,-1708 # 3010954 <g_crgIpMatch+0x444>
 30076c6:	3979                	jal	ra,3007364 <AssertErrorLog.trans.4>
 30076c8:	a001                	j	30076c8 <GPIO_ExcuteCallBack+0x24>
    GPIO_ASSERT_PARAM(IsGPIOInstance(handle->baseAddress));
 30076ca:	fdc42783          	lw	a5,-36(s0)
 30076ce:	4398                	lw	a4,0(a5)
 30076d0:	145007b7          	lui	a5,0x14500
 30076d4:	04f70d63          	beq	a4,a5,300772e <GPIO_ExcuteCallBack+0x8a>
 30076d8:	fdc42783          	lw	a5,-36(s0)
 30076dc:	4398                	lw	a4,0(a5)
 30076de:	145017b7          	lui	a5,0x14501
 30076e2:	04f70663          	beq	a4,a5,300772e <GPIO_ExcuteCallBack+0x8a>
 30076e6:	fdc42783          	lw	a5,-36(s0)
 30076ea:	4398                	lw	a4,0(a5)
 30076ec:	145027b7          	lui	a5,0x14502
 30076f0:	02f70f63          	beq	a4,a5,300772e <GPIO_ExcuteCallBack+0x8a>
 30076f4:	fdc42783          	lw	a5,-36(s0)
 30076f8:	4398                	lw	a4,0(a5)
 30076fa:	145037b7          	lui	a5,0x14503
 30076fe:	02f70863          	beq	a4,a5,300772e <GPIO_ExcuteCallBack+0x8a>
 3007702:	fdc42783          	lw	a5,-36(s0)
 3007706:	4398                	lw	a4,0(a5)
 3007708:	145047b7          	lui	a5,0x14504
 300770c:	02f70163          	beq	a4,a5,300772e <GPIO_ExcuteCallBack+0x8a>
 3007710:	fdc42783          	lw	a5,-36(s0)
 3007714:	4398                	lw	a4,0(a5)
 3007716:	145057b7          	lui	a5,0x14505
 300771a:	00f70a63          	beq	a4,a5,300772e <GPIO_ExcuteCallBack+0x8a>
 300771e:	11400593          	li	a1,276
 3007722:	030117b7          	lui	a5,0x3011
 3007726:	95478513          	addi	a0,a5,-1708 # 3010954 <g_crgIpMatch+0x444>
 300772a:	392d                	jal	ra,3007364 <AssertErrorLog.trans.4>
 300772c:	a001                	j	300772c <GPIO_ExcuteCallBack+0x88>
    GPIO_PARAM_CHECK_NO_RET(IsGpioPins(pin));
 300772e:	fd842503          	lw	a0,-40(s0)
 3007732:	c34ff0ef          	jal	ra,3006b66 <IsGpioPins>
 3007736:	87aa                	mv	a5,a0
 3007738:	0017c793          	xori	a5,a5,1
 300773c:	9f81                	uxtb	a5
 300773e:	cb89                	beqz	a5,3007750 <GPIO_ExcuteCallBack+0xac>
 3007740:	11500593          	li	a1,277
 3007744:	030117b7          	lui	a5,0x3011
 3007748:	95478513          	addi	a0,a5,-1708 # 3010954 <g_crgIpMatch+0x444>
 300774c:	3921                	jal	ra,3007364 <AssertErrorLog.trans.4>
 300774e:	a899                	j	30077a4 <GPIO_ExcuteCallBack+0x100>
    for (unsigned int i = 0; i < GPIO_PIN_NUM; i++) {
 3007750:	fe042623          	sw	zero,-20(s0)
 3007754:	a099                	j	300779a <GPIO_ExcuteCallBack+0xf6>
        if (handle->userCallBack.GPIO_CallbackFuncs[i].pin == pin) {
 3007756:	fdc42703          	lw	a4,-36(s0)
 300775a:	fec42783          	lw	a5,-20(s0)
 300775e:	078e                	slli	a5,a5,0x3
 3007760:	97ba                	add	a5,a5,a4
 3007762:	479c                	lw	a5,8(a5)
 3007764:	fd842703          	lw	a4,-40(s0)
 3007768:	02f71463          	bne	a4,a5,3007790 <GPIO_ExcuteCallBack+0xec>
            if (handle->userCallBack.GPIO_CallbackFuncs[i].callbackFunc != NULL) {
 300776c:	fdc42703          	lw	a4,-36(s0)
 3007770:	fec42783          	lw	a5,-20(s0)
 3007774:	078e                	slli	a5,a5,0x3
 3007776:	97ba                	add	a5,a5,a4
 3007778:	47dc                	lw	a5,12(a5)
 300777a:	cb99                	beqz	a5,3007790 <GPIO_ExcuteCallBack+0xec>
                handle->userCallBack.GPIO_CallbackFuncs[i].callbackFunc(handle);
 300777c:	fdc42703          	lw	a4,-36(s0)
 3007780:	fec42783          	lw	a5,-20(s0)
 3007784:	078e                	slli	a5,a5,0x3
 3007786:	97ba                	add	a5,a5,a4
 3007788:	47dc                	lw	a5,12(a5)
 300778a:	fdc42503          	lw	a0,-36(s0)
 300778e:	9782                	jalr	a5
    for (unsigned int i = 0; i < GPIO_PIN_NUM; i++) {
 3007790:	fec42783          	lw	a5,-20(s0)
 3007794:	0785                	addi	a5,a5,1
 3007796:	fef42623          	sw	a5,-20(s0)
 300779a:	fec42703          	lw	a4,-20(s0)
 300779e:	479d                	li	a5,7
 30077a0:	fae7fbe3          	bgeu	a5,a4,3007756 <GPIO_ExcuteCallBack+0xb2>
            }
        }
    }
}
 30077a4:	50b2                	lw	ra,44(sp)
 30077a6:	5422                	lw	s0,40(sp)
 30077a8:	6145                	addi	sp,sp,48
 30077aa:	8082                	ret

030077ac <HAL_GPIO_IrqHandler>:
  * @brief Handle GPIO interrupt request.
  * @param handle Interrupt parameter.
  * @retval None.
  */
void HAL_GPIO_IrqHandler(void *handle)
{
 30077ac:	7179                	addi	sp,sp,-48
 30077ae:	d606                	sw	ra,44(sp)
 30077b0:	d422                	sw	s0,40(sp)
 30077b2:	1800                	addi	s0,sp,48
 30077b4:	fca42e23          	sw	a0,-36(s0)
    GPIO_Handle *gpioHandle = (GPIO_Handle *)handle;
 30077b8:	fdc42783          	lw	a5,-36(s0)
 30077bc:	fef42423          	sw	a5,-24(s0)
    GPIO_ASSERT_PARAM(gpioHandle != NULL);
 30077c0:	fe842783          	lw	a5,-24(s0)
 30077c4:	eb89                	bnez	a5,30077d6 <HAL_GPIO_IrqHandler+0x2a>
 30077c6:	12700593          	li	a1,295
 30077ca:	030117b7          	lui	a5,0x3011
 30077ce:	95478513          	addi	a0,a5,-1708 # 3010954 <g_crgIpMatch+0x444>
 30077d2:	3e49                	jal	ra,3007364 <AssertErrorLog.trans.4>
 30077d4:	a001                	j	30077d4 <HAL_GPIO_IrqHandler+0x28>
    GPIO_ASSERT_PARAM(IsGPIOInstance(gpioHandle->baseAddress));
 30077d6:	fe842783          	lw	a5,-24(s0)
 30077da:	4398                	lw	a4,0(a5)
 30077dc:	145007b7          	lui	a5,0x14500
 30077e0:	04f70d63          	beq	a4,a5,300783a <HAL_GPIO_IrqHandler+0x8e>
 30077e4:	fe842783          	lw	a5,-24(s0)
 30077e8:	4398                	lw	a4,0(a5)
 30077ea:	145017b7          	lui	a5,0x14501
 30077ee:	04f70663          	beq	a4,a5,300783a <HAL_GPIO_IrqHandler+0x8e>
 30077f2:	fe842783          	lw	a5,-24(s0)
 30077f6:	4398                	lw	a4,0(a5)
 30077f8:	145027b7          	lui	a5,0x14502
 30077fc:	02f70f63          	beq	a4,a5,300783a <HAL_GPIO_IrqHandler+0x8e>
 3007800:	fe842783          	lw	a5,-24(s0)
 3007804:	4398                	lw	a4,0(a5)
 3007806:	145037b7          	lui	a5,0x14503
 300780a:	02f70863          	beq	a4,a5,300783a <HAL_GPIO_IrqHandler+0x8e>
 300780e:	fe842783          	lw	a5,-24(s0)
 3007812:	4398                	lw	a4,0(a5)
 3007814:	145047b7          	lui	a5,0x14504
 3007818:	02f70163          	beq	a4,a5,300783a <HAL_GPIO_IrqHandler+0x8e>
 300781c:	fe842783          	lw	a5,-24(s0)
 3007820:	4398                	lw	a4,0(a5)
 3007822:	145057b7          	lui	a5,0x14505
 3007826:	00f70a63          	beq	a4,a5,300783a <HAL_GPIO_IrqHandler+0x8e>
 300782a:	12800593          	li	a1,296
 300782e:	030117b7          	lui	a5,0x3011
 3007832:	95478513          	addi	a0,a5,-1708 # 3010954 <g_crgIpMatch+0x444>
 3007836:	363d                	jal	ra,3007364 <AssertErrorLog.trans.4>
 3007838:	a001                	j	3007838 <HAL_GPIO_IrqHandler+0x8c>
    unsigned int position = 0x00000000U;
 300783a:	fe042623          	sw	zero,-20(s0)
    unsigned int pinCurrent = 0x00000000U;
 300783e:	fe042223          	sw	zero,-28(s0)
    unsigned int mis = DCL_GPIO_GetMIS(gpioHandle->baseAddress); /* Queries the masked GPIO interrupt status. */
 3007842:	fe842783          	lw	a5,-24(s0)
 3007846:	439c                	lw	a5,0(a5)
 3007848:	853e                	mv	a0,a5
 300784a:	fe8ff0ef          	jal	ra,3007032 <DCL_GPIO_GetMIS>
 300784e:	fea42023          	sw	a0,-32(s0)

    /* Determine which pin sets the callback function. */
    while ((mis >> position) != BASE_CFG_UNSET) {
 3007852:	a0b1                	j	300789e <HAL_GPIO_IrqHandler+0xf2>
        pinCurrent = mis & (1 << position);
 3007854:	4705                	li	a4,1
 3007856:	fec42783          	lw	a5,-20(s0)
 300785a:	00f717b3          	sll	a5,a4,a5
 300785e:	873e                	mv	a4,a5
 3007860:	fe042783          	lw	a5,-32(s0)
 3007864:	8ff9                	and	a5,a5,a4
 3007866:	fef42223          	sw	a5,-28(s0)
        if (pinCurrent) {
 300786a:	fe442783          	lw	a5,-28(s0)
 300786e:	c39d                	beqz	a5,3007894 <HAL_GPIO_IrqHandler+0xe8>
            gpioHandle->pins = pinCurrent;
 3007870:	fe842783          	lw	a5,-24(s0)
 3007874:	fe442703          	lw	a4,-28(s0)
 3007878:	c3d8                	sw	a4,4(a5)
            DCL_GPIO_ClearIrq(gpioHandle->baseAddress, pinCurrent);
 300787a:	fe842783          	lw	a5,-24(s0)
 300787e:	439c                	lw	a5,0(a5)
 3007880:	fe442583          	lw	a1,-28(s0)
 3007884:	853e                	mv	a0,a5
 3007886:	dacff0ef          	jal	ra,3006e32 <DCL_GPIO_ClearIrq>
            GPIO_ExcuteCallBack(gpioHandle, pinCurrent);
 300788a:	fe442583          	lw	a1,-28(s0)
 300788e:	fe842503          	lw	a0,-24(s0)
 3007892:	3d09                	jal	ra,30076a4 <GPIO_ExcuteCallBack>
        }
        position++;
 3007894:	fec42783          	lw	a5,-20(s0)
 3007898:	0785                	addi	a5,a5,1
 300789a:	fef42623          	sw	a5,-20(s0)
    while ((mis >> position) != BASE_CFG_UNSET) {
 300789e:	fe042703          	lw	a4,-32(s0)
 30078a2:	fec42783          	lw	a5,-20(s0)
 30078a6:	00f757b3          	srl	a5,a4,a5
 30078aa:	f7cd                	bnez	a5,3007854 <HAL_GPIO_IrqHandler+0xa8>
    }
}
 30078ac:	0001                	nop
 30078ae:	50b2                	lw	ra,44(sp)
 30078b0:	5422                	lw	s0,40(sp)
 30078b2:	6145                	addi	sp,sp,48
 30078b4:	8082                	ret

030078b6 <HAL_GPIO_RegisterCallBack>:
  * @param pin Value of @ref GPIO_PIN.
  * @param pCallback Value of @ref GPIO_CallbackType.
  * @retval None.
  */
void HAL_GPIO_RegisterCallBack(GPIO_Handle *handle, GPIO_PIN pin, GPIO_CallbackType pCallback)
{
 30078b6:	7179                	addi	sp,sp,-48
 30078b8:	d606                	sw	ra,44(sp)
 30078ba:	d422                	sw	s0,40(sp)
 30078bc:	1800                	addi	s0,sp,48
 30078be:	fca42e23          	sw	a0,-36(s0)
 30078c2:	fcb42c23          	sw	a1,-40(s0)
 30078c6:	fcc42a23          	sw	a2,-44(s0)
    GPIO_ASSERT_PARAM(handle != NULL);
 30078ca:	fdc42783          	lw	a5,-36(s0)
 30078ce:	eb89                	bnez	a5,30078e0 <HAL_GPIO_RegisterCallBack+0x2a>
 30078d0:	14200593          	li	a1,322
 30078d4:	030117b7          	lui	a5,0x3011
 30078d8:	95478513          	addi	a0,a5,-1708 # 3010954 <g_crgIpMatch+0x444>
 30078dc:	3461                	jal	ra,3007364 <AssertErrorLog.trans.4>
 30078de:	a001                	j	30078de <HAL_GPIO_RegisterCallBack+0x28>
    GPIO_ASSERT_PARAM(IsGPIOInstance(handle->baseAddress));
 30078e0:	fdc42783          	lw	a5,-36(s0)
 30078e4:	4398                	lw	a4,0(a5)
 30078e6:	145007b7          	lui	a5,0x14500
 30078ea:	04f70d63          	beq	a4,a5,3007944 <HAL_GPIO_RegisterCallBack+0x8e>
 30078ee:	fdc42783          	lw	a5,-36(s0)
 30078f2:	4398                	lw	a4,0(a5)
 30078f4:	145017b7          	lui	a5,0x14501
 30078f8:	04f70663          	beq	a4,a5,3007944 <HAL_GPIO_RegisterCallBack+0x8e>
 30078fc:	fdc42783          	lw	a5,-36(s0)
 3007900:	4398                	lw	a4,0(a5)
 3007902:	145027b7          	lui	a5,0x14502
 3007906:	02f70f63          	beq	a4,a5,3007944 <HAL_GPIO_RegisterCallBack+0x8e>
 300790a:	fdc42783          	lw	a5,-36(s0)
 300790e:	4398                	lw	a4,0(a5)
 3007910:	145037b7          	lui	a5,0x14503
 3007914:	02f70863          	beq	a4,a5,3007944 <HAL_GPIO_RegisterCallBack+0x8e>
 3007918:	fdc42783          	lw	a5,-36(s0)
 300791c:	4398                	lw	a4,0(a5)
 300791e:	145047b7          	lui	a5,0x14504
 3007922:	02f70163          	beq	a4,a5,3007944 <HAL_GPIO_RegisterCallBack+0x8e>
 3007926:	fdc42783          	lw	a5,-36(s0)
 300792a:	4398                	lw	a4,0(a5)
 300792c:	145057b7          	lui	a5,0x14505
 3007930:	00f70a63          	beq	a4,a5,3007944 <HAL_GPIO_RegisterCallBack+0x8e>
 3007934:	14300593          	li	a1,323
 3007938:	030117b7          	lui	a5,0x3011
 300793c:	95478513          	addi	a0,a5,-1708 # 3010954 <g_crgIpMatch+0x444>
 3007940:	3415                	jal	ra,3007364 <AssertErrorLog.trans.4>
 3007942:	a001                	j	3007942 <HAL_GPIO_RegisterCallBack+0x8c>
    GPIO_PARAM_CHECK_NO_RET(IsGpioPin(pin));
 3007944:	fd842503          	lw	a0,-40(s0)
 3007948:	a4eff0ef          	jal	ra,3006b96 <IsGpioPin>
 300794c:	87aa                	mv	a5,a0
 300794e:	0017c793          	xori	a5,a5,1
 3007952:	9f81                	uxtb	a5
 3007954:	cb89                	beqz	a5,3007966 <HAL_GPIO_RegisterCallBack+0xb0>
 3007956:	14400593          	li	a1,324
 300795a:	030117b7          	lui	a5,0x3011
 300795e:	95478513          	addi	a0,a5,-1708 # 3010954 <g_crgIpMatch+0x444>
 3007962:	3409                	jal	ra,3007364 <AssertErrorLog.trans.4>
 3007964:	a091                	j	30079a8 <HAL_GPIO_RegisterCallBack+0xf2>
    for (unsigned int i = 0; i < GPIO_PIN_NUM; i++) {
 3007966:	fe042623          	sw	zero,-20(s0)
 300796a:	a815                	j	300799e <HAL_GPIO_RegisterCallBack+0xe8>
        if (handle->userCallBack.GPIO_CallbackFuncs[i].pin == pin) {
 300796c:	fdc42703          	lw	a4,-36(s0)
 3007970:	fec42783          	lw	a5,-20(s0)
 3007974:	078e                	slli	a5,a5,0x3
 3007976:	97ba                	add	a5,a5,a4
 3007978:	479c                	lw	a5,8(a5)
 300797a:	fd842703          	lw	a4,-40(s0)
 300797e:	00f71b63          	bne	a4,a5,3007994 <HAL_GPIO_RegisterCallBack+0xde>
            handle->userCallBack.GPIO_CallbackFuncs[i].callbackFunc = pCallback;
 3007982:	fdc42703          	lw	a4,-36(s0)
 3007986:	fec42783          	lw	a5,-20(s0)
 300798a:	078e                	slli	a5,a5,0x3
 300798c:	97ba                	add	a5,a5,a4
 300798e:	fd442703          	lw	a4,-44(s0)
 3007992:	c7d8                	sw	a4,12(a5)
    for (unsigned int i = 0; i < GPIO_PIN_NUM; i++) {
 3007994:	fec42783          	lw	a5,-20(s0)
 3007998:	0785                	addi	a5,a5,1
 300799a:	fef42623          	sw	a5,-20(s0)
 300799e:	fec42703          	lw	a4,-20(s0)
 30079a2:	479d                	li	a5,7
 30079a4:	fce7f4e3          	bgeu	a5,a4,300796c <HAL_GPIO_RegisterCallBack+0xb6>
        }
    }
 30079a8:	50b2                	lw	ra,44(sp)
 30079aa:	5422                	lw	s0,40(sp)
 30079ac:	6145                	addi	sp,sp,48
 30079ae:	8082                	ret

030079b0 <IsGptPwmNum>:
  * @param num    Pwm number, only valid if keep equ 0
  * @retval true
  * @retval false
  */
static inline bool IsGptPwmNum(unsigned int num)
{
 30079b0:	1101                	addi	sp,sp,-32
 30079b2:	ce22                	sw	s0,28(sp)
 30079b4:	1000                	addi	s0,sp,32
 30079b6:	fea42623          	sw	a0,-20(s0)
    return ((num) <= GPT_PWM_MAX_NUM);
 30079ba:	fec42783          	lw	a5,-20(s0)
 30079be:	4007b793          	sltiu	a5,a5,1024
 30079c2:	9f81                	uxtb	a5
}
 30079c4:	853e                	mv	a0,a5
 30079c6:	4472                	lw	s0,28(sp)
 30079c8:	6105                	addi	sp,sp,32
 30079ca:	8082                	ret

030079cc <IsGptDiv>:
  * @param div  division factor of GPT
  * @retval true
  * @retval false
  */
static inline bool IsGptDiv(unsigned int div)
{
 30079cc:	1101                	addi	sp,sp,-32
 30079ce:	ce22                	sw	s0,28(sp)
 30079d0:	1000                	addi	s0,sp,32
 30079d2:	fea42623          	sw	a0,-20(s0)
    return (div <= GPT_PWM_DIV_FACTOR_MAX_VALUE);
 30079d6:	fec42703          	lw	a4,-20(s0)
 30079da:	6785                	lui	a5,0x1
 30079dc:	00f737b3          	sltu	a5,a4,a5
 30079e0:	9f81                	uxtb	a5
}
 30079e2:	853e                	mv	a0,a5
 30079e4:	4472                	lw	s0,28(sp)
 30079e6:	6105                	addi	sp,sp,32
 30079e8:	8082                	ret

030079ea <IsGptPeriod>:
  * @param period  Period of GPT
  * @retval true
  * @retval false
  */
static inline bool IsGptPeriod(unsigned int period)
{
 30079ea:	1101                	addi	sp,sp,-32
 30079ec:	ce22                	sw	s0,28(sp)
 30079ee:	1000                	addi	s0,sp,32
 30079f0:	fea42623          	sw	a0,-20(s0)
    return ((period >= GPT_PWM_PERIOD_MIN_VALUE) && (period <= GPT_PWM_PERIOD_MAX_VALUE));
 30079f4:	fec42703          	lw	a4,-20(s0)
 30079f8:	4785                	li	a5,1
 30079fa:	00e7f963          	bgeu	a5,a4,3007a0c <IsGptPeriod+0x22>
 30079fe:	fec42703          	lw	a4,-20(s0)
 3007a02:	67c1                	lui	a5,0x10
 3007a04:	00f77463          	bgeu	a4,a5,3007a0c <IsGptPeriod+0x22>
 3007a08:	4785                	li	a5,1
 3007a0a:	a011                	j	3007a0e <IsGptPeriod+0x24>
 3007a0c:	4781                	li	a5,0
 3007a0e:	8b85                	andi	a5,a5,1
 3007a10:	9f81                	uxtb	a5
}
 3007a12:	853e                	mv	a0,a5
 3007a14:	4472                	lw	s0,28(sp)
 3007a16:	6105                	addi	sp,sp,32
 3007a18:	8082                	ret

03007a1a <IsGptRefDot>:
  * @param  value  value of GPT ref dot
  * @retval true
  * @retval false
  */
static inline bool IsGptRefDot(unsigned int value)
{
 3007a1a:	1101                	addi	sp,sp,-32
 3007a1c:	ce22                	sw	s0,28(sp)
 3007a1e:	1000                	addi	s0,sp,32
 3007a20:	fea42623          	sw	a0,-20(s0)
    return (value <= GPT_TC_PRD_MAX_VALUE);
 3007a24:	fec42703          	lw	a4,-20(s0)
 3007a28:	67c1                	lui	a5,0x10
 3007a2a:	00f737b3          	sltu	a5,a4,a5
 3007a2e:	9f81                	uxtb	a5
}
 3007a30:	853e                	mv	a0,a5
 3007a32:	4472                	lw	s0,28(sp)
 3007a34:	6105                	addi	sp,sp,32
 3007a36:	8082                	ret

03007a38 <IsGptAction>:
  * @param period  Period of GPT
  * @retval true
  * @retval false
  */
static inline bool IsGptAction(unsigned int action)
{
 3007a38:	1101                	addi	sp,sp,-32
 3007a3a:	ce22                	sw	s0,28(sp)
 3007a3c:	1000                	addi	s0,sp,32
 3007a3e:	fea42623          	sw	a0,-20(s0)
    return (action <= GPT_ACTION_OUTPUT_FLIP);
 3007a42:	fec42783          	lw	a5,-20(s0)
 3007a46:	0047b793          	sltiu	a5,a5,4
 3007a4a:	9f81                	uxtb	a5
}
 3007a4c:	853e                	mv	a0,a5
 3007a4e:	4472                	lw	s0,28(sp)
 3007a50:	6105                	addi	sp,sp,32
 3007a52:	8082                	ret

03007a54 <GPT_GetKeepState>:
 * @param   handle   GPT Handle
 * @retval  keep   0: Outputs a fixed number of square waves
 *                 1: Output continuous square wave
 */
static unsigned int GPT_GetKeepState(GPT_Handle *handle)
{
 3007a54:	7179                	addi	sp,sp,-48
 3007a56:	d622                	sw	s0,44(sp)
 3007a58:	1800                	addi	s0,sp,48
 3007a5a:	fca42e23          	sw	a0,-36(s0)
    GPT_PWM0_CFG_REG pwm0Cfg;
    pwm0Cfg.reg = handle->baseAddress->GPT_PWM0_CFG.reg;
 3007a5e:	fdc42783          	lw	a5,-36(s0)
 3007a62:	439c                	lw	a5,0(a5)
 3007a64:	4007a783          	lw	a5,1024(a5) # 10400 <RAM_SIZE+0xb400>
 3007a68:	fef42623          	sw	a5,-20(s0)
    return pwm0Cfg.BIT.rg_pwm0_keep;
 3007a6c:	fec42783          	lw	a5,-20(s0)
 3007a70:	83fd                	srli	a5,a5,0x1f
 3007a72:	9f81                	uxtb	a5
}
 3007a74:	853e                	mv	a0,a5
 3007a76:	5432                	lw	s0,44(sp)
 3007a78:	6145                	addi	sp,sp,48
 3007a7a:	8082                	ret

03007a7c <HAL_GPT_Init>:
 * @param   handle   GPT Handle.
 * @retval  BASE_STATUS_OK   Success
 * @retval  BASE_STATUS_ERROR Paramter check fail
 */
BASE_StatusType HAL_GPT_Init(GPT_Handle *handle)
{
 3007a7c:	1101                	addi	sp,sp,-32
 3007a7e:	ce06                	sw	ra,28(sp)
 3007a80:	cc22                	sw	s0,24(sp)
 3007a82:	1000                	addi	s0,sp,32
 3007a84:	fea42623          	sw	a0,-20(s0)
    GPT_ASSERT_PARAM(handle != NULL);
 3007a88:	fec42783          	lw	a5,-20(s0)
 3007a8c:	eb89                	bnez	a5,3007a9e <HAL_GPT_Init+0x22>
 3007a8e:	03500593          	li	a1,53
 3007a92:	030117b7          	lui	a5,0x3011
 3007a96:	97078513          	addi	a0,a5,-1680 # 3010970 <g_crgIpMatch+0x460>
 3007a9a:	30e9                	jal	ra,3007364 <AssertErrorLog.trans.4>
 3007a9c:	a001                	j	3007a9c <HAL_GPT_Init+0x20>
    GPT_ASSERT_PARAM(IsGPTInstance(handle->baseAddress));
 3007a9e:	fec42783          	lw	a5,-20(s0)
 3007aa2:	4398                	lw	a4,0(a5)
 3007aa4:	147007b7          	lui	a5,0x14700
 3007aa8:	02f70f63          	beq	a4,a5,3007ae6 <HAL_GPT_Init+0x6a>
 3007aac:	fec42783          	lw	a5,-20(s0)
 3007ab0:	4398                	lw	a4,0(a5)
 3007ab2:	147017b7          	lui	a5,0x14701
 3007ab6:	02f70863          	beq	a4,a5,3007ae6 <HAL_GPT_Init+0x6a>
 3007aba:	fec42783          	lw	a5,-20(s0)
 3007abe:	4398                	lw	a4,0(a5)
 3007ac0:	147027b7          	lui	a5,0x14702
 3007ac4:	02f70163          	beq	a4,a5,3007ae6 <HAL_GPT_Init+0x6a>
 3007ac8:	fec42783          	lw	a5,-20(s0)
 3007acc:	4398                	lw	a4,0(a5)
 3007ace:	147037b7          	lui	a5,0x14703
 3007ad2:	00f70a63          	beq	a4,a5,3007ae6 <HAL_GPT_Init+0x6a>
 3007ad6:	03600593          	li	a1,54
 3007ada:	030117b7          	lui	a5,0x3011
 3007ade:	97078513          	addi	a0,a5,-1680 # 3010970 <g_crgIpMatch+0x460>
 3007ae2:	23fd                	jal	ra,30080d0 <AssertErrorLog.trans.5>
 3007ae4:	a001                	j	3007ae4 <HAL_GPT_Init+0x68>

    HAL_GPT_Stop(handle);
 3007ae6:	fec42503          	lw	a0,-20(s0)
 3007aea:	207d                	jal	ra,3007b98 <HAL_GPT_Stop>
    if (HAL_GPT_Config(handle) == BASE_STATUS_ERROR) {
 3007aec:	fec42503          	lw	a0,-20(s0)
 3007af0:	2a15                	jal	ra,3007c24 <HAL_GPT_Config>
 3007af2:	872a                	mv	a4,a0
 3007af4:	4785                	li	a5,1
 3007af6:	00f71463          	bne	a4,a5,3007afe <HAL_GPT_Init+0x82>
        return BASE_STATUS_ERROR;
 3007afa:	4785                	li	a5,1
 3007afc:	a011                	j	3007b00 <HAL_GPT_Init+0x84>
    }
    return BASE_STATUS_OK;
 3007afe:	4781                	li	a5,0
}
 3007b00:	853e                	mv	a0,a5
 3007b02:	40f2                	lw	ra,28(sp)
 3007b04:	4462                	lw	s0,24(sp)
 3007b06:	6105                	addi	sp,sp,32
 3007b08:	8082                	ret

03007b0a <HAL_GPT_Start>:
 * @brief   Start GPT
 * @param   handle   GPT Handle.
 * @retval  None
 */
void HAL_GPT_Start(GPT_Handle *handle)
{
 3007b0a:	7179                	addi	sp,sp,-48
 3007b0c:	d606                	sw	ra,44(sp)
 3007b0e:	d422                	sw	s0,40(sp)
 3007b10:	1800                	addi	s0,sp,48
 3007b12:	fca42e23          	sw	a0,-36(s0)
    GPT_ASSERT_PARAM(handle != NULL);
 3007b16:	fdc42783          	lw	a5,-36(s0)
 3007b1a:	eb89                	bnez	a5,3007b2c <HAL_GPT_Start+0x22>
 3007b1c:	04600593          	li	a1,70
 3007b20:	030117b7          	lui	a5,0x3011
 3007b24:	97078513          	addi	a0,a5,-1680 # 3010970 <g_crgIpMatch+0x460>
 3007b28:	2365                	jal	ra,30080d0 <AssertErrorLog.trans.5>
 3007b2a:	a001                	j	3007b2a <HAL_GPT_Start+0x20>
    GPT_ASSERT_PARAM(IsGPTInstance(handle->baseAddress));
 3007b2c:	fdc42783          	lw	a5,-36(s0)
 3007b30:	4398                	lw	a4,0(a5)
 3007b32:	147007b7          	lui	a5,0x14700
 3007b36:	02f70f63          	beq	a4,a5,3007b74 <HAL_GPT_Start+0x6a>
 3007b3a:	fdc42783          	lw	a5,-36(s0)
 3007b3e:	4398                	lw	a4,0(a5)
 3007b40:	147017b7          	lui	a5,0x14701
 3007b44:	02f70863          	beq	a4,a5,3007b74 <HAL_GPT_Start+0x6a>
 3007b48:	fdc42783          	lw	a5,-36(s0)
 3007b4c:	4398                	lw	a4,0(a5)
 3007b4e:	147027b7          	lui	a5,0x14702
 3007b52:	02f70163          	beq	a4,a5,3007b74 <HAL_GPT_Start+0x6a>
 3007b56:	fdc42783          	lw	a5,-36(s0)
 3007b5a:	4398                	lw	a4,0(a5)
 3007b5c:	147037b7          	lui	a5,0x14703
 3007b60:	00f70a63          	beq	a4,a5,3007b74 <HAL_GPT_Start+0x6a>
 3007b64:	04700593          	li	a1,71
 3007b68:	030117b7          	lui	a5,0x3011
 3007b6c:	97078513          	addi	a0,a5,-1680 # 3010970 <g_crgIpMatch+0x460>
 3007b70:	2385                	jal	ra,30080d0 <AssertErrorLog.trans.5>
 3007b72:	a001                	j	3007b72 <HAL_GPT_Start+0x68>
    /* Enables the GPT to output PWM waves according to the configuration. */
    GPT_EN_REG gptEn;
    gptEn.BIT.rg_gpt_en = BASE_CFG_SET;
 3007b74:	fec42783          	lw	a5,-20(s0)
 3007b78:	0017e793          	ori	a5,a5,1
 3007b7c:	fef42623          	sw	a5,-20(s0)
    handle->baseAddress->GPT_EN.reg = gptEn.reg;
 3007b80:	fdc42783          	lw	a5,-36(s0)
 3007b84:	439c                	lw	a5,0(a5)
 3007b86:	fec42703          	lw	a4,-20(s0)
 3007b8a:	40e7a623          	sw	a4,1036(a5)
}
 3007b8e:	0001                	nop
 3007b90:	50b2                	lw	ra,44(sp)
 3007b92:	5422                	lw	s0,40(sp)
 3007b94:	6145                	addi	sp,sp,48
 3007b96:	8082                	ret

03007b98 <HAL_GPT_Stop>:
 * @brief   Stop GPT
 * @param   handle   GPT Handle.
 * @retval  None
 */
void HAL_GPT_Stop(GPT_Handle *handle)
{
 3007b98:	7179                	addi	sp,sp,-48
 3007b9a:	d606                	sw	ra,44(sp)
 3007b9c:	d422                	sw	s0,40(sp)
 3007b9e:	1800                	addi	s0,sp,48
 3007ba0:	fca42e23          	sw	a0,-36(s0)
    GPT_ASSERT_PARAM(handle != NULL);
 3007ba4:	fdc42783          	lw	a5,-36(s0)
 3007ba8:	eb89                	bnez	a5,3007bba <HAL_GPT_Stop+0x22>
 3007baa:	05500593          	li	a1,85
 3007bae:	030117b7          	lui	a5,0x3011
 3007bb2:	97078513          	addi	a0,a5,-1680 # 3010970 <g_crgIpMatch+0x460>
 3007bb6:	2b29                	jal	ra,30080d0 <AssertErrorLog.trans.5>
 3007bb8:	a001                	j	3007bb8 <HAL_GPT_Stop+0x20>
    GPT_ASSERT_PARAM(IsGPTInstance(handle->baseAddress));
 3007bba:	fdc42783          	lw	a5,-36(s0)
 3007bbe:	4398                	lw	a4,0(a5)
 3007bc0:	147007b7          	lui	a5,0x14700
 3007bc4:	02f70f63          	beq	a4,a5,3007c02 <HAL_GPT_Stop+0x6a>
 3007bc8:	fdc42783          	lw	a5,-36(s0)
 3007bcc:	4398                	lw	a4,0(a5)
 3007bce:	147017b7          	lui	a5,0x14701
 3007bd2:	02f70863          	beq	a4,a5,3007c02 <HAL_GPT_Stop+0x6a>
 3007bd6:	fdc42783          	lw	a5,-36(s0)
 3007bda:	4398                	lw	a4,0(a5)
 3007bdc:	147027b7          	lui	a5,0x14702
 3007be0:	02f70163          	beq	a4,a5,3007c02 <HAL_GPT_Stop+0x6a>
 3007be4:	fdc42783          	lw	a5,-36(s0)
 3007be8:	4398                	lw	a4,0(a5)
 3007bea:	147037b7          	lui	a5,0x14703
 3007bee:	00f70a63          	beq	a4,a5,3007c02 <HAL_GPT_Stop+0x6a>
 3007bf2:	05600593          	li	a1,86
 3007bf6:	030117b7          	lui	a5,0x3011
 3007bfa:	97078513          	addi	a0,a5,-1680 # 3010970 <g_crgIpMatch+0x460>
 3007bfe:	29c9                	jal	ra,30080d0 <AssertErrorLog.trans.5>
 3007c00:	a001                	j	3007c00 <HAL_GPT_Stop+0x68>
     /* Disable the GPT to output PWM waves. */
    GPT_EN_REG gptEn;
    gptEn.BIT.rg_gpt_en = BASE_CFG_UNSET;
 3007c02:	fec42783          	lw	a5,-20(s0)
 3007c06:	9bf9                	andi	a5,a5,-2
 3007c08:	fef42623          	sw	a5,-20(s0)
    handle->baseAddress->GPT_EN.reg = gptEn.reg;
 3007c0c:	fdc42783          	lw	a5,-36(s0)
 3007c10:	439c                	lw	a5,0(a5)
 3007c12:	fec42703          	lw	a4,-20(s0)
 3007c16:	40e7a623          	sw	a4,1036(a5)
}
 3007c1a:	0001                	nop
 3007c1c:	50b2                	lw	ra,44(sp)
 3007c1e:	5422                	lw	s0,40(sp)
 3007c20:	6145                	addi	sp,sp,48
 3007c22:	8082                	ret

03007c24 <HAL_GPT_Config>:
 * @param   handle   GPT Handle.
 * @retval  BASE_STATUS_OK
 * @retval  BASE_STATUS_ERROR
 */
BASE_StatusType HAL_GPT_Config(GPT_Handle *handle)
{
 3007c24:	7179                	addi	sp,sp,-48
 3007c26:	d606                	sw	ra,44(sp)
 3007c28:	d422                	sw	s0,40(sp)
 3007c2a:	1800                	addi	s0,sp,48
 3007c2c:	fca42e23          	sw	a0,-36(s0)
    GPT_ASSERT_PARAM(handle != NULL);
 3007c30:	fdc42783          	lw	a5,-36(s0)
 3007c34:	eb89                	bnez	a5,3007c46 <HAL_GPT_Config+0x22>
 3007c36:	06500593          	li	a1,101
 3007c3a:	030117b7          	lui	a5,0x3011
 3007c3e:	97078513          	addi	a0,a5,-1680 # 3010970 <g_crgIpMatch+0x460>
 3007c42:	2179                	jal	ra,30080d0 <AssertErrorLog.trans.5>
 3007c44:	a001                	j	3007c44 <HAL_GPT_Config+0x20>
    GPT_ASSERT_PARAM(IsGPTInstance(handle->baseAddress));
 3007c46:	fdc42783          	lw	a5,-36(s0)
 3007c4a:	4398                	lw	a4,0(a5)
 3007c4c:	147007b7          	lui	a5,0x14700
 3007c50:	02f70f63          	beq	a4,a5,3007c8e <HAL_GPT_Config+0x6a>
 3007c54:	fdc42783          	lw	a5,-36(s0)
 3007c58:	4398                	lw	a4,0(a5)
 3007c5a:	147017b7          	lui	a5,0x14701
 3007c5e:	02f70863          	beq	a4,a5,3007c8e <HAL_GPT_Config+0x6a>
 3007c62:	fdc42783          	lw	a5,-36(s0)
 3007c66:	4398                	lw	a4,0(a5)
 3007c68:	147027b7          	lui	a5,0x14702
 3007c6c:	02f70163          	beq	a4,a5,3007c8e <HAL_GPT_Config+0x6a>
 3007c70:	fdc42783          	lw	a5,-36(s0)
 3007c74:	4398                	lw	a4,0(a5)
 3007c76:	147037b7          	lui	a5,0x14703
 3007c7a:	00f70a63          	beq	a4,a5,3007c8e <HAL_GPT_Config+0x6a>
 3007c7e:	06600593          	li	a1,102
 3007c82:	030117b7          	lui	a5,0x3011
 3007c86:	97078513          	addi	a0,a5,-1680 # 3010970 <g_crgIpMatch+0x460>
 3007c8a:	2199                	jal	ra,30080d0 <AssertErrorLog.trans.5>
 3007c8c:	a001                	j	3007c8c <HAL_GPT_Config+0x68>
    GPT_PARAM_CHECK_WITH_RET(IsGptPeriod(handle->period), BASE_STATUS_ERROR);
 3007c8e:	fdc42783          	lw	a5,-36(s0)
 3007c92:	4fdc                	lw	a5,28(a5)
 3007c94:	853e                	mv	a0,a5
 3007c96:	3b91                	jal	ra,30079ea <IsGptPeriod>
 3007c98:	87aa                	mv	a5,a0
 3007c9a:	0017c793          	xori	a5,a5,1
 3007c9e:	9f81                	uxtb	a5
 3007ca0:	cb91                	beqz	a5,3007cb4 <HAL_GPT_Config+0x90>
 3007ca2:	06700593          	li	a1,103
 3007ca6:	030117b7          	lui	a5,0x3011
 3007caa:	97078513          	addi	a0,a5,-1680 # 3010970 <g_crgIpMatch+0x460>
 3007cae:	210d                	jal	ra,30080d0 <AssertErrorLog.trans.5>
 3007cb0:	4785                	li	a5,1
 3007cb2:	ac95                	j	3007f26 <HAL_GPT_Config+0x302>
    GPT_PARAM_CHECK_WITH_RET(IsGptDiv(handle->clockDiv), BASE_STATUS_ERROR);
 3007cb4:	fdc42783          	lw	a5,-36(s0)
 3007cb8:	479c                	lw	a5,8(a5)
 3007cba:	853e                	mv	a0,a5
 3007cbc:	3b01                	jal	ra,30079cc <IsGptDiv>
 3007cbe:	87aa                	mv	a5,a0
 3007cc0:	0017c793          	xori	a5,a5,1
 3007cc4:	9f81                	uxtb	a5
 3007cc6:	cb91                	beqz	a5,3007cda <HAL_GPT_Config+0xb6>
 3007cc8:	06800593          	li	a1,104
 3007ccc:	030117b7          	lui	a5,0x3011
 3007cd0:	97078513          	addi	a0,a5,-1680 # 3010970 <g_crgIpMatch+0x460>
 3007cd4:	2ef5                	jal	ra,30080d0 <AssertErrorLog.trans.5>
 3007cd6:	4785                	li	a5,1
 3007cd8:	a4b9                	j	3007f26 <HAL_GPT_Config+0x302>
    GPT_PARAM_CHECK_WITH_RET(IsGptRefDot(handle->refA0.refdot), BASE_STATUS_ERROR);
 3007cda:	fdc42783          	lw	a5,-36(s0)
 3007cde:	47dc                	lw	a5,12(a5)
 3007ce0:	853e                	mv	a0,a5
 3007ce2:	3b25                	jal	ra,3007a1a <IsGptRefDot>
 3007ce4:	87aa                	mv	a5,a0
 3007ce6:	0017c793          	xori	a5,a5,1
 3007cea:	9f81                	uxtb	a5
 3007cec:	cb91                	beqz	a5,3007d00 <HAL_GPT_Config+0xdc>
 3007cee:	06900593          	li	a1,105
 3007cf2:	030117b7          	lui	a5,0x3011
 3007cf6:	97078513          	addi	a0,a5,-1680 # 3010970 <g_crgIpMatch+0x460>
 3007cfa:	2ed9                	jal	ra,30080d0 <AssertErrorLog.trans.5>
 3007cfc:	4785                	li	a5,1
 3007cfe:	a425                	j	3007f26 <HAL_GPT_Config+0x302>
    GPT_PARAM_CHECK_WITH_RET(IsGptRefDot(handle->refB0.refdot), BASE_STATUS_ERROR);
 3007d00:	fdc42783          	lw	a5,-36(s0)
 3007d04:	4bdc                	lw	a5,20(a5)
 3007d06:	853e                	mv	a0,a5
 3007d08:	3b09                	jal	ra,3007a1a <IsGptRefDot>
 3007d0a:	87aa                	mv	a5,a0
 3007d0c:	0017c793          	xori	a5,a5,1
 3007d10:	9f81                	uxtb	a5
 3007d12:	cb91                	beqz	a5,3007d26 <HAL_GPT_Config+0x102>
 3007d14:	06a00593          	li	a1,106
 3007d18:	030117b7          	lui	a5,0x3011
 3007d1c:	97078513          	addi	a0,a5,-1680 # 3010970 <g_crgIpMatch+0x460>
 3007d20:	2e45                	jal	ra,30080d0 <AssertErrorLog.trans.5>
 3007d22:	4785                	li	a5,1
 3007d24:	a409                	j	3007f26 <HAL_GPT_Config+0x302>
    GPT_PARAM_CHECK_WITH_RET(handle->refA0.refdot <= handle->refB0.refdot, BASE_STATUS_ERROR);
 3007d26:	fdc42783          	lw	a5,-36(s0)
 3007d2a:	47d8                	lw	a4,12(a5)
 3007d2c:	fdc42783          	lw	a5,-36(s0)
 3007d30:	4bdc                	lw	a5,20(a5)
 3007d32:	00e7fb63          	bgeu	a5,a4,3007d48 <HAL_GPT_Config+0x124>
 3007d36:	06b00593          	li	a1,107
 3007d3a:	030117b7          	lui	a5,0x3011
 3007d3e:	97078513          	addi	a0,a5,-1680 # 3010970 <g_crgIpMatch+0x460>
 3007d42:	2679                	jal	ra,30080d0 <AssertErrorLog.trans.5>
 3007d44:	4785                	li	a5,1
 3007d46:	a2c5                	j	3007f26 <HAL_GPT_Config+0x302>
    GPT_PARAM_CHECK_WITH_RET(handle->refB0.refdot <= handle->period, BASE_STATUS_ERROR);
 3007d48:	fdc42783          	lw	a5,-36(s0)
 3007d4c:	4bd8                	lw	a4,20(a5)
 3007d4e:	fdc42783          	lw	a5,-36(s0)
 3007d52:	4fdc                	lw	a5,28(a5)
 3007d54:	00e7fb63          	bgeu	a5,a4,3007d6a <HAL_GPT_Config+0x146>
 3007d58:	06c00593          	li	a1,108
 3007d5c:	030117b7          	lui	a5,0x3011
 3007d60:	97078513          	addi	a0,a5,-1680 # 3010970 <g_crgIpMatch+0x460>
 3007d64:	26b5                	jal	ra,30080d0 <AssertErrorLog.trans.5>
 3007d66:	4785                	li	a5,1
 3007d68:	aa7d                	j	3007f26 <HAL_GPT_Config+0x302>
    GPT_PARAM_CHECK_WITH_RET(IsGptAction(handle->refA0.refAction), BASE_STATUS_ERROR);
 3007d6a:	fdc42783          	lw	a5,-36(s0)
 3007d6e:	4b9c                	lw	a5,16(a5)
 3007d70:	853e                	mv	a0,a5
 3007d72:	31d9                	jal	ra,3007a38 <IsGptAction>
 3007d74:	87aa                	mv	a5,a0
 3007d76:	0017c793          	xori	a5,a5,1
 3007d7a:	9f81                	uxtb	a5
 3007d7c:	cb91                	beqz	a5,3007d90 <HAL_GPT_Config+0x16c>
 3007d7e:	06d00593          	li	a1,109
 3007d82:	030117b7          	lui	a5,0x3011
 3007d86:	97078513          	addi	a0,a5,-1680 # 3010970 <g_crgIpMatch+0x460>
 3007d8a:	2699                	jal	ra,30080d0 <AssertErrorLog.trans.5>
 3007d8c:	4785                	li	a5,1
 3007d8e:	aa61                	j	3007f26 <HAL_GPT_Config+0x302>
    GPT_PARAM_CHECK_WITH_RET(IsGptAction(handle->refB0.refAction), BASE_STATUS_ERROR);
 3007d90:	fdc42783          	lw	a5,-36(s0)
 3007d94:	4f9c                	lw	a5,24(a5)
 3007d96:	853e                	mv	a0,a5
 3007d98:	3145                	jal	ra,3007a38 <IsGptAction>
 3007d9a:	87aa                	mv	a5,a0
 3007d9c:	0017c793          	xori	a5,a5,1
 3007da0:	9f81                	uxtb	a5
 3007da2:	cb91                	beqz	a5,3007db6 <HAL_GPT_Config+0x192>
 3007da4:	06e00593          	li	a1,110
 3007da8:	030117b7          	lui	a5,0x3011
 3007dac:	97078513          	addi	a0,a5,-1680 # 3010970 <g_crgIpMatch+0x460>
 3007db0:	2605                	jal	ra,30080d0 <AssertErrorLog.trans.5>
 3007db2:	4785                	li	a5,1
 3007db4:	aa8d                	j	3007f26 <HAL_GPT_Config+0x302>
    GPT_PARAM_CHECK_WITH_RET(IsGptPwmNum(handle->pwmNum), BASE_STATUS_ERROR);
 3007db6:	fdc42783          	lw	a5,-36(s0)
 3007dba:	539c                	lw	a5,32(a5)
 3007dbc:	853e                	mv	a0,a5
 3007dbe:	3ecd                	jal	ra,30079b0 <IsGptPwmNum>
 3007dc0:	87aa                	mv	a5,a0
 3007dc2:	0017c793          	xori	a5,a5,1
 3007dc6:	9f81                	uxtb	a5
 3007dc8:	cb91                	beqz	a5,3007ddc <HAL_GPT_Config+0x1b8>
 3007dca:	06f00593          	li	a1,111
 3007dce:	030117b7          	lui	a5,0x3011
 3007dd2:	97078513          	addi	a0,a5,-1680 # 3010970 <g_crgIpMatch+0x460>
 3007dd6:	2ced                	jal	ra,30080d0 <AssertErrorLog.trans.5>
 3007dd8:	4785                	li	a5,1
 3007dda:	a2b1                	j	3007f26 <HAL_GPT_Config+0x302>

    GPT_RegStruct *gptReg;
    gptReg = handle->baseAddress;
 3007ddc:	fdc42783          	lw	a5,-36(s0)
 3007de0:	439c                	lw	a5,0(a5)
 3007de2:	fef42623          	sw	a5,-20(s0)
    /* Configure whether to enable cache loading. */
    gptReg->GPT_BUF_LOAD_EN.BIT.rg_buf_load_en = handle->bufLoad;
 3007de6:	fdc42783          	lw	a5,-36(s0)
 3007dea:	0257c683          	lbu	a3,37(a5)
 3007dee:	fec42703          	lw	a4,-20(s0)
 3007df2:	50072783          	lw	a5,1280(a4) # 14002500 <RAM_END+0xfffa500>
 3007df6:	8a85                	andi	a3,a3,1
 3007df8:	9bf9                	andi	a5,a5,-2
 3007dfa:	8fd5                	or	a5,a5,a3
 3007dfc:	50f72023          	sw	a5,1280(a4)
    
    /* Configuring the Cycle and Frequency Divider */
    gptReg->GPT_TC_DIV.reg = handle->clockDiv;
 3007e00:	fdc42783          	lw	a5,-36(s0)
 3007e04:	4798                	lw	a4,8(a5)
 3007e06:	fec42783          	lw	a5,-20(s0)
 3007e0a:	cb98                	sw	a4,16(a5)
    gptReg->GPT_TC_PRD.reg = handle->period;
 3007e0c:	fdc42783          	lw	a5,-36(s0)
 3007e10:	4fd8                	lw	a4,28(a5)
 3007e12:	fec42783          	lw	a5,-20(s0)
 3007e16:	cbd8                	sw	a4,20(a5)
    /* Set the count reference point and the corresponding reference action. */
    gptReg->GPT_TC_REFA0.reg = handle->refA0.refdot;
 3007e18:	fdc42783          	lw	a5,-36(s0)
 3007e1c:	47d8                	lw	a4,12(a5)
 3007e1e:	fec42783          	lw	a5,-20(s0)
 3007e22:	cf98                	sw	a4,24(a5)
    gptReg->GPT_PG_ACT0.BIT.rg_pg_act0_refa0 = handle->refA0.refAction;
 3007e24:	fdc42783          	lw	a5,-36(s0)
 3007e28:	4b9c                	lw	a5,16(a5)
 3007e2a:	8b8d                	andi	a5,a5,3
 3007e2c:	0ff7f693          	andi	a3,a5,255
 3007e30:	fec42703          	lw	a4,-20(s0)
 3007e34:	10072783          	lw	a5,256(a4)
 3007e38:	8a8d                	andi	a3,a3,3
 3007e3a:	9bf1                	andi	a5,a5,-4
 3007e3c:	8fd5                	or	a5,a5,a3
 3007e3e:	10f72023          	sw	a5,256(a4)
    gptReg->GPT_TC_REFB0.reg = handle->refB0.refdot;
 3007e42:	fdc42783          	lw	a5,-36(s0)
 3007e46:	4bd8                	lw	a4,20(a5)
 3007e48:	fec42783          	lw	a5,-20(s0)
 3007e4c:	cfd8                	sw	a4,28(a5)
    gptReg->GPT_PG_ACT0.BIT.rg_pg_act0_refb0 = handle->refB0.refAction;
 3007e4e:	fdc42783          	lw	a5,-36(s0)
 3007e52:	4f9c                	lw	a5,24(a5)
 3007e54:	8b8d                	andi	a5,a5,3
 3007e56:	0ff7f693          	andi	a3,a5,255
 3007e5a:	fec42703          	lw	a4,-20(s0)
 3007e5e:	10072783          	lw	a5,256(a4)
 3007e62:	8a8d                	andi	a3,a3,3
 3007e64:	0692                	slli	a3,a3,0x4
 3007e66:	fcf7f793          	andi	a5,a5,-49
 3007e6a:	8fd5                	or	a5,a5,a3
 3007e6c:	10f72023          	sw	a5,256(a4)
    
    /* Sets the PWM output mode: outputs infinite PWM waves and outputs fixed number PWM. */
    gptReg->GPT_PWM0_CFG.BIT.rg_pwm0_keep = handle->pwmKeep;
 3007e70:	fdc42783          	lw	a5,-36(s0)
 3007e74:	0247c683          	lbu	a3,36(a5)
 3007e78:	fec42703          	lw	a4,-20(s0)
 3007e7c:	40072783          	lw	a5,1024(a4)
 3007e80:	06fe                	slli	a3,a3,0x1f
 3007e82:	80000637          	lui	a2,0x80000
 3007e86:	fff64613          	not	a2,a2
 3007e8a:	8ff1                	and	a5,a5,a2
 3007e8c:	8fd5                	or	a5,a5,a3
 3007e8e:	40f72023          	sw	a5,1024(a4)
    /* Sets the number of output PWM wavelengths. This parameter is valid only when outputs fixed number PWM. */
    gptReg->GPT_PWM0_CFG.BIT.rg_pwm0_num = handle->pwmNum;
 3007e92:	fdc42783          	lw	a5,-36(s0)
 3007e96:	539c                	lw	a5,32(a5)
 3007e98:	3ff7f793          	andi	a5,a5,1023
 3007e9c:	01079693          	slli	a3,a5,0x10
 3007ea0:	82c1                	srli	a3,a3,0x10
 3007ea2:	fec42703          	lw	a4,-20(s0)
 3007ea6:	40072783          	lw	a5,1024(a4)
 3007eaa:	3ff6f693          	andi	a3,a3,1023
 3007eae:	c007f793          	andi	a5,a5,-1024
 3007eb2:	8fd5                	or	a5,a5,a3
 3007eb4:	40f72023          	sw	a5,1024(a4)
    
    /* Sets the GPT output completion interrupt and periodic interrupt. */
    gptReg->GPT_INT_EN.BIT.rg_prd_int_en = handle->handleEx.periodIntEnable;
 3007eb8:	fdc42783          	lw	a5,-36(s0)
 3007ebc:	0307c683          	lbu	a3,48(a5)
 3007ec0:	fec42703          	lw	a4,-20(s0)
 3007ec4:	20072783          	lw	a5,512(a4)
 3007ec8:	8a85                	andi	a3,a3,1
 3007eca:	9bf9                	andi	a5,a5,-2
 3007ecc:	8fd5                	or	a5,a5,a3
 3007ece:	20f72023          	sw	a5,512(a4)
    gptReg->GPT_INT_EN.BIT.rg_pwm0_int_en = handle->handleEx.outputFinIntEnable;
 3007ed2:	fdc42783          	lw	a5,-36(s0)
 3007ed6:	0317c683          	lbu	a3,49(a5)
 3007eda:	fec42703          	lw	a4,-20(s0)
 3007ede:	20072783          	lw	a5,512(a4)
 3007ee2:	8a85                	andi	a3,a3,1
 3007ee4:	0692                	slli	a3,a3,0x4
 3007ee6:	9bbd                	andi	a5,a5,-17
 3007ee8:	8fd5                	or	a5,a5,a3
 3007eea:	20f72023          	sw	a5,512(a4)

    /* ADC Trigger Sampling Configuration */
    gptReg->GPT_SOCDR_EN.BIT.rg_soc_pwm0_en = handle->triggleAdcOutFinish;
 3007eee:	fdc42783          	lw	a5,-36(s0)
 3007ef2:	0277c683          	lbu	a3,39(a5)
 3007ef6:	fec42703          	lw	a4,-20(s0)
 3007efa:	30072783          	lw	a5,768(a4)
 3007efe:	8a85                	andi	a3,a3,1
 3007f00:	0686                	slli	a3,a3,0x1
 3007f02:	9bf5                	andi	a5,a5,-3
 3007f04:	8fd5                	or	a5,a5,a3
 3007f06:	30f72023          	sw	a5,768(a4)
    gptReg->GPT_SOCDR_EN.BIT.rg_soc_prd_en = handle->triggleAdcPeriod;
 3007f0a:	fdc42783          	lw	a5,-36(s0)
 3007f0e:	0267c683          	lbu	a3,38(a5)
 3007f12:	fec42703          	lw	a4,-20(s0)
 3007f16:	30072783          	lw	a5,768(a4)
 3007f1a:	8a85                	andi	a3,a3,1
 3007f1c:	9bf9                	andi	a5,a5,-2
 3007f1e:	8fd5                	or	a5,a5,a3
 3007f20:	30f72023          	sw	a5,768(a4)
    return BASE_STATUS_OK;
 3007f24:	4781                	li	a5,0
}
 3007f26:	853e                	mv	a0,a5
 3007f28:	50b2                	lw	ra,44(sp)
 3007f2a:	5422                	lw	s0,40(sp)
 3007f2c:	6145                	addi	sp,sp,48
 3007f2e:	8082                	ret

03007f30 <HAL_GPT_GetConfig>:
 * @param   handle   GPT Handle.
 * @retval  BASE_STATUS_OK    Success
 * @retval  BASE_STATUS_ERROR Fail
 */
BASE_StatusType HAL_GPT_GetConfig(GPT_Handle *handle)
{
 3007f30:	7179                	addi	sp,sp,-48
 3007f32:	d606                	sw	ra,44(sp)
 3007f34:	d422                	sw	s0,40(sp)
 3007f36:	1800                	addi	s0,sp,48
 3007f38:	fca42e23          	sw	a0,-36(s0)
    GPT_ASSERT_PARAM(handle != NULL);
 3007f3c:	fdc42783          	lw	a5,-36(s0)
 3007f40:	eb89                	bnez	a5,3007f52 <HAL_GPT_GetConfig+0x22>
 3007f42:	09600593          	li	a1,150
 3007f46:	030117b7          	lui	a5,0x3011
 3007f4a:	97078513          	addi	a0,a5,-1680 # 3010970 <g_crgIpMatch+0x460>
 3007f4e:	2249                	jal	ra,30080d0 <AssertErrorLog.trans.5>
 3007f50:	a001                	j	3007f50 <HAL_GPT_GetConfig+0x20>
    GPT_ASSERT_PARAM(IsGPTInstance(handle->baseAddress));
 3007f52:	fdc42783          	lw	a5,-36(s0)
 3007f56:	4398                	lw	a4,0(a5)
 3007f58:	147007b7          	lui	a5,0x14700
 3007f5c:	02f70f63          	beq	a4,a5,3007f9a <HAL_GPT_GetConfig+0x6a>
 3007f60:	fdc42783          	lw	a5,-36(s0)
 3007f64:	4398                	lw	a4,0(a5)
 3007f66:	147017b7          	lui	a5,0x14701
 3007f6a:	02f70863          	beq	a4,a5,3007f9a <HAL_GPT_GetConfig+0x6a>
 3007f6e:	fdc42783          	lw	a5,-36(s0)
 3007f72:	4398                	lw	a4,0(a5)
 3007f74:	147027b7          	lui	a5,0x14702
 3007f78:	02f70163          	beq	a4,a5,3007f9a <HAL_GPT_GetConfig+0x6a>
 3007f7c:	fdc42783          	lw	a5,-36(s0)
 3007f80:	4398                	lw	a4,0(a5)
 3007f82:	147037b7          	lui	a5,0x14703
 3007f86:	00f70a63          	beq	a4,a5,3007f9a <HAL_GPT_GetConfig+0x6a>
 3007f8a:	09700593          	li	a1,151
 3007f8e:	030117b7          	lui	a5,0x3011
 3007f92:	97078513          	addi	a0,a5,-1680 # 3010970 <g_crgIpMatch+0x460>
 3007f96:	2a2d                	jal	ra,30080d0 <AssertErrorLog.trans.5>
 3007f98:	a001                	j	3007f98 <HAL_GPT_GetConfig+0x68>

    GPT_RegStruct *gptReg = handle->baseAddress;
 3007f9a:	fdc42783          	lw	a5,-36(s0)
 3007f9e:	439c                	lw	a5,0(a5)
 3007fa0:	fef42623          	sw	a5,-20(s0)
    /* Obtains the configuration parameters of the PWM wavelength. */
    handle->clockDiv        =   gptReg->GPT_TC_DIV.reg;
 3007fa4:	fec42783          	lw	a5,-20(s0)
 3007fa8:	4b98                	lw	a4,16(a5)
 3007faa:	fdc42783          	lw	a5,-36(s0)
 3007fae:	c798                	sw	a4,8(a5)
    handle->period          =   gptReg->GPT_TC_PRD.reg;
 3007fb0:	fec42783          	lw	a5,-20(s0)
 3007fb4:	4bd8                	lw	a4,20(a5)
 3007fb6:	fdc42783          	lw	a5,-36(s0)
 3007fba:	cfd8                	sw	a4,28(a5)
    handle->refA0.refdot    =   gptReg->GPT_TC_REFA0.reg;
 3007fbc:	fec42783          	lw	a5,-20(s0)
 3007fc0:	4f98                	lw	a4,24(a5)
 3007fc2:	fdc42783          	lw	a5,-36(s0)
 3007fc6:	c7d8                	sw	a4,12(a5)
    handle->refB0.refdot    =   gptReg->GPT_TC_REFB0.reg;
 3007fc8:	fec42783          	lw	a5,-20(s0)
 3007fcc:	4fd8                	lw	a4,28(a5)
 3007fce:	fdc42783          	lw	a5,-36(s0)
 3007fd2:	cbd8                	sw	a4,20(a5)
    handle->refA0.refAction =   gptReg->GPT_PG_ACT0.BIT.rg_pg_act0_refa0;
 3007fd4:	fec42783          	lw	a5,-20(s0)
 3007fd8:	1007a783          	lw	a5,256(a5)
 3007fdc:	8b8d                	andi	a5,a5,3
 3007fde:	9f81                	uxtb	a5
 3007fe0:	873e                	mv	a4,a5
 3007fe2:	fdc42783          	lw	a5,-36(s0)
 3007fe6:	cb98                	sw	a4,16(a5)
    handle->refB0.refAction =   gptReg->GPT_PG_ACT0.BIT.rg_pg_act0_refb0;
 3007fe8:	fec42783          	lw	a5,-20(s0)
 3007fec:	1007a783          	lw	a5,256(a5)
 3007ff0:	8391                	srli	a5,a5,0x4
 3007ff2:	8b8d                	andi	a5,a5,3
 3007ff4:	9f81                	uxtb	a5
 3007ff6:	873e                	mv	a4,a5
 3007ff8:	fdc42783          	lw	a5,-36(s0)
 3007ffc:	cf98                	sw	a4,24(a5)
    /* Obtains the cache loading status. */
    handle->bufLoad         =   gptReg->GPT_BUF_LOAD_EN.BIT.rg_buf_load_en;
 3007ffe:	fec42783          	lw	a5,-20(s0)
 3008002:	5007a783          	lw	a5,1280(a5)
 3008006:	8b85                	andi	a5,a5,1
 3008008:	9f81                	uxtb	a5
 300800a:	00f037b3          	snez	a5,a5
 300800e:	0ff7f713          	andi	a4,a5,255
 3008012:	fdc42783          	lw	a5,-36(s0)
 3008016:	02e782a3          	sb	a4,37(a5)

    /* Obtaining the Interrupt Status */
    handle->handleEx.periodIntEnable    =  gptReg->GPT_INT_EN.BIT.rg_prd_int_en;
 300801a:	fec42783          	lw	a5,-20(s0)
 300801e:	2007a783          	lw	a5,512(a5)
 3008022:	8b85                	andi	a5,a5,1
 3008024:	9f81                	uxtb	a5
 3008026:	00f037b3          	snez	a5,a5
 300802a:	0ff7f713          	andi	a4,a5,255
 300802e:	fdc42783          	lw	a5,-36(s0)
 3008032:	02e78823          	sb	a4,48(a5)
    handle->handleEx.outputFinIntEnable =  gptReg->GPT_INT_EN.BIT.rg_pwm0_int_en;
 3008036:	fec42783          	lw	a5,-20(s0)
 300803a:	2007a783          	lw	a5,512(a5)
 300803e:	8391                	srli	a5,a5,0x4
 3008040:	8b85                	andi	a5,a5,1
 3008042:	9f81                	uxtb	a5
 3008044:	00f037b3          	snez	a5,a5
 3008048:	0ff7f713          	andi	a4,a5,255
 300804c:	fdc42783          	lw	a5,-36(s0)
 3008050:	02e788a3          	sb	a4,49(a5)

    /* Obtains ADC configuration parameters. */
    handle->triggleAdcOutFinish         =  gptReg->GPT_SOCDR_EN.BIT.rg_soc_pwm0_en;
 3008054:	fec42783          	lw	a5,-20(s0)
 3008058:	3007a783          	lw	a5,768(a5)
 300805c:	8385                	srli	a5,a5,0x1
 300805e:	8b85                	andi	a5,a5,1
 3008060:	9f81                	uxtb	a5
 3008062:	00f037b3          	snez	a5,a5
 3008066:	0ff7f713          	andi	a4,a5,255
 300806a:	fdc42783          	lw	a5,-36(s0)
 300806e:	02e783a3          	sb	a4,39(a5)
    handle->triggleAdcPeriod            =  gptReg->GPT_SOCDR_EN.BIT.rg_soc_prd_en;
 3008072:	fec42783          	lw	a5,-20(s0)
 3008076:	3007a783          	lw	a5,768(a5)
 300807a:	8b85                	andi	a5,a5,1
 300807c:	9f81                	uxtb	a5
 300807e:	00f037b3          	snez	a5,a5
 3008082:	0ff7f713          	andi	a4,a5,255
 3008086:	fdc42783          	lw	a5,-36(s0)
 300808a:	02e78323          	sb	a4,38(a5)
    
    /* Obtains the PWM output mode. */
    GPT_PWM0_CFG_REG pwm0Cfg;
    pwm0Cfg.reg              =   gptReg->GPT_PWM0_CFG.reg;
 300808e:	fec42783          	lw	a5,-20(s0)
 3008092:	4007a783          	lw	a5,1024(a5)
 3008096:	fef42423          	sw	a5,-24(s0)
    handle->pwmKeep          =   GPT_GetKeepState(handle);
 300809a:	fdc42503          	lw	a0,-36(s0)
 300809e:	3a5d                	jal	ra,3007a54 <GPT_GetKeepState>
 30080a0:	87aa                	mv	a5,a0
 30080a2:	00f037b3          	snez	a5,a5
 30080a6:	0ff7f713          	andi	a4,a5,255
 30080aa:	fdc42783          	lw	a5,-36(s0)
 30080ae:	02e78223          	sb	a4,36(a5)
    handle->pwmNum           =   pwm0Cfg.BIT.rg_pwm0_num;
 30080b2:	fe842783          	lw	a5,-24(s0)
 30080b6:	3ff7f793          	andi	a5,a5,1023
 30080ba:	9fa1                	uxth	a5
 30080bc:	873e                	mv	a4,a5
 30080be:	fdc42783          	lw	a5,-36(s0)
 30080c2:	d398                	sw	a4,32(a5)
    return BASE_STATUS_OK;
 30080c4:	4781                	li	a5,0
}
 30080c6:	853e                	mv	a0,a5
 30080c8:	50b2                	lw	ra,44(sp)
 30080ca:	5422                	lw	s0,40(sp)
 30080cc:	6145                	addi	sp,sp,48
 30080ce:	8082                	ret

030080d0 <AssertErrorLog.trans.5>:
 30080d0:	c6ffa06f          	j	3002d3e <AssertErrorLog>

030080d4 <IsI2cFunctionMode>:
  * @param functionMode I2C function mode type.
  * @retval true
  * @retval false
  */
static inline bool IsI2cFunctionMode(I2C_ModeSelectType functionMode)
{
 30080d4:	1101                	addi	sp,sp,-32
 30080d6:	ce22                	sw	s0,28(sp)
 30080d8:	1000                	addi	s0,sp,32
 30080da:	fea42623          	sw	a0,-20(s0)
    return (functionMode == I2C_MODE_SELECT_NONE ||
            functionMode == I2C_MODE_SELECT_MASTER_ONLY ||
            functionMode == I2C_MODE_SELECT_SLAVE_ONLY ||
 30080de:	fec42783          	lw	a5,-20(s0)
 30080e2:	c385                	beqz	a5,3008102 <IsI2cFunctionMode+0x2e>
    return (functionMode == I2C_MODE_SELECT_NONE ||
 30080e4:	fec42703          	lw	a4,-20(s0)
 30080e8:	4785                	li	a5,1
 30080ea:	00f70c63          	beq	a4,a5,3008102 <IsI2cFunctionMode+0x2e>
            functionMode == I2C_MODE_SELECT_MASTER_ONLY ||
 30080ee:	fec42703          	lw	a4,-20(s0)
 30080f2:	4789                	li	a5,2
 30080f4:	00f70763          	beq	a4,a5,3008102 <IsI2cFunctionMode+0x2e>
            functionMode == I2C_MODE_SELECT_SLAVE_ONLY ||
 30080f8:	fec42703          	lw	a4,-20(s0)
 30080fc:	478d                	li	a5,3
 30080fe:	00f71463          	bne	a4,a5,3008106 <IsI2cFunctionMode+0x32>
 3008102:	4785                	li	a5,1
 3008104:	a011                	j	3008108 <IsI2cFunctionMode+0x34>
 3008106:	4781                	li	a5,0
 3008108:	8b85                	andi	a5,a5,1
 300810a:	9f81                	uxtb	a5
            functionMode == I2C_MODE_SELECT_MASTER_SLAVE);
}
 300810c:	853e                	mv	a0,a5
 300810e:	4472                	lw	s0,28(sp)
 3008110:	6105                	addi	sp,sp,32
 3008112:	8082                	ret

03008114 <IsI2cAddressMode>:
  * @param addrMode I2C instance
  * @retval true
  * @retval false
  */
static inline bool IsI2cAddressMode(I2C_AddressMode addrMode)
{
 3008114:	1101                	addi	sp,sp,-32
 3008116:	ce22                	sw	s0,28(sp)
 3008118:	1000                	addi	s0,sp,32
 300811a:	fea42623          	sw	a0,-20(s0)
    return (addrMode == I2C_7_BITS ||
 300811e:	fec42783          	lw	a5,-20(s0)
 3008122:	c791                	beqz	a5,300812e <IsI2cAddressMode+0x1a>
 3008124:	fec42703          	lw	a4,-20(s0)
 3008128:	4785                	li	a5,1
 300812a:	00f71463          	bne	a4,a5,3008132 <IsI2cAddressMode+0x1e>
 300812e:	4785                	li	a5,1
 3008130:	a011                	j	3008134 <IsI2cAddressMode+0x20>
 3008132:	4781                	li	a5,0
 3008134:	8b85                	andi	a5,a5,1
 3008136:	9f81                	uxtb	a5
            addrMode == I2C_10_BITS);
}
 3008138:	853e                	mv	a0,a5
 300813a:	4472                	lw	s0,28(sp)
 300813c:	6105                	addi	sp,sp,32
 300813e:	8082                	ret

03008140 <IsI2cSdaHoldTime>:
  * @param sdaHoldTime I2C instance
  * @retval true
  * @retval false
  */
static inline bool IsI2cSdaHoldTime(unsigned int sdaHoldTime)
{
 3008140:	1101                	addi	sp,sp,-32
 3008142:	ce22                	sw	s0,28(sp)
 3008144:	1000                	addi	s0,sp,32
 3008146:	fea42623          	sw	a0,-20(s0)
    return (sdaHoldTime <= 0xFFFF); /* SdaHoldTime value is 0 to 0xFFFF */
 300814a:	fec42703          	lw	a4,-20(s0)
 300814e:	67c1                	lui	a5,0x10
 3008150:	00f737b3          	sltu	a5,a4,a5
 3008154:	9f81                	uxtb	a5
}
 3008156:	853e                	mv	a0,a5
 3008158:	4472                	lw	s0,28(sp)
 300815a:	6105                	addi	sp,sp,32
 300815c:	8082                	ret

0300815e <IsI2cGeneralCallMode>:
  * @param generalCallMode I2C general call mode.
  * @retval true
  * @retval false
  */
static inline bool IsI2cGeneralCallMode(unsigned int generalCallMode)
{
 300815e:	1101                	addi	sp,sp,-32
 3008160:	ce22                	sw	s0,28(sp)
 3008162:	1000                	addi	s0,sp,32
 3008164:	fea42623          	sw	a0,-20(s0)
    return (generalCallMode == BASE_CFG_ENABLE ||
 3008168:	fec42703          	lw	a4,-20(s0)
 300816c:	4785                	li	a5,1
 300816e:	00f70563          	beq	a4,a5,3008178 <IsI2cGeneralCallMode+0x1a>
 3008172:	fec42783          	lw	a5,-20(s0)
 3008176:	e399                	bnez	a5,300817c <IsI2cGeneralCallMode+0x1e>
 3008178:	4785                	li	a5,1
 300817a:	a011                	j	300817e <IsI2cGeneralCallMode+0x20>
 300817c:	4781                	li	a5,0
 300817e:	8b85                	andi	a5,a5,1
 3008180:	9f81                	uxtb	a5
            generalCallMode == BASE_CFG_DISABLE);
}
 3008182:	853e                	mv	a0,a5
 3008184:	4472                	lw	s0,28(sp)
 3008186:	6105                	addi	sp,sp,32
 3008188:	8082                	ret

0300818a <IsI2cOwnAddressOrMask>:
  * @param ownAddress I2C own address.
  * @retval true
  * @retval false
  */
static inline bool IsI2cOwnAddressOrMask(unsigned int ownAddress)
{
 300818a:	1101                	addi	sp,sp,-32
 300818c:	ce22                	sw	s0,28(sp)
 300818e:	1000                	addi	s0,sp,32
 3008190:	fea42623          	sw	a0,-20(s0)
    return (ownAddress <= XMBUS_OWN_ADDRESS_MASK); /* Own address value is 0 to 0x3FF */
 3008194:	fec42783          	lw	a5,-20(s0)
 3008198:	4007b793          	sltiu	a5,a5,1024
 300819c:	9f81                	uxtb	a5
}
 300819e:	853e                	mv	a0,a5
 30081a0:	4472                	lw	s0,28(sp)
 30081a2:	6105                	addi	sp,sp,32
 30081a4:	8082                	ret

030081a6 <IsXMBusAddressOrMask>:
  * @param xmbusAddress XMBus address.
  * @retval true
  * @retval false
  */
static inline bool IsXMBusAddressOrMask(unsigned int xmbusAddress)
{
 30081a6:	1101                	addi	sp,sp,-32
 30081a8:	ce22                	sw	s0,28(sp)
 30081aa:	1000                	addi	s0,sp,32
 30081ac:	fea42623          	sw	a0,-20(s0)
    return (xmbusAddress <= XMBUS_OWN_ADDRESS_MASK); /* XMBus address value is 0 to 0x3FF */
 30081b0:	fec42783          	lw	a5,-20(s0)
 30081b4:	4007b793          	sltiu	a5,a5,1024
 30081b8:	9f81                	uxtb	a5
}
 30081ba:	853e                	mv	a0,a5
 30081bc:	4472                	lw	s0,28(sp)
 30081be:	6105                	addi	sp,sp,32
 30081c0:	8082                	ret

030081c2 <IsXMBusAddressEnable>:
  * @param xmbusAddress XMBus address.
  * @retval true
  * @retval false
  */
static inline bool IsXMBusAddressEnable(unsigned int slaveOwnXmbAddressEnable)
{
 30081c2:	1101                	addi	sp,sp,-32
 30081c4:	ce22                	sw	s0,28(sp)
 30081c6:	1000                	addi	s0,sp,32
 30081c8:	fea42623          	sw	a0,-20(s0)
    return (slaveOwnXmbAddressEnable == BASE_CFG_ENABLE || slaveOwnXmbAddressEnable == BASE_CFG_DISABLE);
 30081cc:	fec42703          	lw	a4,-20(s0)
 30081d0:	4785                	li	a5,1
 30081d2:	00f70563          	beq	a4,a5,30081dc <IsXMBusAddressEnable+0x1a>
 30081d6:	fec42783          	lw	a5,-20(s0)
 30081da:	e399                	bnez	a5,30081e0 <IsXMBusAddressEnable+0x1e>
 30081dc:	4785                	li	a5,1
 30081de:	a011                	j	30081e2 <IsXMBusAddressEnable+0x20>
 30081e0:	4781                	li	a5,0
 30081e2:	8b85                	andi	a5,a5,1
 30081e4:	9f81                	uxtb	a5
}
 30081e6:	853e                	mv	a0,a5
 30081e8:	4472                	lw	s0,28(sp)
 30081ea:	6105                	addi	sp,sp,32
 30081ec:	8082                	ret

030081ee <IsI2cSpikeFilterTime>:
  * @param spikeFilterTime I2C SDA and SCL Glitch Filtering Time.
  * @retval true
  * @retval false
  */
static inline bool IsI2cSpikeFilterTime(unsigned int spikeFilterTime)
{
 30081ee:	1101                	addi	sp,sp,-32
 30081f0:	ce22                	sw	s0,28(sp)
 30081f2:	1000                	addi	s0,sp,32
 30081f4:	fea42623          	sw	a0,-20(s0)
    return (spikeFilterTime <= 0xF); /* The spikeFilterTime value is 0 to 0xF */
 30081f8:	fec42783          	lw	a5,-20(s0)
 30081fc:	0107b793          	sltiu	a5,a5,16
 3008200:	9f81                	uxtb	a5
}
 3008202:	853e                	mv	a0,a5
 3008204:	4472                	lw	s0,28(sp)
 3008206:	6105                	addi	sp,sp,32
 3008208:	8082                	ret

0300820a <IsI2cFreq>:
  * @param freq I2C freq
  * @retval true
  * @retval false
  */
static inline bool IsI2cFreq(unsigned int freq)
{
 300820a:	1101                	addi	sp,sp,-32
 300820c:	ce22                	sw	s0,28(sp)
 300820e:	1000                	addi	s0,sp,32
 3008210:	fea42623          	sw	a0,-20(s0)
    return (freq > 0);
 3008214:	fec42783          	lw	a5,-20(s0)
 3008218:	00f037b3          	snez	a5,a5
 300821c:	9f81                	uxtb	a5
}
 300821e:	853e                	mv	a0,a5
 3008220:	4472                	lw	s0,28(sp)
 3008222:	6105                	addi	sp,sp,32
 3008224:	8082                	ret

03008226 <IsI2cIgnoreAckFlag>:
  * @param ignoreAckFlag I2C ignore ack flag.
  * @retval true
  * @retval false
  */
static inline bool IsI2cIgnoreAckFlag(unsigned int ignoreAckFlag)
{
 3008226:	1101                	addi	sp,sp,-32
 3008228:	ce22                	sw	s0,28(sp)
 300822a:	1000                	addi	s0,sp,32
 300822c:	fea42623          	sw	a0,-20(s0)
    return (ignoreAckFlag == I2C_IGNORE_NAK_ENABLE ||
 3008230:	fec42703          	lw	a4,-20(s0)
 3008234:	4785                	li	a5,1
 3008236:	00f70563          	beq	a4,a5,3008240 <IsI2cIgnoreAckFlag+0x1a>
 300823a:	fec42783          	lw	a5,-20(s0)
 300823e:	e399                	bnez	a5,3008244 <IsI2cIgnoreAckFlag+0x1e>
 3008240:	4785                	li	a5,1
 3008242:	a011                	j	3008246 <IsI2cIgnoreAckFlag+0x20>
 3008244:	4781                	li	a5,0
 3008246:	8b85                	andi	a5,a5,1
 3008248:	9f81                	uxtb	a5
            ignoreAckFlag == I2C_IGNORE_NAK_DISABLE);
}
 300824a:	853e                	mv	a0,a5
 300824c:	4472                	lw	s0,28(sp)
 300824e:	6105                	addi	sp,sp,32
 3008250:	8082                	ret

03008252 <IsI2cTxWaterMark>:
  * @param txWaterMark I2C tx water mark.
  * @retval true
  * @retval false
  */
static inline bool IsI2cTxWaterMark(unsigned int txWaterMark)
{
 3008252:	1101                	addi	sp,sp,-32
 3008254:	ce22                	sw	s0,28(sp)
 3008256:	1000                	addi	s0,sp,32
 3008258:	fea42623          	sw	a0,-20(s0)
    return (txWaterMark <= 0xF); /* The txWaterMark value is 0 to 0xF */
 300825c:	fec42783          	lw	a5,-20(s0)
 3008260:	0107b793          	sltiu	a5,a5,16
 3008264:	9f81                	uxtb	a5
}
 3008266:	853e                	mv	a0,a5
 3008268:	4472                	lw	s0,28(sp)
 300826a:	6105                	addi	sp,sp,32
 300826c:	8082                	ret

0300826e <IsI2cRxWaterMark>:
  * @param rxWaterMark I2C rx water mark.
  * @retval true
  * @retval false
  */
static inline bool IsI2cRxWaterMark(unsigned int rxWaterMark)
{
 300826e:	1101                	addi	sp,sp,-32
 3008270:	ce22                	sw	s0,28(sp)
 3008272:	1000                	addi	s0,sp,32
 3008274:	fea42623          	sw	a0,-20(s0)
    return (rxWaterMark <= 0xF); /* The rxWaterMark value is 0 to 0xF */
 3008278:	fec42783          	lw	a5,-20(s0)
 300827c:	0107b793          	sltiu	a5,a5,16
 3008280:	9f81                	uxtb	a5
}
 3008282:	853e                	mv	a0,a5
 3008284:	4472                	lw	s0,28(sp)
 3008286:	6105                	addi	sp,sp,32
 3008288:	8082                	ret

0300828a <IsI2cSdaDelayTime>:
  * @param sdaDelayTime The value of SDA delay time.
  * @retval true
  * @retval false
  */
static inline bool IsI2cSdaDelayTime(unsigned int sdaDelayTime)
{
 300828a:	1101                	addi	sp,sp,-32
 300828c:	ce22                	sw	s0,28(sp)
 300828e:	1000                	addi	s0,sp,32
 3008290:	fea42623          	sw	a0,-20(s0)
    return (sdaDelayTime <= 0x0F); /* The SDA delay time upper limit is 0x0F. */
 3008294:	fec42783          	lw	a5,-20(s0)
 3008298:	0107b793          	sltiu	a5,a5,16
 300829c:	9f81                	uxtb	a5
}
 300829e:	853e                	mv	a0,a5
 30082a0:	4472                	lw	s0,28(sp)
 30082a2:	6105                	addi	sp,sp,32
 30082a4:	8082                	ret

030082a6 <CheckAllInitParameters>:
  * @param handle I2C handle.
  * @param clockFreq  I2C work clock freq;
  * @retval BASE status type: OK, ERROR, BUSY, TIMEOUT, NOT SUPPORT.
  */
static BASE_StatusType CheckAllInitParameters(I2C_Handle *handle, unsigned int clockFreq)
{
 30082a6:	1101                	addi	sp,sp,-32
 30082a8:	ce06                	sw	ra,28(sp)
 30082aa:	cc22                	sw	s0,24(sp)
 30082ac:	1000                	addi	s0,sp,32
 30082ae:	fea42623          	sw	a0,-20(s0)
 30082b2:	feb42423          	sw	a1,-24(s0)
    /* Check the configuration of basic function parameters. */
    I2C_PARAM_CHECK_WITH_RET(IsI2cFunctionMode(handle->functionMode), BASE_STATUS_ERROR);
 30082b6:	fec42783          	lw	a5,-20(s0)
 30082ba:	43dc                	lw	a5,4(a5)
 30082bc:	853e                	mv	a0,a5
 30082be:	3d19                	jal	ra,30080d4 <IsI2cFunctionMode>
 30082c0:	87aa                	mv	a5,a0
 30082c2:	0017c793          	xori	a5,a5,1
 30082c6:	9f81                	uxtb	a5
 30082c8:	cb91                	beqz	a5,30082dc <CheckAllInitParameters+0x36>
 30082ca:	09000593          	li	a1,144
 30082ce:	030117b7          	lui	a5,0x3011
 30082d2:	98c78513          	addi	a0,a5,-1652 # 301098c <g_crgIpMatch+0x47c>
 30082d6:	3bed                	jal	ra,30080d0 <AssertErrorLog.trans.5>
 30082d8:	4785                	li	a5,1
 30082da:	a439                	j	30084e8 <CheckAllInitParameters+0x242>
    I2C_PARAM_CHECK_WITH_RET(IsI2cAddressMode(handle->addrMode), BASE_STATUS_ERROR);
 30082dc:	fec42783          	lw	a5,-20(s0)
 30082e0:	479c                	lw	a5,8(a5)
 30082e2:	853e                	mv	a0,a5
 30082e4:	3d05                	jal	ra,3008114 <IsI2cAddressMode>
 30082e6:	87aa                	mv	a5,a0
 30082e8:	0017c793          	xori	a5,a5,1
 30082ec:	9f81                	uxtb	a5
 30082ee:	cb91                	beqz	a5,3008302 <CheckAllInitParameters+0x5c>
 30082f0:	09100593          	li	a1,145
 30082f4:	030117b7          	lui	a5,0x3011
 30082f8:	98c78513          	addi	a0,a5,-1652 # 301098c <g_crgIpMatch+0x47c>
 30082fc:	3bd1                	jal	ra,30080d0 <AssertErrorLog.trans.5>
 30082fe:	4785                	li	a5,1
 3008300:	a2e5                	j	30084e8 <CheckAllInitParameters+0x242>
    I2C_PARAM_CHECK_WITH_RET(IsI2cSdaHoldTime(handle->sdaHoldTime), BASE_STATUS_ERROR);
 3008302:	fec42783          	lw	a5,-20(s0)
 3008306:	4b9c                	lw	a5,16(a5)
 3008308:	853e                	mv	a0,a5
 300830a:	3d1d                	jal	ra,3008140 <IsI2cSdaHoldTime>
 300830c:	87aa                	mv	a5,a0
 300830e:	0017c793          	xori	a5,a5,1
 3008312:	9f81                	uxtb	a5
 3008314:	cb91                	beqz	a5,3008328 <CheckAllInitParameters+0x82>
 3008316:	09200593          	li	a1,146
 300831a:	030117b7          	lui	a5,0x3011
 300831e:	98c78513          	addi	a0,a5,-1652 # 301098c <g_crgIpMatch+0x47c>
 3008322:	337d                	jal	ra,30080d0 <AssertErrorLog.trans.5>
 3008324:	4785                	li	a5,1
 3008326:	a2c9                	j	30084e8 <CheckAllInitParameters+0x242>
    /* Check whether the I2C freq is valid. */
    I2C_PARAM_CHECK_WITH_RET(IsI2cFreq(handle->freq), BASE_STATUS_ERROR);
 3008328:	fec42783          	lw	a5,-20(s0)
 300832c:	4bdc                	lw	a5,20(a5)
 300832e:	853e                	mv	a0,a5
 3008330:	3de9                	jal	ra,300820a <IsI2cFreq>
 3008332:	87aa                	mv	a5,a0
 3008334:	0017c793          	xori	a5,a5,1
 3008338:	9f81                	uxtb	a5
 300833a:	cb91                	beqz	a5,300834e <CheckAllInitParameters+0xa8>
 300833c:	09400593          	li	a1,148
 3008340:	030117b7          	lui	a5,0x3011
 3008344:	98c78513          	addi	a0,a5,-1652 # 301098c <g_crgIpMatch+0x47c>
 3008348:	3361                	jal	ra,30080d0 <AssertErrorLog.trans.5>
 300834a:	4785                	li	a5,1
 300834c:	aa71                	j	30084e8 <CheckAllInitParameters+0x242>
    I2C_PARAM_CHECK_WITH_RET((clockFreq > 0), BASE_STATUS_ERROR);
 300834e:	fe842783          	lw	a5,-24(s0)
 3008352:	eb91                	bnez	a5,3008366 <CheckAllInitParameters+0xc0>
 3008354:	09500593          	li	a1,149
 3008358:	030117b7          	lui	a5,0x3011
 300835c:	98c78513          	addi	a0,a5,-1652 # 301098c <g_crgIpMatch+0x47c>
 3008360:	3b85                	jal	ra,30080d0 <AssertErrorLog.trans.5>
 3008362:	4785                	li	a5,1
 3008364:	a251                	j	30084e8 <CheckAllInitParameters+0x242>

    if (handle->freq > clockFreq) {
 3008366:	fec42783          	lw	a5,-20(s0)
 300836a:	4bdc                	lw	a5,20(a5)
 300836c:	fe842703          	lw	a4,-24(s0)
 3008370:	00f77463          	bgeu	a4,a5,3008378 <CheckAllInitParameters+0xd2>
        return BASE_STATUS_ERROR;
 3008374:	4785                	li	a5,1
 3008376:	aa8d                	j	30084e8 <CheckAllInitParameters+0x242>
    }
    /* Check the configuration of basic function parameters. */
    I2C_PARAM_CHECK_WITH_RET(IsI2cIgnoreAckFlag(handle->ignoreAckFlag), BASE_STATUS_ERROR);
 3008378:	fec42783          	lw	a5,-20(s0)
 300837c:	4f9c                	lw	a5,24(a5)
 300837e:	853e                	mv	a0,a5
 3008380:	355d                	jal	ra,3008226 <IsI2cIgnoreAckFlag>
 3008382:	87aa                	mv	a5,a0
 3008384:	0017c793          	xori	a5,a5,1
 3008388:	9f81                	uxtb	a5
 300838a:	cb91                	beqz	a5,300839e <CheckAllInitParameters+0xf8>
 300838c:	09b00593          	li	a1,155
 3008390:	030117b7          	lui	a5,0x3011
 3008394:	98c78513          	addi	a0,a5,-1652 # 301098c <g_crgIpMatch+0x47c>
 3008398:	3b25                	jal	ra,30080d0 <AssertErrorLog.trans.5>
 300839a:	4785                	li	a5,1
 300839c:	a2b1                	j	30084e8 <CheckAllInitParameters+0x242>
    I2C_PARAM_CHECK_WITH_RET(IsI2cTxWaterMark(handle->txWaterMark), BASE_STATUS_ERROR);
 300839e:	fec42783          	lw	a5,-20(s0)
 30083a2:	5bdc                	lw	a5,52(a5)
 30083a4:	853e                	mv	a0,a5
 30083a6:	3575                	jal	ra,3008252 <IsI2cTxWaterMark>
 30083a8:	87aa                	mv	a5,a0
 30083aa:	0017c793          	xori	a5,a5,1
 30083ae:	9f81                	uxtb	a5
 30083b0:	cb91                	beqz	a5,30083c4 <CheckAllInitParameters+0x11e>
 30083b2:	09c00593          	li	a1,156
 30083b6:	030117b7          	lui	a5,0x3011
 30083ba:	98c78513          	addi	a0,a5,-1652 # 301098c <g_crgIpMatch+0x47c>
 30083be:	3b09                	jal	ra,30080d0 <AssertErrorLog.trans.5>
 30083c0:	4785                	li	a5,1
 30083c2:	a21d                	j	30084e8 <CheckAllInitParameters+0x242>
    I2C_PARAM_CHECK_WITH_RET(IsI2cRxWaterMark(handle->rxWaterMark), BASE_STATUS_ERROR);
 30083c4:	fec42783          	lw	a5,-20(s0)
 30083c8:	5b9c                	lw	a5,48(a5)
 30083ca:	853e                	mv	a0,a5
 30083cc:	354d                	jal	ra,300826e <IsI2cRxWaterMark>
 30083ce:	87aa                	mv	a5,a0
 30083d0:	0017c793          	xori	a5,a5,1
 30083d4:	9f81                	uxtb	a5
 30083d6:	cb91                	beqz	a5,30083ea <CheckAllInitParameters+0x144>
 30083d8:	09d00593          	li	a1,157
 30083dc:	030117b7          	lui	a5,0x3011
 30083e0:	98c78513          	addi	a0,a5,-1652 # 301098c <g_crgIpMatch+0x47c>
 30083e4:	31f5                	jal	ra,30080d0 <AssertErrorLog.trans.5>
 30083e6:	4785                	li	a5,1
 30083e8:	a201                	j	30084e8 <CheckAllInitParameters+0x242>
    I2C_PARAM_CHECK_WITH_RET(IsI2cSpikeFilterTime(handle->handleEx.spikeFilterTime), BASE_STATUS_ERROR);
 30083ea:	fec42783          	lw	a5,-20(s0)
 30083ee:	4fbc                	lw	a5,88(a5)
 30083f0:	853e                	mv	a0,a5
 30083f2:	3bf5                	jal	ra,30081ee <IsI2cSpikeFilterTime>
 30083f4:	87aa                	mv	a5,a0
 30083f6:	0017c793          	xori	a5,a5,1
 30083fa:	9f81                	uxtb	a5
 30083fc:	cb91                	beqz	a5,3008410 <CheckAllInitParameters+0x16a>
 30083fe:	09e00593          	li	a1,158
 3008402:	030117b7          	lui	a5,0x3011
 3008406:	98c78513          	addi	a0,a5,-1652 # 301098c <g_crgIpMatch+0x47c>
 300840a:	31d9                	jal	ra,30080d0 <AssertErrorLog.trans.5>
 300840c:	4785                	li	a5,1
 300840e:	a8e9                	j	30084e8 <CheckAllInitParameters+0x242>
    I2C_PARAM_CHECK_WITH_RET(IsI2cSdaDelayTime(handle->handleEx.sdaDelayTime), BASE_STATUS_ERROR);
 3008410:	fec42783          	lw	a5,-20(s0)
 3008414:	4ffc                	lw	a5,92(a5)
 3008416:	853e                	mv	a0,a5
 3008418:	3d8d                	jal	ra,300828a <IsI2cSdaDelayTime>
 300841a:	87aa                	mv	a5,a0
 300841c:	0017c793          	xori	a5,a5,1
 3008420:	9f81                	uxtb	a5
 3008422:	cb91                	beqz	a5,3008436 <CheckAllInitParameters+0x190>
 3008424:	09f00593          	li	a1,159
 3008428:	030117b7          	lui	a5,0x3011
 300842c:	98c78513          	addi	a0,a5,-1652 # 301098c <g_crgIpMatch+0x47c>
 3008430:	3145                	jal	ra,30080d0 <AssertErrorLog.trans.5>
 3008432:	4785                	li	a5,1
 3008434:	a855                	j	30084e8 <CheckAllInitParameters+0x242>

    /* Checking the own address and generalCall parameter enable when is used as slave. */
    if (handle->functionMode == I2C_MODE_SELECT_SLAVE_ONLY || handle->functionMode == I2C_MODE_SELECT_MASTER_SLAVE) {
 3008436:	fec42783          	lw	a5,-20(s0)
 300843a:	43d8                	lw	a4,4(a5)
 300843c:	4789                	li	a5,2
 300843e:	00f70863          	beq	a4,a5,300844e <CheckAllInitParameters+0x1a8>
 3008442:	fec42783          	lw	a5,-20(s0)
 3008446:	43d8                	lw	a4,4(a5)
 3008448:	478d                	li	a5,3
 300844a:	08f71e63          	bne	a4,a5,30084e6 <CheckAllInitParameters+0x240>
        I2C_PARAM_CHECK_WITH_RET(IsI2cOwnAddressOrMask(handle->slaveOwnAddress), BASE_STATUS_ERROR);
 300844e:	fec42783          	lw	a5,-20(s0)
 3008452:	47dc                	lw	a5,12(a5)
 3008454:	853e                	mv	a0,a5
 3008456:	3b15                	jal	ra,300818a <IsI2cOwnAddressOrMask>
 3008458:	87aa                	mv	a5,a0
 300845a:	0017c793          	xori	a5,a5,1
 300845e:	9f81                	uxtb	a5
 3008460:	cb91                	beqz	a5,3008474 <CheckAllInitParameters+0x1ce>
 3008462:	0a300593          	li	a1,163
 3008466:	030117b7          	lui	a5,0x3011
 300846a:	98c78513          	addi	a0,a5,-1652 # 301098c <g_crgIpMatch+0x47c>
 300846e:	318d                	jal	ra,30080d0 <AssertErrorLog.trans.5>
 3008470:	4785                	li	a5,1
 3008472:	a89d                	j	30084e8 <CheckAllInitParameters+0x242>
        I2C_PARAM_CHECK_WITH_RET(IsI2cGeneralCallMode(handle->generalCallMode), BASE_STATUS_ERROR);
 3008474:	fec42783          	lw	a5,-20(s0)
 3008478:	4fdc                	lw	a5,28(a5)
 300847a:	853e                	mv	a0,a5
 300847c:	31cd                	jal	ra,300815e <IsI2cGeneralCallMode>
 300847e:	87aa                	mv	a5,a0
 3008480:	0017c793          	xori	a5,a5,1
 3008484:	9f81                	uxtb	a5
 3008486:	cb91                	beqz	a5,300849a <CheckAllInitParameters+0x1f4>
 3008488:	0a400593          	li	a1,164
 300848c:	030117b7          	lui	a5,0x3011
 3008490:	98c78513          	addi	a0,a5,-1652 # 301098c <g_crgIpMatch+0x47c>
 3008494:	3935                	jal	ra,30080d0 <AssertErrorLog.trans.5>
 3008496:	4785                	li	a5,1
 3008498:	a881                	j	30084e8 <CheckAllInitParameters+0x242>
        I2C_PARAM_CHECK_WITH_RET(IsXMBusAddressEnable(handle->handleEx.slaveOwnXmbAddressEnable), BASE_STATUS_ERROR);
 300849a:	fec42783          	lw	a5,-20(s0)
 300849e:	53bc                	lw	a5,96(a5)
 30084a0:	853e                	mv	a0,a5
 30084a2:	3305                	jal	ra,30081c2 <IsXMBusAddressEnable>
 30084a4:	87aa                	mv	a5,a0
 30084a6:	0017c793          	xori	a5,a5,1
 30084aa:	9f81                	uxtb	a5
 30084ac:	cb91                	beqz	a5,30084c0 <CheckAllInitParameters+0x21a>
 30084ae:	0a500593          	li	a1,165
 30084b2:	030117b7          	lui	a5,0x3011
 30084b6:	98c78513          	addi	a0,a5,-1652 # 301098c <g_crgIpMatch+0x47c>
 30084ba:	3919                	jal	ra,30080d0 <AssertErrorLog.trans.5>
 30084bc:	4785                	li	a5,1
 30084be:	a02d                	j	30084e8 <CheckAllInitParameters+0x242>
        I2C_PARAM_CHECK_WITH_RET(IsXMBusAddressOrMask(handle->handleEx.slaveOwnXmbAddress), BASE_STATUS_ERROR);
 30084c0:	fec42783          	lw	a5,-20(s0)
 30084c4:	53fc                	lw	a5,100(a5)
 30084c6:	853e                	mv	a0,a5
 30084c8:	39f9                	jal	ra,30081a6 <IsXMBusAddressOrMask>
 30084ca:	87aa                	mv	a5,a0
 30084cc:	0017c793          	xori	a5,a5,1
 30084d0:	9f81                	uxtb	a5
 30084d2:	cb91                	beqz	a5,30084e6 <CheckAllInitParameters+0x240>
 30084d4:	0a600593          	li	a1,166
 30084d8:	030117b7          	lui	a5,0x3011
 30084dc:	98c78513          	addi	a0,a5,-1652 # 301098c <g_crgIpMatch+0x47c>
 30084e0:	3ec5                	jal	ra,30080d0 <AssertErrorLog.trans.5>
 30084e2:	4785                	li	a5,1
 30084e4:	a011                	j	30084e8 <CheckAllInitParameters+0x242>
    }
    return BASE_STATUS_OK;
 30084e6:	4781                	li	a5,0
}
 30084e8:	853e                	mv	a0,a5
 30084ea:	40f2                	lw	ra,28(sp)
 30084ec:	4462                	lw	s0,24(sp)
 30084ee:	6105                	addi	sp,sp,32
 30084f0:	8082                	ret

030084f2 <HAL_I2C_Init>:
  * @brief Initializing the I2C Module.
  * @param handle I2C handle.
  * @retval BASE status type: OK, ERROR, BUSY, TIMEOUT, NOT SUPPORT.
  */
BASE_StatusType HAL_I2C_Init(I2C_Handle *handle)
{
 30084f2:	7139                	addi	sp,sp,-64
 30084f4:	de06                	sw	ra,60(sp)
 30084f6:	dc22                	sw	s0,56(sp)
 30084f8:	0080                	addi	s0,sp,64
 30084fa:	fca42623          	sw	a0,-52(s0)
    unsigned int tempReg;
    unsigned int temp;
    unsigned int tempSclLowTime;
    unsigned int tempSclHighTime;

    I2C_ASSERT_PARAM(handle != NULL);
 30084fe:	fcc42783          	lw	a5,-52(s0)
 3008502:	eb89                	bnez	a5,3008514 <HAL_I2C_Init+0x22>
 3008504:	4f400593          	li	a1,1268
 3008508:	030117b7          	lui	a5,0x3011
 300850c:	98c78513          	addi	a0,a5,-1652 # 301098c <g_crgIpMatch+0x47c>
 3008510:	36c1                	jal	ra,30080d0 <AssertErrorLog.trans.5>
 3008512:	a001                	j	3008512 <HAL_I2C_Init+0x20>
    I2C_ASSERT_PARAM(IsI2CInstance(handle->baseAddress));
 3008514:	fcc42783          	lw	a5,-52(s0)
 3008518:	4398                	lw	a4,0(a5)
 300851a:	141007b7          	lui	a5,0x14100
 300851e:	02f70163          	beq	a4,a5,3008540 <HAL_I2C_Init+0x4e>
 3008522:	fcc42783          	lw	a5,-52(s0)
 3008526:	4398                	lw	a4,0(a5)
 3008528:	141017b7          	lui	a5,0x14101
 300852c:	00f70a63          	beq	a4,a5,3008540 <HAL_I2C_Init+0x4e>
 3008530:	4f500593          	li	a1,1269
 3008534:	030117b7          	lui	a5,0x3011
 3008538:	98c78513          	addi	a0,a5,-1652 # 301098c <g_crgIpMatch+0x47c>
 300853c:	3e51                	jal	ra,30080d0 <AssertErrorLog.trans.5>
 300853e:	a001                	j	300853e <HAL_I2C_Init+0x4c>

    clockFreq = HAL_CRG_GetIpFreq((void *)handle->baseAddress);
 3008540:	fcc42783          	lw	a5,-52(s0)
 3008544:	439c                	lw	a5,0(a5)
 3008546:	853e                	mv	a0,a5
 3008548:	9abfc0ef          	jal	ra,3004ef2 <HAL_CRG_GetIpFreq>
 300854c:	fea42423          	sw	a0,-24(s0)
    if (CheckAllInitParameters(handle, clockFreq) != BASE_STATUS_OK) {
 3008550:	fe842583          	lw	a1,-24(s0)
 3008554:	fcc42503          	lw	a0,-52(s0)
 3008558:	33b9                	jal	ra,30082a6 <CheckAllInitParameters>
 300855a:	87aa                	mv	a5,a0
 300855c:	c399                	beqz	a5,3008562 <HAL_I2C_Init+0x70>
        return BASE_STATUS_ERROR;
 300855e:	4785                	li	a5,1
 3008560:	a4ad                	j	30087ca <HAL_I2C_Init+0x2d8>
    }

    handle->state = I2C_STATE_BUSY;
 3008562:	fcc42783          	lw	a5,-52(s0)
 3008566:	4709                	li	a4,2
 3008568:	c3f8                	sw	a4,68(a5)
    /* Clears interrupts and disables interrupt reporting to facilitate switching between different working modes. */
    handle->baseAddress->I2C_INTR_EN.reg = I2C_INTR_EN_ALL_DISABLE;
 300856a:	fcc42783          	lw	a5,-52(s0)
 300856e:	439c                	lw	a5,0(a5)
 3008570:	0e07a223          	sw	zero,228(a5)
    handle->baseAddress->I2C_INTR_RAW.reg = I2C_INTR_RAW_ALL_ENABLE;
 3008574:	fcc42783          	lw	a5,-52(s0)
 3008578:	439c                	lw	a5,0(a5)
 300857a:	01000737          	lui	a4,0x1000
 300857e:	177d                	addi	a4,a4,-1 # ffffff <FLASH_SIZE+0xfe0003>
 3008580:	0ee7a023          	sw	a4,224(a5)

    /* Set SDA and SCL glitch filtering time. */
    handle->baseAddress->I2C_FILTER.BIT.spike_filter_time = handle->handleEx.spikeFilterTime;
 3008584:	fcc42783          	lw	a5,-52(s0)
 3008588:	4fb4                	lw	a3,88(a5)
 300858a:	fcc42783          	lw	a5,-52(s0)
 300858e:	4398                	lw	a4,0(a5)
 3008590:	87b6                	mv	a5,a3
 3008592:	8bbd                	andi	a5,a5,15
 3008594:	0ff7f693          	andi	a3,a5,255
 3008598:	10c72783          	lw	a5,268(a4)
 300859c:	8abd                	andi	a3,a3,15
 300859e:	9bc1                	andi	a5,a5,-16
 30085a0:	8fd5                	or	a5,a5,a3
 30085a2:	10f72623          	sw	a5,268(a4)
    /* Set SCL high and low duratiom time */
    tempSclLowTime = I2C_FREQ_LOW_PARAMTER + handle->handleEx.spikeFilterTime;
 30085a6:	fcc42783          	lw	a5,-52(s0)
 30085aa:	4fbc                	lw	a5,88(a5)
 30085ac:	07a5                	addi	a5,a5,9
 30085ae:	fef42223          	sw	a5,-28(s0)
    tempSclHighTime = I2C_FREQ_HIGH_PARAMTER + handle->handleEx.spikeFilterTime;
 30085b2:	fcc42783          	lw	a5,-52(s0)
 30085b6:	4fbc                	lw	a5,88(a5)
 30085b8:	07a1                	addi	a5,a5,8
 30085ba:	fef42023          	sw	a5,-32(s0)
    if (handle->freq <= I2C_STANDARD_FREQ_TH) {
 30085be:	fcc42783          	lw	a5,-52(s0)
 30085c2:	4bd8                	lw	a4,20(a5)
 30085c4:	67e1                	lui	a5,0x18
 30085c6:	6a078793          	addi	a5,a5,1696 # 186a0 <RAM_SIZE+0x136a0>
 30085ca:	02e7ee63          	bltu	a5,a4,3008606 <HAL_I2C_Init+0x114>
        /* scl_high_time = (fclk_i2c/fSCL) x 0.5 - 8 - spike_filter_time. */
        val = clockFreq / (handle->freq * 2) - tempSclHighTime; /* The clockFreq / (freq * 2) = cloclFreq/0.5/freq. */
 30085ce:	fcc42783          	lw	a5,-52(s0)
 30085d2:	4bdc                	lw	a5,20(a5)
 30085d4:	0786                	slli	a5,a5,0x1
 30085d6:	fe842703          	lw	a4,-24(s0)
 30085da:	02f75733          	divu	a4,a4,a5
 30085de:	fe042783          	lw	a5,-32(s0)
 30085e2:	40f707b3          	sub	a5,a4,a5
 30085e6:	fef42623          	sw	a5,-20(s0)
        /* scl_low_time = (fclk_i2c/fSCL) x 0.5 - 9 - spike_filter_time. */
        val = ((val - 1) & LOW_HOLD_TIME_MASK) | ((val << HIGH_HOLD_TIME_POS) & HIGH_HOLD_TIME_MASK);
 30085ea:	fec42783          	lw	a5,-20(s0)
 30085ee:	fff78713          	addi	a4,a5,-1
 30085f2:	67c1                	lui	a5,0x10
 30085f4:	17fd                	addi	a5,a5,-1 # ffff <RAM_SIZE+0xafff>
 30085f6:	8f7d                	and	a4,a4,a5
 30085f8:	fec42783          	lw	a5,-20(s0)
 30085fc:	07c2                	slli	a5,a5,0x10
 30085fe:	8fd9                	or	a5,a5,a4
 3008600:	fef42623          	sw	a5,-20(s0)
 3008604:	a8b9                	j	3008662 <HAL_I2C_Init+0x170>
    } else {
        /* scl_high_time = (fclk_i2c/fSCL) x 0.36 - 8 - spike_filter_time. (n/100*36)=0.36n. */
        val = ((((clockFreq / 100) * 36) / handle->freq) - tempSclHighTime) << HIGH_HOLD_TIME_POS;
 3008606:	fe842703          	lw	a4,-24(s0)
 300860a:	06400793          	li	a5,100
 300860e:	02f75733          	divu	a4,a4,a5
 3008612:	02400793          	li	a5,36
 3008616:	02f70733          	mul	a4,a4,a5
 300861a:	fcc42783          	lw	a5,-52(s0)
 300861e:	4bdc                	lw	a5,20(a5)
 3008620:	02f75733          	divu	a4,a4,a5
 3008624:	fe042783          	lw	a5,-32(s0)
 3008628:	40f707b3          	sub	a5,a4,a5
 300862c:	07c2                	slli	a5,a5,0x10
 300862e:	fef42623          	sw	a5,-20(s0)
        /* scl_low_time = (fclk_i2c/fSCL) x 0.64 - 9 - spike_filter_time. (n/100*64)=0.64n. */
        val |= (((((clockFreq / 100) * 64) / handle->freq) - tempSclLowTime) & LOW_HOLD_TIME_MASK);
 3008632:	fe842703          	lw	a4,-24(s0)
 3008636:	06400793          	li	a5,100
 300863a:	02f757b3          	divu	a5,a4,a5
 300863e:	00679713          	slli	a4,a5,0x6
 3008642:	fcc42783          	lw	a5,-52(s0)
 3008646:	4bdc                	lw	a5,20(a5)
 3008648:	02f75733          	divu	a4,a4,a5
 300864c:	fe442783          	lw	a5,-28(s0)
 3008650:	8f1d                	sub	a4,a4,a5
 3008652:	67c1                	lui	a5,0x10
 3008654:	17fd                	addi	a5,a5,-1 # ffff <RAM_SIZE+0xafff>
 3008656:	8ff9                	and	a5,a5,a4
 3008658:	fec42703          	lw	a4,-20(s0)
 300865c:	8fd9                	or	a5,a5,a4
 300865e:	fef42623          	sw	a5,-20(s0)
    }
    handle->baseAddress->I2C_SCL_CFG.reg = val;
 3008662:	fcc42783          	lw	a5,-52(s0)
 3008666:	439c                	lw	a5,0(a5)
 3008668:	fec42703          	lw	a4,-20(s0)
 300866c:	c3d8                	sw	a4,4(a5)

    /* Set sda hold duration.The value is fixed to 0xa */
    temp = ((handle->sdaHoldTime & 0x0000FFFF) << I2C_SDA_HOLD_DURATION_POS);
 300866e:	fcc42783          	lw	a5,-52(s0)
 3008672:	4b9c                	lw	a5,16(a5)
 3008674:	07c2                	slli	a5,a5,0x10
 3008676:	fcf42e23          	sw	a5,-36(s0)
    tempReg = (handle->handleEx.sdaDelayTime & 0x0000000F) | temp;
 300867a:	fcc42783          	lw	a5,-52(s0)
 300867e:	4ffc                	lw	a5,92(a5)
 3008680:	8bbd                	andi	a5,a5,15
 3008682:	fdc42703          	lw	a4,-36(s0)
 3008686:	8fd9                	or	a5,a5,a4
 3008688:	fcf42c23          	sw	a5,-40(s0)
    handle->baseAddress->I2C_SDA_CFG.reg = tempReg;
 300868c:	fcc42783          	lw	a5,-52(s0)
 3008690:	439c                	lw	a5,0(a5)
 3008692:	fd842703          	lw	a4,-40(s0)
 3008696:	c798                	sw	a4,8(a5)

    /* Set I2C TX FIFO watermark */
    handle->baseAddress->I2C_TX_WATERMARK.BIT.tx_watermark = handle->txWaterMark;
 3008698:	fcc42783          	lw	a5,-52(s0)
 300869c:	5bd4                	lw	a3,52(a5)
 300869e:	fcc42783          	lw	a5,-52(s0)
 30086a2:	4398                	lw	a4,0(a5)
 30086a4:	87b6                	mv	a5,a3
 30086a6:	8bbd                	andi	a5,a5,15
 30086a8:	0ff7f693          	andi	a3,a5,255
 30086ac:	0c872783          	lw	a5,200(a4)
 30086b0:	8abd                	andi	a3,a3,15
 30086b2:	9bc1                	andi	a5,a5,-16
 30086b4:	8fd5                	or	a5,a5,a3
 30086b6:	0cf72423          	sw	a5,200(a4)
    /* Set I2C RX FIFO watermark */
    handle->baseAddress->I2C_RX_WATERMARK.BIT.rx_watermark = handle->rxWaterMark;
 30086ba:	fcc42783          	lw	a5,-52(s0)
 30086be:	5b94                	lw	a3,48(a5)
 30086c0:	fcc42783          	lw	a5,-52(s0)
 30086c4:	4398                	lw	a4,0(a5)
 30086c6:	87b6                	mv	a5,a3
 30086c8:	8bbd                	andi	a5,a5,15
 30086ca:	0ff7f693          	andi	a3,a5,255
 30086ce:	0cc72783          	lw	a5,204(a4)
 30086d2:	8abd                	andi	a3,a3,15
 30086d4:	9bc1                	andi	a5,a5,-16
 30086d6:	8fd5                	or	a5,a5,a3
 30086d8:	0cf72623          	sw	a5,204(a4)
    handle->baseAddress->I2C_MODE.BIT.mst_slv_function = handle->functionMode;
 30086dc:	fcc42783          	lw	a5,-52(s0)
 30086e0:	43d4                	lw	a3,4(a5)
 30086e2:	fcc42783          	lw	a5,-52(s0)
 30086e6:	4398                	lw	a4,0(a5)
 30086e8:	87b6                	mv	a5,a3
 30086ea:	8b8d                	andi	a5,a5,3
 30086ec:	0ff7f693          	andi	a3,a5,255
 30086f0:	431c                	lw	a5,0(a4)
 30086f2:	8a8d                	andi	a3,a3,3
 30086f4:	9bf1                	andi	a5,a5,-4
 30086f6:	8fd5                	or	a5,a5,a3
 30086f8:	c31c                	sw	a5,0(a4)
    handle->baseAddress->I2C_MODE.BIT.rack_mode = handle->ignoreAckFlag;
 30086fa:	fcc42783          	lw	a5,-52(s0)
 30086fe:	4f94                	lw	a3,24(a5)
 3008700:	fcc42783          	lw	a5,-52(s0)
 3008704:	4398                	lw	a4,0(a5)
 3008706:	87b6                	mv	a5,a3
 3008708:	8b85                	andi	a5,a5,1
 300870a:	0ff7f693          	andi	a3,a5,255
 300870e:	431c                	lw	a5,0(a4)
 3008710:	8a85                	andi	a3,a3,1
 3008712:	0692                	slli	a3,a3,0x4
 3008714:	9bbd                	andi	a5,a5,-17
 3008716:	8fd5                	or	a5,a5,a3
 3008718:	c31c                	sw	a5,0(a4)

    if (handle->functionMode == I2C_MODE_SELECT_SLAVE_ONLY || handle->functionMode == I2C_MODE_SELECT_MASTER_SLAVE) {
 300871a:	fcc42783          	lw	a5,-52(s0)
 300871e:	43d8                	lw	a4,4(a5)
 3008720:	4789                	li	a5,2
 3008722:	00f70863          	beq	a4,a5,3008732 <HAL_I2C_Init+0x240>
 3008726:	fcc42783          	lw	a5,-52(s0)
 300872a:	43d8                	lw	a4,4(a5)
 300872c:	478d                	li	a5,3
 300872e:	08f71963          	bne	a4,a5,30087c0 <HAL_I2C_Init+0x2ce>
        /* Sets the first own address of the slave. */
        handle->baseAddress->I2C_OWN_ADDR.BIT.own_address = handle->slaveOwnAddress;
 3008732:	fcc42783          	lw	a5,-52(s0)
 3008736:	47d4                	lw	a3,12(a5)
 3008738:	fcc42783          	lw	a5,-52(s0)
 300873c:	4398                	lw	a4,0(a5)
 300873e:	87b6                	mv	a5,a3
 3008740:	3ff7f793          	andi	a5,a5,1023
 3008744:	01079693          	slli	a3,a5,0x10
 3008748:	82c1                	srli	a3,a3,0x10
 300874a:	475c                	lw	a5,12(a4)
 300874c:	3ff6f693          	andi	a3,a3,1023
 3008750:	c007f793          	andi	a5,a5,-1024
 3008754:	8fd5                	or	a5,a5,a3
 3008756:	c75c                	sw	a5,12(a4)
        handle->baseAddress->I2C_OWN_ADDR.BIT.i2c_general_call_en = handle->generalCallMode;
 3008758:	fcc42783          	lw	a5,-52(s0)
 300875c:	4fd4                	lw	a3,28(a5)
 300875e:	fcc42783          	lw	a5,-52(s0)
 3008762:	4398                	lw	a4,0(a5)
 3008764:	87b6                	mv	a5,a3
 3008766:	8b85                	andi	a5,a5,1
 3008768:	0ff7f693          	andi	a3,a5,255
 300876c:	475c                	lw	a5,12(a4)
 300876e:	8a85                	andi	a3,a3,1
 3008770:	06e2                	slli	a3,a3,0x18
 3008772:	ff000637          	lui	a2,0xff000
 3008776:	167d                	addi	a2,a2,-1 # feffffff <RAM_END+0xfaff7fff>
 3008778:	8ff1                	and	a5,a5,a2
 300877a:	8fd5                	or	a5,a5,a3
 300877c:	c75c                	sw	a5,12(a4)
        /* Sets the second own address of the slave. */
        if (handle->handleEx.slaveOwnXmbAddressEnable == BASE_CFG_ENABLE) {
 300877e:	fcc42783          	lw	a5,-52(s0)
 3008782:	53b8                	lw	a4,96(a5)
 3008784:	4785                	li	a5,1
 3008786:	02f71d63          	bne	a4,a5,30087c0 <HAL_I2C_Init+0x2ce>
            handle->baseAddress->XMB_DEV_ADDR.BIT.xmb_address_en = BASE_CFG_ENABLE;
 300878a:	fcc42783          	lw	a5,-52(s0)
 300878e:	4398                	lw	a4,0(a5)
 3008790:	4b1c                	lw	a5,16(a4)
 3008792:	004006b7          	lui	a3,0x400
 3008796:	8fd5                	or	a5,a5,a3
 3008798:	cb1c                	sw	a5,16(a4)
            handle->baseAddress->XMB_DEV_ADDR.BIT.xmb_address = handle->handleEx.slaveOwnXmbAddress;
 300879a:	fcc42783          	lw	a5,-52(s0)
 300879e:	53f4                	lw	a3,100(a5)
 30087a0:	fcc42783          	lw	a5,-52(s0)
 30087a4:	4398                	lw	a4,0(a5)
 30087a6:	87b6                	mv	a5,a3
 30087a8:	3ff7f793          	andi	a5,a5,1023
 30087ac:	01079693          	slli	a3,a5,0x10
 30087b0:	82c1                	srli	a3,a3,0x10
 30087b2:	4b1c                	lw	a5,16(a4)
 30087b4:	3ff6f693          	andi	a3,a3,1023
 30087b8:	c007f793          	andi	a5,a5,-1024
 30087bc:	8fd5                	or	a5,a5,a3
 30087be:	cb1c                	sw	a5,16(a4)
        }
    }
    handle->state = I2C_STATE_READY;
 30087c0:	fcc42783          	lw	a5,-52(s0)
 30087c4:	4705                	li	a4,1
 30087c6:	c3f8                	sw	a4,68(a5)
    return BASE_STATUS_OK;
 30087c8:	4781                	li	a5,0
}
 30087ca:	853e                	mv	a0,a5
 30087cc:	50f2                	lw	ra,60(sp)
 30087ce:	5462                	lw	s0,56(sp)
 30087d0:	6121                	addi	sp,sp,64
 30087d2:	8082                	ret

030087d4 <DCL_IOCMG_SetRegValue>:
  * @param iocmgRegx Value of @ref IOCMG_REG.
  * @param regValue value of @ref IOCMG_REG.
  * @retval None.
  */
static inline void DCL_IOCMG_SetRegValue(IOCMG_REG *iocmgRegx, unsigned int regValue)
{
 30087d4:	1101                	addi	sp,sp,-32
 30087d6:	ce06                	sw	ra,28(sp)
 30087d8:	cc22                	sw	s0,24(sp)
 30087da:	1000                	addi	s0,sp,32
 30087dc:	fea42623          	sw	a0,-20(s0)
 30087e0:	feb42423          	sw	a1,-24(s0)
    IOCMG_ASSERT_PARAM(IsIOCMGInstance((void *)((uintptr_t)(void *)iocmgRegx & IOCMG_BASE_ADDR_MASK)));
 30087e4:	fec42703          	lw	a4,-20(s0)
 30087e8:	77c1                	lui	a5,0xffff0
 30087ea:	8f7d                	and	a4,a4,a5
 30087ec:	147f07b7          	lui	a5,0x147f0
 30087f0:	00f70a63          	beq	a4,a5,3008804 <DCL_IOCMG_SetRegValue+0x30>
 30087f4:	08500593          	li	a1,133
 30087f8:	030117b7          	lui	a5,0x3011
 30087fc:	9a878513          	addi	a0,a5,-1624 # 30109a8 <g_crgIpMatch+0x498>
 3008800:	266d                	jal	ra,3008baa <AssertErrorLog.trans.6>
 3008802:	a001                	j	3008802 <DCL_IOCMG_SetRegValue+0x2e>
    iocmgRegx->reg = regValue;
 3008804:	fec42783          	lw	a5,-20(s0)
 3008808:	fe842703          	lw	a4,-24(s0)
 300880c:	c398                	sw	a4,0(a5)
}
 300880e:	0001                	nop
 3008810:	40f2                	lw	ra,28(sp)
 3008812:	4462                	lw	s0,24(sp)
 3008814:	6105                	addi	sp,sp,32
 3008816:	8082                	ret

03008818 <DCL_IOCMG_SetDriveRate>:
  * @param iocmgRegx Value of @ref IOCMG_REG.
  * @param driveRate value of @ref IOCMG_DriveRate.
  * @retval None.
  */
static inline void DCL_IOCMG_SetDriveRate(IOCMG_REG *iocmgRegx, IOCMG_DriveRate driveRate)
{
 3008818:	1101                	addi	sp,sp,-32
 300881a:	ce06                	sw	ra,28(sp)
 300881c:	cc22                	sw	s0,24(sp)
 300881e:	1000                	addi	s0,sp,32
 3008820:	fea42623          	sw	a0,-20(s0)
 3008824:	feb42423          	sw	a1,-24(s0)
    IOCMG_ASSERT_PARAM(IsIOCMGInstance((void *)((uintptr_t)(void *)iocmgRegx & IOCMG_BASE_ADDR_MASK)));
 3008828:	fec42703          	lw	a4,-20(s0)
 300882c:	77c1                	lui	a5,0xffff0
 300882e:	8f7d                	and	a4,a4,a5
 3008830:	147f07b7          	lui	a5,0x147f0
 3008834:	00f70a63          	beq	a4,a5,3008848 <DCL_IOCMG_SetDriveRate+0x30>
 3008838:	0b400593          	li	a1,180
 300883c:	030117b7          	lui	a5,0x3011
 3008840:	9a878513          	addi	a0,a5,-1624 # 30109a8 <g_crgIpMatch+0x498>
 3008844:	269d                	jal	ra,3008baa <AssertErrorLog.trans.6>
 3008846:	a001                	j	3008846 <DCL_IOCMG_SetDriveRate+0x2e>
    IOCMG_PARAM_CHECK_NO_RET(driveRate < DRIVER_RATE_MAX && driveRate >= DRIVER_RATE_4);
 3008848:	fe842703          	lw	a4,-24(s0)
 300884c:	478d                	li	a5,3
 300884e:	00e7fa63          	bgeu	a5,a4,3008862 <DCL_IOCMG_SetDriveRate+0x4a>
 3008852:	0b500593          	li	a1,181
 3008856:	030117b7          	lui	a5,0x3011
 300885a:	9a878513          	addi	a0,a5,-1624 # 30109a8 <g_crgIpMatch+0x498>
 300885e:	26b1                	jal	ra,3008baa <AssertErrorLog.trans.6>
 3008860:	a839                	j	300887e <DCL_IOCMG_SetDriveRate+0x66>
    iocmgRegx->BIT.ds = driveRate;
 3008862:	fe842783          	lw	a5,-24(s0)
 3008866:	8b8d                	andi	a5,a5,3
 3008868:	0ff7f693          	andi	a3,a5,255
 300886c:	fec42703          	lw	a4,-20(s0)
 3008870:	431c                	lw	a5,0(a4)
 3008872:	8a8d                	andi	a3,a3,3
 3008874:	0692                	slli	a3,a3,0x4
 3008876:	fcf7f793          	andi	a5,a5,-49
 300887a:	8fd5                	or	a5,a5,a3
 300887c:	c31c                	sw	a5,0(a4)
}
 300887e:	40f2                	lw	ra,28(sp)
 3008880:	4462                	lw	s0,24(sp)
 3008882:	6105                	addi	sp,sp,32
 3008884:	8082                	ret

03008886 <DCL_IOCMG_SetPullMode>:
  * @param iocmgRegx Value of @ref IOCMG_REG.
  * @param pullMode value of @ref IOCMG_PullMode.
  * @retval None.
  */
static inline void DCL_IOCMG_SetPullMode(IOCMG_REG *iocmgRegx, IOCMG_PullMode pullMode)
{
 3008886:	1101                	addi	sp,sp,-32
 3008888:	ce06                	sw	ra,28(sp)
 300888a:	cc22                	sw	s0,24(sp)
 300888c:	1000                	addi	s0,sp,32
 300888e:	fea42623          	sw	a0,-20(s0)
 3008892:	feb42423          	sw	a1,-24(s0)
    IOCMG_ASSERT_PARAM(IsIOCMGInstance((void *)((uintptr_t)(void *)iocmgRegx & IOCMG_BASE_ADDR_MASK)));
 3008896:	fec42703          	lw	a4,-20(s0)
 300889a:	77c1                	lui	a5,0xffff0
 300889c:	8f7d                	and	a4,a4,a5
 300889e:	147f07b7          	lui	a5,0x147f0
 30088a2:	00f70a63          	beq	a4,a5,30088b6 <DCL_IOCMG_SetPullMode+0x30>
 30088a6:	0cc00593          	li	a1,204
 30088aa:	030117b7          	lui	a5,0x3011
 30088ae:	9a878513          	addi	a0,a5,-1624 # 30109a8 <g_crgIpMatch+0x498>
 30088b2:	2ce5                	jal	ra,3008baa <AssertErrorLog.trans.6>
 30088b4:	a001                	j	30088b4 <DCL_IOCMG_SetPullMode+0x2e>
    IOCMG_PARAM_CHECK_NO_RET(pullMode < PULL_MODE_MAX && pullMode >= PULL_NONE);
 30088b6:	fe842703          	lw	a4,-24(s0)
 30088ba:	478d                	li	a5,3
 30088bc:	00e7fa63          	bgeu	a5,a4,30088d0 <DCL_IOCMG_SetPullMode+0x4a>
 30088c0:	0cd00593          	li	a1,205
 30088c4:	030117b7          	lui	a5,0x3011
 30088c8:	9a878513          	addi	a0,a5,-1624 # 30109a8 <g_crgIpMatch+0x498>
 30088cc:	2cf9                	jal	ra,3008baa <AssertErrorLog.trans.6>
 30088ce:	a835                	j	300890a <DCL_IOCMG_SetPullMode+0x84>
    iocmgRegx->BIT.pu = (pullMode & 0x02) >> 1; /* 10b: pull up mode */
 30088d0:	fe842783          	lw	a5,-24(s0)
 30088d4:	8385                	srli	a5,a5,0x1
 30088d6:	8b85                	andi	a5,a5,1
 30088d8:	0ff7f693          	andi	a3,a5,255
 30088dc:	fec42703          	lw	a4,-20(s0)
 30088e0:	431c                	lw	a5,0(a4)
 30088e2:	8a85                	andi	a3,a3,1
 30088e4:	06a2                	slli	a3,a3,0x8
 30088e6:	eff7f793          	andi	a5,a5,-257
 30088ea:	8fd5                	or	a5,a5,a3
 30088ec:	c31c                	sw	a5,0(a4)
    iocmgRegx->BIT.pd = pullMode & 0x01; /* 01b: pull down mode */
 30088ee:	fe842783          	lw	a5,-24(s0)
 30088f2:	8b85                	andi	a5,a5,1
 30088f4:	0ff7f693          	andi	a3,a5,255
 30088f8:	fec42703          	lw	a4,-20(s0)
 30088fc:	431c                	lw	a5,0(a4)
 30088fe:	8a85                	andi	a3,a3,1
 3008900:	069e                	slli	a3,a3,0x7
 3008902:	f7f7f793          	andi	a5,a5,-129
 3008906:	8fd5                	or	a5,a5,a3
 3008908:	c31c                	sw	a5,0(a4)
}
 300890a:	40f2                	lw	ra,28(sp)
 300890c:	4462                	lw	s0,24(sp)
 300890e:	6105                	addi	sp,sp,32
 3008910:	8082                	ret

03008912 <DCL_IOCMG_SetLevelShiftRate>:
  * @param iocmgRegx Value of @ref IOCMG_REG.
  * @param levelShiftRate value of @ref IOCMG_LevelShiftRate.
  * @retval None.
  */
static inline void DCL_IOCMG_SetLevelShiftRate(IOCMG_REG *iocmgRegx, IOCMG_LevelShiftRate levelShiftRate)
{
 3008912:	1101                	addi	sp,sp,-32
 3008914:	ce06                	sw	ra,28(sp)
 3008916:	cc22                	sw	s0,24(sp)
 3008918:	1000                	addi	s0,sp,32
 300891a:	fea42623          	sw	a0,-20(s0)
 300891e:	feb42423          	sw	a1,-24(s0)
    IOCMG_ASSERT_PARAM(IsIOCMGInstance((void *)((uintptr_t)(void *)iocmgRegx & IOCMG_BASE_ADDR_MASK)));
 3008922:	fec42703          	lw	a4,-20(s0)
 3008926:	77c1                	lui	a5,0xffff0
 3008928:	8f7d                	and	a4,a4,a5
 300892a:	147f07b7          	lui	a5,0x147f0
 300892e:	00f70a63          	beq	a4,a5,3008942 <DCL_IOCMG_SetLevelShiftRate+0x30>
 3008932:	0e700593          	li	a1,231
 3008936:	030117b7          	lui	a5,0x3011
 300893a:	9a878513          	addi	a0,a5,-1624 # 30109a8 <g_crgIpMatch+0x498>
 300893e:	24b5                	jal	ra,3008baa <AssertErrorLog.trans.6>
 3008940:	a001                	j	3008940 <DCL_IOCMG_SetLevelShiftRate+0x2e>
    IOCMG_PARAM_CHECK_NO_RET(levelShiftRate < LEVEL_SHIFT_RATE_MAX && levelShiftRate >= LEVEL_SHIFT_RATE_FAST);
 3008942:	fe842703          	lw	a4,-24(s0)
 3008946:	4785                	li	a5,1
 3008948:	00e7fa63          	bgeu	a5,a4,300895c <DCL_IOCMG_SetLevelShiftRate+0x4a>
 300894c:	0e800593          	li	a1,232
 3008950:	030117b7          	lui	a5,0x3011
 3008954:	9a878513          	addi	a0,a5,-1624 # 30109a8 <g_crgIpMatch+0x498>
 3008958:	2c89                	jal	ra,3008baa <AssertErrorLog.trans.6>
 300895a:	a839                	j	3008978 <DCL_IOCMG_SetLevelShiftRate+0x66>
    iocmgRegx->BIT.sr = levelShiftRate;
 300895c:	fe842783          	lw	a5,-24(s0)
 3008960:	8b85                	andi	a5,a5,1
 3008962:	0ff7f693          	andi	a3,a5,255
 3008966:	fec42703          	lw	a4,-20(s0)
 300896a:	431c                	lw	a5,0(a4)
 300896c:	8a85                	andi	a3,a3,1
 300896e:	06a6                	slli	a3,a3,0x9
 3008970:	dff7f793          	andi	a5,a5,-513
 3008974:	8fd5                	or	a5,a5,a3
 3008976:	c31c                	sw	a5,0(a4)
}
 3008978:	40f2                	lw	ra,28(sp)
 300897a:	4462                	lw	s0,24(sp)
 300897c:	6105                	addi	sp,sp,32
 300897e:	8082                	ret

03008980 <DCL_IOCMG_SetSchmidtMode>:
  * @param iocmgRegx Value of @ref IOCMG_REG.
  * @param schmidtMode value of @ref IOCMG_SchmidtMode.
  * @retval None.
  */
static inline void DCL_IOCMG_SetSchmidtMode(IOCMG_REG *iocmgRegx, IOCMG_SchmidtMode schmidtMode)
{
 3008980:	1101                	addi	sp,sp,-32
 3008982:	ce06                	sw	ra,28(sp)
 3008984:	cc22                	sw	s0,24(sp)
 3008986:	1000                	addi	s0,sp,32
 3008988:	fea42623          	sw	a0,-20(s0)
 300898c:	feb42423          	sw	a1,-24(s0)
    IOCMG_ASSERT_PARAM(IsIOCMGInstance((void *)((uintptr_t)(void *)iocmgRegx & IOCMG_BASE_ADDR_MASK)));
 3008990:	fec42703          	lw	a4,-20(s0)
 3008994:	77c1                	lui	a5,0xffff0
 3008996:	8f7d                	and	a4,a4,a5
 3008998:	147f07b7          	lui	a5,0x147f0
 300899c:	00f70a63          	beq	a4,a5,30089b0 <DCL_IOCMG_SetSchmidtMode+0x30>
 30089a0:	0ff00593          	li	a1,255
 30089a4:	030117b7          	lui	a5,0x3011
 30089a8:	9a878513          	addi	a0,a5,-1624 # 30109a8 <g_crgIpMatch+0x498>
 30089ac:	2afd                	jal	ra,3008baa <AssertErrorLog.trans.6>
 30089ae:	a001                	j	30089ae <DCL_IOCMG_SetSchmidtMode+0x2e>
    IOCMG_PARAM_CHECK_NO_RET(schmidtMode <= SCHMIDT_ENABLE && schmidtMode >= SCHMIDT_DISABLE);
 30089b0:	fe842703          	lw	a4,-24(s0)
 30089b4:	4785                	li	a5,1
 30089b6:	00e7fa63          	bgeu	a5,a4,30089ca <DCL_IOCMG_SetSchmidtMode+0x4a>
 30089ba:	10000593          	li	a1,256
 30089be:	030117b7          	lui	a5,0x3011
 30089c2:	9a878513          	addi	a0,a5,-1624 # 30109a8 <g_crgIpMatch+0x498>
 30089c6:	22d5                	jal	ra,3008baa <AssertErrorLog.trans.6>
 30089c8:	a839                	j	30089e6 <DCL_IOCMG_SetSchmidtMode+0x66>
    iocmgRegx->BIT.se = schmidtMode;
 30089ca:	fe842783          	lw	a5,-24(s0)
 30089ce:	8b85                	andi	a5,a5,1
 30089d0:	0ff7f693          	andi	a3,a5,255
 30089d4:	fec42703          	lw	a4,-20(s0)
 30089d8:	431c                	lw	a5,0(a4)
 30089da:	8a85                	andi	a3,a3,1
 30089dc:	06aa                	slli	a3,a3,0xa
 30089de:	bff7f793          	andi	a5,a5,-1025
 30089e2:	8fd5                	or	a5,a5,a3
 30089e4:	c31c                	sw	a5,0(a4)
}
 30089e6:	40f2                	lw	ra,28(sp)
 30089e8:	4462                	lw	s0,24(sp)
 30089ea:	6105                	addi	sp,sp,32
 30089ec:	8082                	ret

030089ee <IOCMG_GetRegAddr>:
  * @brief Get pins iocmg reg address
  * @param pinTypedef the pin type defined in iomap.h
  * @retval IOCMG_REG iocmg reg address.
  */
static IOCMG_REG* IOCMG_GetRegAddr(unsigned int pinTypedef)
{
 30089ee:	7179                	addi	sp,sp,-48
 30089f0:	d622                	sw	s0,44(sp)
 30089f2:	1800                	addi	s0,sp,48
 30089f4:	fca42e23          	sw	a0,-36(s0)
    /* decode pin's iocmg reg offset address in base address, and conver value to point address */
    unsigned int iocmgBaseAddrValue = (uintptr_t)IOCMG_BASE;
 30089f8:	147f07b7          	lui	a5,0x147f0
 30089fc:	fef42623          	sw	a5,-20(s0)
    unsigned int iocmgRegOffsetAddrValue = (pinTypedef >> 16) & 0x00000FFF; /* 16 : shift 16 bit */
 3008a00:	fdc42783          	lw	a5,-36(s0)
 3008a04:	0107d713          	srli	a4,a5,0x10
 3008a08:	6785                	lui	a5,0x1
 3008a0a:	17fd                	addi	a5,a5,-1 # fff <__bss_size__+0x38b>
 3008a0c:	8ff9                	and	a5,a5,a4
 3008a0e:	fef42423          	sw	a5,-24(s0)
    IOCMG_REG* iocmgRegxAddr = (IOCMG_REG*)(void*)(iocmgBaseAddrValue + iocmgRegOffsetAddrValue);
 3008a12:	fec42703          	lw	a4,-20(s0)
 3008a16:	fe842783          	lw	a5,-24(s0)
 3008a1a:	97ba                	add	a5,a5,a4
 3008a1c:	fef42223          	sw	a5,-28(s0)
    if (!IsIOCMGInstance((void *)((uintptr_t)(void *)iocmgRegxAddr & IOCMG_BASE_ADDR_MASK))) {
 3008a20:	fe442703          	lw	a4,-28(s0)
 3008a24:	77c1                	lui	a5,0xffff0
 3008a26:	8f7d                	and	a4,a4,a5
 3008a28:	147f07b7          	lui	a5,0x147f0
 3008a2c:	00f70463          	beq	a4,a5,3008a34 <IOCMG_GetRegAddr+0x46>
        return NULL;
 3008a30:	4781                	li	a5,0
 3008a32:	a019                	j	3008a38 <IOCMG_GetRegAddr+0x4a>
    }
    return iocmgRegxAddr;
 3008a34:	fe442783          	lw	a5,-28(s0)
}
 3008a38:	853e                	mv	a0,a5
 3008a3a:	5432                	lw	s0,44(sp)
 3008a3c:	6145                	addi	sp,sp,48
 3008a3e:	8082                	ret

03008a40 <HAL_IOCMG_SetPinAltFuncMode>:
  * @brief Set pins as function mode
  * @param pinTypedef the pin type defined in iomap.h
  * @retval IOCMG_Status @ref IOCMG_Status.
  */
IOCMG_Status HAL_IOCMG_SetPinAltFuncMode(unsigned int pinTypedef)
{
 3008a40:	7179                	addi	sp,sp,-48
 3008a42:	d606                	sw	ra,44(sp)
 3008a44:	d422                	sw	s0,40(sp)
 3008a46:	1800                	addi	s0,sp,48
 3008a48:	fca42e23          	sw	a0,-36(s0)
    /* get iocmg reg address */
    IOCMG_REG* iocmgRegx = IOCMG_GetRegAddr(pinTypedef);
 3008a4c:	fdc42503          	lw	a0,-36(s0)
 3008a50:	3f79                	jal	ra,30089ee <IOCMG_GetRegAddr>
 3008a52:	fea42623          	sw	a0,-20(s0)
    /* get iocmg reg default value */
    unsigned int regValue = pinTypedef & IOCMG_REG_VALUE_MASK;
 3008a56:	fdc42703          	lw	a4,-36(s0)
 3008a5a:	67c1                	lui	a5,0x10
 3008a5c:	17fd                	addi	a5,a5,-1 # ffff <RAM_SIZE+0xafff>
 3008a5e:	8ff9                	and	a5,a5,a4
 3008a60:	fef42423          	sw	a5,-24(s0)
    DCL_IOCMG_SetRegValue(iocmgRegx, regValue);
 3008a64:	fe842583          	lw	a1,-24(s0)
 3008a68:	fec42503          	lw	a0,-20(s0)
 3008a6c:	33a5                	jal	ra,30087d4 <DCL_IOCMG_SetRegValue>
    return IOCMG_STATUS_OK;
 3008a6e:	4781                	li	a5,0
}
 3008a70:	853e                	mv	a0,a5
 3008a72:	50b2                	lw	ra,44(sp)
 3008a74:	5422                	lw	s0,40(sp)
 3008a76:	6145                	addi	sp,sp,48
 3008a78:	8082                	ret

03008a7a <HAL_IOCMG_SetPinPullMode>:
  * @param pinTypedef the pin type defined in iomap.h
  * @param pullMode function define as @ref IOCMG_PullMode
  * @retval IOCMG_Status @ref IOCMG_Status.
  */
IOCMG_Status HAL_IOCMG_SetPinPullMode(unsigned int pinTypedef, IOCMG_PullMode pullMode)
{
 3008a7a:	7179                	addi	sp,sp,-48
 3008a7c:	d606                	sw	ra,44(sp)
 3008a7e:	d422                	sw	s0,40(sp)
 3008a80:	1800                	addi	s0,sp,48
 3008a82:	fca42e23          	sw	a0,-36(s0)
 3008a86:	fcb42c23          	sw	a1,-40(s0)
    IOCMG_PARAM_CHECK_WITH_RET(pullMode < PULL_MODE_MAX && pullMode >= PULL_NONE, IOCMG_PARAM_ERROR);
 3008a8a:	fd842703          	lw	a4,-40(s0)
 3008a8e:	478d                	li	a5,3
 3008a90:	00e7fb63          	bgeu	a5,a4,3008aa6 <HAL_IOCMG_SetPinPullMode+0x2c>
 3008a94:	07800593          	li	a1,120
 3008a98:	030117b7          	lui	a5,0x3011
 3008a9c:	9c878513          	addi	a0,a5,-1592 # 30109c8 <g_crgIpMatch+0x4b8>
 3008aa0:	2229                	jal	ra,3008baa <AssertErrorLog.trans.6>
 3008aa2:	4791                	li	a5,4
 3008aa4:	a821                	j	3008abc <HAL_IOCMG_SetPinPullMode+0x42>
    /* get iocmg reg address */
    IOCMG_REG* iocmgRegx = IOCMG_GetRegAddr(pinTypedef);
 3008aa6:	fdc42503          	lw	a0,-36(s0)
 3008aaa:	3791                	jal	ra,30089ee <IOCMG_GetRegAddr>
 3008aac:	fea42623          	sw	a0,-20(s0)
    DCL_IOCMG_SetPullMode(iocmgRegx, pullMode);
 3008ab0:	fd842583          	lw	a1,-40(s0)
 3008ab4:	fec42503          	lw	a0,-20(s0)
 3008ab8:	33f9                	jal	ra,3008886 <DCL_IOCMG_SetPullMode>
    return IOCMG_STATUS_OK;
 3008aba:	4781                	li	a5,0
}
 3008abc:	853e                	mv	a0,a5
 3008abe:	50b2                	lw	ra,44(sp)
 3008ac0:	5422                	lw	s0,40(sp)
 3008ac2:	6145                	addi	sp,sp,48
 3008ac4:	8082                	ret

03008ac6 <HAL_IOCMG_SetPinSchmidtMode>:
  * @param pinTypedef the pin type defined in iomap.h
  * @param schmidtMode function define as @ref IOCMG_SchmidtMode
  * @retval IOCMG_Status @ref IOCMG_Status.
  */
IOCMG_Status HAL_IOCMG_SetPinSchmidtMode(unsigned int pinTypedef, IOCMG_SchmidtMode schmidtMode)
{
 3008ac6:	7179                	addi	sp,sp,-48
 3008ac8:	d606                	sw	ra,44(sp)
 3008aca:	d422                	sw	s0,40(sp)
 3008acc:	1800                	addi	s0,sp,48
 3008ace:	fca42e23          	sw	a0,-36(s0)
 3008ad2:	fcb42c23          	sw	a1,-40(s0)
    IOCMG_PARAM_CHECK_WITH_RET(schmidtMode <= SCHMIDT_ENABLE && schmidtMode >= SCHMIDT_DISABLE, IOCMG_PARAM_ERROR);
 3008ad6:	fd842703          	lw	a4,-40(s0)
 3008ada:	4785                	li	a5,1
 3008adc:	00e7fb63          	bgeu	a5,a4,3008af2 <HAL_IOCMG_SetPinSchmidtMode+0x2c>
 3008ae0:	09300593          	li	a1,147
 3008ae4:	030117b7          	lui	a5,0x3011
 3008ae8:	9c878513          	addi	a0,a5,-1592 # 30109c8 <g_crgIpMatch+0x4b8>
 3008aec:	287d                	jal	ra,3008baa <AssertErrorLog.trans.6>
 3008aee:	4791                	li	a5,4
 3008af0:	a821                	j	3008b08 <HAL_IOCMG_SetPinSchmidtMode+0x42>
    /* get iocmg reg address */
    IOCMG_REG* iocmgRegx = IOCMG_GetRegAddr(pinTypedef);
 3008af2:	fdc42503          	lw	a0,-36(s0)
 3008af6:	3de5                	jal	ra,30089ee <IOCMG_GetRegAddr>
 3008af8:	fea42623          	sw	a0,-20(s0)
    DCL_IOCMG_SetSchmidtMode(iocmgRegx, schmidtMode);
 3008afc:	fd842583          	lw	a1,-40(s0)
 3008b00:	fec42503          	lw	a0,-20(s0)
 3008b04:	3db5                	jal	ra,3008980 <DCL_IOCMG_SetSchmidtMode>
    return IOCMG_STATUS_OK;
 3008b06:	4781                	li	a5,0
}
 3008b08:	853e                	mv	a0,a5
 3008b0a:	50b2                	lw	ra,44(sp)
 3008b0c:	5422                	lw	s0,40(sp)
 3008b0e:	6145                	addi	sp,sp,48
 3008b10:	8082                	ret

03008b12 <HAL_IOCMG_SetPinLevelShiftRate>:
  * @param pinTypedef the pin type defined in iomap.h
  * @param schmidtMode function define as @ref IOCMG_SchmidtMode
  * @retval IOCMG_Status @ref IOCMG_Status.
  */
IOCMG_Status HAL_IOCMG_SetPinLevelShiftRate(unsigned int pinTypedef, IOCMG_LevelShiftRate levelShiftRate)
{
 3008b12:	7179                	addi	sp,sp,-48
 3008b14:	d606                	sw	ra,44(sp)
 3008b16:	d422                	sw	s0,40(sp)
 3008b18:	1800                	addi	s0,sp,48
 3008b1a:	fca42e23          	sw	a0,-36(s0)
 3008b1e:	fcb42c23          	sw	a1,-40(s0)
    IOCMG_PARAM_CHECK_WITH_RET(levelShiftRate < LEVEL_SHIFT_RATE_MAX, IOCMG_PARAM_ERROR);
 3008b22:	fd842703          	lw	a4,-40(s0)
 3008b26:	4785                	li	a5,1
 3008b28:	00e7fb63          	bgeu	a5,a4,3008b3e <HAL_IOCMG_SetPinLevelShiftRate+0x2c>
 3008b2c:	0ae00593          	li	a1,174
 3008b30:	030117b7          	lui	a5,0x3011
 3008b34:	9c878513          	addi	a0,a5,-1592 # 30109c8 <g_crgIpMatch+0x4b8>
 3008b38:	288d                	jal	ra,3008baa <AssertErrorLog.trans.6>
 3008b3a:	4791                	li	a5,4
 3008b3c:	a821                	j	3008b54 <HAL_IOCMG_SetPinLevelShiftRate+0x42>
    IOCMG_PARAM_CHECK_WITH_RET(levelShiftRate >= LEVEL_SHIFT_RATE_FAST, IOCMG_PARAM_ERROR);
    /* get iocmg reg address */
    IOCMG_REG* iocmgRegx = IOCMG_GetRegAddr(pinTypedef);
 3008b3e:	fdc42503          	lw	a0,-36(s0)
 3008b42:	3575                	jal	ra,30089ee <IOCMG_GetRegAddr>
 3008b44:	fea42623          	sw	a0,-20(s0)
    DCL_IOCMG_SetLevelShiftRate(iocmgRegx, levelShiftRate);
 3008b48:	fd842583          	lw	a1,-40(s0)
 3008b4c:	fec42503          	lw	a0,-20(s0)
 3008b50:	33c9                	jal	ra,3008912 <DCL_IOCMG_SetLevelShiftRate>
    return IOCMG_STATUS_OK;
 3008b52:	4781                	li	a5,0
}
 3008b54:	853e                	mv	a0,a5
 3008b56:	50b2                	lw	ra,44(sp)
 3008b58:	5422                	lw	s0,40(sp)
 3008b5a:	6145                	addi	sp,sp,48
 3008b5c:	8082                	ret

03008b5e <HAL_IOCMG_SetPinDriveRate>:
  * @param pinTypedef the pin type defined in iomap.h
  * @param driveRate function define as @ref IOCMG_DriveRate
  * @retval IOCMG_Status @ref IOCMG_Status.
  */
IOCMG_Status HAL_IOCMG_SetPinDriveRate(unsigned int pinTypedef, IOCMG_DriveRate driveRate)
{
 3008b5e:	7179                	addi	sp,sp,-48
 3008b60:	d606                	sw	ra,44(sp)
 3008b62:	d422                	sw	s0,40(sp)
 3008b64:	1800                	addi	s0,sp,48
 3008b66:	fca42e23          	sw	a0,-36(s0)
 3008b6a:	fcb42c23          	sw	a1,-40(s0)
    /* get iocmg reg address */
    IOCMG_PARAM_CHECK_WITH_RET(driveRate < DRIVER_RATE_MAX && driveRate >= DRIVER_RATE_4, IOCMG_PARAM_ERROR);
 3008b6e:	fd842703          	lw	a4,-40(s0)
 3008b72:	478d                	li	a5,3
 3008b74:	00e7fb63          	bgeu	a5,a4,3008b8a <HAL_IOCMG_SetPinDriveRate+0x2c>
 3008b78:	0cb00593          	li	a1,203
 3008b7c:	030117b7          	lui	a5,0x3011
 3008b80:	9c878513          	addi	a0,a5,-1592 # 30109c8 <g_crgIpMatch+0x4b8>
 3008b84:	201d                	jal	ra,3008baa <AssertErrorLog.trans.6>
 3008b86:	4791                	li	a5,4
 3008b88:	a821                	j	3008ba0 <HAL_IOCMG_SetPinDriveRate+0x42>
    IOCMG_REG* iocmgRegx = IOCMG_GetRegAddr(pinTypedef);
 3008b8a:	fdc42503          	lw	a0,-36(s0)
 3008b8e:	3585                	jal	ra,30089ee <IOCMG_GetRegAddr>
 3008b90:	fea42623          	sw	a0,-20(s0)
    DCL_IOCMG_SetDriveRate(iocmgRegx, driveRate);
 3008b94:	fd842583          	lw	a1,-40(s0)
 3008b98:	fec42503          	lw	a0,-20(s0)
 3008b9c:	39b5                	jal	ra,3008818 <DCL_IOCMG_SetDriveRate>
    return IOCMG_STATUS_OK;
 3008b9e:	4781                	li	a5,0
}
 3008ba0:	853e                	mv	a0,a5
 3008ba2:	50b2                	lw	ra,44(sp)
 3008ba4:	5422                	lw	s0,40(sp)
 3008ba6:	6145                	addi	sp,sp,48
 3008ba8:	8082                	ret

03008baa <AssertErrorLog.trans.6>:
 3008baa:	994fa06f          	j	3002d3e <AssertErrorLog>

03008bae <IsEmuMode>:
  * @param mode QDM mode
  * @retval true
  * @retval false
  */
static inline bool IsEmuMode(unsigned int mode)
{
 3008bae:	1101                	addi	sp,sp,-32
 3008bb0:	ce22                	sw	s0,28(sp)
 3008bb2:	1000                	addi	s0,sp,32
 3008bb4:	fea42623          	sw	a0,-20(s0)
    if (mode == QDM_EMULATION_MODE_STOP_IMMEDIATELY || mode == QDM_EMULATION_MODE_STOP_AT_ROLLOVER ||
 3008bb8:	fec42783          	lw	a5,-20(s0)
 3008bbc:	cb99                	beqz	a5,3008bd2 <IsEmuMode+0x24>
 3008bbe:	fec42703          	lw	a4,-20(s0)
 3008bc2:	4785                	li	a5,1
 3008bc4:	00f70763          	beq	a4,a5,3008bd2 <IsEmuMode+0x24>
 3008bc8:	fec42703          	lw	a4,-20(s0)
 3008bcc:	4789                	li	a5,2
 3008bce:	00f71463          	bne	a4,a5,3008bd6 <IsEmuMode+0x28>
        mode == QDM_EMULATION_MODE_RUN_FREE) {
        return true;
 3008bd2:	4785                	li	a5,1
 3008bd4:	a011                	j	3008bd8 <IsEmuMode+0x2a>
    }
    return false;
 3008bd6:	4781                	li	a5,0
}
 3008bd8:	853e                	mv	a0,a5
 3008bda:	4472                	lw	s0,28(sp)
 3008bdc:	6105                	addi	sp,sp,32
 3008bde:	8082                	ret

03008be0 <IsLockMode>:
  * @param mode QDM mode
  * @retval true
  * @retval false
  */
static inline bool IsLockMode(unsigned int mode)
{
 3008be0:	1101                	addi	sp,sp,-32
 3008be2:	ce22                	sw	s0,28(sp)
 3008be4:	1000                	addi	s0,sp,32
 3008be6:	fea42623          	sw	a0,-20(s0)
    if (mode == QDM_LOCK_RESERVE || mode == QDM_LOCK_RISING_INDEX ||
 3008bea:	fec42783          	lw	a5,-20(s0)
 3008bee:	c385                	beqz	a5,3008c0e <IsLockMode+0x2e>
 3008bf0:	fec42703          	lw	a4,-20(s0)
 3008bf4:	4785                	li	a5,1
 3008bf6:	00f70c63          	beq	a4,a5,3008c0e <IsLockMode+0x2e>
 3008bfa:	fec42703          	lw	a4,-20(s0)
 3008bfe:	4789                	li	a5,2
 3008c00:	00f70763          	beq	a4,a5,3008c0e <IsLockMode+0x2e>
        mode == QDM_LOCK_FALLING_INDEX || mode == QDM_LOCK_SW_INDEX_MARKER) {
 3008c04:	fec42703          	lw	a4,-20(s0)
 3008c08:	478d                	li	a5,3
 3008c0a:	00f71463          	bne	a4,a5,3008c12 <IsLockMode+0x32>
        return true;
 3008c0e:	4785                	li	a5,1
 3008c10:	a011                	j	3008c14 <IsLockMode+0x34>
    }
    return false;
 3008c12:	4781                	li	a5,0
}
 3008c14:	853e                	mv	a0,a5
 3008c16:	4472                	lw	s0,28(sp)
 3008c18:	6105                	addi	sp,sp,32
 3008c1a:	8082                	ret

03008c1c <IsDecodeMode>:
  * @param mode QDM decode mode
  * @retval true
  * @retval false
  */
static inline bool IsDecodeMode(unsigned int mode)
{
 3008c1c:	1101                	addi	sp,sp,-32
 3008c1e:	ce22                	sw	s0,28(sp)
 3008c20:	1000                	addi	s0,sp,32
 3008c22:	fea42623          	sw	a0,-20(s0)
    if (mode <= QDM_NONSTANDARD_TYPE2) {
 3008c26:	fec42703          	lw	a4,-20(s0)
 3008c2a:	478d                	li	a5,3
 3008c2c:	00e7e463          	bltu	a5,a4,3008c34 <IsDecodeMode+0x18>
        return true;
 3008c30:	4785                	li	a5,1
 3008c32:	a011                	j	3008c36 <IsDecodeMode+0x1a>
    }
    return false;
 3008c34:	4781                	li	a5,0
}
 3008c36:	853e                	mv	a0,a5
 3008c38:	4472                	lw	s0,28(sp)
 3008c3a:	6105                	addi	sp,sp,32
 3008c3c:	8082                	ret

03008c3e <IsResolution>:
  * @param mode QDM mode
  * @retval true
  * @retval false
  */
static inline bool IsResolution(unsigned int mode)
{
 3008c3e:	1101                	addi	sp,sp,-32
 3008c40:	ce22                	sw	s0,28(sp)
 3008c42:	1000                	addi	s0,sp,32
 3008c44:	fea42623          	sw	a0,-20(s0)
    if (mode == QDM_1X_RESOLUTION || mode == QDM_2X_RESOLUTION || mode == QDM_4X_RESOLUTION) {
 3008c48:	fec42783          	lw	a5,-20(s0)
 3008c4c:	cb99                	beqz	a5,3008c62 <IsResolution+0x24>
 3008c4e:	fec42703          	lw	a4,-20(s0)
 3008c52:	4785                	li	a5,1
 3008c54:	00f70763          	beq	a4,a5,3008c62 <IsResolution+0x24>
 3008c58:	fec42703          	lw	a4,-20(s0)
 3008c5c:	4789                	li	a5,2
 3008c5e:	00f71463          	bne	a4,a5,3008c66 <IsResolution+0x28>
        return true;
 3008c62:	4785                	li	a5,1
 3008c64:	a011                	j	3008c68 <IsResolution+0x2a>
    }
    return false;
 3008c66:	4781                	li	a5,0
}
 3008c68:	853e                	mv	a0,a5
 3008c6a:	4472                	lw	s0,28(sp)
 3008c6c:	6105                	addi	sp,sp,32
 3008c6e:	8082                	ret

03008c70 <IsSwap>:
  * @param mode QDM mode
  * @retval true
  * @retval false
  */
static inline bool IsSwap(unsigned int mode)
{
 3008c70:	1101                	addi	sp,sp,-32
 3008c72:	ce22                	sw	s0,28(sp)
 3008c74:	1000                	addi	s0,sp,32
 3008c76:	fea42623          	sw	a0,-20(s0)
    if (mode == QDM_SWAP_DISABLE || mode == QDM_SWAP_ENABLE) {
 3008c7a:	fec42783          	lw	a5,-20(s0)
 3008c7e:	c791                	beqz	a5,3008c8a <IsSwap+0x1a>
 3008c80:	fec42703          	lw	a4,-20(s0)
 3008c84:	4785                	li	a5,1
 3008c86:	00f71463          	bne	a4,a5,3008c8e <IsSwap+0x1e>
        return true;
 3008c8a:	4785                	li	a5,1
 3008c8c:	a011                	j	3008c90 <IsSwap+0x20>
    }
    return false;
 3008c8e:	4781                	li	a5,0
}
 3008c90:	853e                	mv	a0,a5
 3008c92:	4472                	lw	s0,28(sp)
 3008c94:	6105                	addi	sp,sp,32
 3008c96:	8082                	ret

03008c98 <IsTrgLockMode>:
  * @param mode QDM mode
  * @retval true
  * @retval false
  */
static inline bool IsTrgLockMode(unsigned int mode)
{
 3008c98:	1101                	addi	sp,sp,-32
 3008c9a:	ce22                	sw	s0,28(sp)
 3008c9c:	1000                	addi	s0,sp,32
 3008c9e:	fea42623          	sw	a0,-20(s0)
    if (mode == QDM_TRG_BY_READ || mode == QDM_TRG_BY_CYCLE) {
 3008ca2:	fec42783          	lw	a5,-20(s0)
 3008ca6:	c791                	beqz	a5,3008cb2 <IsTrgLockMode+0x1a>
 3008ca8:	fec42703          	lw	a4,-20(s0)
 3008cac:	4785                	li	a5,1
 3008cae:	00f71463          	bne	a4,a5,3008cb6 <IsTrgLockMode+0x1e>
        return true;
 3008cb2:	4785                	li	a5,1
 3008cb4:	a011                	j	3008cb8 <IsTrgLockMode+0x20>
    }
    return false;
 3008cb6:	4781                	li	a5,0
}
 3008cb8:	853e                	mv	a0,a5
 3008cba:	4472                	lw	s0,28(sp)
 3008cbc:	6105                	addi	sp,sp,32
 3008cbe:	8082                	ret

03008cc0 <IsPtuMode>:
  * @param mode QDM mode
  * @retval true
  * @retval false
  */
static inline bool IsPtuMode(unsigned int mode)
{
 3008cc0:	1101                	addi	sp,sp,-32
 3008cc2:	ce22                	sw	s0,28(sp)
 3008cc4:	1000                	addi	s0,sp,32
 3008cc6:	fea42623          	sw	a0,-20(s0)
    if (mode == QDM_PTU_MODE_CYCLE || mode == QDM_PTU_MODE_WATCHDOG) {
 3008cca:	fec42783          	lw	a5,-20(s0)
 3008cce:	c791                	beqz	a5,3008cda <IsPtuMode+0x1a>
 3008cd0:	fec42703          	lw	a4,-20(s0)
 3008cd4:	4785                	li	a5,1
 3008cd6:	00f71463          	bne	a4,a5,3008cde <IsPtuMode+0x1e>
        return true;
 3008cda:	4785                	li	a5,1
 3008cdc:	a011                	j	3008ce0 <IsPtuMode+0x20>
    }
    return false;
 3008cde:	4781                	li	a5,0
}
 3008ce0:	853e                	mv	a0,a5
 3008ce2:	4472                	lw	s0,28(sp)
 3008ce4:	6105                	addi	sp,sp,32
 3008ce6:	8082                	ret

03008ce8 <IsPcntMode>:
  * @param mode QDM mode
  * @retval true
  * @retval false
  */
static inline bool IsPcntMode(unsigned int mode)
{
 3008ce8:	1101                	addi	sp,sp,-32
 3008cea:	ce22                	sw	s0,28(sp)
 3008cec:	1000                	addi	s0,sp,32
 3008cee:	fea42623          	sw	a0,-20(s0)
    if (mode == QDM_PCNT_MODE_BY_DIR || mode == QDM_PCNT_MODE_UP || mode == QDM_PCNT_MODE_DOWN) {
 3008cf2:	fec42783          	lw	a5,-20(s0)
 3008cf6:	cb99                	beqz	a5,3008d0c <IsPcntMode+0x24>
 3008cf8:	fec42703          	lw	a4,-20(s0)
 3008cfc:	4785                	li	a5,1
 3008cfe:	00f70763          	beq	a4,a5,3008d0c <IsPcntMode+0x24>
 3008d02:	fec42703          	lw	a4,-20(s0)
 3008d06:	4789                	li	a5,2
 3008d08:	00f71463          	bne	a4,a5,3008d10 <IsPcntMode+0x28>
        return true;
 3008d0c:	4785                	li	a5,1
 3008d0e:	a011                	j	3008d12 <IsPcntMode+0x2a>
    }
    return false;
 3008d10:	4781                	li	a5,0
}
 3008d12:	853e                	mv	a0,a5
 3008d14:	4472                	lw	s0,28(sp)
 3008d16:	6105                	addi	sp,sp,32
 3008d18:	8082                	ret

03008d1a <IsPcntRstMode>:
  * @param mode QDM mode
  * @retval true
  * @retval false
  */
static inline bool IsPcntRstMode(unsigned int mode)
{
 3008d1a:	1101                	addi	sp,sp,-32
 3008d1c:	ce22                	sw	s0,28(sp)
 3008d1e:	1000                	addi	s0,sp,32
 3008d20:	fea42623          	sw	a0,-20(s0)
    if (mode == QDM_PCNT_RST_AUTO || mode == QDM_PCNT_RST_OVF ||
 3008d24:	fec42783          	lw	a5,-20(s0)
 3008d28:	c385                	beqz	a5,3008d48 <IsPcntRstMode+0x2e>
 3008d2a:	fec42703          	lw	a4,-20(s0)
 3008d2e:	4785                	li	a5,1
 3008d30:	00f70c63          	beq	a4,a5,3008d48 <IsPcntRstMode+0x2e>
 3008d34:	fec42703          	lw	a4,-20(s0)
 3008d38:	4789                	li	a5,2
 3008d3a:	00f70763          	beq	a4,a5,3008d48 <IsPcntRstMode+0x2e>
        mode == QDM_PCNT_RST_HARDWARE_ONCE || mode == QDM_PCNT_RST_BY_PTU) {
 3008d3e:	fec42703          	lw	a4,-20(s0)
 3008d42:	478d                	li	a5,3
 3008d44:	00f71463          	bne	a4,a5,3008d4c <IsPcntRstMode+0x32>
        return true;
 3008d48:	4785                	li	a5,1
 3008d4a:	a011                	j	3008d4e <IsPcntRstMode+0x34>
    }
    return false;
 3008d4c:	4781                	li	a5,0
}
 3008d4e:	853e                	mv	a0,a5
 3008d50:	4472                	lw	s0,28(sp)
 3008d52:	6105                	addi	sp,sp,32
 3008d54:	8082                	ret

03008d56 <IsPcntIdxInitMode>:
  * @param mode QDM mode
  * @retval true
  * @retval false
  */
static inline bool IsPcntIdxInitMode(unsigned int mode)
{
 3008d56:	1101                	addi	sp,sp,-32
 3008d58:	ce22                	sw	s0,28(sp)
 3008d5a:	1000                	addi	s0,sp,32
 3008d5c:	fea42623          	sw	a0,-20(s0)
    if (mode == QDM_IDX_INIT_DISABLE || mode == QDM_IDX_INIT_AUTO ||
 3008d60:	fec42783          	lw	a5,-20(s0)
 3008d64:	c385                	beqz	a5,3008d84 <IsPcntIdxInitMode+0x2e>
 3008d66:	fec42703          	lw	a4,-20(s0)
 3008d6a:	4785                	li	a5,1
 3008d6c:	00f70c63          	beq	a4,a5,3008d84 <IsPcntIdxInitMode+0x2e>
 3008d70:	fec42703          	lw	a4,-20(s0)
 3008d74:	4789                	li	a5,2
 3008d76:	00f70763          	beq	a4,a5,3008d84 <IsPcntIdxInitMode+0x2e>
        mode == QDM_IDX_INIT_Z_UP || mode == QDM_IDX_INIT_Z_DOWN) {
 3008d7a:	fec42703          	lw	a4,-20(s0)
 3008d7e:	478d                	li	a5,3
 3008d80:	00f71463          	bne	a4,a5,3008d88 <IsPcntIdxInitMode+0x32>
        return true;
 3008d84:	4785                	li	a5,1
 3008d86:	a011                	j	3008d8a <IsPcntIdxInitMode+0x34>
    }
    return false;
 3008d88:	4781                	li	a5,0
}
 3008d8a:	853e                	mv	a0,a5
 3008d8c:	4472                	lw	s0,28(sp)
 3008d8e:	6105                	addi	sp,sp,32
 3008d90:	8082                	ret

03008d92 <IsTsuPrescaler>:
  * @param mode QDM mode
  * @retval true
  * @retval false
  */
static inline bool IsTsuPrescaler(unsigned int mode)
{
 3008d92:	1101                	addi	sp,sp,-32
 3008d94:	ce22                	sw	s0,28(sp)
 3008d96:	1000                	addi	s0,sp,32
 3008d98:	fea42623          	sw	a0,-20(s0)
    /* Check whether the TSU prescaler is right. */
    if (mode == QDM_TSU_PRESCALER_EQUAL || mode == QDM_TSU_PRESCALER_2X ||
 3008d9c:	fec42783          	lw	a5,-20(s0)
 3008da0:	cba9                	beqz	a5,3008df2 <IsTsuPrescaler+0x60>
 3008da2:	fec42703          	lw	a4,-20(s0)
 3008da6:	4785                	li	a5,1
 3008da8:	04f70563          	beq	a4,a5,3008df2 <IsTsuPrescaler+0x60>
 3008dac:	fec42703          	lw	a4,-20(s0)
 3008db0:	4789                	li	a5,2
 3008db2:	04f70063          	beq	a4,a5,3008df2 <IsTsuPrescaler+0x60>
        mode == QDM_TSU_PRESCALER_4X || mode == QDM_TSU_PRESCALER_8X ||
 3008db6:	fec42703          	lw	a4,-20(s0)
 3008dba:	478d                	li	a5,3
 3008dbc:	02f70b63          	beq	a4,a5,3008df2 <IsTsuPrescaler+0x60>
 3008dc0:	fec42703          	lw	a4,-20(s0)
 3008dc4:	4791                	li	a5,4
 3008dc6:	02f70663          	beq	a4,a5,3008df2 <IsTsuPrescaler+0x60>
        mode == QDM_TSU_PRESCALER_16X || mode == QDM_TSU_PRESCALER_32X ||
 3008dca:	fec42703          	lw	a4,-20(s0)
 3008dce:	4795                	li	a5,5
 3008dd0:	02f70163          	beq	a4,a5,3008df2 <IsTsuPrescaler+0x60>
 3008dd4:	fec42703          	lw	a4,-20(s0)
 3008dd8:	4799                	li	a5,6
 3008dda:	00f70c63          	beq	a4,a5,3008df2 <IsTsuPrescaler+0x60>
        mode == QDM_TSU_PRESCALER_64X || mode == QDM_TSU_PRESCALER_128X ||
 3008dde:	fec42703          	lw	a4,-20(s0)
 3008de2:	479d                	li	a5,7
 3008de4:	00f70763          	beq	a4,a5,3008df2 <IsTsuPrescaler+0x60>
 3008de8:	fec42703          	lw	a4,-20(s0)
 3008dec:	47a1                	li	a5,8
 3008dee:	00f71463          	bne	a4,a5,3008df6 <IsTsuPrescaler+0x64>
        mode == QDM_TSU_PRESCALER_256X) {
        return true;
 3008df2:	4785                	li	a5,1
 3008df4:	a011                	j	3008df8 <IsTsuPrescaler+0x66>
    }
    return false;
 3008df6:	4781                	li	a5,0
}
 3008df8:	853e                	mv	a0,a5
 3008dfa:	4472                	lw	s0,28(sp)
 3008dfc:	6105                	addi	sp,sp,32
 3008dfe:	8082                	ret

03008e00 <IsCevtPrescaler>:
  * @param mode QDM mode
  * @retval true
  * @retval false
  */
static inline bool IsCevtPrescaler(unsigned int mode)
{
 3008e00:	1101                	addi	sp,sp,-32
 3008e02:	ce22                	sw	s0,28(sp)
 3008e04:	1000                	addi	s0,sp,32
 3008e06:	fea42623          	sw	a0,-20(s0)
    /* Check whether the CEVT prescaler is right. */
    if (mode == QDM_CEVT_PRESCALER_DIVI1 || mode == QDM_CEVT_PRESCALER_DIVI2 ||
 3008e0a:	fec42783          	lw	a5,-20(s0)
 3008e0e:	cba5                	beqz	a5,3008e7e <IsCevtPrescaler+0x7e>
 3008e10:	fec42703          	lw	a4,-20(s0)
 3008e14:	4785                	li	a5,1
 3008e16:	06f70463          	beq	a4,a5,3008e7e <IsCevtPrescaler+0x7e>
 3008e1a:	fec42703          	lw	a4,-20(s0)
 3008e1e:	4789                	li	a5,2
 3008e20:	04f70f63          	beq	a4,a5,3008e7e <IsCevtPrescaler+0x7e>
        mode == QDM_CEVT_PRESCALER_DIVI4 || mode == QDM_CEVT_PRESCALER_DIVI8 ||
 3008e24:	fec42703          	lw	a4,-20(s0)
 3008e28:	478d                	li	a5,3
 3008e2a:	04f70a63          	beq	a4,a5,3008e7e <IsCevtPrescaler+0x7e>
 3008e2e:	fec42703          	lw	a4,-20(s0)
 3008e32:	4791                	li	a5,4
 3008e34:	04f70563          	beq	a4,a5,3008e7e <IsCevtPrescaler+0x7e>
        mode == QDM_CEVT_PRESCALER_DIVI16 || mode == QDM_CEVT_PRESCALER_DIVI32 ||
 3008e38:	fec42703          	lw	a4,-20(s0)
 3008e3c:	4795                	li	a5,5
 3008e3e:	04f70063          	beq	a4,a5,3008e7e <IsCevtPrescaler+0x7e>
 3008e42:	fec42703          	lw	a4,-20(s0)
 3008e46:	4799                	li	a5,6
 3008e48:	02f70b63          	beq	a4,a5,3008e7e <IsCevtPrescaler+0x7e>
        mode == QDM_CEVT_PRESCALER_DIVI64 || mode == QDM_CEVT_PRESCALER_DIVI128 ||
 3008e4c:	fec42703          	lw	a4,-20(s0)
 3008e50:	479d                	li	a5,7
 3008e52:	02f70663          	beq	a4,a5,3008e7e <IsCevtPrescaler+0x7e>
 3008e56:	fec42703          	lw	a4,-20(s0)
 3008e5a:	47a1                	li	a5,8
 3008e5c:	02f70163          	beq	a4,a5,3008e7e <IsCevtPrescaler+0x7e>
        mode == QDM_CEVT_PRESCALER_DIVI256 || mode == QDM_CEVT_PRESCALER_DIVI512 ||
 3008e60:	fec42703          	lw	a4,-20(s0)
 3008e64:	47a5                	li	a5,9
 3008e66:	00f70c63          	beq	a4,a5,3008e7e <IsCevtPrescaler+0x7e>
 3008e6a:	fec42703          	lw	a4,-20(s0)
 3008e6e:	47a9                	li	a5,10
 3008e70:	00f70763          	beq	a4,a5,3008e7e <IsCevtPrescaler+0x7e>
        mode == QDM_CEVT_PRESCALER_DIVI1024 || mode == QDM_CEVT_PRESCALER_DIVI2048) {
 3008e74:	fec42703          	lw	a4,-20(s0)
 3008e78:	47ad                	li	a5,11
 3008e7a:	00f71463          	bne	a4,a5,3008e82 <IsCevtPrescaler+0x82>
        return true;
 3008e7e:	4785                	li	a5,1
 3008e80:	a011                	j	3008e84 <IsCevtPrescaler+0x84>
    }
    return false;
 3008e82:	4781                	li	a5,0
}
 3008e84:	853e                	mv	a0,a5
 3008e86:	4472                	lw	s0,28(sp)
 3008e88:	6105                	addi	sp,sp,32
 3008e8a:	8082                	ret

03008e8c <DCL_QDM_SetInputFilterWidth>:
  */
static inline void DCL_QDM_SetInputFilterWidth(QDM_RegStruct *qdmx,
                                               unsigned short filtWidthQDMA,
                                               unsigned short filtWidthQDMB,
                                               unsigned short filtWidthQDMI)
{
 3008e8c:	1101                	addi	sp,sp,-32
 3008e8e:	ce06                	sw	ra,28(sp)
 3008e90:	cc22                	sw	s0,24(sp)
 3008e92:	1000                	addi	s0,sp,32
 3008e94:	fea42623          	sw	a0,-20(s0)
 3008e98:	87ae                	mv	a5,a1
 3008e9a:	8736                	mv	a4,a3
 3008e9c:	fef41523          	sh	a5,-22(s0)
 3008ea0:	87b2                	mv	a5,a2
 3008ea2:	fef41423          	sh	a5,-24(s0)
 3008ea6:	87ba                	mv	a5,a4
 3008ea8:	fef41323          	sh	a5,-26(s0)
    QDM_ASSERT_PARAM(IsQDMInstance(qdmx));
 3008eac:	fec42703          	lw	a4,-20(s0)
 3008eb0:	14c007b7          	lui	a5,0x14c00
 3008eb4:	02f70063          	beq	a4,a5,3008ed4 <DCL_QDM_SetInputFilterWidth+0x48>
 3008eb8:	fec42703          	lw	a4,-20(s0)
 3008ebc:	14c017b7          	lui	a5,0x14c01
 3008ec0:	00f70a63          	beq	a4,a5,3008ed4 <DCL_QDM_SetInputFilterWidth+0x48>
 3008ec4:	3e700593          	li	a1,999
 3008ec8:	030117b7          	lui	a5,0x3011
 3008ecc:	9e878513          	addi	a0,a5,-1560 # 30109e8 <g_crgIpMatch+0x4d8>
 3008ed0:	39e9                	jal	ra,3008baa <AssertErrorLog.trans.6>
 3008ed2:	a001                	j	3008ed2 <DCL_QDM_SetInputFilterWidth+0x46>
    QDM_PARAM_CHECK_NO_RET(filtWidthQDMA <= QDM_MAX_FILTER_LEVEL);
 3008ed4:	fea45703          	lhu	a4,-22(s0)
 3008ed8:	6789                	lui	a5,0x2
 3008eda:	00f76a63          	bltu	a4,a5,3008eee <DCL_QDM_SetInputFilterWidth+0x62>
 3008ede:	3e800593          	li	a1,1000
 3008ee2:	030117b7          	lui	a5,0x3011
 3008ee6:	9e878513          	addi	a0,a5,-1560 # 30109e8 <g_crgIpMatch+0x4d8>
 3008eea:	31c1                	jal	ra,3008baa <AssertErrorLog.trans.6>
 3008eec:	a04d                	j	3008f8e <DCL_QDM_SetInputFilterWidth+0x102>
    QDM_PARAM_CHECK_NO_RET(filtWidthQDMB <= QDM_MAX_FILTER_LEVEL);
 3008eee:	fe845703          	lhu	a4,-24(s0)
 3008ef2:	6789                	lui	a5,0x2
 3008ef4:	00f76a63          	bltu	a4,a5,3008f08 <DCL_QDM_SetInputFilterWidth+0x7c>
 3008ef8:	3e900593          	li	a1,1001
 3008efc:	030117b7          	lui	a5,0x3011
 3008f00:	9e878513          	addi	a0,a5,-1560 # 30109e8 <g_crgIpMatch+0x4d8>
 3008f04:	315d                	jal	ra,3008baa <AssertErrorLog.trans.6>
 3008f06:	a061                	j	3008f8e <DCL_QDM_SetInputFilterWidth+0x102>
    QDM_PARAM_CHECK_NO_RET(filtWidthQDMI <= QDM_MAX_FILTER_LEVEL);
 3008f08:	fe645703          	lhu	a4,-26(s0)
 3008f0c:	6789                	lui	a5,0x2
 3008f0e:	00f76a63          	bltu	a4,a5,3008f22 <DCL_QDM_SetInputFilterWidth+0x96>
 3008f12:	3ea00593          	li	a1,1002
 3008f16:	030117b7          	lui	a5,0x3011
 3008f1a:	9e878513          	addi	a0,a5,-1560 # 30109e8 <g_crgIpMatch+0x4d8>
 3008f1e:	3171                	jal	ra,3008baa <AssertErrorLog.trans.6>
 3008f20:	a0bd                	j	3008f8e <DCL_QDM_SetInputFilterWidth+0x102>
    /* Set QDM input filter width. */
    qdmx->QDMAFT.BIT.qdma_ft_level = filtWidthQDMA;
 3008f22:	fea45703          	lhu	a4,-22(s0)
 3008f26:	6789                	lui	a5,0x2
 3008f28:	17fd                	addi	a5,a5,-1 # 1fff <__bss_size__+0x138b>
 3008f2a:	8ff9                	and	a5,a5,a4
 3008f2c:	01079613          	slli	a2,a5,0x10
 3008f30:	8241                	srli	a2,a2,0x10
 3008f32:	fec42703          	lw	a4,-20(s0)
 3008f36:	4f7c                	lw	a5,92(a4)
 3008f38:	6689                	lui	a3,0x2
 3008f3a:	16fd                	addi	a3,a3,-1 # 1fff <__bss_size__+0x138b>
 3008f3c:	8ef1                	and	a3,a3,a2
 3008f3e:	7679                	lui	a2,0xffffe
 3008f40:	8ff1                	and	a5,a5,a2
 3008f42:	8fd5                	or	a5,a5,a3
 3008f44:	cf7c                	sw	a5,92(a4)
    qdmx->QDMBFT.BIT.qdmb_ft_level = filtWidthQDMB;
 3008f46:	fe845703          	lhu	a4,-24(s0)
 3008f4a:	6789                	lui	a5,0x2
 3008f4c:	17fd                	addi	a5,a5,-1 # 1fff <__bss_size__+0x138b>
 3008f4e:	8ff9                	and	a5,a5,a4
 3008f50:	01079613          	slli	a2,a5,0x10
 3008f54:	8241                	srli	a2,a2,0x10
 3008f56:	fec42703          	lw	a4,-20(s0)
 3008f5a:	533c                	lw	a5,96(a4)
 3008f5c:	6689                	lui	a3,0x2
 3008f5e:	16fd                	addi	a3,a3,-1 # 1fff <__bss_size__+0x138b>
 3008f60:	8ef1                	and	a3,a3,a2
 3008f62:	7679                	lui	a2,0xffffe
 3008f64:	8ff1                	and	a5,a5,a2
 3008f66:	8fd5                	or	a5,a5,a3
 3008f68:	d33c                	sw	a5,96(a4)
    qdmx->QDMIFT.BIT.qdmi_ft_level = filtWidthQDMI;
 3008f6a:	fe645703          	lhu	a4,-26(s0)
 3008f6e:	6789                	lui	a5,0x2
 3008f70:	17fd                	addi	a5,a5,-1 # 1fff <__bss_size__+0x138b>
 3008f72:	8ff9                	and	a5,a5,a4
 3008f74:	01079613          	slli	a2,a5,0x10
 3008f78:	8241                	srli	a2,a2,0x10
 3008f7a:	fec42703          	lw	a4,-20(s0)
 3008f7e:	537c                	lw	a5,100(a4)
 3008f80:	6689                	lui	a3,0x2
 3008f82:	16fd                	addi	a3,a3,-1 # 1fff <__bss_size__+0x138b>
 3008f84:	8ef1                	and	a3,a3,a2
 3008f86:	7679                	lui	a2,0xffffe
 3008f88:	8ff1                	and	a5,a5,a2
 3008f8a:	8fd5                	or	a5,a5,a3
 3008f8c:	d37c                	sw	a5,100(a4)
}
 3008f8e:	40f2                	lw	ra,28(sp)
 3008f90:	4462                	lw	s0,24(sp)
 3008f92:	6105                	addi	sp,sp,32
 3008f94:	8082                	ret

03008f96 <DCL_QDM_SetIndexLockMode>:
  * @param qdmx QDM register base address.
  * @param lockMode Lock mode of index.
  * @retval None.
  */
static inline void DCL_QDM_SetIndexLockMode(QDM_RegStruct *qdmx, QDM_IndexLockMode lockMode)
{
 3008f96:	1101                	addi	sp,sp,-32
 3008f98:	ce06                	sw	ra,28(sp)
 3008f9a:	cc22                	sw	s0,24(sp)
 3008f9c:	1000                	addi	s0,sp,32
 3008f9e:	fea42623          	sw	a0,-20(s0)
 3008fa2:	feb42423          	sw	a1,-24(s0)
    QDM_ASSERT_PARAM(IsQDMInstance(qdmx));
 3008fa6:	fec42703          	lw	a4,-20(s0)
 3008faa:	14c007b7          	lui	a5,0x14c00
 3008fae:	02f70063          	beq	a4,a5,3008fce <DCL_QDM_SetIndexLockMode+0x38>
 3008fb2:	fec42703          	lw	a4,-20(s0)
 3008fb6:	14c017b7          	lui	a5,0x14c01
 3008fba:	00f70a63          	beq	a4,a5,3008fce <DCL_QDM_SetIndexLockMode+0x38>
 3008fbe:	46d00593          	li	a1,1133
 3008fc2:	030117b7          	lui	a5,0x3011
 3008fc6:	9e878513          	addi	a0,a5,-1560 # 30109e8 <g_crgIpMatch+0x4d8>
 3008fca:	36c5                	jal	ra,3008baa <AssertErrorLog.trans.6>
 3008fcc:	a001                	j	3008fcc <DCL_QDM_SetIndexLockMode+0x36>
    QDM_PARAM_CHECK_NO_RET(lockMode >= QDM_LOCK_RESERVE);
    QDM_PARAM_CHECK_NO_RET(lockMode <= QDM_LOCK_SW_INDEX_MARKER);
 3008fce:	fe842703          	lw	a4,-24(s0)
 3008fd2:	478d                	li	a5,3
 3008fd4:	00e7fa63          	bgeu	a5,a4,3008fe8 <DCL_QDM_SetIndexLockMode+0x52>
 3008fd8:	46f00593          	li	a1,1135
 3008fdc:	030117b7          	lui	a5,0x3011
 3008fe0:	9e878513          	addi	a0,a5,-1560 # 30109e8 <g_crgIpMatch+0x4d8>
 3008fe4:	36d9                	jal	ra,3008baa <AssertErrorLog.trans.6>
 3008fe6:	a00d                	j	3009008 <DCL_QDM_SetIndexLockMode+0x72>
    qdmx->QPPUCTRL.BIT.pcnt_idx_lock_mode = lockMode;
 3008fe8:	fe842783          	lw	a5,-24(s0)
 3008fec:	8b8d                	andi	a5,a5,3
 3008fee:	0ff7f693          	andi	a3,a5,255
 3008ff2:	fec42703          	lw	a4,-20(s0)
 3008ff6:	475c                	lw	a5,12(a4)
 3008ff8:	8a8d                	andi	a3,a3,3
 3008ffa:	06d2                	slli	a3,a3,0x14
 3008ffc:	ffd00637          	lui	a2,0xffd00
 3009000:	167d                	addi	a2,a2,-1 # ffcfffff <RAM_END+0xfbcf7fff>
 3009002:	8ff1                	and	a5,a5,a2
 3009004:	8fd5                	or	a5,a5,a3
 3009006:	c75c                	sw	a5,12(a4)
}
 3009008:	40f2                	lw	ra,28(sp)
 300900a:	4462                	lw	s0,24(sp)
 300900c:	6105                	addi	sp,sp,32
 300900e:	8082                	ret

03009010 <QDM_DecoderConfig>:
  * @brief Set Decoder configurations
  * @param qdmHandle Value of @ref QDM_Handle.
  * @retval None
  */
static void QDM_DecoderConfig(QDM_Handle *qdmHandle)
{
 3009010:	1101                	addi	sp,sp,-32
 3009012:	ce06                	sw	ra,28(sp)
 3009014:	cc22                	sw	s0,24(sp)
 3009016:	1000                	addi	s0,sp,32
 3009018:	fea42623          	sw	a0,-20(s0)
    QDM_ASSERT_PARAM(qdmHandle != NULL);
 300901c:	fec42783          	lw	a5,-20(s0)
 3009020:	eb89                	bnez	a5,3009032 <QDM_DecoderConfig+0x22>
 3009022:	02700593          	li	a1,39
 3009026:	030117b7          	lui	a5,0x3011
 300902a:	a0478513          	addi	a0,a5,-1532 # 3010a04 <g_crgIpMatch+0x4f4>
 300902e:	3eb5                	jal	ra,3008baa <AssertErrorLog.trans.6>
 3009030:	a001                	j	3009030 <QDM_DecoderConfig+0x20>
    QDM_ASSERT_PARAM(IsQDMInstance(qdmHandle->baseAddress));
 3009032:	fec42783          	lw	a5,-20(s0)
 3009036:	4398                	lw	a4,0(a5)
 3009038:	14c007b7          	lui	a5,0x14c00
 300903c:	02f70163          	beq	a4,a5,300905e <QDM_DecoderConfig+0x4e>
 3009040:	fec42783          	lw	a5,-20(s0)
 3009044:	4398                	lw	a4,0(a5)
 3009046:	14c017b7          	lui	a5,0x14c01
 300904a:	00f70a63          	beq	a4,a5,300905e <QDM_DecoderConfig+0x4e>
 300904e:	02800593          	li	a1,40
 3009052:	030117b7          	lui	a5,0x3011
 3009056:	a0478513          	addi	a0,a5,-1532 # 3010a04 <g_crgIpMatch+0x4f4>
 300905a:	3e81                	jal	ra,3008baa <AssertErrorLog.trans.6>
 300905c:	a001                	j	300905c <QDM_DecoderConfig+0x4c>
    QDM_PARAM_CHECK_NO_RET(IsDecodeMode(qdmHandle->ctrlConfig.decoderMode));
 300905e:	fec42783          	lw	a5,-20(s0)
 3009062:	4bdc                	lw	a5,20(a5)
 3009064:	853e                	mv	a0,a5
 3009066:	3e5d                	jal	ra,3008c1c <IsDecodeMode>
 3009068:	87aa                	mv	a5,a0
 300906a:	0017c793          	xori	a5,a5,1
 300906e:	9f81                	uxtb	a5
 3009070:	cb89                	beqz	a5,3009082 <QDM_DecoderConfig+0x72>
 3009072:	02900593          	li	a1,41
 3009076:	030117b7          	lui	a5,0x3011
 300907a:	a0478513          	addi	a0,a5,-1532 # 3010a04 <g_crgIpMatch+0x4f4>
 300907e:	3635                	jal	ra,3008baa <AssertErrorLog.trans.6>
 3009080:	a27d                	j	300922e <QDM_DecoderConfig+0x21e>
    QDM_PARAM_CHECK_NO_RET(IsSwap(qdmHandle->ctrlConfig.swap));
 3009082:	fec42783          	lw	a5,-20(s0)
 3009086:	53dc                	lw	a5,36(a5)
 3009088:	853e                	mv	a0,a5
 300908a:	36dd                	jal	ra,3008c70 <IsSwap>
 300908c:	87aa                	mv	a5,a0
 300908e:	0017c793          	xori	a5,a5,1
 3009092:	9f81                	uxtb	a5
 3009094:	cb89                	beqz	a5,30090a6 <QDM_DecoderConfig+0x96>
 3009096:	02a00593          	li	a1,42
 300909a:	030117b7          	lui	a5,0x3011
 300909e:	a0478513          	addi	a0,a5,-1532 # 3010a04 <g_crgIpMatch+0x4f4>
 30090a2:	3621                	jal	ra,3008baa <AssertErrorLog.trans.6>
 30090a4:	a269                	j	300922e <QDM_DecoderConfig+0x21e>
    QDM_PARAM_CHECK_NO_RET(IsResolution(qdmHandle->ctrlConfig.resolution));
 30090a6:	fec42783          	lw	a5,-20(s0)
 30090aa:	4f9c                	lw	a5,24(a5)
 30090ac:	853e                	mv	a0,a5
 30090ae:	3e41                	jal	ra,3008c3e <IsResolution>
 30090b0:	87aa                	mv	a5,a0
 30090b2:	0017c793          	xori	a5,a5,1
 30090b6:	9f81                	uxtb	a5
 30090b8:	cb89                	beqz	a5,30090ca <QDM_DecoderConfig+0xba>
 30090ba:	02b00593          	li	a1,43
 30090be:	030117b7          	lui	a5,0x3011
 30090c2:	a0478513          	addi	a0,a5,-1532 # 3010a04 <g_crgIpMatch+0x4f4>
 30090c6:	34d5                	jal	ra,3008baa <AssertErrorLog.trans.6>
 30090c8:	a29d                	j	300922e <QDM_DecoderConfig+0x21e>
    QDM_PARAM_CHECK_NO_RET(IsTrgLockMode(qdmHandle->ctrlConfig.trgLockMode));
 30090ca:	fec42783          	lw	a5,-20(s0)
 30090ce:	4fdc                	lw	a5,28(a5)
 30090d0:	853e                	mv	a0,a5
 30090d2:	36d9                	jal	ra,3008c98 <IsTrgLockMode>
 30090d4:	87aa                	mv	a5,a0
 30090d6:	0017c793          	xori	a5,a5,1
 30090da:	9f81                	uxtb	a5
 30090dc:	cb89                	beqz	a5,30090ee <QDM_DecoderConfig+0xde>
 30090de:	02c00593          	li	a1,44
 30090e2:	030117b7          	lui	a5,0x3011
 30090e6:	a0478513          	addi	a0,a5,-1532 # 3010a04 <g_crgIpMatch+0x4f4>
 30090ea:	34c1                	jal	ra,3008baa <AssertErrorLog.trans.6>
 30090ec:	a289                	j	300922e <QDM_DecoderConfig+0x21e>
    QDM_PARAM_CHECK_NO_RET(IsPtuMode(qdmHandle->ctrlConfig.ptuMode));
 30090ee:	fec42783          	lw	a5,-20(s0)
 30090f2:	539c                	lw	a5,32(a5)
 30090f4:	853e                	mv	a0,a5
 30090f6:	36e9                	jal	ra,3008cc0 <IsPtuMode>
 30090f8:	87aa                	mv	a5,a0
 30090fa:	0017c793          	xori	a5,a5,1
 30090fe:	9f81                	uxtb	a5
 3009100:	cb89                	beqz	a5,3009112 <QDM_DecoderConfig+0x102>
 3009102:	02d00593          	li	a1,45
 3009106:	030117b7          	lui	a5,0x3011
 300910a:	a0478513          	addi	a0,a5,-1532 # 3010a04 <g_crgIpMatch+0x4f4>
 300910e:	3c71                	jal	ra,3008baa <AssertErrorLog.trans.6>
 3009110:	aa39                	j	300922e <QDM_DecoderConfig+0x21e>

    /* input mode setting */
    qdmHandle->baseAddress->QCTRL.BIT.qdu_mode = qdmHandle->ctrlConfig.decoderMode;
 3009112:	fec42783          	lw	a5,-20(s0)
 3009116:	4bd4                	lw	a3,20(a5)
 3009118:	fec42783          	lw	a5,-20(s0)
 300911c:	4398                	lw	a4,0(a5)
 300911e:	87b6                	mv	a5,a3
 3009120:	8b8d                	andi	a5,a5,3
 3009122:	0ff7f693          	andi	a3,a5,255
 3009126:	471c                	lw	a5,8(a4)
 3009128:	8a8d                	andi	a3,a3,3
 300912a:	06ba                	slli	a3,a3,0xe
 300912c:	7651                	lui	a2,0xffff4
 300912e:	167d                	addi	a2,a2,-1 # ffff3fff <RAM_END+0xfbfebfff>
 3009130:	8ff1                	and	a5,a5,a2
 3009132:	8fd5                	or	a5,a5,a3
 3009134:	c71c                	sw	a5,8(a4)
    /* swap */
    qdmHandle->baseAddress->QCTRL.BIT.qdm_ab_swap = qdmHandle->ctrlConfig.swap;
 3009136:	fec42783          	lw	a5,-20(s0)
 300913a:	53d4                	lw	a3,36(a5)
 300913c:	fec42783          	lw	a5,-20(s0)
 3009140:	4398                	lw	a4,0(a5)
 3009142:	87b6                	mv	a5,a3
 3009144:	8b85                	andi	a5,a5,1
 3009146:	0ff7f693          	andi	a3,a5,255
 300914a:	471c                	lw	a5,8(a4)
 300914c:	8a85                	andi	a3,a3,1
 300914e:	06ae                	slli	a3,a3,0xb
 3009150:	767d                	lui	a2,0xfffff
 3009152:	7ff60613          	addi	a2,a2,2047 # fffff7ff <RAM_END+0xfbff77ff>
 3009156:	8ff1                	and	a5,a5,a2
 3009158:	8fd5                	or	a5,a5,a3
 300915a:	c71c                	sw	a5,8(a4)
    /* qdm xclk */
    qdmHandle->baseAddress->QCTRL.BIT.qdu_xclk = qdmHandle->ctrlConfig.resolution;
 300915c:	fec42783          	lw	a5,-20(s0)
 3009160:	4f94                	lw	a3,24(a5)
 3009162:	fec42783          	lw	a5,-20(s0)
 3009166:	4398                	lw	a4,0(a5)
 3009168:	87b6                	mv	a5,a3
 300916a:	8b8d                	andi	a5,a5,3
 300916c:	0ff7f693          	andi	a3,a5,255
 3009170:	471c                	lw	a5,8(a4)
 3009172:	8a8d                	andi	a3,a3,3
 3009174:	06b2                	slli	a3,a3,0xc
 3009176:	7675                	lui	a2,0xffffd
 3009178:	167d                	addi	a2,a2,-1 # ffffcfff <RAM_END+0xfbff4fff>
 300917a:	8ff1                	and	a5,a5,a2
 300917c:	8fd5                	or	a5,a5,a3
 300917e:	c71c                	sw	a5,8(a4)
    /* polarity */
    /* bit0: A input polarity, bit value: 0--direct input, 1--invert input */
    qdmHandle->baseAddress->QCTRL.BIT.qdma_polarity = (qdmHandle->ctrlConfig.polarity & 0x01);
 3009180:	fec42783          	lw	a5,-20(s0)
 3009184:	5794                	lw	a3,40(a5)
 3009186:	fec42783          	lw	a5,-20(s0)
 300918a:	4398                	lw	a4,0(a5)
 300918c:	87b6                	mv	a5,a3
 300918e:	8b85                	andi	a5,a5,1
 3009190:	0ff7f693          	andi	a3,a5,255
 3009194:	471c                	lw	a5,8(a4)
 3009196:	8a85                	andi	a3,a3,1
 3009198:	06aa                	slli	a3,a3,0xa
 300919a:	bff7f793          	andi	a5,a5,-1025
 300919e:	8fd5                	or	a5,a5,a3
 30091a0:	c71c                	sw	a5,8(a4)
    /* bit1: B input polarity, bit value: 0--direct input, 1--invert input */
    qdmHandle->baseAddress->QCTRL.BIT.qdmb_polarity = ((qdmHandle->ctrlConfig.polarity >> 1) & 0x01);
 30091a2:	fec42783          	lw	a5,-20(s0)
 30091a6:	579c                	lw	a5,40(a5)
 30091a8:	0017d693          	srli	a3,a5,0x1
 30091ac:	fec42783          	lw	a5,-20(s0)
 30091b0:	4398                	lw	a4,0(a5)
 30091b2:	87b6                	mv	a5,a3
 30091b4:	8b85                	andi	a5,a5,1
 30091b6:	0ff7f693          	andi	a3,a5,255
 30091ba:	471c                	lw	a5,8(a4)
 30091bc:	8a85                	andi	a3,a3,1
 30091be:	06a6                	slli	a3,a3,0x9
 30091c0:	dff7f793          	andi	a5,a5,-513
 30091c4:	8fd5                	or	a5,a5,a3
 30091c6:	c71c                	sw	a5,8(a4)
    /* bit2: index input polarity, bit value: 0--direct input, 1--invert input */
    qdmHandle->baseAddress->QCTRL.BIT.qdmi_polarity = ((qdmHandle->ctrlConfig.polarity >> 2) & 0x01);
 30091c8:	fec42783          	lw	a5,-20(s0)
 30091cc:	579c                	lw	a5,40(a5)
 30091ce:	0027d693          	srli	a3,a5,0x2
 30091d2:	fec42783          	lw	a5,-20(s0)
 30091d6:	4398                	lw	a4,0(a5)
 30091d8:	87b6                	mv	a5,a3
 30091da:	8b85                	andi	a5,a5,1
 30091dc:	0ff7f693          	andi	a3,a5,255
 30091e0:	471c                	lw	a5,8(a4)
 30091e2:	8a85                	andi	a3,a3,1
 30091e4:	06a2                	slli	a3,a3,0x8
 30091e6:	eff7f793          	andi	a5,a5,-257
 30091ea:	8fd5                	or	a5,a5,a3
 30091ec:	c71c                	sw	a5,8(a4)
    /* lock mode */
    qdmHandle->baseAddress->QCTRL.BIT.qtrg_lock_mode = qdmHandle->ctrlConfig.trgLockMode;
 30091ee:	fec42783          	lw	a5,-20(s0)
 30091f2:	4fd4                	lw	a3,28(a5)
 30091f4:	fec42783          	lw	a5,-20(s0)
 30091f8:	4398                	lw	a4,0(a5)
 30091fa:	87b6                	mv	a5,a3
 30091fc:	8b85                	andi	a5,a5,1
 30091fe:	0ff7f693          	andi	a3,a5,255
 3009202:	471c                	lw	a5,8(a4)
 3009204:	8a85                	andi	a3,a3,1
 3009206:	0692                	slli	a3,a3,0x4
 3009208:	9bbd                	andi	a5,a5,-17
 300920a:	8fd5                	or	a5,a5,a3
 300920c:	c71c                	sw	a5,8(a4)
    /* ptu mode */
    qdmHandle->baseAddress->QCTRL.BIT.ptu_mode = qdmHandle->ctrlConfig.ptuMode;
 300920e:	fec42783          	lw	a5,-20(s0)
 3009212:	5394                	lw	a3,32(a5)
 3009214:	fec42783          	lw	a5,-20(s0)
 3009218:	4398                	lw	a4,0(a5)
 300921a:	87b6                	mv	a5,a3
 300921c:	8b85                	andi	a5,a5,1
 300921e:	0ff7f693          	andi	a3,a5,255
 3009222:	471c                	lw	a5,8(a4)
 3009224:	8a85                	andi	a3,a3,1
 3009226:	068e                	slli	a3,a3,0x3
 3009228:	9bdd                	andi	a5,a5,-9
 300922a:	8fd5                	or	a5,a5,a3
 300922c:	c71c                	sw	a5,8(a4)
}
 300922e:	40f2                	lw	ra,28(sp)
 3009230:	4462                	lw	s0,24(sp)
 3009232:	6105                	addi	sp,sp,32
 3009234:	8082                	ret

03009236 <QDM_CounterConfig>:
  * @brief Set counter configurations
  * @param qdmHandle Value of @ref QDM_Handle.
  * @retval None
  */
static void QDM_CounterConfig(QDM_Handle *qdmHandle)
{
 3009236:	1101                	addi	sp,sp,-32
 3009238:	ce06                	sw	ra,28(sp)
 300923a:	cc22                	sw	s0,24(sp)
 300923c:	1000                	addi	s0,sp,32
 300923e:	fea42623          	sw	a0,-20(s0)
    QDM_ASSERT_PARAM(qdmHandle != NULL);
 3009242:	fec42783          	lw	a5,-20(s0)
 3009246:	eb89                	bnez	a5,3009258 <QDM_CounterConfig+0x22>
 3009248:	04900593          	li	a1,73
 300924c:	030117b7          	lui	a5,0x3011
 3009250:	a0478513          	addi	a0,a5,-1532 # 3010a04 <g_crgIpMatch+0x4f4>
 3009254:	3a99                	jal	ra,3008baa <AssertErrorLog.trans.6>
 3009256:	a001                	j	3009256 <QDM_CounterConfig+0x20>
    QDM_ASSERT_PARAM(IsQDMInstance(qdmHandle->baseAddress));
 3009258:	fec42783          	lw	a5,-20(s0)
 300925c:	4398                	lw	a4,0(a5)
 300925e:	14c007b7          	lui	a5,0x14c00
 3009262:	02f70163          	beq	a4,a5,3009284 <QDM_CounterConfig+0x4e>
 3009266:	fec42783          	lw	a5,-20(s0)
 300926a:	4398                	lw	a4,0(a5)
 300926c:	14c017b7          	lui	a5,0x14c01
 3009270:	00f70a63          	beq	a4,a5,3009284 <QDM_CounterConfig+0x4e>
 3009274:	04a00593          	li	a1,74
 3009278:	030117b7          	lui	a5,0x3011
 300927c:	a0478513          	addi	a0,a5,-1532 # 3010a04 <g_crgIpMatch+0x4f4>
 3009280:	322d                	jal	ra,3008baa <AssertErrorLog.trans.6>
 3009282:	a001                	j	3009282 <QDM_CounterConfig+0x4c>
    QDM_PARAM_CHECK_NO_RET(IsPcntMode(qdmHandle->pcntMode));
 3009284:	fec42783          	lw	a5,-20(s0)
 3009288:	57dc                	lw	a5,44(a5)
 300928a:	853e                	mv	a0,a5
 300928c:	3cb1                	jal	ra,3008ce8 <IsPcntMode>
 300928e:	87aa                	mv	a5,a0
 3009290:	0017c793          	xori	a5,a5,1
 3009294:	9f81                	uxtb	a5
 3009296:	cb89                	beqz	a5,30092a8 <QDM_CounterConfig+0x72>
 3009298:	04b00593          	li	a1,75
 300929c:	030117b7          	lui	a5,0x3011
 30092a0:	a0478513          	addi	a0,a5,-1532 # 3010a04 <g_crgIpMatch+0x4f4>
 30092a4:	3219                	jal	ra,3008baa <AssertErrorLog.trans.6>
 30092a6:	aab5                	j	3009422 <QDM_CounterConfig+0x1ec>
    QDM_PARAM_CHECK_NO_RET(IsPcntRstMode(qdmHandle->pcntRstMode));
 30092a8:	fec42783          	lw	a5,-20(s0)
 30092ac:	5b9c                	lw	a5,48(a5)
 30092ae:	853e                	mv	a0,a5
 30092b0:	34ad                	jal	ra,3008d1a <IsPcntRstMode>
 30092b2:	87aa                	mv	a5,a0
 30092b4:	0017c793          	xori	a5,a5,1
 30092b8:	9f81                	uxtb	a5
 30092ba:	cb89                	beqz	a5,30092cc <QDM_CounterConfig+0x96>
 30092bc:	04c00593          	li	a1,76
 30092c0:	030117b7          	lui	a5,0x3011
 30092c4:	a0478513          	addi	a0,a5,-1532 # 3010a04 <g_crgIpMatch+0x4f4>
 30092c8:	30cd                	jal	ra,3008baa <AssertErrorLog.trans.6>
 30092ca:	aaa1                	j	3009422 <QDM_CounterConfig+0x1ec>
    QDM_PARAM_CHECK_NO_RET(IsPcntIdxInitMode(qdmHandle->pcntIdxInitMode));
 30092cc:	fec42783          	lw	a5,-20(s0)
 30092d0:	5bdc                	lw	a5,52(a5)
 30092d2:	853e                	mv	a0,a5
 30092d4:	3449                	jal	ra,3008d56 <IsPcntIdxInitMode>
 30092d6:	87aa                	mv	a5,a0
 30092d8:	0017c793          	xori	a5,a5,1
 30092dc:	9f81                	uxtb	a5
 30092de:	cb89                	beqz	a5,30092f0 <QDM_CounterConfig+0xba>
 30092e0:	04d00593          	li	a1,77
 30092e4:	030117b7          	lui	a5,0x3011
 30092e8:	a0478513          	addi	a0,a5,-1532 # 3010a04 <g_crgIpMatch+0x4f4>
 30092ec:	2f1d                	jal	ra,3009a22 <AssertErrorLog.trans.7>
 30092ee:	aa15                	j	3009422 <QDM_CounterConfig+0x1ec>
    QDM_PARAM_CHECK_NO_RET(IsTsuPrescaler(qdmHandle->tsuPrescaler));
 30092f0:	fec42783          	lw	a5,-20(s0)
 30092f4:	5fdc                	lw	a5,60(a5)
 30092f6:	853e                	mv	a0,a5
 30092f8:	3c69                	jal	ra,3008d92 <IsTsuPrescaler>
 30092fa:	87aa                	mv	a5,a0
 30092fc:	0017c793          	xori	a5,a5,1
 3009300:	9f81                	uxtb	a5
 3009302:	cb89                	beqz	a5,3009314 <QDM_CounterConfig+0xde>
 3009304:	04e00593          	li	a1,78
 3009308:	030117b7          	lui	a5,0x3011
 300930c:	a0478513          	addi	a0,a5,-1532 # 3010a04 <g_crgIpMatch+0x4f4>
 3009310:	2f09                	jal	ra,3009a22 <AssertErrorLog.trans.7>
 3009312:	aa01                	j	3009422 <QDM_CounterConfig+0x1ec>
    QDM_PARAM_CHECK_NO_RET(IsCevtPrescaler(qdmHandle->cevtPrescaler));
 3009314:	fec42783          	lw	a5,-20(s0)
 3009318:	43bc                	lw	a5,64(a5)
 300931a:	853e                	mv	a0,a5
 300931c:	34d5                	jal	ra,3008e00 <IsCevtPrescaler>
 300931e:	87aa                	mv	a5,a0
 3009320:	0017c793          	xori	a5,a5,1
 3009324:	9f81                	uxtb	a5
 3009326:	cb89                	beqz	a5,3009338 <QDM_CounterConfig+0x102>
 3009328:	04f00593          	li	a1,79
 300932c:	030117b7          	lui	a5,0x3011
 3009330:	a0478513          	addi	a0,a5,-1532 # 3010a04 <g_crgIpMatch+0x4f4>
 3009334:	25fd                	jal	ra,3009a22 <AssertErrorLog.trans.7>
 3009336:	a0f5                	j	3009422 <QDM_CounterConfig+0x1ec>

    /* set pcnt mode */
    qdmHandle->baseAddress->QPPUCTRL.BIT.pcnt_mode = qdmHandle->pcntMode;
 3009338:	fec42783          	lw	a5,-20(s0)
 300933c:	57d4                	lw	a3,44(a5)
 300933e:	fec42783          	lw	a5,-20(s0)
 3009342:	4398                	lw	a4,0(a5)
 3009344:	87b6                	mv	a5,a3
 3009346:	8b8d                	andi	a5,a5,3
 3009348:	0ff7f693          	andi	a3,a5,255
 300934c:	475c                	lw	a5,12(a4)
 300934e:	8a8d                	andi	a3,a3,3
 3009350:	06ea                	slli	a3,a3,0x1a
 3009352:	f4000637          	lui	a2,0xf4000
 3009356:	167d                	addi	a2,a2,-1 # f3ffffff <RAM_END+0xefff7fff>
 3009358:	8ff1                	and	a5,a5,a2
 300935a:	8fd5                	or	a5,a5,a3
 300935c:	c75c                	sw	a5,12(a4)
    qdmHandle->baseAddress->QPPUCTRL.BIT.pcnt_rst_mode = qdmHandle->pcntRstMode;
 300935e:	fec42783          	lw	a5,-20(s0)
 3009362:	5b94                	lw	a3,48(a5)
 3009364:	fec42783          	lw	a5,-20(s0)
 3009368:	4398                	lw	a4,0(a5)
 300936a:	87b6                	mv	a5,a3
 300936c:	8b8d                	andi	a5,a5,3
 300936e:	0ff7f693          	andi	a3,a5,255
 3009372:	475c                	lw	a5,12(a4)
 3009374:	8a8d                	andi	a3,a3,3
 3009376:	06e2                	slli	a3,a3,0x18
 3009378:	fd000637          	lui	a2,0xfd000
 300937c:	167d                	addi	a2,a2,-1 # fcffffff <RAM_END+0xf8ff7fff>
 300937e:	8ff1                	and	a5,a5,a2
 3009380:	8fd5                	or	a5,a5,a3
 3009382:	c75c                	sw	a5,12(a4)
    qdmHandle->baseAddress->QPPUCTRL.BIT.pcnt_idx_init_mode = qdmHandle->pcntIdxInitMode;
 3009384:	fec42783          	lw	a5,-20(s0)
 3009388:	5bd4                	lw	a3,52(a5)
 300938a:	fec42783          	lw	a5,-20(s0)
 300938e:	4398                	lw	a4,0(a5)
 3009390:	87b6                	mv	a5,a3
 3009392:	8b8d                	andi	a5,a5,3
 3009394:	0ff7f693          	andi	a3,a5,255
 3009398:	475c                	lw	a5,12(a4)
 300939a:	8a8d                	andi	a3,a3,3
 300939c:	06da                	slli	a3,a3,0x16
 300939e:	ff400637          	lui	a2,0xff400
 30093a2:	167d                	addi	a2,a2,-1 # ff3fffff <RAM_END+0xfb3f7fff>
 30093a4:	8ff1                	and	a5,a5,a2
 30093a6:	8fd5                	or	a5,a5,a3
 30093a8:	c75c                	sw	a5,12(a4)
    /* set TSU */
    qdmHandle->baseAddress->QTSUCTRL.BIT.tsu_prescaler = qdmHandle->tsuPrescaler;
 30093aa:	fec42783          	lw	a5,-20(s0)
 30093ae:	5fd4                	lw	a3,60(a5)
 30093b0:	fec42783          	lw	a5,-20(s0)
 30093b4:	4398                	lw	a4,0(a5)
 30093b6:	87b6                	mv	a5,a3
 30093b8:	8bbd                	andi	a5,a5,15
 30093ba:	0ff7f693          	andi	a3,a5,255
 30093be:	4b1c                	lw	a5,16(a4)
 30093c0:	8abd                	andi	a3,a3,15
 30093c2:	0692                	slli	a3,a3,0x4
 30093c4:	f0f7f793          	andi	a5,a5,-241
 30093c8:	8fd5                	or	a5,a5,a3
 30093ca:	cb1c                	sw	a5,16(a4)
    qdmHandle->baseAddress->QTSUCTRL.BIT.cevt_prescaler = qdmHandle->cevtPrescaler;
 30093cc:	fec42783          	lw	a5,-20(s0)
 30093d0:	43b4                	lw	a3,64(a5)
 30093d2:	fec42783          	lw	a5,-20(s0)
 30093d6:	4398                	lw	a4,0(a5)
 30093d8:	87b6                	mv	a5,a3
 30093da:	8bbd                	andi	a5,a5,15
 30093dc:	0ff7f693          	andi	a3,a5,255
 30093e0:	4b1c                	lw	a5,16(a4)
 30093e2:	8abd                	andi	a3,a3,15
 30093e4:	9bc1                	andi	a5,a5,-16
 30093e6:	8fd5                	or	a5,a5,a3
 30093e8:	cb1c                	sw	a5,16(a4)
    /* set init value */
    qdmHandle->baseAddress->QPOSINIT = qdmHandle->posInit;
 30093ea:	fec42783          	lw	a5,-20(s0)
 30093ee:	439c                	lw	a5,0(a5)
 30093f0:	fec42703          	lw	a4,-20(s0)
 30093f4:	4378                	lw	a4,68(a4)
 30093f6:	d7d8                	sw	a4,44(a5)
    /* set count max value */
    qdmHandle->baseAddress->QPOSMAX  = qdmHandle->posMax;
 30093f8:	fec42783          	lw	a5,-20(s0)
 30093fc:	439c                	lw	a5,0(a5)
 30093fe:	fec42703          	lw	a4,-20(s0)
 3009402:	4738                	lw	a4,72(a4)
 3009404:	db98                	sw	a4,48(a5)
    qdmHandle->baseAddress->QUPRD    = qdmHandle->period;
 3009406:	fec42783          	lw	a5,-20(s0)
 300940a:	439c                	lw	a5,0(a5)
 300940c:	fec42703          	lw	a4,-20(s0)
 3009410:	4b38                	lw	a4,80(a4)
 3009412:	c3f8                	sw	a4,68(a5)
    qdmHandle->baseAddress->QCMAX = qdmHandle->qcMax;
 3009414:	fec42783          	lw	a5,-20(s0)
 3009418:	439c                	lw	a5,0(a5)
 300941a:	fec42703          	lw	a4,-20(s0)
 300941e:	4778                	lw	a4,76(a4)
 3009420:	c7f8                	sw	a4,76(a5)
}
 3009422:	40f2                	lw	ra,28(sp)
 3009424:	4462                	lw	s0,24(sp)
 3009426:	6105                	addi	sp,sp,32
 3009428:	8082                	ret

0300942a <QDM_EnableSubmodule>:
  * @brief enable submodules
  * @param qdmHandle Value of @ref QDM_Handle.
  * @retval None
  */
static void QDM_EnableSubmodule(QDM_Handle *qdmHandle)
{
 300942a:	1101                	addi	sp,sp,-32
 300942c:	ce06                	sw	ra,28(sp)
 300942e:	cc22                	sw	s0,24(sp)
 3009430:	1000                	addi	s0,sp,32
 3009432:	fea42623          	sw	a0,-20(s0)
    QDM_ASSERT_PARAM(qdmHandle != NULL);
 3009436:	fec42783          	lw	a5,-20(s0)
 300943a:	eb89                	bnez	a5,300944c <QDM_EnableSubmodule+0x22>
 300943c:	06700593          	li	a1,103
 3009440:	030117b7          	lui	a5,0x3011
 3009444:	a0478513          	addi	a0,a5,-1532 # 3010a04 <g_crgIpMatch+0x4f4>
 3009448:	2be9                	jal	ra,3009a22 <AssertErrorLog.trans.7>
 300944a:	a001                	j	300944a <QDM_EnableSubmodule+0x20>
    QDM_ASSERT_PARAM(IsQDMInstance(qdmHandle->baseAddress));
 300944c:	fec42783          	lw	a5,-20(s0)
 3009450:	4398                	lw	a4,0(a5)
 3009452:	14c007b7          	lui	a5,0x14c00
 3009456:	02f70163          	beq	a4,a5,3009478 <QDM_EnableSubmodule+0x4e>
 300945a:	fec42783          	lw	a5,-20(s0)
 300945e:	4398                	lw	a4,0(a5)
 3009460:	14c017b7          	lui	a5,0x14c01
 3009464:	00f70a63          	beq	a4,a5,3009478 <QDM_EnableSubmodule+0x4e>
 3009468:	06800593          	li	a1,104
 300946c:	030117b7          	lui	a5,0x3011
 3009470:	a0478513          	addi	a0,a5,-1532 # 3010a04 <g_crgIpMatch+0x4f4>
 3009474:	237d                	jal	ra,3009a22 <AssertErrorLog.trans.7>
 3009476:	a001                	j	3009476 <QDM_EnableSubmodule+0x4c>
    if (qdmHandle->subModeEn == true) {
 3009478:	fec42783          	lw	a5,-20(s0)
 300947c:	0387c783          	lbu	a5,56(a5)
 3009480:	c795                	beqz	a5,30094ac <QDM_EnableSubmodule+0x82>
        qdmHandle->baseAddress->QCTRL.BIT.ppu_en = BASE_CFG_ENABLE;
 3009482:	fec42783          	lw	a5,-20(s0)
 3009486:	4398                	lw	a4,0(a5)
 3009488:	471c                	lw	a5,8(a4)
 300948a:	0027e793          	ori	a5,a5,2
 300948e:	c71c                	sw	a5,8(a4)
        qdmHandle->baseAddress->QCTRL.BIT.ptu_en = BASE_CFG_ENABLE;
 3009490:	fec42783          	lw	a5,-20(s0)
 3009494:	4398                	lw	a4,0(a5)
 3009496:	471c                	lw	a5,8(a4)
 3009498:	0017e793          	ori	a5,a5,1
 300949c:	c71c                	sw	a5,8(a4)
        qdmHandle->baseAddress->QCTRL.BIT.tsu_en = BASE_CFG_ENABLE;
 300949e:	fec42783          	lw	a5,-20(s0)
 30094a2:	4398                	lw	a4,0(a5)
 30094a4:	471c                	lw	a5,8(a4)
 30094a6:	0047e793          	ori	a5,a5,4
 30094aa:	c71c                	sw	a5,8(a4)
    }
}
 30094ac:	0001                	nop
 30094ae:	40f2                	lw	ra,28(sp)
 30094b0:	4462                	lw	s0,24(sp)
 30094b2:	6105                	addi	sp,sp,32
 30094b4:	8082                	ret

030094b6 <QDM_InterruptEnable>:
  * @brief enable interrupt
  * @param qdmHandle Value of @ref QDM_Handle.
  * @retval None
  */
static void QDM_InterruptEnable(QDM_Handle *qdmHandle)
{
 30094b6:	1101                	addi	sp,sp,-32
 30094b8:	ce06                	sw	ra,28(sp)
 30094ba:	cc22                	sw	s0,24(sp)
 30094bc:	1000                	addi	s0,sp,32
 30094be:	fea42623          	sw	a0,-20(s0)
    QDM_ASSERT_PARAM(qdmHandle != NULL);
 30094c2:	fec42783          	lw	a5,-20(s0)
 30094c6:	eb89                	bnez	a5,30094d8 <QDM_InterruptEnable+0x22>
 30094c8:	07700593          	li	a1,119
 30094cc:	030117b7          	lui	a5,0x3011
 30094d0:	a0478513          	addi	a0,a5,-1532 # 3010a04 <g_crgIpMatch+0x4f4>
 30094d4:	23b9                	jal	ra,3009a22 <AssertErrorLog.trans.7>
 30094d6:	a001                	j	30094d6 <QDM_InterruptEnable+0x20>
    QDM_ASSERT_PARAM(IsQDMInstance(qdmHandle->baseAddress));
 30094d8:	fec42783          	lw	a5,-20(s0)
 30094dc:	4398                	lw	a4,0(a5)
 30094de:	14c007b7          	lui	a5,0x14c00
 30094e2:	02f70163          	beq	a4,a5,3009504 <QDM_InterruptEnable+0x4e>
 30094e6:	fec42783          	lw	a5,-20(s0)
 30094ea:	4398                	lw	a4,0(a5)
 30094ec:	14c017b7          	lui	a5,0x14c01
 30094f0:	00f70a63          	beq	a4,a5,3009504 <QDM_InterruptEnable+0x4e>
 30094f4:	07800593          	li	a1,120
 30094f8:	030117b7          	lui	a5,0x3011
 30094fc:	a0478513          	addi	a0,a5,-1532 # 3010a04 <g_crgIpMatch+0x4f4>
 3009500:	230d                	jal	ra,3009a22 <AssertErrorLog.trans.7>
 3009502:	a001                	j	3009502 <QDM_InterruptEnable+0x4c>
    qdmHandle->baseAddress->QINTENA.reg = qdmHandle->interruptEn;
 3009504:	fec42783          	lw	a5,-20(s0)
 3009508:	439c                	lw	a5,0(a5)
 300950a:	fec42703          	lw	a4,-20(s0)
 300950e:	4b78                	lw	a4,84(a4)
 3009510:	cbd8                	sw	a4,20(a5)
}
 3009512:	0001                	nop
 3009514:	40f2                	lw	ra,28(sp)
 3009516:	4462                	lw	s0,24(sp)
 3009518:	6105                	addi	sp,sp,32
 300951a:	8082                	ret

0300951c <SpeedLose>:
 * @brief Speed lose interrupt.
 * @param qdmHandle Value of @ref QDM_Handle.
 * @retval None
 */
static void SpeedLose(QDM_Handle *qdmHandle)
{
 300951c:	1101                	addi	sp,sp,-32
 300951e:	ce06                	sw	ra,28(sp)
 3009520:	cc22                	sw	s0,24(sp)
 3009522:	1000                	addi	s0,sp,32
 3009524:	fea42623          	sw	a0,-20(s0)
    if (qdmHandle->userCallBack.SpeedLoseCallback != NULL) {
 3009528:	fec42783          	lw	a5,-20(s0)
 300952c:	57bc                	lw	a5,104(a5)
 300952e:	c799                	beqz	a5,300953c <SpeedLose+0x20>
        qdmHandle->userCallBack.SpeedLoseCallback(qdmHandle);
 3009530:	fec42783          	lw	a5,-20(s0)
 3009534:	57bc                	lw	a5,104(a5)
 3009536:	fec42503          	lw	a0,-20(s0)
 300953a:	9782                	jalr	a5
    }
}
 300953c:	0001                	nop
 300953e:	40f2                	lw	ra,28(sp)
 3009540:	4462                	lw	s0,24(sp)
 3009542:	6105                	addi	sp,sp,32
 3009544:	8082                	ret

03009546 <ZIndexLock>:
 * @brief QDM Z index lock interrupt.
 * @param qdmHandle Value of @ref QDM_Handle.
 * @retval None
 */
static void ZIndexLock(QDM_Handle *qdmHandle)
{
 3009546:	1101                	addi	sp,sp,-32
 3009548:	ce06                	sw	ra,28(sp)
 300954a:	cc22                	sw	s0,24(sp)
 300954c:	1000                	addi	s0,sp,32
 300954e:	fea42623          	sw	a0,-20(s0)
    if (qdmHandle->userCallBack.ZIndexLockedCallBack != NULL) {
 3009552:	fec42783          	lw	a5,-20(s0)
 3009556:	57fc                	lw	a5,108(a5)
 3009558:	c799                	beqz	a5,3009566 <ZIndexLock+0x20>
        qdmHandle->userCallBack.ZIndexLockedCallBack(qdmHandle);
 300955a:	fec42783          	lw	a5,-20(s0)
 300955e:	57fc                	lw	a5,108(a5)
 3009560:	fec42503          	lw	a0,-20(s0)
 3009564:	9782                	jalr	a5
    }
}
 3009566:	0001                	nop
 3009568:	40f2                	lw	ra,28(sp)
 300956a:	4462                	lw	s0,24(sp)
 300956c:	6105                	addi	sp,sp,32
 300956e:	8082                	ret

03009570 <OrthoDirChange>:
 * @brief Orthogonal direction change interrupt.
 * @param qdmHandle Value of @ref QDM_Handle.
 * @retval None
 */
static void OrthoDirChange(QDM_Handle *qdmHandle)
{
 3009570:	1101                	addi	sp,sp,-32
 3009572:	ce06                	sw	ra,28(sp)
 3009574:	cc22                	sw	s0,24(sp)
 3009576:	1000                	addi	s0,sp,32
 3009578:	fea42623          	sw	a0,-20(s0)
    if (qdmHandle->userCallBack.OrthogonalDirectionChangeCallBack != NULL) {
 300957c:	fec42783          	lw	a5,-20(s0)
 3009580:	0807a783          	lw	a5,128(a5)
 3009584:	cb81                	beqz	a5,3009594 <OrthoDirChange+0x24>
        qdmHandle->userCallBack.OrthogonalDirectionChangeCallBack(qdmHandle);
 3009586:	fec42783          	lw	a5,-20(s0)
 300958a:	0807a783          	lw	a5,128(a5)
 300958e:	fec42503          	lw	a0,-20(s0)
 3009592:	9782                	jalr	a5
    }
}
 3009594:	0001                	nop
 3009596:	40f2                	lw	ra,28(sp)
 3009598:	4462                	lw	s0,24(sp)
 300959a:	6105                	addi	sp,sp,32
 300959c:	8082                	ret

0300959e <OrthoPhaseErr>:
 * @brief Orthogonal phase error interrupt.
 * @param qdmHandle Value of @ref QDM_Handle.
 * @retval None
 */
static void OrthoPhaseErr(QDM_Handle *qdmHandle)
{
 300959e:	1101                	addi	sp,sp,-32
 30095a0:	ce06                	sw	ra,28(sp)
 30095a2:	cc22                	sw	s0,24(sp)
 30095a4:	1000                	addi	s0,sp,32
 30095a6:	fea42623          	sw	a0,-20(s0)
    if (qdmHandle->userCallBack.OrthogonalPhaseErrorCallBack != NULL) {
 30095aa:	fec42783          	lw	a5,-20(s0)
 30095ae:	0847a783          	lw	a5,132(a5)
 30095b2:	cb81                	beqz	a5,30095c2 <OrthoPhaseErr+0x24>
        qdmHandle->userCallBack.OrthogonalPhaseErrorCallBack(qdmHandle);
 30095b4:	fec42783          	lw	a5,-20(s0)
 30095b8:	0847a783          	lw	a5,132(a5)
 30095bc:	fec42503          	lw	a0,-20(s0)
 30095c0:	9782                	jalr	a5
    }
}
 30095c2:	0001                	nop
 30095c4:	40f2                	lw	ra,28(sp)
 30095c6:	4462                	lw	s0,24(sp)
 30095c8:	6105                	addi	sp,sp,32
 30095ca:	8082                	ret

030095cc <PosCompareMatch>:
 * @brief Position compare match interrupt.
 * @param qdmHandle Value of @ref QDM_Handle.
 * @retval None
 */
static void PosCompareMatch(QDM_Handle *qdmHandle)
{
 30095cc:	1101                	addi	sp,sp,-32
 30095ce:	ce06                	sw	ra,28(sp)
 30095d0:	cc22                	sw	s0,24(sp)
 30095d2:	1000                	addi	s0,sp,32
 30095d4:	fea42623          	sw	a0,-20(s0)
    if (qdmHandle->userCallBack.PositionCompareMatchCallBack != NULL) {
 30095d8:	fec42783          	lw	a5,-20(s0)
 30095dc:	5bbc                	lw	a5,112(a5)
 30095de:	c799                	beqz	a5,30095ec <PosCompareMatch+0x20>
        qdmHandle->userCallBack.PositionCompareMatchCallBack(qdmHandle);
 30095e0:	fec42783          	lw	a5,-20(s0)
 30095e4:	5bbc                	lw	a5,112(a5)
 30095e6:	fec42503          	lw	a0,-20(s0)
 30095ea:	9782                	jalr	a5
    }
}
 30095ec:	0001                	nop
 30095ee:	40f2                	lw	ra,28(sp)
 30095f0:	4462                	lw	s0,24(sp)
 30095f2:	6105                	addi	sp,sp,32
 30095f4:	8082                	ret

030095f6 <PosCompareReady>:
 * @brief Position compare ready interrupt.
 * @param qdmHandle Value of @ref QDM_Handle.
 * @retval None
 */
static void PosCompareReady(QDM_Handle *qdmHandle)
{
 30095f6:	1101                	addi	sp,sp,-32
 30095f8:	ce06                	sw	ra,28(sp)
 30095fa:	cc22                	sw	s0,24(sp)
 30095fc:	1000                	addi	s0,sp,32
 30095fe:	fea42623          	sw	a0,-20(s0)
    if (qdmHandle->userCallBack.PositionCompareReadyCallBack != NULL) {
 3009602:	fec42783          	lw	a5,-20(s0)
 3009606:	5bfc                	lw	a5,116(a5)
 3009608:	c799                	beqz	a5,3009616 <PosCompareReady+0x20>
        qdmHandle->userCallBack.PositionCompareReadyCallBack(qdmHandle);
 300960a:	fec42783          	lw	a5,-20(s0)
 300960e:	5bfc                	lw	a5,116(a5)
 3009610:	fec42503          	lw	a0,-20(s0)
 3009614:	9782                	jalr	a5
    }
}
 3009616:	0001                	nop
 3009618:	40f2                	lw	ra,28(sp)
 300961a:	4462                	lw	s0,24(sp)
 300961c:	6105                	addi	sp,sp,32
 300961e:	8082                	ret

03009620 <PosCounterErr>:
 * @brief Position counter error interrupt.
 * @param qdmHandle Value of @ref QDM_Handle.
 * @retval None
 */
static void PosCounterErr(QDM_Handle *qdmHandle)
{
 3009620:	1101                	addi	sp,sp,-32
 3009622:	ce06                	sw	ra,28(sp)
 3009624:	cc22                	sw	s0,24(sp)
 3009626:	1000                	addi	s0,sp,32
 3009628:	fea42623          	sw	a0,-20(s0)
    if (qdmHandle->userCallBack.PositionCounterErrorCallBack != NULL) {
 300962c:	fec42783          	lw	a5,-20(s0)
 3009630:	0887a783          	lw	a5,136(a5)
 3009634:	cb81                	beqz	a5,3009644 <PosCounterErr+0x24>
        qdmHandle->userCallBack.PositionCounterErrorCallBack(qdmHandle);
 3009636:	fec42783          	lw	a5,-20(s0)
 300963a:	0887a783          	lw	a5,136(a5)
 300963e:	fec42503          	lw	a0,-20(s0)
 3009642:	9782                	jalr	a5
    }
}
 3009644:	0001                	nop
 3009646:	40f2                	lw	ra,28(sp)
 3009648:	4462                	lw	s0,24(sp)
 300964a:	6105                	addi	sp,sp,32
 300964c:	8082                	ret

0300964e <PosCounterOverflow>:
 * @brief Position counter overflow interrupt.
 * @param qdmHandle Value of @ref QDM_Handle.
 * @retval None
 */
static void PosCounterOverflow(QDM_Handle *qdmHandle)
{
 300964e:	1101                	addi	sp,sp,-32
 3009650:	ce06                	sw	ra,28(sp)
 3009652:	cc22                	sw	s0,24(sp)
 3009654:	1000                	addi	s0,sp,32
 3009656:	fea42623          	sw	a0,-20(s0)
    if (qdmHandle->userCallBack.PositionCounterOverflowCallBack != NULL) {
 300965a:	fec42783          	lw	a5,-20(s0)
 300965e:	5fbc                	lw	a5,120(a5)
 3009660:	c799                	beqz	a5,300966e <PosCounterOverflow+0x20>
        qdmHandle->userCallBack.PositionCounterOverflowCallBack(qdmHandle);
 3009662:	fec42783          	lw	a5,-20(s0)
 3009666:	5fbc                	lw	a5,120(a5)
 3009668:	fec42503          	lw	a0,-20(s0)
 300966c:	9782                	jalr	a5
    }
}
 300966e:	0001                	nop
 3009670:	40f2                	lw	ra,28(sp)
 3009672:	4462                	lw	s0,24(sp)
 3009674:	6105                	addi	sp,sp,32
 3009676:	8082                	ret

03009678 <PosCounterUnderflow>:
 * @brief Position counter underflow interrupt.
 * @param qdmHandle Value of @ref QDM_Handle.
 * @retval None
 */
static void PosCounterUnderflow(QDM_Handle *qdmHandle)
{
 3009678:	1101                	addi	sp,sp,-32
 300967a:	ce06                	sw	ra,28(sp)
 300967c:	cc22                	sw	s0,24(sp)
 300967e:	1000                	addi	s0,sp,32
 3009680:	fea42623          	sw	a0,-20(s0)
    if (qdmHandle->userCallBack.PositionCounterUnderflowCallBack != NULL) {
 3009684:	fec42783          	lw	a5,-20(s0)
 3009688:	5ffc                	lw	a5,124(a5)
 300968a:	c799                	beqz	a5,3009698 <PosCounterUnderflow+0x20>
        qdmHandle->userCallBack.PositionCounterUnderflowCallBack(qdmHandle);
 300968c:	fec42783          	lw	a5,-20(s0)
 3009690:	5ffc                	lw	a5,124(a5)
 3009692:	fec42503          	lw	a0,-20(s0)
 3009696:	9782                	jalr	a5
    }
}
 3009698:	0001                	nop
 300969a:	40f2                	lw	ra,28(sp)
 300969c:	4462                	lw	s0,24(sp)
 300969e:	6105                	addi	sp,sp,32
 30096a0:	8082                	ret

030096a2 <OtherInterruptCallBack>:
 * @param qdmHandle Value of @ref QDM_Handle.
 * @param qinsts: Interrupt status register.
 * @retval None
 */
static void OtherInterruptCallBack(QDM_Handle *qdmHandle, QDM_QINTSTS_REG qinsts)
{
 30096a2:	1101                	addi	sp,sp,-32
 30096a4:	ce06                	sw	ra,28(sp)
 30096a6:	cc22                	sw	s0,24(sp)
 30096a8:	1000                	addi	s0,sp,32
 30096aa:	fea42623          	sw	a0,-20(s0)
 30096ae:	feb42423          	sw	a1,-24(s0)
    if (qinsts.BIT.qphs_err_int == BASE_CFG_SET) {
 30096b2:	fe842783          	lw	a5,-24(s0)
 30096b6:	8385                	srli	a5,a5,0x1
 30096b8:	8b85                	andi	a5,a5,1
 30096ba:	0ff7f713          	andi	a4,a5,255
 30096be:	4785                	li	a5,1
 30096c0:	00f71c63          	bne	a4,a5,30096d8 <OtherInterruptCallBack+0x36>
        /* Orthogonal phase error interrupt. */
        OrthoPhaseErr(qdmHandle);
 30096c4:	fec42503          	lw	a0,-20(s0)
 30096c8:	3dd9                	jal	ra,300959e <OrthoPhaseErr>
        qdmHandle->baseAddress->QINTRAW.BIT.qphs_err_raw = BASE_CFG_ENABLE;
 30096ca:	fec42783          	lw	a5,-20(s0)
 30096ce:	4398                	lw	a4,0(a5)
 30096d0:	4f5c                	lw	a5,28(a4)
 30096d2:	0027e793          	ori	a5,a5,2
 30096d6:	cf5c                	sw	a5,28(a4)
    }
    if (qinsts.BIT.pcnt_cpm_int == BASE_CFG_SET) {
 30096d8:	fe842783          	lw	a5,-24(s0)
 30096dc:	839d                	srli	a5,a5,0x7
 30096de:	8b85                	andi	a5,a5,1
 30096e0:	0ff7f713          	andi	a4,a5,255
 30096e4:	4785                	li	a5,1
 30096e6:	00f71c63          	bne	a4,a5,30096fe <OtherInterruptCallBack+0x5c>
        /* Position compare match interrupt. */
        PosCompareMatch(qdmHandle);
 30096ea:	fec42503          	lw	a0,-20(s0)
 30096ee:	3df9                	jal	ra,30095cc <PosCompareMatch>
        qdmHandle->baseAddress->QINTRAW.BIT.pcnt_cpm_raw = BASE_CFG_ENABLE;
 30096f0:	fec42783          	lw	a5,-20(s0)
 30096f4:	4398                	lw	a4,0(a5)
 30096f6:	4f5c                	lw	a5,28(a4)
 30096f8:	0807e793          	ori	a5,a5,128
 30096fc:	cf5c                	sw	a5,28(a4)
    }
    if (qinsts.BIT.pcnt_cpr_int == BASE_CFG_SET) {
 30096fe:	fe842783          	lw	a5,-24(s0)
 3009702:	8399                	srli	a5,a5,0x6
 3009704:	8b85                	andi	a5,a5,1
 3009706:	0ff7f713          	andi	a4,a5,255
 300970a:	4785                	li	a5,1
 300970c:	00f71c63          	bne	a4,a5,3009724 <OtherInterruptCallBack+0x82>
        /* Position compare ready interrupt. */
        PosCompareReady(qdmHandle);
 3009710:	fec42503          	lw	a0,-20(s0)
 3009714:	35cd                	jal	ra,30095f6 <PosCompareReady>
        qdmHandle->baseAddress->QINTRAW.BIT.pcnt_cpr_raw = BASE_CFG_ENABLE;
 3009716:	fec42783          	lw	a5,-20(s0)
 300971a:	4398                	lw	a4,0(a5)
 300971c:	4f5c                	lw	a5,28(a4)
 300971e:	0407e793          	ori	a5,a5,64
 3009722:	cf5c                	sw	a5,28(a4)
    }
    if (qinsts.BIT.pcnt_err_int == BASE_CFG_SET) {
 3009724:	fe842783          	lw	a5,-24(s0)
 3009728:	8b85                	andi	a5,a5,1
 300972a:	0ff7f713          	andi	a4,a5,255
 300972e:	4785                	li	a5,1
 3009730:	00f71c63          	bne	a4,a5,3009748 <OtherInterruptCallBack+0xa6>
        /* Position counter error interrupt. */
        PosCounterErr(qdmHandle);
 3009734:	fec42503          	lw	a0,-20(s0)
 3009738:	35e5                	jal	ra,3009620 <PosCounterErr>
        qdmHandle->baseAddress->QINTRAW.BIT.pcnt_err_raw = BASE_CFG_ENABLE;
 300973a:	fec42783          	lw	a5,-20(s0)
 300973e:	4398                	lw	a4,0(a5)
 3009740:	4f5c                	lw	a5,28(a4)
 3009742:	0017e793          	ori	a5,a5,1
 3009746:	cf5c                	sw	a5,28(a4)
    }
    if (qinsts.BIT.pcnt_ovf_int == BASE_CFG_SET) {
 3009748:	fe842783          	lw	a5,-24(s0)
 300974c:	8395                	srli	a5,a5,0x5
 300974e:	8b85                	andi	a5,a5,1
 3009750:	0ff7f713          	andi	a4,a5,255
 3009754:	4785                	li	a5,1
 3009756:	00f71c63          	bne	a4,a5,300976e <OtherInterruptCallBack+0xcc>
        /* Position counter overflow interrupt. */
        PosCounterOverflow(qdmHandle);
 300975a:	fec42503          	lw	a0,-20(s0)
 300975e:	3dc5                	jal	ra,300964e <PosCounterOverflow>
        qdmHandle->baseAddress->QINTRAW.BIT.pcnt_ovf_raw = BASE_CFG_ENABLE;
 3009760:	fec42783          	lw	a5,-20(s0)
 3009764:	4398                	lw	a4,0(a5)
 3009766:	4f5c                	lw	a5,28(a4)
 3009768:	0207e793          	ori	a5,a5,32
 300976c:	cf5c                	sw	a5,28(a4)
    }
    if (qinsts.BIT.pcnt_udf_int == BASE_CFG_SET) {
 300976e:	fe842783          	lw	a5,-24(s0)
 3009772:	8391                	srli	a5,a5,0x4
 3009774:	8b85                	andi	a5,a5,1
 3009776:	0ff7f713          	andi	a4,a5,255
 300977a:	4785                	li	a5,1
 300977c:	00f71c63          	bne	a4,a5,3009794 <OtherInterruptCallBack+0xf2>
        /* Position counter underflow interrupt. */
        PosCounterUnderflow(qdmHandle);
 3009780:	fec42503          	lw	a0,-20(s0)
 3009784:	3dd5                	jal	ra,3009678 <PosCounterUnderflow>
        qdmHandle->baseAddress->QINTRAW.BIT.pcnt_udf_raw = BASE_CFG_ENABLE;
 3009786:	fec42783          	lw	a5,-20(s0)
 300978a:	4398                	lw	a4,0(a5)
 300978c:	4f5c                	lw	a5,28(a4)
 300978e:	0107e793          	ori	a5,a5,16
 3009792:	cf5c                	sw	a5,28(a4)
    }
}
 3009794:	0001                	nop
 3009796:	40f2                	lw	ra,28(sp)
 3009798:	4462                	lw	s0,24(sp)
 300979a:	6105                	addi	sp,sp,32
 300979c:	8082                	ret

0300979e <CalculateSpeed>:
  * @brief M-method speed calculation.
  * @param qdmHandle Value of @ref QDM_Handle.
  * @retval None
  */
static void CalculateSpeed(QDM_Handle *qdmHandle)
{
 300979e:	7179                	addi	sp,sp,-48
 30097a0:	d606                	sw	ra,44(sp)
 30097a2:	d422                	sw	s0,40(sp)
 30097a4:	d226                	sw	s1,36(sp)
 30097a6:	1800                	addi	s0,sp,48
 30097a8:	fca42e23          	sw	a0,-36(s0)
    unsigned int deltaValue, tmp, intFlag;
    /* Last QPOSLOCK value */
    static unsigned int lastPoslockValue = 0;
    int speed;
    deltaValue = qdmHandle->baseAddress->QPOSLOCK;
 30097ac:	fdc42783          	lw	a5,-36(s0)
 30097b0:	439c                	lw	a5,0(a5)
 30097b2:	5fdc                	lw	a5,60(a5)
 30097b4:	fef42623          	sw	a5,-20(s0)
    /* The position count reset mode is overflow reset. */
    intFlag = (qdmHandle->baseAddress->QINTSTS.reg & QDM_INT_MASK);
 30097b8:	fdc42783          	lw	a5,-36(s0)
 30097bc:	439c                	lw	a5,0(a5)
 30097be:	4f9c                	lw	a5,24(a5)
 30097c0:	0387f793          	andi	a5,a5,56
 30097c4:	fef42423          	sw	a5,-24(s0)
    if ((qdmHandle->pcntRstMode == QDM_PCNT_RST_OVF) && (intFlag == 0)) {
 30097c8:	fdc42783          	lw	a5,-36(s0)
 30097cc:	5b98                	lw	a4,48(a5)
 30097ce:	4785                	li	a5,1
 30097d0:	00f71f63          	bne	a4,a5,30097ee <CalculateSpeed+0x50>
 30097d4:	fe842783          	lw	a5,-24(s0)
 30097d8:	eb99                	bnez	a5,30097ee <CalculateSpeed+0x50>
        deltaValue = qdmHandle->baseAddress->QPOSLOCK - lastPoslockValue;
 30097da:	fdc42783          	lw	a5,-36(s0)
 30097de:	439c                	lw	a5,0(a5)
 30097e0:	5fd8                	lw	a4,60(a5)
 30097e2:	eac1a783          	lw	a5,-340(gp) # 40005a8 <lastPoslockValue.3568>
 30097e6:	40f707b3          	sub	a5,a4,a5
 30097ea:	fef42623          	sw	a5,-20(s0)
    }
    lastPoslockValue = qdmHandle->baseAddress->QPOSLOCK;
 30097ee:	fdc42783          	lw	a5,-36(s0)
 30097f2:	439c                	lw	a5,0(a5)
 30097f4:	5fd8                	lw	a4,60(a5)
 30097f6:	eae1a623          	sw	a4,-340(gp) # 40005a8 <lastPoslockValue.3568>
    if (qdmHandle->baseAddress->QDMSTS.BIT.qdir_sts == 1) { /* forward */
 30097fa:	fdc42783          	lw	a5,-36(s0)
 30097fe:	439c                	lw	a5,0(a5)
 3009800:	53dc                	lw	a5,36(a5)
 3009802:	8399                	srli	a5,a5,0x6
 3009804:	8b85                	andi	a5,a5,1
 3009806:	0ff7f713          	andi	a4,a5,255
 300980a:	4785                	li	a5,1
 300980c:	04f71d63          	bne	a4,a5,3009866 <CalculateSpeed+0xc8>
        tmp = deltaValue >> qdmHandle->baseAddress->QCTRL.BIT.qdu_xclk;
 3009810:	fdc42783          	lw	a5,-36(s0)
 3009814:	439c                	lw	a5,0(a5)
 3009816:	479c                	lw	a5,8(a5)
 3009818:	83b1                	srli	a5,a5,0xc
 300981a:	8b8d                	andi	a5,a5,3
 300981c:	9f81                	uxtb	a5
 300981e:	873e                	mv	a4,a5
 3009820:	fec42783          	lw	a5,-20(s0)
 3009824:	00e7d7b3          	srl	a5,a5,a4
 3009828:	fef42223          	sw	a5,-28(s0)
        speed = ((tmp * SECONDS_PER_MINUTES) / qdmHandle->motorLineNum) \
 300982c:	fe442703          	lw	a4,-28(s0)
 3009830:	03c00793          	li	a5,60
 3009834:	02f707b3          	mul	a5,a4,a5
 3009838:	fdc42703          	lw	a4,-36(s0)
 300983c:	4f38                	lw	a4,88(a4)
 300983e:	02e7d4b3          	divu	s1,a5,a4
                * (BASE_FUNC_GetCpuFreqHz() / qdmHandle->period);
 3009842:	d26f90ef          	jal	ra,3002d68 <BASE_FUNC_GetCpuFreqHz>
 3009846:	872a                	mv	a4,a0
 3009848:	fdc42783          	lw	a5,-36(s0)
 300984c:	4bbc                	lw	a5,80(a5)
 300984e:	02f757b3          	divu	a5,a4,a5
 3009852:	02f487b3          	mul	a5,s1,a5
        speed = ((tmp * SECONDS_PER_MINUTES) / qdmHandle->motorLineNum) \
 3009856:	fef42023          	sw	a5,-32(s0)
        qdmHandle->speedRpm = speed;
 300985a:	fdc42783          	lw	a5,-36(s0)
 300985e:	fe042703          	lw	a4,-32(s0)
 3009862:	cff8                	sw	a4,92(a5)
        tmp = (qdmHandle->posMax - deltaValue) >> qdmHandle->baseAddress->QCTRL.BIT.qdu_xclk;
        speed = ((tmp * SECONDS_PER_MINUTES) / qdmHandle->motorLineNum) \
                * (BASE_FUNC_GetCpuFreqHz() / qdmHandle->period);
        qdmHandle->speedRpm = -speed;
    }
}
 3009864:	a08d                	j	30098c6 <CalculateSpeed+0x128>
        tmp = (qdmHandle->posMax - deltaValue) >> qdmHandle->baseAddress->QCTRL.BIT.qdu_xclk;
 3009866:	fdc42783          	lw	a5,-36(s0)
 300986a:	47b8                	lw	a4,72(a5)
 300986c:	fec42783          	lw	a5,-20(s0)
 3009870:	40f707b3          	sub	a5,a4,a5
 3009874:	fdc42703          	lw	a4,-36(s0)
 3009878:	4318                	lw	a4,0(a4)
 300987a:	4718                	lw	a4,8(a4)
 300987c:	8331                	srli	a4,a4,0xc
 300987e:	8b0d                	andi	a4,a4,3
 3009880:	9f01                	uxtb	a4
 3009882:	00e7d7b3          	srl	a5,a5,a4
 3009886:	fef42223          	sw	a5,-28(s0)
        speed = ((tmp * SECONDS_PER_MINUTES) / qdmHandle->motorLineNum) \
 300988a:	fe442703          	lw	a4,-28(s0)
 300988e:	03c00793          	li	a5,60
 3009892:	02f707b3          	mul	a5,a4,a5
 3009896:	fdc42703          	lw	a4,-36(s0)
 300989a:	4f38                	lw	a4,88(a4)
 300989c:	02e7d4b3          	divu	s1,a5,a4
                * (BASE_FUNC_GetCpuFreqHz() / qdmHandle->period);
 30098a0:	cc8f90ef          	jal	ra,3002d68 <BASE_FUNC_GetCpuFreqHz>
 30098a4:	872a                	mv	a4,a0
 30098a6:	fdc42783          	lw	a5,-36(s0)
 30098aa:	4bbc                	lw	a5,80(a5)
 30098ac:	02f757b3          	divu	a5,a4,a5
 30098b0:	02f487b3          	mul	a5,s1,a5
        speed = ((tmp * SECONDS_PER_MINUTES) / qdmHandle->motorLineNum) \
 30098b4:	fef42023          	sw	a5,-32(s0)
        qdmHandle->speedRpm = -speed;
 30098b8:	fe042783          	lw	a5,-32(s0)
 30098bc:	40f00733          	neg	a4,a5
 30098c0:	fdc42783          	lw	a5,-36(s0)
 30098c4:	cff8                	sw	a4,92(a5)
}
 30098c6:	0001                	nop
 30098c8:	50b2                	lw	ra,44(sp)
 30098ca:	5422                	lw	s0,40(sp)
 30098cc:	5492                	lw	s1,36(sp)
 30098ce:	6145                	addi	sp,sp,48
 30098d0:	8082                	ret

030098d2 <HAL_QDM_IrqHandler>:
  * @brief IRQ Handler
  * @param handle: QDM handle.
  * @retval None
  */
void HAL_QDM_IrqHandler(void *handle)
{
 30098d2:	7179                	addi	sp,sp,-48
 30098d4:	d606                	sw	ra,44(sp)
 30098d6:	d422                	sw	s0,40(sp)
 30098d8:	1800                	addi	s0,sp,48
 30098da:	fca42e23          	sw	a0,-36(s0)
    QDM_ASSERT_PARAM(handle != NULL);
 30098de:	fdc42783          	lw	a5,-36(s0)
 30098e2:	eb89                	bnez	a5,30098f4 <HAL_QDM_IrqHandler+0x22>
 30098e4:	13600593          	li	a1,310
 30098e8:	030117b7          	lui	a5,0x3011
 30098ec:	a0478513          	addi	a0,a5,-1532 # 3010a04 <g_crgIpMatch+0x4f4>
 30098f0:	2a0d                	jal	ra,3009a22 <AssertErrorLog.trans.7>
 30098f2:	a001                	j	30098f2 <HAL_QDM_IrqHandler+0x20>
    QDM_Handle *qdmHandle = (QDM_Handle *)handle;
 30098f4:	fdc42783          	lw	a5,-36(s0)
 30098f8:	fef42623          	sw	a5,-20(s0)
    QDM_ASSERT_PARAM(IsQDMInstance(qdmHandle->baseAddress));
 30098fc:	fec42783          	lw	a5,-20(s0)
 3009900:	4398                	lw	a4,0(a5)
 3009902:	14c007b7          	lui	a5,0x14c00
 3009906:	02f70163          	beq	a4,a5,3009928 <HAL_QDM_IrqHandler+0x56>
 300990a:	fec42783          	lw	a5,-20(s0)
 300990e:	4398                	lw	a4,0(a5)
 3009910:	14c017b7          	lui	a5,0x14c01
 3009914:	00f70a63          	beq	a4,a5,3009928 <HAL_QDM_IrqHandler+0x56>
 3009918:	13800593          	li	a1,312
 300991c:	030117b7          	lui	a5,0x3011
 3009920:	a0478513          	addi	a0,a5,-1532 # 3010a04 <g_crgIpMatch+0x4f4>
 3009924:	28fd                	jal	ra,3009a22 <AssertErrorLog.trans.7>
 3009926:	a001                	j	3009926 <HAL_QDM_IrqHandler+0x54>


    if (qdmHandle->motorLineNum == 0 || qdmHandle->period == 0) {
 3009928:	fec42783          	lw	a5,-20(s0)
 300992c:	4fbc                	lw	a5,88(a5)
 300992e:	c789                	beqz	a5,3009938 <HAL_QDM_IrqHandler+0x66>
 3009930:	fec42783          	lw	a5,-20(s0)
 3009934:	4bbc                	lw	a5,80(a5)
 3009936:	e385                	bnez	a5,3009956 <HAL_QDM_IrqHandler+0x84>
        /* clear interrupt */
        qdmHandle->baseAddress->QINTRAW.BIT.sped_lst_raw = BASE_CFG_ENABLE;
 3009938:	fec42783          	lw	a5,-20(s0)
 300993c:	4398                	lw	a4,0(a5)
 300993e:	4f5c                	lw	a5,28(a4)
 3009940:	0047e793          	ori	a5,a5,4
 3009944:	cf5c                	sw	a5,28(a4)
        qdmHandle->baseAddress->QINTRAW.BIT.utmr_prd_raw = BASE_CFG_ENABLE;
 3009946:	fec42783          	lw	a5,-20(s0)
 300994a:	4398                	lw	a4,0(a5)
 300994c:	4f5c                	lw	a5,28(a4)
 300994e:	2007e793          	ori	a5,a5,512
 3009952:	cf5c                	sw	a5,28(a4)
        return;
 3009954:	a0d9                	j	3009a1a <HAL_QDM_IrqHandler+0x148>
    }

    QDM_QINTSTS_REG qinsts = qdmHandle->baseAddress->QINTSTS;
 3009956:	fec42783          	lw	a5,-20(s0)
 300995a:	439c                	lw	a5,0(a5)
 300995c:	4f9c                	lw	a5,24(a5)
 300995e:	fef42423          	sw	a5,-24(s0)
    if (qinsts.BIT.utmr_prd_int == BASE_CFG_SET) {
 3009962:	fe842783          	lw	a5,-24(s0)
 3009966:	83a5                	srli	a5,a5,0x9
 3009968:	8b85                	andi	a5,a5,1
 300996a:	0ff7f713          	andi	a4,a5,255
 300996e:	4785                	li	a5,1
 3009970:	02f71663          	bne	a4,a5,300999c <HAL_QDM_IrqHandler+0xca>
        //int temp = qdmHandle->baseAddress->QPOSLOCK;
        //DBG_PRINTF("QPOSLOCK num: %d\r\n", temp);
        //DBG_PRINTF("temp num: %d\r\n", qdmHandle->baseAddress->QUPRD);
        CalculateSpeed(qdmHandle);
 3009974:	fec42503          	lw	a0,-20(s0)
 3009978:	351d                	jal	ra,300979e <CalculateSpeed>
        /* PTU timer cycle triggle interrupt */
        if (qdmHandle->userCallBack.PtuCycleTrgCallback != NULL) {
 300997a:	fec42783          	lw	a5,-20(s0)
 300997e:	53fc                	lw	a5,100(a5)
 3009980:	c799                	beqz	a5,300998e <HAL_QDM_IrqHandler+0xbc>
            qdmHandle->userCallBack.PtuCycleTrgCallback(qdmHandle);
 3009982:	fec42783          	lw	a5,-20(s0)
 3009986:	53fc                	lw	a5,100(a5)
 3009988:	fec42503          	lw	a0,-20(s0)
 300998c:	9782                	jalr	a5
        }
        qdmHandle->baseAddress->QINTRAW.BIT.utmr_prd_raw = BASE_CFG_ENABLE;
 300998e:	fec42783          	lw	a5,-20(s0)
 3009992:	4398                	lw	a4,0(a5)
 3009994:	4f5c                	lw	a5,28(a4)
 3009996:	2007e793          	ori	a5,a5,512
 300999a:	cf5c                	sw	a5,28(a4)
    }
    if (qinsts.BIT.sped_lst_int == BASE_CFG_SET) {
 300999c:	fe842783          	lw	a5,-24(s0)
 30099a0:	8389                	srli	a5,a5,0x2
 30099a2:	8b85                	andi	a5,a5,1
 30099a4:	0ff7f713          	andi	a4,a5,255
 30099a8:	4785                	li	a5,1
 30099aa:	00f71c63          	bne	a4,a5,30099c2 <HAL_QDM_IrqHandler+0xf0>
        /* speed lose interrupt */
        SpeedLose(qdmHandle);
 30099ae:	fec42503          	lw	a0,-20(s0)
 30099b2:	36ad                	jal	ra,300951c <SpeedLose>
        qdmHandle->baseAddress->QINTRAW.BIT.sped_lst_raw = BASE_CFG_ENABLE;
 30099b4:	fec42783          	lw	a5,-20(s0)
 30099b8:	4398                	lw	a4,0(a5)
 30099ba:	4f5c                	lw	a5,28(a4)
 30099bc:	0047e793          	ori	a5,a5,4
 30099c0:	cf5c                	sw	a5,28(a4)
    }
    if (qinsts.BIT.indx_lck_int == BASE_CFG_SET) {
 30099c2:	fe842783          	lw	a5,-24(s0)
 30099c6:	83a1                	srli	a5,a5,0x8
 30099c8:	8b85                	andi	a5,a5,1
 30099ca:	0ff7f713          	andi	a4,a5,255
 30099ce:	4785                	li	a5,1
 30099d0:	00f71c63          	bne	a4,a5,30099e8 <HAL_QDM_IrqHandler+0x116>
        /* QDM Z index lock interrupt. */
        ZIndexLock(qdmHandle);
 30099d4:	fec42503          	lw	a0,-20(s0)
 30099d8:	36bd                	jal	ra,3009546 <ZIndexLock>
        qdmHandle->baseAddress->QINTRAW.BIT.indx_lck_raw = BASE_CFG_ENABLE;
 30099da:	fec42783          	lw	a5,-20(s0)
 30099de:	4398                	lw	a4,0(a5)
 30099e0:	4f5c                	lw	a5,28(a4)
 30099e2:	1007e793          	ori	a5,a5,256
 30099e6:	cf5c                	sw	a5,28(a4)
    }
    if (qinsts.BIT.qdir_chg_int == BASE_CFG_SET) {
 30099e8:	fe842783          	lw	a5,-24(s0)
 30099ec:	838d                	srli	a5,a5,0x3
 30099ee:	8b85                	andi	a5,a5,1
 30099f0:	0ff7f713          	andi	a4,a5,255
 30099f4:	4785                	li	a5,1
 30099f6:	00f71c63          	bne	a4,a5,3009a0e <HAL_QDM_IrqHandler+0x13c>
        /* Orthogonal direction change interrupt. */
        OrthoDirChange(qdmHandle);
 30099fa:	fec42503          	lw	a0,-20(s0)
 30099fe:	3e8d                	jal	ra,3009570 <OrthoDirChange>
        qdmHandle->baseAddress->QINTRAW.BIT.qdir_chg_raw = BASE_CFG_ENABLE;
 3009a00:	fec42783          	lw	a5,-20(s0)
 3009a04:	4398                	lw	a4,0(a5)
 3009a06:	4f5c                	lw	a5,28(a4)
 3009a08:	0087e793          	ori	a5,a5,8
 3009a0c:	cf5c                	sw	a5,28(a4)
    }
    OtherInterruptCallBack(qdmHandle, qinsts);
 3009a0e:	fe842583          	lw	a1,-24(s0)
 3009a12:	fec42503          	lw	a0,-20(s0)
 3009a16:	3171                	jal	ra,30096a2 <OtherInterruptCallBack>
    return;
 3009a18:	0001                	nop
}
 3009a1a:	50b2                	lw	ra,44(sp)
 3009a1c:	5422                	lw	s0,40(sp)
 3009a1e:	6145                	addi	sp,sp,48
 3009a20:	8082                	ret

03009a22 <AssertErrorLog.trans.7>:
 3009a22:	b1cf906f          	j	3002d3e <AssertErrorLog>

03009a26 <SelectInterruptCallback>:
 * @param typeId: Interrupt type.
 * @param pCallBack: Interrupt callback function.
 * @retval None
 */
static void SelectInterruptCallback(QDM_Handle *qdmHandle, QDM_CallbackFuncType typeID, QDM_CallbackType pCallback)
{
 3009a26:	1101                	addi	sp,sp,-32
 3009a28:	ce22                	sw	s0,28(sp)
 3009a2a:	1000                	addi	s0,sp,32
 3009a2c:	fea42623          	sw	a0,-20(s0)
 3009a30:	feb42423          	sw	a1,-24(s0)
 3009a34:	fec42223          	sw	a2,-28(s0)
    switch (typeID) {
 3009a38:	fe842703          	lw	a4,-24(s0)
 3009a3c:	47a5                	li	a5,9
 3009a3e:	08e7ec63          	bltu	a5,a4,3009ad6 <SelectInterruptCallback+0xb0>
 3009a42:	fe842783          	lw	a5,-24(s0)
 3009a46:	00279713          	slli	a4,a5,0x2
 3009a4a:	030117b7          	lui	a5,0x3011
 3009a4e:	a2078793          	addi	a5,a5,-1504 # 3010a20 <g_crgIpMatch+0x510>
 3009a52:	97ba                	add	a5,a5,a4
 3009a54:	439c                	lw	a5,0(a5)
 3009a56:	8782                	jr	a5
        case QDM_TSU_CYCLE:
            /* PTU timer cycle triggle interrupt. */
            qdmHandle->userCallBack.PtuCycleTrgCallback = pCallback;
 3009a58:	fec42783          	lw	a5,-20(s0)
 3009a5c:	fe442703          	lw	a4,-28(s0)
 3009a60:	d3f8                	sw	a4,100(a5)
            break;
 3009a62:	a89d                	j	3009ad8 <SelectInterruptCallback+0xb2>
        case QDM_SPEED_LOSE:
            /* Speed lose interrupt. */
            qdmHandle->userCallBack.SpeedLoseCallback = pCallback;
 3009a64:	fec42783          	lw	a5,-20(s0)
 3009a68:	fe442703          	lw	a4,-28(s0)
 3009a6c:	d7b8                	sw	a4,104(a5)
            break;
 3009a6e:	a0ad                	j	3009ad8 <SelectInterruptCallback+0xb2>
        case QDM_INDEX_LOCKED:
            /* QDM Z index lock interrupt. */
            qdmHandle->userCallBack.ZIndexLockedCallBack = pCallback;
 3009a70:	fec42783          	lw	a5,-20(s0)
 3009a74:	fe442703          	lw	a4,-28(s0)
 3009a78:	d7f8                	sw	a4,108(a5)
            break;
 3009a7a:	a8b9                	j	3009ad8 <SelectInterruptCallback+0xb2>
        case QDM_DIR_CHANGE:
            /* Orthogonal direction change interrupt. */
            qdmHandle->userCallBack.OrthogonalDirectionChangeCallBack = pCallback;
 3009a7c:	fec42783          	lw	a5,-20(s0)
 3009a80:	fe442703          	lw	a4,-28(s0)
 3009a84:	08e7a023          	sw	a4,128(a5)
            break;
 3009a88:	a881                	j	3009ad8 <SelectInterruptCallback+0xb2>
        case QDM_PHASE_ERROR:
            /* Orthogonal phase error interrupt. */
            qdmHandle->userCallBack.OrthogonalPhaseErrorCallBack = pCallback;
 3009a8a:	fec42783          	lw	a5,-20(s0)
 3009a8e:	fe442703          	lw	a4,-28(s0)
 3009a92:	08e7a223          	sw	a4,132(a5)
            break;
 3009a96:	a089                	j	3009ad8 <SelectInterruptCallback+0xb2>
        case QDM_POS_MATCH:
            /* Position compare match interrupt. */
            qdmHandle->userCallBack.PositionCompareMatchCallBack = pCallback;
 3009a98:	fec42783          	lw	a5,-20(s0)
 3009a9c:	fe442703          	lw	a4,-28(s0)
 3009aa0:	dbb8                	sw	a4,112(a5)
            break;
 3009aa2:	a81d                	j	3009ad8 <SelectInterruptCallback+0xb2>
        case QDM_POS_READY:
            /* Position compare ready interrupt. */
            qdmHandle->userCallBack.PositionCompareReadyCallBack = pCallback;
 3009aa4:	fec42783          	lw	a5,-20(s0)
 3009aa8:	fe442703          	lw	a4,-28(s0)
 3009aac:	dbf8                	sw	a4,116(a5)
            break;
 3009aae:	a02d                	j	3009ad8 <SelectInterruptCallback+0xb2>
        case QDM_POS_CNT_ERROR:
            /* Position counter error interrupt. */
            qdmHandle->userCallBack.PositionCounterErrorCallBack = pCallback;
 3009ab0:	fec42783          	lw	a5,-20(s0)
 3009ab4:	fe442703          	lw	a4,-28(s0)
 3009ab8:	08e7a423          	sw	a4,136(a5)
            break;
 3009abc:	a831                	j	3009ad8 <SelectInterruptCallback+0xb2>
        case QDM_POS_CNT_OVERFLOW:
            /* Position counter overflow interrupt. */
            qdmHandle->userCallBack.PositionCounterOverflowCallBack = pCallback;
 3009abe:	fec42783          	lw	a5,-20(s0)
 3009ac2:	fe442703          	lw	a4,-28(s0)
 3009ac6:	dfb8                	sw	a4,120(a5)
            break;
 3009ac8:	a801                	j	3009ad8 <SelectInterruptCallback+0xb2>
        case QDM_POS_CNT_UNDERFLOW:
            /* Position counter underflow interrupt. */
            qdmHandle->userCallBack.PositionCounterUnderflowCallBack = pCallback;
 3009aca:	fec42783          	lw	a5,-20(s0)
 3009ace:	fe442703          	lw	a4,-28(s0)
 3009ad2:	dff8                	sw	a4,124(a5)
            break;
 3009ad4:	a011                	j	3009ad8 <SelectInterruptCallback+0xb2>
        default:
            return;
 3009ad6:	0001                	nop
    }
}
 3009ad8:	4472                	lw	s0,28(sp)
 3009ada:	6105                	addi	sp,sp,32
 3009adc:	8082                	ret

03009ade <HAL_QDM_RegisterCallback>:
  * @param typeID: callback function type ID.
  * @param pCallback: pointer of callback function.
  * @retval None
  */
void HAL_QDM_RegisterCallback(QDM_Handle *qdmHandle, QDM_CallbackFuncType typeID, QDM_CallbackType pCallback)
{
 3009ade:	1101                	addi	sp,sp,-32
 3009ae0:	ce06                	sw	ra,28(sp)
 3009ae2:	cc22                	sw	s0,24(sp)
 3009ae4:	1000                	addi	s0,sp,32
 3009ae6:	fea42623          	sw	a0,-20(s0)
 3009aea:	feb42423          	sw	a1,-24(s0)
 3009aee:	fec42223          	sw	a2,-28(s0)
    QDM_ASSERT_PARAM(qdmHandle != NULL);
 3009af2:	fec42783          	lw	a5,-20(s0)
 3009af6:	eb89                	bnez	a5,3009b08 <HAL_QDM_RegisterCallback+0x2a>
 3009af8:	1a100593          	li	a1,417
 3009afc:	030117b7          	lui	a5,0x3011
 3009b00:	a0478513          	addi	a0,a5,-1532 # 3010a04 <g_crgIpMatch+0x4f4>
 3009b04:	3f39                	jal	ra,3009a22 <AssertErrorLog.trans.7>
 3009b06:	a001                	j	3009b06 <HAL_QDM_RegisterCallback+0x28>
    QDM_ASSERT_PARAM(pCallback != NULL);
 3009b08:	fe442783          	lw	a5,-28(s0)
 3009b0c:	eb89                	bnez	a5,3009b1e <HAL_QDM_RegisterCallback+0x40>
 3009b0e:	1a200593          	li	a1,418
 3009b12:	030117b7          	lui	a5,0x3011
 3009b16:	a0478513          	addi	a0,a5,-1532 # 3010a04 <g_crgIpMatch+0x4f4>
 3009b1a:	3721                	jal	ra,3009a22 <AssertErrorLog.trans.7>
 3009b1c:	a001                	j	3009b1c <HAL_QDM_RegisterCallback+0x3e>
    QDM_ASSERT_PARAM(IsQDMInstance(qdmHandle->baseAddress));
 3009b1e:	fec42783          	lw	a5,-20(s0)
 3009b22:	4398                	lw	a4,0(a5)
 3009b24:	14c007b7          	lui	a5,0x14c00
 3009b28:	02f70163          	beq	a4,a5,3009b4a <HAL_QDM_RegisterCallback+0x6c>
 3009b2c:	fec42783          	lw	a5,-20(s0)
 3009b30:	4398                	lw	a4,0(a5)
 3009b32:	14c017b7          	lui	a5,0x14c01
 3009b36:	00f70a63          	beq	a4,a5,3009b4a <HAL_QDM_RegisterCallback+0x6c>
 3009b3a:	1a300593          	li	a1,419
 3009b3e:	030117b7          	lui	a5,0x3011
 3009b42:	a0478513          	addi	a0,a5,-1532 # 3010a04 <g_crgIpMatch+0x4f4>
 3009b46:	3df1                	jal	ra,3009a22 <AssertErrorLog.trans.7>
 3009b48:	a001                	j	3009b48 <HAL_QDM_RegisterCallback+0x6a>
    /* Select the interrupt callback function by the switch-case. */
    SelectInterruptCallback(qdmHandle, typeID, pCallback);
 3009b4a:	fe442603          	lw	a2,-28(s0)
 3009b4e:	fe842583          	lw	a1,-24(s0)
 3009b52:	fec42503          	lw	a0,-20(s0)
 3009b56:	3dc1                	jal	ra,3009a26 <SelectInterruptCallback>
}
 3009b58:	0001                	nop
 3009b5a:	40f2                	lw	ra,28(sp)
 3009b5c:	4462                	lw	s0,24(sp)
 3009b5e:	6105                	addi	sp,sp,32
 3009b60:	8082                	ret

03009b62 <HAL_QDM_Init>:
  * @brief  QDM initialization functions
  * @param qdmHandle Value of @ref QDM_Handle.
  * @retval BASE_StatusType:BASE_STATUS_OK, BASE_STATUS_ERROR, BASE_STATUS_BUSY, BASE_STATUS_TIMEOUT
  */
BASE_StatusType HAL_QDM_Init(QDM_Handle *qdmHandle)
{
 3009b62:	1101                	addi	sp,sp,-32
 3009b64:	ce06                	sw	ra,28(sp)
 3009b66:	cc22                	sw	s0,24(sp)
 3009b68:	1000                	addi	s0,sp,32
 3009b6a:	fea42623          	sw	a0,-20(s0)
    QDM_ASSERT_PARAM(qdmHandle != NULL);
 3009b6e:	fec42783          	lw	a5,-20(s0)
 3009b72:	eb89                	bnez	a5,3009b84 <HAL_QDM_Init+0x22>
 3009b74:	1af00593          	li	a1,431
 3009b78:	030117b7          	lui	a5,0x3011
 3009b7c:	a0478513          	addi	a0,a5,-1532 # 3010a04 <g_crgIpMatch+0x4f4>
 3009b80:	354d                	jal	ra,3009a22 <AssertErrorLog.trans.7>
 3009b82:	a001                	j	3009b82 <HAL_QDM_Init+0x20>
    QDM_ASSERT_PARAM(IsQDMInstance(qdmHandle->baseAddress));
 3009b84:	fec42783          	lw	a5,-20(s0)
 3009b88:	4398                	lw	a4,0(a5)
 3009b8a:	14c007b7          	lui	a5,0x14c00
 3009b8e:	02f70163          	beq	a4,a5,3009bb0 <HAL_QDM_Init+0x4e>
 3009b92:	fec42783          	lw	a5,-20(s0)
 3009b96:	4398                	lw	a4,0(a5)
 3009b98:	14c017b7          	lui	a5,0x14c01
 3009b9c:	00f70a63          	beq	a4,a5,3009bb0 <HAL_QDM_Init+0x4e>
 3009ba0:	1b000593          	li	a1,432
 3009ba4:	030117b7          	lui	a5,0x3011
 3009ba8:	a0478513          	addi	a0,a5,-1532 # 3010a04 <g_crgIpMatch+0x4f4>
 3009bac:	3d9d                	jal	ra,3009a22 <AssertErrorLog.trans.7>
 3009bae:	a001                	j	3009bae <HAL_QDM_Init+0x4c>
    QDM_PARAM_CHECK_WITH_RET(IsEmuMode(qdmHandle->emuMode), BASE_STATUS_ERROR);
 3009bb0:	fec42783          	lw	a5,-20(s0)
 3009bb4:	43dc                	lw	a5,4(a5)
 3009bb6:	853e                	mv	a0,a5
 3009bb8:	ff7fe0ef          	jal	ra,3008bae <IsEmuMode>
 3009bbc:	87aa                	mv	a5,a0
 3009bbe:	0017c793          	xori	a5,a5,1
 3009bc2:	9f81                	uxtb	a5
 3009bc4:	cb91                	beqz	a5,3009bd8 <HAL_QDM_Init+0x76>
 3009bc6:	1b100593          	li	a1,433
 3009bca:	030117b7          	lui	a5,0x3011
 3009bce:	a0478513          	addi	a0,a5,-1532 # 3010a04 <g_crgIpMatch+0x4f4>
 3009bd2:	3d81                	jal	ra,3009a22 <AssertErrorLog.trans.7>
 3009bd4:	4785                	li	a5,1
 3009bd6:	a85d                	j	3009c8c <HAL_QDM_Init+0x12a>
    QDM_PARAM_CHECK_WITH_RET(IsLockMode(qdmHandle->lock_mode), BASE_STATUS_ERROR);
 3009bd8:	fec42783          	lw	a5,-20(s0)
 3009bdc:	53bc                	lw	a5,96(a5)
 3009bde:	853e                	mv	a0,a5
 3009be0:	800ff0ef          	jal	ra,3008be0 <IsLockMode>
 3009be4:	87aa                	mv	a5,a0
 3009be6:	0017c793          	xori	a5,a5,1
 3009bea:	9f81                	uxtb	a5
 3009bec:	cb91                	beqz	a5,3009c00 <HAL_QDM_Init+0x9e>
 3009bee:	1b200593          	li	a1,434
 3009bf2:	030117b7          	lui	a5,0x3011
 3009bf6:	a0478513          	addi	a0,a5,-1532 # 3010a04 <g_crgIpMatch+0x4f4>
 3009bfa:	3525                	jal	ra,3009a22 <AssertErrorLog.trans.7>
 3009bfc:	4785                	li	a5,1
 3009bfe:	a079                	j	3009c8c <HAL_QDM_Init+0x12a>

    qdmHandle->baseAddress->QEMUMODE.BIT.emu_mode = qdmHandle->emuMode;
 3009c00:	fec42783          	lw	a5,-20(s0)
 3009c04:	43d4                	lw	a3,4(a5)
 3009c06:	fec42783          	lw	a5,-20(s0)
 3009c0a:	4398                	lw	a4,0(a5)
 3009c0c:	87b6                	mv	a5,a3
 3009c0e:	8b8d                	andi	a5,a5,3
 3009c10:	0ff7f693          	andi	a3,a5,255
 3009c14:	435c                	lw	a5,4(a4)
 3009c16:	8a8d                	andi	a3,a3,3
 3009c18:	9bf1                	andi	a5,a5,-4
 3009c1a:	8fd5                	or	a5,a5,a3
 3009c1c:	c35c                	sw	a5,4(a4)
    /* Set Z index locked mode. */
    if ((qdmHandle->interruptEn & QDM_INT_INDEX_EVNT_LATCH) == QDM_INT_INDEX_EVNT_LATCH) {
 3009c1e:	fec42783          	lw	a5,-20(s0)
 3009c22:	4bfc                	lw	a5,84(a5)
 3009c24:	1007f793          	andi	a5,a5,256
 3009c28:	cb99                	beqz	a5,3009c3e <HAL_QDM_Init+0xdc>
        DCL_QDM_SetIndexLockMode(qdmHandle->baseAddress, qdmHandle->lock_mode);
 3009c2a:	fec42783          	lw	a5,-20(s0)
 3009c2e:	4398                	lw	a4,0(a5)
 3009c30:	fec42783          	lw	a5,-20(s0)
 3009c34:	53bc                	lw	a5,96(a5)
 3009c36:	85be                	mv	a1,a5
 3009c38:	853a                	mv	a0,a4
 3009c3a:	b5cff0ef          	jal	ra,3008f96 <DCL_QDM_SetIndexLockMode>
    }
    /* Set input filter width. */
    DCL_QDM_SetInputFilterWidth(qdmHandle->baseAddress, qdmHandle->inputFilter.qdmAFilterLevel, \
 3009c3e:	fec42783          	lw	a5,-20(s0)
 3009c42:	4398                	lw	a4,0(a5)
 3009c44:	fec42783          	lw	a5,-20(s0)
 3009c48:	479c                	lw	a5,8(a5)
 3009c4a:	01079593          	slli	a1,a5,0x10
 3009c4e:	81c1                	srli	a1,a1,0x10
                                qdmHandle->inputFilter.qdmBFilterLevel, qdmHandle->inputFilter.qdmZFilterLevel);
 3009c50:	fec42783          	lw	a5,-20(s0)
 3009c54:	47dc                	lw	a5,12(a5)
    DCL_QDM_SetInputFilterWidth(qdmHandle->baseAddress, qdmHandle->inputFilter.qdmAFilterLevel, \
 3009c56:	01079613          	slli	a2,a5,0x10
 3009c5a:	8241                	srli	a2,a2,0x10
                                qdmHandle->inputFilter.qdmBFilterLevel, qdmHandle->inputFilter.qdmZFilterLevel);
 3009c5c:	fec42783          	lw	a5,-20(s0)
 3009c60:	4b9c                	lw	a5,16(a5)
    DCL_QDM_SetInputFilterWidth(qdmHandle->baseAddress, qdmHandle->inputFilter.qdmAFilterLevel, \
 3009c62:	9fa1                	uxth	a5
 3009c64:	86be                	mv	a3,a5
 3009c66:	853a                	mv	a0,a4
 3009c68:	a24ff0ef          	jal	ra,3008e8c <DCL_QDM_SetInputFilterWidth>
    QDM_DecoderConfig(qdmHandle);
 3009c6c:	fec42503          	lw	a0,-20(s0)
 3009c70:	ba0ff0ef          	jal	ra,3009010 <QDM_DecoderConfig>
    QDM_CounterConfig(qdmHandle);
 3009c74:	fec42503          	lw	a0,-20(s0)
 3009c78:	dbeff0ef          	jal	ra,3009236 <QDM_CounterConfig>
    /* Enable interrupt. */
    QDM_InterruptEnable(qdmHandle);
 3009c7c:	fec42503          	lw	a0,-20(s0)
 3009c80:	381d                	jal	ra,30094b6 <QDM_InterruptEnable>
    QDM_EnableSubmodule(qdmHandle);
 3009c82:	fec42503          	lw	a0,-20(s0)
 3009c86:	fa4ff0ef          	jal	ra,300942a <QDM_EnableSubmodule>
    return BASE_STATUS_OK;
 3009c8a:	4781                	li	a5,0
}
 3009c8c:	853e                	mv	a0,a5
 3009c8e:	40f2                	lw	ra,28(sp)
 3009c90:	4462                	lw	s0,24(sp)
 3009c92:	6105                	addi	sp,sp,32
 3009c94:	8082                	ret

03009c96 <HAL_QDM_ReadPosCountAndDir>:
  * @param count: count value pointer.
  * @param dir: dir.
  * @retval none.
  */
void HAL_QDM_ReadPosCountAndDir(const QDM_Handle *qdmHandle, unsigned int *count, unsigned int *dir)
{
 3009c96:	1101                	addi	sp,sp,-32
 3009c98:	ce06                	sw	ra,28(sp)
 3009c9a:	cc22                	sw	s0,24(sp)
 3009c9c:	1000                	addi	s0,sp,32
 3009c9e:	fea42623          	sw	a0,-20(s0)
 3009ca2:	feb42423          	sw	a1,-24(s0)
 3009ca6:	fec42223          	sw	a2,-28(s0)
    QDM_ASSERT_PARAM(qdmHandle != NULL);
 3009caa:	fec42783          	lw	a5,-20(s0)
 3009cae:	eb89                	bnez	a5,3009cc0 <HAL_QDM_ReadPosCountAndDir+0x2a>
 3009cb0:	1e300593          	li	a1,483
 3009cb4:	030117b7          	lui	a5,0x3011
 3009cb8:	a0478513          	addi	a0,a5,-1532 # 3010a04 <g_crgIpMatch+0x4f4>
 3009cbc:	339d                	jal	ra,3009a22 <AssertErrorLog.trans.7>
 3009cbe:	a001                	j	3009cbe <HAL_QDM_ReadPosCountAndDir+0x28>
    QDM_ASSERT_PARAM(count != NULL);
 3009cc0:	fe842783          	lw	a5,-24(s0)
 3009cc4:	eb89                	bnez	a5,3009cd6 <HAL_QDM_ReadPosCountAndDir+0x40>
 3009cc6:	1e400593          	li	a1,484
 3009cca:	030117b7          	lui	a5,0x3011
 3009cce:	a0478513          	addi	a0,a5,-1532 # 3010a04 <g_crgIpMatch+0x4f4>
 3009cd2:	3b81                	jal	ra,3009a22 <AssertErrorLog.trans.7>
 3009cd4:	a001                	j	3009cd4 <HAL_QDM_ReadPosCountAndDir+0x3e>
    QDM_ASSERT_PARAM(dir != NULL);
 3009cd6:	fe442783          	lw	a5,-28(s0)
 3009cda:	eb89                	bnez	a5,3009cec <HAL_QDM_ReadPosCountAndDir+0x56>
 3009cdc:	1e500593          	li	a1,485
 3009ce0:	030117b7          	lui	a5,0x3011
 3009ce4:	a0478513          	addi	a0,a5,-1532 # 3010a04 <g_crgIpMatch+0x4f4>
 3009ce8:	3b2d                	jal	ra,3009a22 <AssertErrorLog.trans.7>
 3009cea:	a001                	j	3009cea <HAL_QDM_ReadPosCountAndDir+0x54>
    QDM_ASSERT_PARAM(IsQDMInstance(qdmHandle->baseAddress));
 3009cec:	fec42783          	lw	a5,-20(s0)
 3009cf0:	4398                	lw	a4,0(a5)
 3009cf2:	14c007b7          	lui	a5,0x14c00
 3009cf6:	02f70163          	beq	a4,a5,3009d18 <HAL_QDM_ReadPosCountAndDir+0x82>
 3009cfa:	fec42783          	lw	a5,-20(s0)
 3009cfe:	4398                	lw	a4,0(a5)
 3009d00:	14c017b7          	lui	a5,0x14c01
 3009d04:	00f70a63          	beq	a4,a5,3009d18 <HAL_QDM_ReadPosCountAndDir+0x82>
 3009d08:	1e600593          	li	a1,486
 3009d0c:	030117b7          	lui	a5,0x3011
 3009d10:	a0478513          	addi	a0,a5,-1532 # 3010a04 <g_crgIpMatch+0x4f4>
 3009d14:	3339                	jal	ra,3009a22 <AssertErrorLog.trans.7>
 3009d16:	a001                	j	3009d16 <HAL_QDM_ReadPosCountAndDir+0x80>
    *count = qdmHandle->baseAddress->QPOSCNT;
 3009d18:	fec42783          	lw	a5,-20(s0)
 3009d1c:	439c                	lw	a5,0(a5)
 3009d1e:	5798                	lw	a4,40(a5)
 3009d20:	fe842783          	lw	a5,-24(s0)
 3009d24:	c398                	sw	a4,0(a5)
    *dir = qdmHandle->baseAddress->QDMSTS.BIT.qdir_sts;
 3009d26:	fec42783          	lw	a5,-20(s0)
 3009d2a:	439c                	lw	a5,0(a5)
 3009d2c:	53dc                	lw	a5,36(a5)
 3009d2e:	8399                	srli	a5,a5,0x6
 3009d30:	8b85                	andi	a5,a5,1
 3009d32:	9f81                	uxtb	a5
 3009d34:	873e                	mv	a4,a5
 3009d36:	fe442783          	lw	a5,-28(s0)
 3009d3a:	c398                	sw	a4,0(a5)

    return;
 3009d3c:	0001                	nop
}
 3009d3e:	40f2                	lw	ra,28(sp)
 3009d40:	4462                	lw	s0,24(sp)
 3009d42:	6105                	addi	sp,sp,32
 3009d44:	8082                	ret

03009d46 <IsTimerMode>:
  * @param mode Timer Mode, @ref TIMER_Mode
  * @retval true
  * @retval false
  */
static inline bool IsTimerMode(TIMER_Mode mode)
{
 3009d46:	1101                	addi	sp,sp,-32
 3009d48:	ce22                	sw	s0,28(sp)
 3009d4a:	1000                	addi	s0,sp,32
 3009d4c:	fea42623          	sw	a0,-20(s0)
    return (((mode) == TIMER_MODE_RUN_FREE) ||
            ((mode) == TIMER_MODE_RUN_PERIODIC) ||
 3009d50:	fec42783          	lw	a5,-20(s0)
 3009d54:	cb99                	beqz	a5,3009d6a <IsTimerMode+0x24>
    return (((mode) == TIMER_MODE_RUN_FREE) ||
 3009d56:	fec42703          	lw	a4,-20(s0)
 3009d5a:	4785                	li	a5,1
 3009d5c:	00f70763          	beq	a4,a5,3009d6a <IsTimerMode+0x24>
            ((mode) == TIMER_MODE_RUN_PERIODIC) ||
 3009d60:	fec42703          	lw	a4,-20(s0)
 3009d64:	4789                	li	a5,2
 3009d66:	00f71463          	bne	a4,a5,3009d6e <IsTimerMode+0x28>
 3009d6a:	4785                	li	a5,1
 3009d6c:	a011                	j	3009d70 <IsTimerMode+0x2a>
 3009d6e:	4781                	li	a5,0
 3009d70:	8b85                	andi	a5,a5,1
 3009d72:	9f81                	uxtb	a5
            ((mode) == TIMER_MODE_RUN_ONTSHOT));
}
 3009d74:	853e                	mv	a0,a5
 3009d76:	4472                	lw	s0,28(sp)
 3009d78:	6105                	addi	sp,sp,32
 3009d7a:	8082                	ret

03009d7c <IsTimerInterruptType>:
  * @param mode Timer Interrupt Type, @ref TIMER_InterruptType
  * @retval true
  * @retval false
  */
static inline bool IsTimerInterruptType(TIMER_InterruptType interruptType)
{
 3009d7c:	1101                	addi	sp,sp,-32
 3009d7e:	ce22                	sw	s0,28(sp)
 3009d80:	1000                	addi	s0,sp,32
 3009d82:	fea42623          	sw	a0,-20(s0)
    return (((interruptType) == TIMER_PERIOD_FIN) ||
 3009d86:	fec42783          	lw	a5,-20(s0)
 3009d8a:	c791                	beqz	a5,3009d96 <IsTimerInterruptType+0x1a>
 3009d8c:	fec42703          	lw	a4,-20(s0)
 3009d90:	4785                	li	a5,1
 3009d92:	00f71463          	bne	a4,a5,3009d9a <IsTimerInterruptType+0x1e>
 3009d96:	4785                	li	a5,1
 3009d98:	a011                	j	3009d9c <IsTimerInterruptType+0x20>
 3009d9a:	4781                	li	a5,0
 3009d9c:	8b85                	andi	a5,a5,1
 3009d9e:	9f81                	uxtb	a5
            ((interruptType) == TIMER_OVER_FLOW));
}
 3009da0:	853e                	mv	a0,a5
 3009da2:	4472                	lw	s0,28(sp)
 3009da4:	6105                	addi	sp,sp,32
 3009da6:	8082                	ret

03009da8 <IsTimerSize>:
  * @param size  Timer Size, @ref TIMER_Size
  * @retval true
  * @retval false
  */
static inline bool IsTimerSize(TIMER_Size size)
{
 3009da8:	1101                	addi	sp,sp,-32
 3009daa:	ce22                	sw	s0,28(sp)
 3009dac:	1000                	addi	s0,sp,32
 3009dae:	fea42623          	sw	a0,-20(s0)
    return (((size) == TIMER_SIZE_16BIT) ||
 3009db2:	fec42783          	lw	a5,-20(s0)
 3009db6:	c791                	beqz	a5,3009dc2 <IsTimerSize+0x1a>
 3009db8:	fec42703          	lw	a4,-20(s0)
 3009dbc:	4785                	li	a5,1
 3009dbe:	00f71463          	bne	a4,a5,3009dc6 <IsTimerSize+0x1e>
 3009dc2:	4785                	li	a5,1
 3009dc4:	a011                	j	3009dc8 <IsTimerSize+0x20>
 3009dc6:	4781                	li	a5,0
 3009dc8:	8b85                	andi	a5,a5,1
 3009dca:	9f81                	uxtb	a5
            ((size) == TIMER_SIZE_32BIT));
}
 3009dcc:	853e                	mv	a0,a5
 3009dce:	4472                	lw	s0,28(sp)
 3009dd0:	6105                	addi	sp,sp,32
 3009dd2:	8082                	ret

03009dd4 <IsTimerPeriod>:
  * @param period
  * @retval true
  * @retval false
  */
static inline bool IsTimerPeriod(unsigned int period)
{
 3009dd4:	1101                	addi	sp,sp,-32
 3009dd6:	ce22                	sw	s0,28(sp)
 3009dd8:	1000                	addi	s0,sp,32
 3009dda:	fea42623          	sw	a0,-20(s0)
    return ((period) >= PERIOD_MIN_VALUE);
 3009dde:	fec42783          	lw	a5,-20(s0)
 3009de2:	00f037b3          	snez	a5,a5
 3009de6:	9f81                	uxtb	a5
}
 3009de8:	853e                	mv	a0,a5
 3009dea:	4472                	lw	s0,28(sp)
 3009dec:	6105                	addi	sp,sp,32
 3009dee:	8082                	ret

03009df0 <IsTimerDiv>:
  * @param div @see TIMER_PrescalerFactor
  * @retval true
  * @retval false
  */
static inline bool IsTimerDiv(TIMER_PrescalerFactor div)
{
 3009df0:	1101                	addi	sp,sp,-32
 3009df2:	ce22                	sw	s0,28(sp)
 3009df4:	1000                	addi	s0,sp,32
 3009df6:	fea42623          	sw	a0,-20(s0)
    return (((div) == TIMERPRESCALER_NO_DIV) ||
            ((div) == TIMERPRESCALER_DIV_16) ||
 3009dfa:	fec42783          	lw	a5,-20(s0)
 3009dfe:	cb99                	beqz	a5,3009e14 <IsTimerDiv+0x24>
    return (((div) == TIMERPRESCALER_NO_DIV) ||
 3009e00:	fec42703          	lw	a4,-20(s0)
 3009e04:	4785                	li	a5,1
 3009e06:	00f70763          	beq	a4,a5,3009e14 <IsTimerDiv+0x24>
            ((div) == TIMERPRESCALER_DIV_16) ||
 3009e0a:	fec42703          	lw	a4,-20(s0)
 3009e0e:	4789                	li	a5,2
 3009e10:	00f71463          	bne	a4,a5,3009e18 <IsTimerDiv+0x28>
 3009e14:	4785                	li	a5,1
 3009e16:	a011                	j	3009e1a <IsTimerDiv+0x2a>
 3009e18:	4781                	li	a5,0
 3009e1a:	8b85                	andi	a5,a5,1
 3009e1c:	9f81                	uxtb	a5
            ((div) == TIMERPRESCALER_DIV_256));
}
 3009e1e:	853e                	mv	a0,a5
 3009e20:	4472                	lw	s0,28(sp)
 3009e22:	6105                	addi	sp,sp,32
 3009e24:	8082                	ret

03009e26 <HAL_TIMER_Init>:
  * @param   handle  Timer Handle
  * @retval  BASE_STATUS_OK    Success
  * @retval  BASE_STATUS_ERROR parameter check fail
  */
BASE_StatusType HAL_TIMER_Init(TIMER_Handle *handle)
{
 3009e26:	1101                	addi	sp,sp,-32
 3009e28:	ce06                	sw	ra,28(sp)
 3009e2a:	cc22                	sw	s0,24(sp)
 3009e2c:	1000                	addi	s0,sp,32
 3009e2e:	fea42623          	sw	a0,-20(s0)
    TIMER_ASSERT_PARAM(handle != NULL);
 3009e32:	fec42783          	lw	a5,-20(s0)
 3009e36:	eb89                	bnez	a5,3009e48 <HAL_TIMER_Init+0x22>
 3009e38:	02800593          	li	a1,40
 3009e3c:	030117b7          	lui	a5,0x3011
 3009e40:	a6878513          	addi	a0,a5,-1432 # 3010a68 <g_crgIpMatch+0x558>
 3009e44:	3ef9                	jal	ra,3009a22 <AssertErrorLog.trans.7>
 3009e46:	a001                	j	3009e46 <HAL_TIMER_Init+0x20>
    TIMER_ASSERT_PARAM(IsTIMERInstance(handle->baseAddress));
 3009e48:	fec42783          	lw	a5,-20(s0)
 3009e4c:	4398                	lw	a4,0(a5)
 3009e4e:	143007b7          	lui	a5,0x14300
 3009e52:	02f70f63          	beq	a4,a5,3009e90 <HAL_TIMER_Init+0x6a>
 3009e56:	fec42783          	lw	a5,-20(s0)
 3009e5a:	4398                	lw	a4,0(a5)
 3009e5c:	143017b7          	lui	a5,0x14301
 3009e60:	02f70863          	beq	a4,a5,3009e90 <HAL_TIMER_Init+0x6a>
 3009e64:	fec42783          	lw	a5,-20(s0)
 3009e68:	4398                	lw	a4,0(a5)
 3009e6a:	143027b7          	lui	a5,0x14302
 3009e6e:	02f70163          	beq	a4,a5,3009e90 <HAL_TIMER_Init+0x6a>
 3009e72:	fec42783          	lw	a5,-20(s0)
 3009e76:	4398                	lw	a4,0(a5)
 3009e78:	143037b7          	lui	a5,0x14303
 3009e7c:	00f70a63          	beq	a4,a5,3009e90 <HAL_TIMER_Init+0x6a>
 3009e80:	02900593          	li	a1,41
 3009e84:	030117b7          	lui	a5,0x3011
 3009e88:	a6878513          	addi	a0,a5,-1432 # 3010a68 <g_crgIpMatch+0x558>
 3009e8c:	3e59                	jal	ra,3009a22 <AssertErrorLog.trans.7>
 3009e8e:	a001                	j	3009e8e <HAL_TIMER_Init+0x68>

    TIMER_PARAM_CHECK_WITH_RET(IsTimerPeriod(handle->load), BASE_STATUS_ERROR);
 3009e90:	fec42783          	lw	a5,-20(s0)
 3009e94:	4bdc                	lw	a5,20(a5)
 3009e96:	853e                	mv	a0,a5
 3009e98:	3f35                	jal	ra,3009dd4 <IsTimerPeriod>
 3009e9a:	87aa                	mv	a5,a0
 3009e9c:	0017c793          	xori	a5,a5,1
 3009ea0:	9f81                	uxtb	a5
 3009ea2:	cb91                	beqz	a5,3009eb6 <HAL_TIMER_Init+0x90>
 3009ea4:	02b00593          	li	a1,43
 3009ea8:	030117b7          	lui	a5,0x3011
 3009eac:	a6878513          	addi	a0,a5,-1432 # 3010a68 <g_crgIpMatch+0x558>
 3009eb0:	3e8d                	jal	ra,3009a22 <AssertErrorLog.trans.7>
 3009eb2:	4785                	li	a5,1
 3009eb4:	aa6d                	j	300a06e <HAL_TIMER_Init+0x248>
    TIMER_PARAM_CHECK_WITH_RET(IsTimerPeriod(handle->bgLoad), BASE_STATUS_ERROR);
 3009eb6:	fec42783          	lw	a5,-20(s0)
 3009eba:	4f9c                	lw	a5,24(a5)
 3009ebc:	853e                	mv	a0,a5
 3009ebe:	3f19                	jal	ra,3009dd4 <IsTimerPeriod>
 3009ec0:	87aa                	mv	a5,a0
 3009ec2:	0017c793          	xori	a5,a5,1
 3009ec6:	9f81                	uxtb	a5
 3009ec8:	cb91                	beqz	a5,3009edc <HAL_TIMER_Init+0xb6>
 3009eca:	02c00593          	li	a1,44
 3009ece:	030117b7          	lui	a5,0x3011
 3009ed2:	a6878513          	addi	a0,a5,-1432 # 3010a68 <g_crgIpMatch+0x558>
 3009ed6:	36b1                	jal	ra,3009a22 <AssertErrorLog.trans.7>
 3009ed8:	4785                	li	a5,1
 3009eda:	aa51                	j	300a06e <HAL_TIMER_Init+0x248>
    TIMER_PARAM_CHECK_WITH_RET(IsTimerMode(handle->mode), BASE_STATUS_ERROR);
 3009edc:	fec42783          	lw	a5,-20(s0)
 3009ee0:	479c                	lw	a5,8(a5)
 3009ee2:	853e                	mv	a0,a5
 3009ee4:	358d                	jal	ra,3009d46 <IsTimerMode>
 3009ee6:	87aa                	mv	a5,a0
 3009ee8:	0017c793          	xori	a5,a5,1
 3009eec:	9f81                	uxtb	a5
 3009eee:	cb91                	beqz	a5,3009f02 <HAL_TIMER_Init+0xdc>
 3009ef0:	02d00593          	li	a1,45
 3009ef4:	030117b7          	lui	a5,0x3011
 3009ef8:	a6878513          	addi	a0,a5,-1432 # 3010a68 <g_crgIpMatch+0x558>
 3009efc:	361d                	jal	ra,3009a22 <AssertErrorLog.trans.7>
 3009efe:	4785                	li	a5,1
 3009f00:	a2bd                	j	300a06e <HAL_TIMER_Init+0x248>
    TIMER_PARAM_CHECK_WITH_RET(IsTimerSize(handle->size), BASE_STATUS_ERROR);
 3009f02:	fec42783          	lw	a5,-20(s0)
 3009f06:	4b9c                	lw	a5,16(a5)
 3009f08:	853e                	mv	a0,a5
 3009f0a:	3d79                	jal	ra,3009da8 <IsTimerSize>
 3009f0c:	87aa                	mv	a5,a0
 3009f0e:	0017c793          	xori	a5,a5,1
 3009f12:	9f81                	uxtb	a5
 3009f14:	cb91                	beqz	a5,3009f28 <HAL_TIMER_Init+0x102>
 3009f16:	02e00593          	li	a1,46
 3009f1a:	030117b7          	lui	a5,0x3011
 3009f1e:	a6878513          	addi	a0,a5,-1432 # 3010a68 <g_crgIpMatch+0x558>
 3009f22:	3601                	jal	ra,3009a22 <AssertErrorLog.trans.7>
 3009f24:	4785                	li	a5,1
 3009f26:	a2a1                	j	300a06e <HAL_TIMER_Init+0x248>
    TIMER_PARAM_CHECK_WITH_RET(IsTimerDiv(handle->prescaler), BASE_STATUS_ERROR);
 3009f28:	fec42783          	lw	a5,-20(s0)
 3009f2c:	47dc                	lw	a5,12(a5)
 3009f2e:	853e                	mv	a0,a5
 3009f30:	35c1                	jal	ra,3009df0 <IsTimerDiv>
 3009f32:	87aa                	mv	a5,a0
 3009f34:	0017c793          	xori	a5,a5,1
 3009f38:	9f81                	uxtb	a5
 3009f3a:	cb91                	beqz	a5,3009f4e <HAL_TIMER_Init+0x128>
 3009f3c:	02f00593          	li	a1,47
 3009f40:	030117b7          	lui	a5,0x3011
 3009f44:	a6878513          	addi	a0,a5,-1432 # 3010a68 <g_crgIpMatch+0x558>
 3009f48:	3ce9                	jal	ra,3009a22 <AssertErrorLog.trans.7>
 3009f4a:	4785                	li	a5,1
 3009f4c:	a20d                	j	300a06e <HAL_TIMER_Init+0x248>

    /* Initialize the configuration parameters of the timer */
    handle->baseAddress->timer_intclr = BASE_CFG_SET;   /* Writing to this register clears interrupt output of timer */
 3009f4e:	fec42783          	lw	a5,-20(s0)
 3009f52:	439c                	lw	a5,0(a5)
 3009f54:	4705                	li	a4,1
 3009f56:	c7d8                	sw	a4,12(a5)
    handle->baseAddress->timer_load = handle->load;
 3009f58:	fec42783          	lw	a5,-20(s0)
 3009f5c:	439c                	lw	a5,0(a5)
 3009f5e:	fec42703          	lw	a4,-20(s0)
 3009f62:	4b58                	lw	a4,20(a4)
 3009f64:	c398                	sw	a4,0(a5)
    handle->baseAddress->timerbgload = handle->bgLoad;
 3009f66:	fec42783          	lw	a5,-20(s0)
 3009f6a:	439c                	lw	a5,0(a5)
 3009f6c:	fec42703          	lw	a4,-20(s0)
 3009f70:	4f18                	lw	a4,24(a4)
 3009f72:	cf98                	sw	a4,24(a5)
    handle->baseAddress->TIMERx_CONTROL.BIT.timeren = BASE_CFG_DISABLE;
 3009f74:	fec42783          	lw	a5,-20(s0)
 3009f78:	4398                	lw	a4,0(a5)
 3009f7a:	471c                	lw	a5,8(a4)
 3009f7c:	f7f7f793          	andi	a5,a5,-129
 3009f80:	c71c                	sw	a5,8(a4)
    handle->baseAddress->TIMERx_CONTROL.BIT.timerintenable = handle->interruptEn;
 3009f82:	fec42783          	lw	a5,-20(s0)
 3009f86:	4398                	lw	a4,0(a5)
 3009f88:	fec42783          	lw	a5,-20(s0)
 3009f8c:	2fd4                	lbu	a3,28(a5)
 3009f8e:	471c                	lw	a5,8(a4)
 3009f90:	8a85                	andi	a3,a3,1
 3009f92:	0696                	slli	a3,a3,0x5
 3009f94:	fdf7f793          	andi	a5,a5,-33
 3009f98:	8fd5                	or	a5,a5,a3
 3009f9a:	c71c                	sw	a5,8(a4)
    
    /* Sets the frequency divider and size of the timer module. */
    handle->baseAddress->TIMERx_CONTROL.BIT.timerpre = handle->prescaler;
 3009f9c:	fec42783          	lw	a5,-20(s0)
 3009fa0:	47d4                	lw	a3,12(a5)
 3009fa2:	fec42783          	lw	a5,-20(s0)
 3009fa6:	4398                	lw	a4,0(a5)
 3009fa8:	87b6                	mv	a5,a3
 3009faa:	8b8d                	andi	a5,a5,3
 3009fac:	0ff7f693          	andi	a3,a5,255
 3009fb0:	471c                	lw	a5,8(a4)
 3009fb2:	8a8d                	andi	a3,a3,3
 3009fb4:	068a                	slli	a3,a3,0x2
 3009fb6:	9bcd                	andi	a5,a5,-13
 3009fb8:	8fd5                	or	a5,a5,a3
 3009fba:	c71c                	sw	a5,8(a4)
    handle->baseAddress->TIMERx_CONTROL.BIT.timersize = handle->size;
 3009fbc:	fec42783          	lw	a5,-20(s0)
 3009fc0:	4b94                	lw	a3,16(a5)
 3009fc2:	fec42783          	lw	a5,-20(s0)
 3009fc6:	4398                	lw	a4,0(a5)
 3009fc8:	87b6                	mv	a5,a3
 3009fca:	8b85                	andi	a5,a5,1
 3009fcc:	0ff7f693          	andi	a3,a5,255
 3009fd0:	471c                	lw	a5,8(a4)
 3009fd2:	8a85                	andi	a3,a3,1
 3009fd4:	0686                	slli	a3,a3,0x1
 3009fd6:	9bf5                	andi	a5,a5,-3
 3009fd8:	8fd5                	or	a5,a5,a3
 3009fda:	c71c                	sw	a5,8(a4)

    /* Sets the running mode of the timer. */
    if (handle->mode == TIMER_MODE_RUN_ONTSHOT) {
 3009fdc:	fec42783          	lw	a5,-20(s0)
 3009fe0:	4798                	lw	a4,8(a5)
 3009fe2:	4789                	li	a5,2
 3009fe4:	00f71a63          	bne	a4,a5,3009ff8 <HAL_TIMER_Init+0x1d2>
        handle->baseAddress->TIMERx_CONTROL.BIT.oneshot = BASE_CFG_SET;
 3009fe8:	fec42783          	lw	a5,-20(s0)
 3009fec:	4398                	lw	a4,0(a5)
 3009fee:	471c                	lw	a5,8(a4)
 3009ff0:	0017e793          	ori	a5,a5,1
 3009ff4:	c71c                	sw	a5,8(a4)
 3009ff6:	a805                	j	300a026 <HAL_TIMER_Init+0x200>
    } else {
        handle->baseAddress->TIMERx_CONTROL.BIT.oneshot = BASE_CFG_UNSET;
 3009ff8:	fec42783          	lw	a5,-20(s0)
 3009ffc:	4398                	lw	a4,0(a5)
 3009ffe:	471c                	lw	a5,8(a4)
 300a000:	9bf9                	andi	a5,a5,-2
 300a002:	c71c                	sw	a5,8(a4)
        handle->baseAddress->TIMERx_CONTROL.BIT.timermode =
            (handle->mode == TIMER_MODE_RUN_FREE) ? BASE_CFG_UNSET : BASE_CFG_SET;
 300a004:	fec42783          	lw	a5,-20(s0)
 300a008:	479c                	lw	a5,8(a5)
        handle->baseAddress->TIMERx_CONTROL.BIT.timermode =
 300a00a:	fec42703          	lw	a4,-20(s0)
 300a00e:	4318                	lw	a4,0(a4)
            (handle->mode == TIMER_MODE_RUN_FREE) ? BASE_CFG_UNSET : BASE_CFG_SET;
 300a010:	00f037b3          	snez	a5,a5
 300a014:	0ff7f693          	andi	a3,a5,255
        handle->baseAddress->TIMERx_CONTROL.BIT.timermode =
 300a018:	471c                	lw	a5,8(a4)
 300a01a:	8a85                	andi	a3,a3,1
 300a01c:	069a                	slli	a3,a3,0x6
 300a01e:	fbf7f793          	andi	a5,a5,-65
 300a022:	8fd5                	or	a5,a5,a3
 300a024:	c71c                	sw	a5,8(a4)
    }

    /* Request for setting the DMA and ADC. */
    handle->baseAddress->TIMERx_CONTROLB.BIT.dmasreqen = handle->dmaReqEnable;
 300a026:	fec42783          	lw	a5,-20(s0)
 300a02a:	4398                	lw	a4,0(a5)
 300a02c:	fec42783          	lw	a5,-20(s0)
 300a030:	2ff4                	lbu	a3,30(a5)
 300a032:	4f5c                	lw	a5,28(a4)
 300a034:	8a85                	andi	a3,a3,1
 300a036:	0686                	slli	a3,a3,0x1
 300a038:	9bf5                	andi	a5,a5,-3
 300a03a:	8fd5                	or	a5,a5,a3
 300a03c:	cf5c                	sw	a5,28(a4)
    handle->baseAddress->TIMERx_CONTROLB.BIT.dmabreqen = handle->dmaReqEnable;
 300a03e:	fec42783          	lw	a5,-20(s0)
 300a042:	4398                	lw	a4,0(a5)
 300a044:	fec42783          	lw	a5,-20(s0)
 300a048:	2ff4                	lbu	a3,30(a5)
 300a04a:	4f5c                	lw	a5,28(a4)
 300a04c:	8a85                	andi	a3,a3,1
 300a04e:	9bf9                	andi	a5,a5,-2
 300a050:	8fd5                	or	a5,a5,a3
 300a052:	cf5c                	sw	a5,28(a4)
    handle->baseAddress->TIMERx_CONTROLB.BIT.socen = handle->adcSocReqEnable;
 300a054:	fec42783          	lw	a5,-20(s0)
 300a058:	4398                	lw	a4,0(a5)
 300a05a:	fec42783          	lw	a5,-20(s0)
 300a05e:	3fd4                	lbu	a3,29(a5)
 300a060:	4f5c                	lw	a5,28(a4)
 300a062:	8a85                	andi	a3,a3,1
 300a064:	068a                	slli	a3,a3,0x2
 300a066:	9bed                	andi	a5,a5,-5
 300a068:	8fd5                	or	a5,a5,a3
 300a06a:	cf5c                	sw	a5,28(a4)
    return BASE_STATUS_OK;
 300a06c:	4781                	li	a5,0
}
 300a06e:	853e                	mv	a0,a5
 300a070:	40f2                	lw	ra,28(sp)
 300a072:	4462                	lw	s0,24(sp)
 300a074:	6105                	addi	sp,sp,32
 300a076:	8082                	ret

0300a078 <HAL_TIMER_Start>:
  * @brief   Start timer.
  * @param   handle Timer Handle
  * @retval  None
  */
void HAL_TIMER_Start(TIMER_Handle *handle)
{
 300a078:	1101                	addi	sp,sp,-32
 300a07a:	ce06                	sw	ra,28(sp)
 300a07c:	cc22                	sw	s0,24(sp)
 300a07e:	1000                	addi	s0,sp,32
 300a080:	fea42623          	sw	a0,-20(s0)
    TIMER_ASSERT_PARAM(handle != NULL);
 300a084:	fec42783          	lw	a5,-20(s0)
 300a088:	eb89                	bnez	a5,300a09a <HAL_TIMER_Start+0x22>
 300a08a:	0bc00593          	li	a1,188
 300a08e:	030117b7          	lui	a5,0x3011
 300a092:	a6878513          	addi	a0,a5,-1432 # 3010a68 <g_crgIpMatch+0x558>
 300a096:	3271                	jal	ra,3009a22 <AssertErrorLog.trans.7>
 300a098:	a001                	j	300a098 <HAL_TIMER_Start+0x20>
    TIMER_ASSERT_PARAM(IsTIMERInstance(handle->baseAddress));
 300a09a:	fec42783          	lw	a5,-20(s0)
 300a09e:	4398                	lw	a4,0(a5)
 300a0a0:	143007b7          	lui	a5,0x14300
 300a0a4:	02f70f63          	beq	a4,a5,300a0e2 <HAL_TIMER_Start+0x6a>
 300a0a8:	fec42783          	lw	a5,-20(s0)
 300a0ac:	4398                	lw	a4,0(a5)
 300a0ae:	143017b7          	lui	a5,0x14301
 300a0b2:	02f70863          	beq	a4,a5,300a0e2 <HAL_TIMER_Start+0x6a>
 300a0b6:	fec42783          	lw	a5,-20(s0)
 300a0ba:	4398                	lw	a4,0(a5)
 300a0bc:	143027b7          	lui	a5,0x14302
 300a0c0:	02f70163          	beq	a4,a5,300a0e2 <HAL_TIMER_Start+0x6a>
 300a0c4:	fec42783          	lw	a5,-20(s0)
 300a0c8:	4398                	lw	a4,0(a5)
 300a0ca:	143037b7          	lui	a5,0x14303
 300a0ce:	00f70a63          	beq	a4,a5,300a0e2 <HAL_TIMER_Start+0x6a>
 300a0d2:	0bd00593          	li	a1,189
 300a0d6:	030117b7          	lui	a5,0x3011
 300a0da:	a6878513          	addi	a0,a5,-1432 # 3010a68 <g_crgIpMatch+0x558>
 300a0de:	3291                	jal	ra,3009a22 <AssertErrorLog.trans.7>
 300a0e0:	a001                	j	300a0e0 <HAL_TIMER_Start+0x68>
    /* Enable timer */
    handle->baseAddress->TIMERx_CONTROL.BIT.timeren = BASE_CFG_SET;
 300a0e2:	fec42783          	lw	a5,-20(s0)
 300a0e6:	4398                	lw	a4,0(a5)
 300a0e8:	471c                	lw	a5,8(a4)
 300a0ea:	0807e793          	ori	a5,a5,128
 300a0ee:	c71c                	sw	a5,8(a4)
}
 300a0f0:	0001                	nop
 300a0f2:	40f2                	lw	ra,28(sp)
 300a0f4:	4462                	lw	s0,24(sp)
 300a0f6:	6105                	addi	sp,sp,32
 300a0f8:	8082                	ret

0300a0fa <HAL_TIMER_IrqHandler>:
 * @brief   GPT Interrupt service processing function.
 * @param   handle   TIMER Handle
 * @retval  None
 */
void HAL_TIMER_IrqHandler(void *handle)
{
 300a0fa:	7179                	addi	sp,sp,-48
 300a0fc:	d606                	sw	ra,44(sp)
 300a0fe:	d422                	sw	s0,40(sp)
 300a100:	1800                	addi	s0,sp,48
 300a102:	fca42e23          	sw	a0,-36(s0)
    TIMER_ASSERT_PARAM(handle != NULL);
 300a106:	fdc42783          	lw	a5,-36(s0)
 300a10a:	eb89                	bnez	a5,300a11c <HAL_TIMER_IrqHandler+0x22>
 300a10c:	0d800593          	li	a1,216
 300a110:	030117b7          	lui	a5,0x3011
 300a114:	a6878513          	addi	a0,a5,-1432 # 3010a68 <g_crgIpMatch+0x558>
 300a118:	3229                	jal	ra,3009a22 <AssertErrorLog.trans.7>
 300a11a:	a001                	j	300a11a <HAL_TIMER_IrqHandler+0x20>
    TIMER_Handle *timerHandle = (TIMER_Handle *)handle;
 300a11c:	fdc42783          	lw	a5,-36(s0)
 300a120:	fef42623          	sw	a5,-20(s0)
    TIMER_ASSERT_PARAM(IsTIMERInstance(timerHandle->baseAddress));
 300a124:	fec42783          	lw	a5,-20(s0)
 300a128:	4398                	lw	a4,0(a5)
 300a12a:	143007b7          	lui	a5,0x14300
 300a12e:	02f70f63          	beq	a4,a5,300a16c <HAL_TIMER_IrqHandler+0x72>
 300a132:	fec42783          	lw	a5,-20(s0)
 300a136:	4398                	lw	a4,0(a5)
 300a138:	143017b7          	lui	a5,0x14301
 300a13c:	02f70863          	beq	a4,a5,300a16c <HAL_TIMER_IrqHandler+0x72>
 300a140:	fec42783          	lw	a5,-20(s0)
 300a144:	4398                	lw	a4,0(a5)
 300a146:	143027b7          	lui	a5,0x14302
 300a14a:	02f70163          	beq	a4,a5,300a16c <HAL_TIMER_IrqHandler+0x72>
 300a14e:	fec42783          	lw	a5,-20(s0)
 300a152:	4398                	lw	a4,0(a5)
 300a154:	143037b7          	lui	a5,0x14303
 300a158:	00f70a63          	beq	a4,a5,300a16c <HAL_TIMER_IrqHandler+0x72>
 300a15c:	0da00593          	li	a1,218
 300a160:	030117b7          	lui	a5,0x3011
 300a164:	a6878513          	addi	a0,a5,-1432 # 3010a68 <g_crgIpMatch+0x558>
 300a168:	2239                	jal	ra,300a276 <AssertErrorLog.trans.8>
 300a16a:	a001                	j	300a16a <HAL_TIMER_IrqHandler+0x70>
    /* Check interrupt type */
    if (timerHandle->baseAddress->TIMERx_MIS.dmaovmis == BASE_CFG_ENABLE) {
 300a16c:	fec42783          	lw	a5,-20(s0)
 300a170:	439c                	lw	a5,0(a5)
 300a172:	4bdc                	lw	a5,20(a5)
 300a174:	8385                	srli	a5,a5,0x1
 300a176:	8b85                	andi	a5,a5,1
 300a178:	0ff7f713          	andi	a4,a5,255
 300a17c:	4785                	li	a5,1
 300a17e:	02f71363          	bne	a4,a5,300a1a4 <HAL_TIMER_IrqHandler+0xaa>
        /* DMA overflow interrupt */
        timerHandle->baseAddress->DMAOV_INTCLR.BIT.dmaov_intclr = BASE_CFG_ENABLE;
 300a182:	fec42783          	lw	a5,-20(s0)
 300a186:	4398                	lw	a4,0(a5)
 300a188:	531c                	lw	a5,32(a4)
 300a18a:	0017e793          	ori	a5,a5,1
 300a18e:	d31c                	sw	a5,32(a4)
       /* Call the timer DMA request overflow callback function of the user. */
        if (timerHandle->userCallBack.TimerOverFlowCallBack != NULL) {
 300a190:	fec42783          	lw	a5,-20(s0)
 300a194:	53dc                	lw	a5,36(a5)
 300a196:	c799                	beqz	a5,300a1a4 <HAL_TIMER_IrqHandler+0xaa>
            timerHandle->userCallBack.TimerOverFlowCallBack(timerHandle);
 300a198:	fec42783          	lw	a5,-20(s0)
 300a19c:	53dc                	lw	a5,36(a5)
 300a19e:	fec42503          	lw	a0,-20(s0)
 300a1a2:	9782                	jalr	a5
        }
    }
    if (timerHandle->baseAddress->TIMERx_MIS.timermis == BASE_CFG_ENABLE) {
 300a1a4:	fec42783          	lw	a5,-20(s0)
 300a1a8:	439c                	lw	a5,0(a5)
 300a1aa:	4bdc                	lw	a5,20(a5)
 300a1ac:	8b85                	andi	a5,a5,1
 300a1ae:	0ff7f713          	andi	a4,a5,255
 300a1b2:	4785                	li	a5,1
 300a1b4:	02f71263          	bne	a4,a5,300a1d8 <HAL_TIMER_IrqHandler+0xde>
        /* TIMER Interrupt */
        timerHandle->baseAddress->timer_intclr = BASE_CFG_ENABLE;
 300a1b8:	fec42783          	lw	a5,-20(s0)
 300a1bc:	439c                	lw	a5,0(a5)
 300a1be:	4705                	li	a4,1
 300a1c0:	c7d8                	sw	a4,12(a5)
        /* Call the period finish callback function of the user. */
        if (timerHandle->userCallBack.TimerPeriodFinCallBack != NULL) {
 300a1c2:	fec42783          	lw	a5,-20(s0)
 300a1c6:	539c                	lw	a5,32(a5)
 300a1c8:	cb81                	beqz	a5,300a1d8 <HAL_TIMER_IrqHandler+0xde>
            timerHandle->userCallBack.TimerPeriodFinCallBack(timerHandle);
 300a1ca:	fec42783          	lw	a5,-20(s0)
 300a1ce:	539c                	lw	a5,32(a5)
 300a1d0:	fec42503          	lw	a0,-20(s0)
 300a1d4:	9782                	jalr	a5
        }
    }
    return;
 300a1d6:	0001                	nop
 300a1d8:	0001                	nop
}
 300a1da:	50b2                	lw	ra,44(sp)
 300a1dc:	5422                	lw	s0,40(sp)
 300a1de:	6145                	addi	sp,sp,48
 300a1e0:	8082                	ret

0300a1e2 <HAL_TIMER_RegisterCallback>:
  * @retval  BASE_STATUS_OK  Success
  * @retval  BASE_STATUS_ERROR Parameter check fail
  */
BASE_StatusType HAL_TIMER_RegisterCallback(TIMER_Handle *handle, TIMER_InterruptType typeID,
                                           TIMER_CallBackFunc callBackFunc)
{
 300a1e2:	1101                	addi	sp,sp,-32
 300a1e4:	ce06                	sw	ra,28(sp)
 300a1e6:	cc22                	sw	s0,24(sp)
 300a1e8:	1000                	addi	s0,sp,32
 300a1ea:	fea42623          	sw	a0,-20(s0)
 300a1ee:	feb42423          	sw	a1,-24(s0)
 300a1f2:	fec42223          	sw	a2,-28(s0)
    TIMER_ASSERT_PARAM(handle != NULL);
 300a1f6:	fec42783          	lw	a5,-20(s0)
 300a1fa:	eb89                	bnez	a5,300a20c <HAL_TIMER_RegisterCallback+0x2a>
 300a1fc:	0fa00593          	li	a1,250
 300a200:	030117b7          	lui	a5,0x3011
 300a204:	a6878513          	addi	a0,a5,-1432 # 3010a68 <g_crgIpMatch+0x558>
 300a208:	20bd                	jal	ra,300a276 <AssertErrorLog.trans.8>
 300a20a:	a001                	j	300a20a <HAL_TIMER_RegisterCallback+0x28>
    TIMER_ASSERT_PARAM(callBackFunc != NULL);
 300a20c:	fe442783          	lw	a5,-28(s0)
 300a210:	eb89                	bnez	a5,300a222 <HAL_TIMER_RegisterCallback+0x40>
 300a212:	0fb00593          	li	a1,251
 300a216:	030117b7          	lui	a5,0x3011
 300a21a:	a6878513          	addi	a0,a5,-1432 # 3010a68 <g_crgIpMatch+0x558>
 300a21e:	28a1                	jal	ra,300a276 <AssertErrorLog.trans.8>
 300a220:	a001                	j	300a220 <HAL_TIMER_RegisterCallback+0x3e>
    TIMER_ASSERT_PARAM(IsTimerInterruptType(typeID));
 300a222:	fe842503          	lw	a0,-24(s0)
 300a226:	3e99                	jal	ra,3009d7c <IsTimerInterruptType>
 300a228:	87aa                	mv	a5,a0
 300a22a:	0017c793          	xori	a5,a5,1
 300a22e:	9f81                	uxtb	a5
 300a230:	cb89                	beqz	a5,300a242 <HAL_TIMER_RegisterCallback+0x60>
 300a232:	0fc00593          	li	a1,252
 300a236:	030117b7          	lui	a5,0x3011
 300a23a:	a6878513          	addi	a0,a5,-1432 # 3010a68 <g_crgIpMatch+0x558>
 300a23e:	2825                	jal	ra,300a276 <AssertErrorLog.trans.8>
 300a240:	a001                	j	300a240 <HAL_TIMER_RegisterCallback+0x5e>
    
    /* Registers the user callback function. */
    switch (typeID) {
 300a242:	fe842783          	lw	a5,-24(s0)
 300a246:	cb91                	beqz	a5,300a25a <HAL_TIMER_RegisterCallback+0x78>
 300a248:	4705                	li	a4,1
 300a24a:	00e79e63          	bne	a5,a4,300a266 <HAL_TIMER_RegisterCallback+0x84>
        case TIMER_OVER_FLOW:
            handle->userCallBack.TimerOverFlowCallBack = callBackFunc; /* User DMA request overflow function */
 300a24e:	fec42783          	lw	a5,-20(s0)
 300a252:	fe442703          	lw	a4,-28(s0)
 300a256:	d3d8                	sw	a4,36(a5)
            break;
 300a258:	a809                	j	300a26a <HAL_TIMER_RegisterCallback+0x88>
        case TIMER_PERIOD_FIN:
            handle->userCallBack.TimerPeriodFinCallBack = callBackFunc; /* User timer period finish call back. */
 300a25a:	fec42783          	lw	a5,-20(s0)
 300a25e:	fe442703          	lw	a4,-28(s0)
 300a262:	d398                	sw	a4,32(a5)
            break;
 300a264:	a019                	j	300a26a <HAL_TIMER_RegisterCallback+0x88>
        default:
            return BASE_STATUS_ERROR;
 300a266:	4785                	li	a5,1
 300a268:	a011                	j	300a26c <HAL_TIMER_RegisterCallback+0x8a>
    }
    return BASE_STATUS_OK;
 300a26a:	4781                	li	a5,0
}
 300a26c:	853e                	mv	a0,a5
 300a26e:	40f2                	lw	ra,28(sp)
 300a270:	4462                	lw	s0,24(sp)
 300a272:	6105                	addi	sp,sp,32
 300a274:	8082                	ret

0300a276 <AssertErrorLog.trans.8>:
 300a276:	ac9f806f          	j	3002d3e <AssertErrorLog>

0300a27a <IsUartDatalength>:
  * @brief Check UART datalength parameter.
  * @param datalength The number of data bits in a frame, @ref UART_DataLength
  * @retval bool
  */
static inline bool IsUartDatalength(UART_DataLength datalength)
{
 300a27a:	1101                	addi	sp,sp,-32
 300a27c:	ce22                	sw	s0,28(sp)
 300a27e:	1000                	addi	s0,sp,32
 300a280:	fea42623          	sw	a0,-20(s0)
    return (datalength >= UART_DATALENGTH_5BIT) && (datalength <= UART_DATALENGTH_8BIT);
 300a284:	fec42783          	lw	a5,-20(s0)
 300a288:	0047b793          	sltiu	a5,a5,4
 300a28c:	9f81                	uxtb	a5
}
 300a28e:	853e                	mv	a0,a5
 300a290:	4472                	lw	s0,28(sp)
 300a292:	6105                	addi	sp,sp,32
 300a294:	8082                	ret

0300a296 <IsUartStopbits>:
  * @brief Check UART stopbits parameter.
  * @param stopbits The number of stop bits in a frame, @ref UART_StopBits
  * @retval bool
  */
static inline bool IsUartStopbits(UART_StopBits stopbits)
{
 300a296:	1101                	addi	sp,sp,-32
 300a298:	ce22                	sw	s0,28(sp)
 300a29a:	1000                	addi	s0,sp,32
 300a29c:	fea42623          	sw	a0,-20(s0)
    return (stopbits == UART_STOPBITS_ONE) || (stopbits == UART_STOPBITS_TWO);
 300a2a0:	fec42783          	lw	a5,-20(s0)
 300a2a4:	c791                	beqz	a5,300a2b0 <IsUartStopbits+0x1a>
 300a2a6:	fec42703          	lw	a4,-20(s0)
 300a2aa:	4785                	li	a5,1
 300a2ac:	00f71463          	bne	a4,a5,300a2b4 <IsUartStopbits+0x1e>
 300a2b0:	4785                	li	a5,1
 300a2b2:	a011                	j	300a2b6 <IsUartStopbits+0x20>
 300a2b4:	4781                	li	a5,0
 300a2b6:	8b85                	andi	a5,a5,1
 300a2b8:	9f81                	uxtb	a5
}
 300a2ba:	853e                	mv	a0,a5
 300a2bc:	4472                	lw	s0,28(sp)
 300a2be:	6105                	addi	sp,sp,32
 300a2c0:	8082                	ret

0300a2c2 <IsUartParitymode>:
  * @brief Check UART paritymode parameter.
  * @param paritymode UART parity check mode, @ref UART_Parity_Mode
  * @retval bool
  */
static inline bool IsUartParitymode(UART_Parity_Mode paritymode)
{
 300a2c2:	1101                	addi	sp,sp,-32
 300a2c4:	ce22                	sw	s0,28(sp)
 300a2c6:	1000                	addi	s0,sp,32
 300a2c8:	fea42623          	sw	a0,-20(s0)
    if ((paritymode >= UART_PARITY_ODD) && (paritymode <= UART_PARITY_NONE)) {
 300a2cc:	fec42703          	lw	a4,-20(s0)
 300a2d0:	4791                	li	a5,4
 300a2d2:	00e7e463          	bltu	a5,a4,300a2da <IsUartParitymode+0x18>
        return true;
 300a2d6:	4785                	li	a5,1
 300a2d8:	a011                	j	300a2dc <IsUartParitymode+0x1a>
    }
    return false;
 300a2da:	4781                	li	a5,0
}
 300a2dc:	853e                	mv	a0,a5
 300a2de:	4472                	lw	s0,28(sp)
 300a2e0:	6105                	addi	sp,sp,32
 300a2e2:	8082                	ret

0300a2e4 <IsUartTransmode>:
  * @brief Check UART transmode parameter.
  * @param transmode Transmit mode, @ref UART_Transmit_Mode
  * @retval bool
  */
static inline bool IsUartTransmode(UART_Transmit_Mode transmode)
{
 300a2e4:	1101                	addi	sp,sp,-32
 300a2e6:	ce22                	sw	s0,28(sp)
 300a2e8:	1000                	addi	s0,sp,32
 300a2ea:	fea42623          	sw	a0,-20(s0)
    if ((transmode == UART_MODE_BLOCKING) ||
 300a2ee:	fec42783          	lw	a5,-20(s0)
 300a2f2:	c385                	beqz	a5,300a312 <IsUartTransmode+0x2e>
 300a2f4:	fec42703          	lw	a4,-20(s0)
 300a2f8:	4785                	li	a5,1
 300a2fa:	00f70c63          	beq	a4,a5,300a312 <IsUartTransmode+0x2e>
        (transmode == UART_MODE_INTERRUPT) ||
 300a2fe:	fec42703          	lw	a4,-20(s0)
 300a302:	4789                	li	a5,2
 300a304:	00f70763          	beq	a4,a5,300a312 <IsUartTransmode+0x2e>
        (transmode == UART_MODE_DMA) ||
 300a308:	fec42703          	lw	a4,-20(s0)
 300a30c:	478d                	li	a5,3
 300a30e:	00f71463          	bne	a4,a5,300a316 <IsUartTransmode+0x32>
        (transmode == UART_MODE_DISABLE)) {
        return true;
 300a312:	4785                	li	a5,1
 300a314:	a011                	j	300a318 <IsUartTransmode+0x34>
    }
    return false;
 300a316:	4781                	li	a5,0
}
 300a318:	853e                	mv	a0,a5
 300a31a:	4472                	lw	s0,28(sp)
 300a31c:	6105                	addi	sp,sp,32
 300a31e:	8082                	ret

0300a320 <IsUartFIFOThreshold>:
  * @brief Check UART fifoThreshold parameter.
  * @param fifoThreshold UART TX/RX FIFO line interrupt threshold, @ref UART_FIFO_Threshold
  * @retval bool
  */
static inline bool IsUartFIFOThreshold(UART_FIFO_Threshold fifoThreshold)
{
 300a320:	1101                	addi	sp,sp,-32
 300a322:	ce22                	sw	s0,28(sp)
 300a324:	1000                	addi	s0,sp,32
 300a326:	fea42623          	sw	a0,-20(s0)
    return (fifoThreshold >= UART_FIFODEPTH_SIZE0) && (fifoThreshold <= UART_FIFODEPTH_SIZE15);
 300a32a:	fec42783          	lw	a5,-20(s0)
 300a32e:	0107b793          	sltiu	a5,a5,16
 300a332:	9f81                	uxtb	a5
}
 300a334:	853e                	mv	a0,a5
 300a336:	4472                	lw	s0,28(sp)
 300a338:	6105                	addi	sp,sp,32
 300a33a:	8082                	ret

0300a33c <IsUartOversampleMultiple>:
  * @brief Check UART Oversampling multiple.
  * @param multiple Oversampling multiple, @ref UART_OversampleMultiple
  * @retval bool
  */
static inline bool IsUartOversampleMultiple(UART_OversampleMultiple multiple)
{
 300a33c:	1101                	addi	sp,sp,-32
 300a33e:	ce22                	sw	s0,28(sp)
 300a340:	1000                	addi	s0,sp,32
 300a342:	fea42623          	sw	a0,-20(s0)
    return (multiple >= UART_OVERSAMPLING_16X) && (multiple <= UART_OVERSAMPLING_12X);
 300a346:	fec42783          	lw	a5,-20(s0)
 300a34a:	0057b793          	sltiu	a5,a5,5
 300a34e:	9f81                	uxtb	a5
}
 300a350:	853e                	mv	a0,a5
 300a352:	4472                	lw	s0,28(sp)
 300a354:	6105                	addi	sp,sp,32
 300a356:	8082                	ret

0300a358 <DivClosest>:
#define PARITY_EVEN   0x6
#define PARITY_MARK   0x82
#define PARITY_SPACE  0x86

static unsigned int DivClosest(unsigned int x, unsigned int divisor)
{
 300a358:	7179                	addi	sp,sp,-48
 300a35a:	d622                	sw	s0,44(sp)
 300a35c:	1800                	addi	s0,sp,48
 300a35e:	fca42e23          	sw	a0,-36(s0)
 300a362:	fcb42c23          	sw	a1,-40(s0)
    unsigned int ret;
    if (divisor == 0) {
 300a366:	fd842783          	lw	a5,-40(s0)
 300a36a:	e399                	bnez	a5,300a370 <DivClosest+0x18>
        return 0;
 300a36c:	4781                	li	a5,0
 300a36e:	a005                	j	300a38e <DivClosest+0x36>
    }
    ret = (((x) + ((divisor) / 2)) / (divisor));  /* Round up the result, add 1/2 */
 300a370:	fd842783          	lw	a5,-40(s0)
 300a374:	0017d713          	srli	a4,a5,0x1
 300a378:	fdc42783          	lw	a5,-36(s0)
 300a37c:	973e                	add	a4,a4,a5
 300a37e:	fd842783          	lw	a5,-40(s0)
 300a382:	02f757b3          	divu	a5,a4,a5
 300a386:	fef42623          	sw	a5,-20(s0)
    return ret;
 300a38a:	fec42783          	lw	a5,-20(s0)
}
 300a38e:	853e                	mv	a0,a5
 300a390:	5432                	lw	s0,44(sp)
 300a392:	6145                	addi	sp,sp,48
 300a394:	8082                	ret

0300a396 <BaudDetectCallBack>:
  * @brief Baud rate detection interrupt callback function.
  * @param uartHandle UART handle.
  * @retval None.
  */
static void BaudDetectCallBack(UART_Handle *uartHandle)
{
 300a396:	1101                	addi	sp,sp,-32
 300a398:	ce06                	sw	ra,28(sp)
 300a39a:	cc22                	sw	s0,24(sp)
 300a39c:	1000                	addi	s0,sp,32
 300a39e:	fea42623          	sw	a0,-20(s0)
    if (uartHandle->baseAddress->UART_MIS.BIT.abdcis == 0x01) {
 300a3a2:	fec42783          	lw	a5,-20(s0)
 300a3a6:	439c                	lw	a5,0(a5)
 300a3a8:	43bc                	lw	a5,64(a5)
 300a3aa:	83cd                	srli	a5,a5,0x13
 300a3ac:	8b85                	andi	a5,a5,1
 300a3ae:	0ff7f713          	andi	a4,a5,255
 300a3b2:	4785                	li	a5,1
 300a3b4:	06f71b63          	bne	a4,a5,300a42a <BaudDetectCallBack+0x94>
        uartHandle->baseAddress->UART_ABDEN.BIT.abden = BASE_CFG_DISABLE;
 300a3b8:	fec42783          	lw	a5,-20(s0)
 300a3bc:	4398                	lw	a4,0(a5)
 300a3be:	4f7c                	lw	a5,92(a4)
 300a3c0:	9bf9                	andi	a5,a5,-2
 300a3c2:	cf7c                	sw	a5,92(a4)
        uartHandle->baseAddress->UART_IMSC.BIT.abdeim = BASE_CFG_DISABLE;
 300a3c4:	fec42783          	lw	a5,-20(s0)
 300a3c8:	4398                	lw	a4,0(a5)
 300a3ca:	5f1c                	lw	a5,56(a4)
 300a3cc:	fff006b7          	lui	a3,0xfff00
 300a3d0:	16fd                	addi	a3,a3,-1 # ffefffff <RAM_END+0xfbef7fff>
 300a3d2:	8ff5                	and	a5,a5,a3
 300a3d4:	df1c                	sw	a5,56(a4)
        uartHandle->baseAddress->UART_IMSC.BIT.abdcim = BASE_CFG_DISABLE;
 300a3d6:	fec42783          	lw	a5,-20(s0)
 300a3da:	4398                	lw	a4,0(a5)
 300a3dc:	5f1c                	lw	a5,56(a4)
 300a3de:	fff806b7          	lui	a3,0xfff80
 300a3e2:	16fd                	addi	a3,a3,-1 # fff7ffff <RAM_END+0xfbf77fff>
 300a3e4:	8ff5                	and	a5,a5,a3
 300a3e6:	df1c                	sw	a5,56(a4)
        uartHandle->baseAddress->UART_ICR.BIT.abdcic = BASE_CFG_ENABLE;
 300a3e8:	fec42783          	lw	a5,-20(s0)
 300a3ec:	4398                	lw	a4,0(a5)
 300a3ee:	437c                	lw	a5,68(a4)
 300a3f0:	000806b7          	lui	a3,0x80
 300a3f4:	8fd5                	or	a5,a5,a3
 300a3f6:	c37c                	sw	a5,68(a4)
        /* After the baud rate automatic detection function is configured, enable UART. */
        uartHandle->baseAddress->UART_CR.BIT.txe = BASE_CFG_ENABLE;
 300a3f8:	fec42783          	lw	a5,-20(s0)
 300a3fc:	4398                	lw	a4,0(a5)
 300a3fe:	5b1c                	lw	a5,48(a4)
 300a400:	1007e793          	ori	a5,a5,256
 300a404:	db1c                	sw	a5,48(a4)
        uartHandle->baseAddress->UART_CR.BIT.rxe = BASE_CFG_ENABLE;
 300a406:	fec42783          	lw	a5,-20(s0)
 300a40a:	4398                	lw	a4,0(a5)
 300a40c:	5b1c                	lw	a5,48(a4)
 300a40e:	2007e793          	ori	a5,a5,512
 300a412:	db1c                	sw	a5,48(a4)
        /* Call back user detect success function. */
        if (uartHandle->userCallBack.BaudDetectSuccessCallBack != NULL) {
 300a414:	fec42783          	lw	a5,-20(s0)
 300a418:	57fc                	lw	a5,108(a5)
 300a41a:	c7b9                	beqz	a5,300a468 <BaudDetectCallBack+0xd2>
            uartHandle->userCallBack.BaudDetectSuccessCallBack(uartHandle);
 300a41c:	fec42783          	lw	a5,-20(s0)
 300a420:	57fc                	lw	a5,108(a5)
 300a422:	fec42503          	lw	a0,-20(s0)
 300a426:	9782                	jalr	a5
        /* Call back user baud detect error function. */
        if (uartHandle->userCallBack.BaudDetectErrorCallBack != NULL) {
            uartHandle->userCallBack.BaudDetectErrorCallBack(uartHandle);
        }
    }
    return;
 300a428:	a081                	j	300a468 <BaudDetectCallBack+0xd2>
        while (uartHandle->baseAddress->UART_ABDEN.BIT.abdbusy == 0x01) {
 300a42a:	0001                	nop
 300a42c:	fec42783          	lw	a5,-20(s0)
 300a430:	439c                	lw	a5,0(a5)
 300a432:	4ffc                	lw	a5,92(a5)
 300a434:	8391                	srli	a5,a5,0x4
 300a436:	8b85                	andi	a5,a5,1
 300a438:	0ff7f713          	andi	a4,a5,255
 300a43c:	4785                	li	a5,1
 300a43e:	fef707e3          	beq	a4,a5,300a42c <BaudDetectCallBack+0x96>
        uartHandle->baseAddress->UART_ICR.BIT.abdeic = BASE_CFG_ENABLE;
 300a442:	fec42783          	lw	a5,-20(s0)
 300a446:	4398                	lw	a4,0(a5)
 300a448:	437c                	lw	a5,68(a4)
 300a44a:	001006b7          	lui	a3,0x100
 300a44e:	8fd5                	or	a5,a5,a3
 300a450:	c37c                	sw	a5,68(a4)
        if (uartHandle->userCallBack.BaudDetectErrorCallBack != NULL) {
 300a452:	fec42783          	lw	a5,-20(s0)
 300a456:	5bbc                	lw	a5,112(a5)
 300a458:	cb81                	beqz	a5,300a468 <BaudDetectCallBack+0xd2>
            uartHandle->userCallBack.BaudDetectErrorCallBack(uartHandle);
 300a45a:	fec42783          	lw	a5,-20(s0)
 300a45e:	5bbc                	lw	a5,112(a5)
 300a460:	fec42503          	lw	a0,-20(s0)
 300a464:	9782                	jalr	a5
    return;
 300a466:	0001                	nop
 300a468:	0001                	nop
}
 300a46a:	40f2                	lw	ra,28(sp)
 300a46c:	4462                	lw	s0,24(sp)
 300a46e:	6105                	addi	sp,sp,32
 300a470:	8082                	ret

0300a472 <CharterMatchCallBack>:
  * @brief Character detection interrupt callback function.
  * @param uartHandle UART handle.
  * @retval None.
  */
static void CharterMatchCallBack(UART_Handle *uartHandle)
{
 300a472:	1101                	addi	sp,sp,-32
 300a474:	ce06                	sw	ra,28(sp)
 300a476:	cc22                	sw	s0,24(sp)
 300a478:	1000                	addi	s0,sp,32
 300a47a:	fea42623          	sw	a0,-20(s0)
    uartHandle->baseAddress->UART_IMSC.BIT.cmim = BASE_CFG_DISABLE;
 300a47e:	fec42783          	lw	a5,-20(s0)
 300a482:	4398                	lw	a4,0(a5)
 300a484:	5f1c                	lw	a5,56(a4)
 300a486:	ffe006b7          	lui	a3,0xffe00
 300a48a:	16fd                	addi	a3,a3,-1 # ffdfffff <RAM_END+0xfbdf7fff>
 300a48c:	8ff5                	and	a5,a5,a3
 300a48e:	df1c                	sw	a5,56(a4)
    uartHandle->baseAddress->UART_ICR.BIT.cmic = BASE_CFG_ENABLE;
 300a490:	fec42783          	lw	a5,-20(s0)
 300a494:	4398                	lw	a4,0(a5)
 300a496:	437c                	lw	a5,68(a4)
 300a498:	002006b7          	lui	a3,0x200
 300a49c:	8fd5                	or	a5,a5,a3
 300a49e:	c37c                	sw	a5,68(a4)
    if (uartHandle->userCallBack.CharacterMatchCallBack != NULL) {
 300a4a0:	fec42783          	lw	a5,-20(s0)
 300a4a4:	5bfc                	lw	a5,116(a5)
 300a4a6:	c799                	beqz	a5,300a4b4 <CharterMatchCallBack+0x42>
        uartHandle->userCallBack.CharacterMatchCallBack(uartHandle);
 300a4a8:	fec42783          	lw	a5,-20(s0)
 300a4ac:	5bfc                	lw	a5,116(a5)
 300a4ae:	fec42503          	lw	a0,-20(s0)
 300a4b2:	9782                	jalr	a5
    }
}
 300a4b4:	0001                	nop
 300a4b6:	40f2                	lw	ra,28(sp)
 300a4b8:	4462                	lw	s0,24(sp)
 300a4ba:	6105                	addi	sp,sp,32
 300a4bc:	8082                	ret

0300a4be <UART_SetParityBit>:
  * @brief Sets the parity bit of the UART.
  * @param uartHandle UART handle.
  * @retval None.
  */
static void UART_SetParityBit(UART_Handle *uartHandle)
{
 300a4be:	1101                	addi	sp,sp,-32
 300a4c0:	ce22                	sw	s0,28(sp)
 300a4c2:	1000                	addi	s0,sp,32
 300a4c4:	fea42623          	sw	a0,-20(s0)
    /* Sets the UART check mode. */
    switch (uartHandle->parity) {
 300a4c8:	fec42783          	lw	a5,-20(s0)
 300a4cc:	4b9c                	lw	a5,16(a5)
 300a4ce:	4711                	li	a4,4
 300a4d0:	06f76e63          	bltu	a4,a5,300a54c <UART_SetParityBit+0x8e>
 300a4d4:	00279713          	slli	a4,a5,0x2
 300a4d8:	030117b7          	lui	a5,0x3011
 300a4dc:	a8878793          	addi	a5,a5,-1400 # 3010a88 <g_crgIpMatch+0x578>
 300a4e0:	97ba                	add	a5,a5,a4
 300a4e2:	439c                	lw	a5,0(a5)
 300a4e4:	8782                	jr	a5
        case UART_PARITY_ODD:
            uartHandle->baseAddress->UART_LCR_H.reg |= PARITY_ODD; /* Odd parity. */
 300a4e6:	fec42783          	lw	a5,-20(s0)
 300a4ea:	439c                	lw	a5,0(a5)
 300a4ec:	57d8                	lw	a4,44(a5)
 300a4ee:	fec42783          	lw	a5,-20(s0)
 300a4f2:	439c                	lw	a5,0(a5)
 300a4f4:	00276713          	ori	a4,a4,2
 300a4f8:	d7d8                	sw	a4,44(a5)
            break;
 300a4fa:	a891                	j	300a54e <UART_SetParityBit+0x90>
        case UART_PARITY_EVEN:
            uartHandle->baseAddress->UART_LCR_H.reg |= PARITY_EVEN; /* Even parity. */
 300a4fc:	fec42783          	lw	a5,-20(s0)
 300a500:	439c                	lw	a5,0(a5)
 300a502:	57d8                	lw	a4,44(a5)
 300a504:	fec42783          	lw	a5,-20(s0)
 300a508:	439c                	lw	a5,0(a5)
 300a50a:	00676713          	ori	a4,a4,6
 300a50e:	d7d8                	sw	a4,44(a5)
            break;
 300a510:	a83d                	j	300a54e <UART_SetParityBit+0x90>
        case UART_PARITY_MARK:
            uartHandle->baseAddress->UART_LCR_H.reg |= PARITY_MARK; /* Marking parity */
 300a512:	fec42783          	lw	a5,-20(s0)
 300a516:	439c                	lw	a5,0(a5)
 300a518:	57d8                	lw	a4,44(a5)
 300a51a:	fec42783          	lw	a5,-20(s0)
 300a51e:	439c                	lw	a5,0(a5)
 300a520:	08276713          	ori	a4,a4,130
 300a524:	d7d8                	sw	a4,44(a5)
            break;
 300a526:	a025                	j	300a54e <UART_SetParityBit+0x90>
        case UART_PARITY_SPACE:
            uartHandle->baseAddress->UART_LCR_H.reg |= PARITY_SPACE; /* space parity */
 300a528:	fec42783          	lw	a5,-20(s0)
 300a52c:	439c                	lw	a5,0(a5)
 300a52e:	57d8                	lw	a4,44(a5)
 300a530:	fec42783          	lw	a5,-20(s0)
 300a534:	439c                	lw	a5,0(a5)
 300a536:	08676713          	ori	a4,a4,134
 300a53a:	d7d8                	sw	a4,44(a5)
            break;
 300a53c:	a809                	j	300a54e <UART_SetParityBit+0x90>
        case UART_PARITY_NONE:
            uartHandle->baseAddress->UART_LCR_H.BIT.pen = BASE_CFG_DISABLE; /* No parity */
 300a53e:	fec42783          	lw	a5,-20(s0)
 300a542:	4398                	lw	a4,0(a5)
 300a544:	575c                	lw	a5,44(a4)
 300a546:	9bf5                	andi	a5,a5,-3
 300a548:	d75c                	sw	a5,44(a4)
            break;
 300a54a:	a011                	j	300a54e <UART_SetParityBit+0x90>
        default:
            return;
 300a54c:	0001                	nop
    }
}
 300a54e:	4472                	lw	s0,28(sp)
 300a550:	6105                	addi	sp,sp,32
 300a552:	8082                	ret

0300a554 <HAL_UART_Init>:
  * @brief Initialize the UART hardware configuration and configure parameters based on the specified handle.
  * @param uartHandle UART handle.
  * @retval BASE status type: OK, ERROR.
  */
BASE_StatusType HAL_UART_Init(UART_Handle *uartHandle)
{
 300a554:	7179                	addi	sp,sp,-48
 300a556:	d606                	sw	ra,44(sp)
 300a558:	d422                	sw	s0,40(sp)
 300a55a:	1800                	addi	s0,sp,48
 300a55c:	fca42e23          	sw	a0,-36(s0)
    UART_ASSERT_PARAM(uartHandle != NULL);
 300a560:	fdc42783          	lw	a5,-36(s0)
 300a564:	eb89                	bnez	a5,300a576 <HAL_UART_Init+0x22>
 300a566:	09700593          	li	a1,151
 300a56a:	030117b7          	lui	a5,0x3011
 300a56e:	a9c78513          	addi	a0,a5,-1380 # 3010a9c <g_crgIpMatch+0x58c>
 300a572:	3311                	jal	ra,300a276 <AssertErrorLog.trans.8>
 300a574:	a001                	j	300a574 <HAL_UART_Init+0x20>
    UART_ASSERT_PARAM(IsUARTInstance(uartHandle->baseAddress));
 300a576:	fdc42783          	lw	a5,-36(s0)
 300a57a:	4398                	lw	a4,0(a5)
 300a57c:	140007b7          	lui	a5,0x14000
 300a580:	02f70f63          	beq	a4,a5,300a5be <HAL_UART_Init+0x6a>
 300a584:	fdc42783          	lw	a5,-36(s0)
 300a588:	4398                	lw	a4,0(a5)
 300a58a:	140017b7          	lui	a5,0x14001
 300a58e:	02f70863          	beq	a4,a5,300a5be <HAL_UART_Init+0x6a>
 300a592:	fdc42783          	lw	a5,-36(s0)
 300a596:	4398                	lw	a4,0(a5)
 300a598:	140027b7          	lui	a5,0x14002
 300a59c:	02f70163          	beq	a4,a5,300a5be <HAL_UART_Init+0x6a>
 300a5a0:	fdc42783          	lw	a5,-36(s0)
 300a5a4:	4398                	lw	a4,0(a5)
 300a5a6:	140037b7          	lui	a5,0x14003
 300a5aa:	00f70a63          	beq	a4,a5,300a5be <HAL_UART_Init+0x6a>
 300a5ae:	09800593          	li	a1,152
 300a5b2:	030117b7          	lui	a5,0x3011
 300a5b6:	a9c78513          	addi	a0,a5,-1380 # 3010a9c <g_crgIpMatch+0x58c>
 300a5ba:	3975                	jal	ra,300a276 <AssertErrorLog.trans.8>
 300a5bc:	a001                	j	300a5bc <HAL_UART_Init+0x68>
    UART_PARAM_CHECK_WITH_RET(uartHandle->txState == UART_STATE_NONE_INIT, BASE_STATUS_ERROR);
 300a5be:	fdc42783          	lw	a5,-36(s0)
 300a5c2:	47bc                	lw	a5,72(a5)
 300a5c4:	cb91                	beqz	a5,300a5d8 <HAL_UART_Init+0x84>
 300a5c6:	09900593          	li	a1,153
 300a5ca:	030117b7          	lui	a5,0x3011
 300a5ce:	a9c78513          	addi	a0,a5,-1380 # 3010a9c <g_crgIpMatch+0x58c>
 300a5d2:	3155                	jal	ra,300a276 <AssertErrorLog.trans.8>
 300a5d4:	4785                	li	a5,1
 300a5d6:	ae0d                	j	300a908 <HAL_UART_Init+0x3b4>
    UART_PARAM_CHECK_WITH_RET(uartHandle->rxState == UART_STATE_NONE_INIT, BASE_STATUS_ERROR);
 300a5d8:	fdc42783          	lw	a5,-36(s0)
 300a5dc:	47fc                	lw	a5,76(a5)
 300a5de:	cb91                	beqz	a5,300a5f2 <HAL_UART_Init+0x9e>
 300a5e0:	09a00593          	li	a1,154
 300a5e4:	030117b7          	lui	a5,0x3011
 300a5e8:	a9c78513          	addi	a0,a5,-1380 # 3010a9c <g_crgIpMatch+0x58c>
 300a5ec:	3169                	jal	ra,300a276 <AssertErrorLog.trans.8>
 300a5ee:	4785                	li	a5,1
 300a5f0:	ae21                	j	300a908 <HAL_UART_Init+0x3b4>
    unsigned int uartClock, quot;
    UART_PARAM_CHECK_WITH_RET(IsUartDatalength(uartHandle->dataLength), BASE_STATUS_ERROR);
 300a5f2:	fdc42783          	lw	a5,-36(s0)
 300a5f6:	479c                	lw	a5,8(a5)
 300a5f8:	853e                	mv	a0,a5
 300a5fa:	3141                	jal	ra,300a27a <IsUartDatalength>
 300a5fc:	87aa                	mv	a5,a0
 300a5fe:	0017c793          	xori	a5,a5,1
 300a602:	9f81                	uxtb	a5
 300a604:	cb91                	beqz	a5,300a618 <HAL_UART_Init+0xc4>
 300a606:	09c00593          	li	a1,156
 300a60a:	030117b7          	lui	a5,0x3011
 300a60e:	a9c78513          	addi	a0,a5,-1380 # 3010a9c <g_crgIpMatch+0x58c>
 300a612:	3195                	jal	ra,300a276 <AssertErrorLog.trans.8>
 300a614:	4785                	li	a5,1
 300a616:	accd                	j	300a908 <HAL_UART_Init+0x3b4>
    UART_PARAM_CHECK_WITH_RET(IsUartStopbits(uartHandle->stopBits), BASE_STATUS_ERROR);
 300a618:	fdc42783          	lw	a5,-36(s0)
 300a61c:	47dc                	lw	a5,12(a5)
 300a61e:	853e                	mv	a0,a5
 300a620:	399d                	jal	ra,300a296 <IsUartStopbits>
 300a622:	87aa                	mv	a5,a0
 300a624:	0017c793          	xori	a5,a5,1
 300a628:	9f81                	uxtb	a5
 300a62a:	cb91                	beqz	a5,300a63e <HAL_UART_Init+0xea>
 300a62c:	09d00593          	li	a1,157
 300a630:	030117b7          	lui	a5,0x3011
 300a634:	a9c78513          	addi	a0,a5,-1380 # 3010a9c <g_crgIpMatch+0x58c>
 300a638:	393d                	jal	ra,300a276 <AssertErrorLog.trans.8>
 300a63a:	4785                	li	a5,1
 300a63c:	a4f1                	j	300a908 <HAL_UART_Init+0x3b4>
    UART_PARAM_CHECK_WITH_RET(IsUartParitymode(uartHandle->parity), BASE_STATUS_ERROR);
 300a63e:	fdc42783          	lw	a5,-36(s0)
 300a642:	4b9c                	lw	a5,16(a5)
 300a644:	853e                	mv	a0,a5
 300a646:	39b5                	jal	ra,300a2c2 <IsUartParitymode>
 300a648:	87aa                	mv	a5,a0
 300a64a:	0017c793          	xori	a5,a5,1
 300a64e:	9f81                	uxtb	a5
 300a650:	cb91                	beqz	a5,300a664 <HAL_UART_Init+0x110>
 300a652:	09e00593          	li	a1,158
 300a656:	030117b7          	lui	a5,0x3011
 300a65a:	a9c78513          	addi	a0,a5,-1380 # 3010a9c <g_crgIpMatch+0x58c>
 300a65e:	3921                	jal	ra,300a276 <AssertErrorLog.trans.8>
 300a660:	4785                	li	a5,1
 300a662:	a45d                	j	300a908 <HAL_UART_Init+0x3b4>
    UART_PARAM_CHECK_WITH_RET(IsUartTransmode(uartHandle->txMode), BASE_STATUS_ERROR);
 300a664:	fdc42783          	lw	a5,-36(s0)
 300a668:	4bdc                	lw	a5,20(a5)
 300a66a:	853e                	mv	a0,a5
 300a66c:	39a5                	jal	ra,300a2e4 <IsUartTransmode>
 300a66e:	87aa                	mv	a5,a0
 300a670:	0017c793          	xori	a5,a5,1
 300a674:	9f81                	uxtb	a5
 300a676:	cb91                	beqz	a5,300a68a <HAL_UART_Init+0x136>
 300a678:	09f00593          	li	a1,159
 300a67c:	030117b7          	lui	a5,0x3011
 300a680:	a9c78513          	addi	a0,a5,-1380 # 3010a9c <g_crgIpMatch+0x58c>
 300a684:	3ecd                	jal	ra,300a276 <AssertErrorLog.trans.8>
 300a686:	4785                	li	a5,1
 300a688:	a441                	j	300a908 <HAL_UART_Init+0x3b4>
    UART_PARAM_CHECK_WITH_RET(IsUartTransmode(uartHandle->rxMode), BASE_STATUS_ERROR);
 300a68a:	fdc42783          	lw	a5,-36(s0)
 300a68e:	4f9c                	lw	a5,24(a5)
 300a690:	853e                	mv	a0,a5
 300a692:	3989                	jal	ra,300a2e4 <IsUartTransmode>
 300a694:	87aa                	mv	a5,a0
 300a696:	0017c793          	xori	a5,a5,1
 300a69a:	9f81                	uxtb	a5
 300a69c:	cb91                	beqz	a5,300a6b0 <HAL_UART_Init+0x15c>
 300a69e:	0a000593          	li	a1,160
 300a6a2:	030117b7          	lui	a5,0x3011
 300a6a6:	a9c78513          	addi	a0,a5,-1380 # 3010a9c <g_crgIpMatch+0x58c>
 300a6aa:	36f1                	jal	ra,300a276 <AssertErrorLog.trans.8>
 300a6ac:	4785                	li	a5,1
 300a6ae:	aca9                	j	300a908 <HAL_UART_Init+0x3b4>
    UART_PARAM_CHECK_WITH_RET(IsUartFIFOThreshold(uartHandle->fifoTxThr), BASE_STATUS_ERROR);
 300a6b0:	fdc42783          	lw	a5,-36(s0)
 300a6b4:	5b9c                	lw	a5,48(a5)
 300a6b6:	853e                	mv	a0,a5
 300a6b8:	31a5                	jal	ra,300a320 <IsUartFIFOThreshold>
 300a6ba:	87aa                	mv	a5,a0
 300a6bc:	0017c793          	xori	a5,a5,1
 300a6c0:	9f81                	uxtb	a5
 300a6c2:	cb91                	beqz	a5,300a6d6 <HAL_UART_Init+0x182>
 300a6c4:	0a100593          	li	a1,161
 300a6c8:	030117b7          	lui	a5,0x3011
 300a6cc:	a9c78513          	addi	a0,a5,-1380 # 3010a9c <g_crgIpMatch+0x58c>
 300a6d0:	365d                	jal	ra,300a276 <AssertErrorLog.trans.8>
 300a6d2:	4785                	li	a5,1
 300a6d4:	ac15                	j	300a908 <HAL_UART_Init+0x3b4>
    UART_PARAM_CHECK_WITH_RET(IsUartFIFOThreshold(uartHandle->fifoRxThr), BASE_STATUS_ERROR);
 300a6d6:	fdc42783          	lw	a5,-36(s0)
 300a6da:	5bdc                	lw	a5,52(a5)
 300a6dc:	853e                	mv	a0,a5
 300a6de:	3189                	jal	ra,300a320 <IsUartFIFOThreshold>
 300a6e0:	87aa                	mv	a5,a0
 300a6e2:	0017c793          	xori	a5,a5,1
 300a6e6:	9f81                	uxtb	a5
 300a6e8:	cb91                	beqz	a5,300a6fc <HAL_UART_Init+0x1a8>
 300a6ea:	0a200593          	li	a1,162
 300a6ee:	030117b7          	lui	a5,0x3011
 300a6f2:	a9c78513          	addi	a0,a5,-1380 # 3010a9c <g_crgIpMatch+0x58c>
 300a6f6:	3641                	jal	ra,300a276 <AssertErrorLog.trans.8>
 300a6f8:	4785                	li	a5,1
 300a6fa:	a439                	j	300a908 <HAL_UART_Init+0x3b4>
    UART_PARAM_CHECK_WITH_RET(IsUartOversampleMultiple(uartHandle->handleEx.overSampleMultiple), BASE_STATUS_ERROR);
 300a6fc:	fdc42783          	lw	a5,-36(s0)
 300a700:	5fbc                	lw	a5,120(a5)
 300a702:	853e                	mv	a0,a5
 300a704:	3925                	jal	ra,300a33c <IsUartOversampleMultiple>
 300a706:	87aa                	mv	a5,a0
 300a708:	0017c793          	xori	a5,a5,1
 300a70c:	9f81                	uxtb	a5
 300a70e:	cb91                	beqz	a5,300a722 <HAL_UART_Init+0x1ce>
 300a710:	0a300593          	li	a1,163
 300a714:	030117b7          	lui	a5,0x3011
 300a718:	a9c78513          	addi	a0,a5,-1380 # 3010a9c <g_crgIpMatch+0x58c>
 300a71c:	3ea9                	jal	ra,300a276 <AssertErrorLog.trans.8>
 300a71e:	4785                	li	a5,1
 300a720:	a2e5                	j	300a908 <HAL_UART_Init+0x3b4>

    uartHandle->baseAddress->UART_CR.BIT.uarten = BASE_CFG_DISABLE;
 300a722:	fdc42783          	lw	a5,-36(s0)
 300a726:	4398                	lw	a4,0(a5)
 300a728:	5b1c                	lw	a5,48(a4)
 300a72a:	9bf9                	andi	a5,a5,-2
 300a72c:	db1c                	sw	a5,48(a4)
    while (uartHandle->baseAddress->UART_FR.BIT.busy == 0x01) {
 300a72e:	0001                	nop
 300a730:	fdc42783          	lw	a5,-36(s0)
 300a734:	439c                	lw	a5,0(a5)
 300a736:	4f9c                	lw	a5,24(a5)
 300a738:	838d                	srli	a5,a5,0x3
 300a73a:	8b85                	andi	a5,a5,1
 300a73c:	0ff7f713          	andi	a4,a5,255
 300a740:	4785                	li	a5,1
 300a742:	fef707e3          	beq	a4,a5,300a730 <HAL_UART_Init+0x1dc>
        ;
    }

    uartClock = HAL_CRG_GetIpFreq((void *)uartHandle->baseAddress);
 300a746:	fdc42783          	lw	a5,-36(s0)
 300a74a:	439c                	lw	a5,0(a5)
 300a74c:	853e                	mv	a0,a5
 300a74e:	fa4fa0ef          	jal	ra,3004ef2 <HAL_CRG_GetIpFreq>
 300a752:	fea42623          	sw	a0,-20(s0)

    /* DCL OverSample Multiple check */
    uartHandle->baseAddress->UART_SPCFG.BIT.spcfg = uartHandle->handleEx.overSampleMultiple;
 300a756:	fdc42783          	lw	a5,-36(s0)
 300a75a:	5fb4                	lw	a3,120(a5)
 300a75c:	fdc42783          	lw	a5,-36(s0)
 300a760:	4398                	lw	a4,0(a5)
 300a762:	87b6                	mv	a5,a3
 300a764:	8bbd                	andi	a5,a5,15
 300a766:	0ff7f693          	andi	a3,a5,255
 300a76a:	4f3c                	lw	a5,88(a4)
 300a76c:	8abd                	andi	a3,a3,15
 300a76e:	9bc1                	andi	a5,a5,-16
 300a770:	8fd5                	or	a5,a5,a3
 300a772:	cf3c                	sw	a5,88(a4)

    /* DCL sequences setting */
    uartHandle->baseAddress->UART_DS.BIT.msbfirst = uartHandle->handleEx.msbFirst;
 300a774:	fdc42783          	lw	a5,-36(s0)
 300a778:	4398                	lw	a4,0(a5)
 300a77a:	fdc42783          	lw	a5,-36(s0)
 300a77e:	07c7c683          	lbu	a3,124(a5)
 300a782:	4b3c                	lw	a5,80(a4)
 300a784:	8a85                	andi	a3,a3,1
 300a786:	9bf9                	andi	a5,a5,-2
 300a788:	8fd5                	or	a5,a5,a3
 300a78a:	cb3c                	sw	a5,80(a4)

    /* The baud rate divider(BRD) based on the baud rate and clock frequency, calculation formula */
    unsigned int oversample = uartHandle->baseAddress->UART_SPCFG.reg;
 300a78c:	fdc42783          	lw	a5,-36(s0)
 300a790:	439c                	lw	a5,0(a5)
 300a792:	4fbc                	lw	a5,88(a5)
 300a794:	fef42423          	sw	a5,-24(s0)
    if (uartHandle->baudRate > (uartClock / (OVERSAMPLING_PARAM - oversample))) {
 300a798:	fdc42783          	lw	a5,-36(s0)
 300a79c:	43d8                	lw	a4,4(a5)
 300a79e:	46c1                	li	a3,16
 300a7a0:	fe842783          	lw	a5,-24(s0)
 300a7a4:	40f687b3          	sub	a5,a3,a5
 300a7a8:	fec42683          	lw	a3,-20(s0)
 300a7ac:	02f6d7b3          	divu	a5,a3,a5
 300a7b0:	00e7f463          	bgeu	a5,a4,300a7b8 <HAL_UART_Init+0x264>
        return BASE_STATUS_ERROR;
 300a7b4:	4785                	li	a5,1
 300a7b6:	aa89                	j	300a908 <HAL_UART_Init+0x3b4>
    } else {
        unsigned int tmpClock = uartClock / (OVERSAMPLING_PARAM - oversample) * 64;  /* 64 is for decimal parts */
 300a7b8:	4741                	li	a4,16
 300a7ba:	fe842783          	lw	a5,-24(s0)
 300a7be:	40f707b3          	sub	a5,a4,a5
 300a7c2:	fec42703          	lw	a4,-20(s0)
 300a7c6:	02f757b3          	divu	a5,a4,a5
 300a7ca:	079a                	slli	a5,a5,0x6
 300a7cc:	fef42223          	sw	a5,-28(s0)
        quot = DivClosest(tmpClock, uartHandle->baudRate);
 300a7d0:	fdc42783          	lw	a5,-36(s0)
 300a7d4:	43dc                	lw	a5,4(a5)
 300a7d6:	85be                	mv	a1,a5
 300a7d8:	fe442503          	lw	a0,-28(s0)
 300a7dc:	3eb5                	jal	ra,300a358 <DivClosest>
 300a7de:	fea42023          	sw	a0,-32(s0)
    }
    /* Clear the baud rate divider register */
    uartHandle->baseAddress->UART_FBRD.reg = 0;
 300a7e2:	fdc42783          	lw	a5,-36(s0)
 300a7e6:	439c                	lw	a5,0(a5)
 300a7e8:	0207a423          	sw	zero,40(a5)
    uartHandle->baseAddress->UART_IBRD.reg = 0;
 300a7ec:	fdc42783          	lw	a5,-36(s0)
 300a7f0:	439c                	lw	a5,0(a5)
 300a7f2:	0207a223          	sw	zero,36(a5)
    /* The fractional baud rate divider value is stored to the lower 6 bits of the FBRD */
    uartHandle->baseAddress->UART_FBRD.reg = (quot & 0x3F);
 300a7f6:	fdc42783          	lw	a5,-36(s0)
 300a7fa:	439c                	lw	a5,0(a5)
 300a7fc:	fe042703          	lw	a4,-32(s0)
 300a800:	03f77713          	andi	a4,a4,63
 300a804:	d798                	sw	a4,40(a5)
    /* Right shift 6 bits is the integer baud rate divider value, is stored to IBRD */
    uartHandle->baseAddress->UART_IBRD.reg = (quot >> 6);
 300a806:	fdc42783          	lw	a5,-36(s0)
 300a80a:	439c                	lw	a5,0(a5)
 300a80c:	fe042703          	lw	a4,-32(s0)
 300a810:	8319                	srli	a4,a4,0x6
 300a812:	d3d8                	sw	a4,36(a5)
    uartHandle->baseAddress->UART_LCR_H.reg = 0;
 300a814:	fdc42783          	lw	a5,-36(s0)
 300a818:	439c                	lw	a5,0(a5)
 300a81a:	0207a623          	sw	zero,44(a5)
    uartHandle->baseAddress->UART_LCR_H.BIT.wlen = uartHandle->dataLength;      /* Frame length seting */
 300a81e:	fdc42783          	lw	a5,-36(s0)
 300a822:	4794                	lw	a3,8(a5)
 300a824:	fdc42783          	lw	a5,-36(s0)
 300a828:	4398                	lw	a4,0(a5)
 300a82a:	87b6                	mv	a5,a3
 300a82c:	8b8d                	andi	a5,a5,3
 300a82e:	0ff7f693          	andi	a3,a5,255
 300a832:	575c                	lw	a5,44(a4)
 300a834:	8a8d                	andi	a3,a3,3
 300a836:	0696                	slli	a3,a3,0x5
 300a838:	f9f7f793          	andi	a5,a5,-97
 300a83c:	8fd5                	or	a5,a5,a3
 300a83e:	d75c                	sw	a5,44(a4)
    uartHandle->baseAddress->UART_LCR_H.BIT.stp2 = uartHandle->stopBits;        /* Stop bit seting */
 300a840:	fdc42783          	lw	a5,-36(s0)
 300a844:	47d4                	lw	a3,12(a5)
 300a846:	fdc42783          	lw	a5,-36(s0)
 300a84a:	4398                	lw	a4,0(a5)
 300a84c:	87b6                	mv	a5,a3
 300a84e:	8b85                	andi	a5,a5,1
 300a850:	0ff7f693          	andi	a3,a5,255
 300a854:	575c                	lw	a5,44(a4)
 300a856:	8a85                	andi	a3,a3,1
 300a858:	068e                	slli	a3,a3,0x3
 300a85a:	9bdd                	andi	a5,a5,-9
 300a85c:	8fd5                	or	a5,a5,a3
 300a85e:	d75c                	sw	a5,44(a4)
    UART_SetParityBit(uartHandle);
 300a860:	fdc42503          	lw	a0,-36(s0)
 300a864:	39a9                	jal	ra,300a4be <UART_SetParityBit>
    if (uartHandle->fifoMode == true) {                     /* FIFO threshold setting */
 300a866:	fdc42783          	lw	a5,-36(s0)
 300a86a:	02c7c783          	lbu	a5,44(a5)
 300a86e:	cbb1                	beqz	a5,300a8c2 <HAL_UART_Init+0x36e>
        uartHandle->baseAddress->UART_LCR_H.BIT.fen = BASE_CFG_ENABLE;
 300a870:	fdc42783          	lw	a5,-36(s0)
 300a874:	4398                	lw	a4,0(a5)
 300a876:	575c                	lw	a5,44(a4)
 300a878:	0107e793          	ori	a5,a5,16
 300a87c:	d75c                	sw	a5,44(a4)
        uartHandle->baseAddress->UART_IFLS.BIT.rxiflsel = uartHandle->fifoRxThr;
 300a87e:	fdc42783          	lw	a5,-36(s0)
 300a882:	5bd4                	lw	a3,52(a5)
 300a884:	fdc42783          	lw	a5,-36(s0)
 300a888:	4398                	lw	a4,0(a5)
 300a88a:	87b6                	mv	a5,a3
 300a88c:	8bbd                	andi	a5,a5,15
 300a88e:	0ff7f693          	andi	a3,a5,255
 300a892:	5b5c                	lw	a5,52(a4)
 300a894:	8abd                	andi	a3,a3,15
 300a896:	06a2                	slli	a3,a3,0x8
 300a898:	767d                	lui	a2,0xfffff
 300a89a:	0ff60613          	addi	a2,a2,255 # fffff0ff <RAM_END+0xfbff70ff>
 300a89e:	8ff1                	and	a5,a5,a2
 300a8a0:	8fd5                	or	a5,a5,a3
 300a8a2:	db5c                	sw	a5,52(a4)
        uartHandle->baseAddress->UART_IFLS.BIT.txiflsel = uartHandle->fifoTxThr;
 300a8a4:	fdc42783          	lw	a5,-36(s0)
 300a8a8:	5b94                	lw	a3,48(a5)
 300a8aa:	fdc42783          	lw	a5,-36(s0)
 300a8ae:	4398                	lw	a4,0(a5)
 300a8b0:	87b6                	mv	a5,a3
 300a8b2:	8bbd                	andi	a5,a5,15
 300a8b4:	0ff7f693          	andi	a3,a5,255
 300a8b8:	5b5c                	lw	a5,52(a4)
 300a8ba:	8abd                	andi	a3,a3,15
 300a8bc:	9bc1                	andi	a5,a5,-16
 300a8be:	8fd5                	or	a5,a5,a3
 300a8c0:	db5c                	sw	a5,52(a4)
    }
    if (uartHandle->hwFlowCtr == UART_HW_FLOWCTR_ENABLE) {  /* Hardwarer flow control setting */
 300a8c2:	fdc42783          	lw	a5,-36(s0)
 300a8c6:	5f98                	lw	a4,56(a5)
 300a8c8:	4785                	li	a5,1
 300a8ca:	00f71c63          	bne	a4,a5,300a8e2 <HAL_UART_Init+0x38e>
        uartHandle->baseAddress->UART_CR.reg |= 0xC000;
 300a8ce:	fdc42783          	lw	a5,-36(s0)
 300a8d2:	439c                	lw	a5,0(a5)
 300a8d4:	5b94                	lw	a3,48(a5)
 300a8d6:	fdc42783          	lw	a5,-36(s0)
 300a8da:	439c                	lw	a5,0(a5)
 300a8dc:	6731                	lui	a4,0xc
 300a8de:	8f55                	or	a4,a4,a3
 300a8e0:	db98                	sw	a4,48(a5)
    }
    uartHandle->baseAddress->UART_CR.reg |= 0x301;          /* Enable bit use 0x301 is to set txe/rxe/uarten */
 300a8e2:	fdc42783          	lw	a5,-36(s0)
 300a8e6:	439c                	lw	a5,0(a5)
 300a8e8:	5b98                	lw	a4,48(a5)
 300a8ea:	fdc42783          	lw	a5,-36(s0)
 300a8ee:	439c                	lw	a5,0(a5)
 300a8f0:	30176713          	ori	a4,a4,769
 300a8f4:	db98                	sw	a4,48(a5)
    uartHandle->txState = UART_STATE_READY;
 300a8f6:	fdc42783          	lw	a5,-36(s0)
 300a8fa:	4705                	li	a4,1
 300a8fc:	c7b8                	sw	a4,72(a5)
    uartHandle->rxState = UART_STATE_READY;
 300a8fe:	fdc42783          	lw	a5,-36(s0)
 300a902:	4705                	li	a4,1
 300a904:	c7f8                	sw	a4,76(a5)
    return BASE_STATUS_OK;
 300a906:	4781                	li	a5,0
}
 300a908:	853e                	mv	a0,a5
 300a90a:	50b2                	lw	ra,44(sp)
 300a90c:	5422                	lw	s0,40(sp)
 300a90e:	6145                	addi	sp,sp,48
 300a910:	8082                	ret

0300a912 <HAL_UART_WriteIT>:
  * @param srcData Address of the data buff to be sent.
  * @param dataLength Number of the data to be sent.
  * @retval BASE status type: OK, ERROR, BUSY, TIMEOUT.
  */
BASE_StatusType HAL_UART_WriteIT(UART_Handle *uartHandle, unsigned char *srcData, unsigned int dataLength)
{
 300a912:	1101                	addi	sp,sp,-32
 300a914:	ce06                	sw	ra,28(sp)
 300a916:	cc22                	sw	s0,24(sp)
 300a918:	1000                	addi	s0,sp,32
 300a91a:	fea42623          	sw	a0,-20(s0)
 300a91e:	feb42423          	sw	a1,-24(s0)
 300a922:	fec42223          	sw	a2,-28(s0)
    UART_ASSERT_PARAM(uartHandle != NULL);
 300a926:	fec42783          	lw	a5,-20(s0)
 300a92a:	eb89                	bnez	a5,300a93c <HAL_UART_WriteIT+0x2a>
 300a92c:	14400593          	li	a1,324
 300a930:	030117b7          	lui	a5,0x3011
 300a934:	a9c78513          	addi	a0,a5,-1380 # 3010a9c <g_crgIpMatch+0x58c>
 300a938:	3a3d                	jal	ra,300a276 <AssertErrorLog.trans.8>
 300a93a:	a001                	j	300a93a <HAL_UART_WriteIT+0x28>
    UART_ASSERT_PARAM(IsUARTInstance(uartHandle->baseAddress));
 300a93c:	fec42783          	lw	a5,-20(s0)
 300a940:	4398                	lw	a4,0(a5)
 300a942:	140007b7          	lui	a5,0x14000
 300a946:	02f70f63          	beq	a4,a5,300a984 <HAL_UART_WriteIT+0x72>
 300a94a:	fec42783          	lw	a5,-20(s0)
 300a94e:	4398                	lw	a4,0(a5)
 300a950:	140017b7          	lui	a5,0x14001
 300a954:	02f70863          	beq	a4,a5,300a984 <HAL_UART_WriteIT+0x72>
 300a958:	fec42783          	lw	a5,-20(s0)
 300a95c:	4398                	lw	a4,0(a5)
 300a95e:	140027b7          	lui	a5,0x14002
 300a962:	02f70163          	beq	a4,a5,300a984 <HAL_UART_WriteIT+0x72>
 300a966:	fec42783          	lw	a5,-20(s0)
 300a96a:	4398                	lw	a4,0(a5)
 300a96c:	140037b7          	lui	a5,0x14003
 300a970:	00f70a63          	beq	a4,a5,300a984 <HAL_UART_WriteIT+0x72>
 300a974:	14500593          	li	a1,325
 300a978:	030117b7          	lui	a5,0x3011
 300a97c:	a9c78513          	addi	a0,a5,-1380 # 3010a9c <g_crgIpMatch+0x58c>
 300a980:	38dd                	jal	ra,300a276 <AssertErrorLog.trans.8>
 300a982:	a001                	j	300a982 <HAL_UART_WriteIT+0x70>
    UART_PARAM_CHECK_WITH_RET(uartHandle->txMode == UART_MODE_INTERRUPT, BASE_STATUS_ERROR);
 300a984:	fec42783          	lw	a5,-20(s0)
 300a988:	4bd8                	lw	a4,20(a5)
 300a98a:	4785                	li	a5,1
 300a98c:	00f70b63          	beq	a4,a5,300a9a2 <HAL_UART_WriteIT+0x90>
 300a990:	14600593          	li	a1,326
 300a994:	030117b7          	lui	a5,0x3011
 300a998:	a9c78513          	addi	a0,a5,-1380 # 3010a9c <g_crgIpMatch+0x58c>
 300a99c:	38e9                	jal	ra,300a276 <AssertErrorLog.trans.8>
 300a99e:	4785                	li	a5,1
 300a9a0:	a861                	j	300aa38 <HAL_UART_WriteIT+0x126>
    UART_PARAM_CHECK_WITH_RET(srcData != NULL, BASE_STATUS_ERROR);
 300a9a2:	fe842783          	lw	a5,-24(s0)
 300a9a6:	eb91                	bnez	a5,300a9ba <HAL_UART_WriteIT+0xa8>
 300a9a8:	14700593          	li	a1,327
 300a9ac:	030117b7          	lui	a5,0x3011
 300a9b0:	a9c78513          	addi	a0,a5,-1380 # 3010a9c <g_crgIpMatch+0x58c>
 300a9b4:	2f01                	jal	ra,300b0c4 <AssertErrorLog.trans.9>
 300a9b6:	4785                	li	a5,1
 300a9b8:	a041                	j	300aa38 <HAL_UART_WriteIT+0x126>
    UART_PARAM_CHECK_WITH_RET(dataLength > 0, BASE_STATUS_ERROR);
 300a9ba:	fe442783          	lw	a5,-28(s0)
 300a9be:	eb91                	bnez	a5,300a9d2 <HAL_UART_WriteIT+0xc0>
 300a9c0:	14800593          	li	a1,328
 300a9c4:	030117b7          	lui	a5,0x3011
 300a9c8:	a9c78513          	addi	a0,a5,-1380 # 3010a9c <g_crgIpMatch+0x58c>
 300a9cc:	2de5                	jal	ra,300b0c4 <AssertErrorLog.trans.9>
 300a9ce:	4785                	li	a5,1
 300a9d0:	a0a5                	j	300aa38 <HAL_UART_WriteIT+0x126>

    if (uartHandle->txState == UART_STATE_READY) {
 300a9d2:	fec42783          	lw	a5,-20(s0)
 300a9d6:	47b8                	lw	a4,72(a5)
 300a9d8:	4785                	li	a5,1
 300a9da:	04f71c63          	bne	a4,a5,300aa32 <HAL_UART_WriteIT+0x120>
        uartHandle->txState = UART_STATE_BUSY_TX;
 300a9de:	fec42783          	lw	a5,-20(s0)
 300a9e2:	470d                	li	a4,3
 300a9e4:	c7b8                	sw	a4,72(a5)
        uartHandle->txbuff = srcData;
 300a9e6:	fec42783          	lw	a5,-20(s0)
 300a9ea:	fe842703          	lw	a4,-24(s0)
 300a9ee:	cfd8                	sw	a4,28(a5)
        uartHandle->txBuffSize = dataLength;
 300a9f0:	fec42783          	lw	a5,-20(s0)
 300a9f4:	fe442703          	lw	a4,-28(s0)
 300a9f8:	d3d8                	sw	a4,36(a5)
        uartHandle->baseAddress->UART_ICR.BIT.txic = BASE_CFG_ENABLE;
 300a9fa:	fec42783          	lw	a5,-20(s0)
 300a9fe:	4398                	lw	a4,0(a5)
 300aa00:	437c                	lw	a5,68(a4)
 300aa02:	0207e793          	ori	a5,a5,32
 300aa06:	c37c                	sw	a5,68(a4)
        if (uartHandle->fifoMode == true) {
 300aa08:	fec42783          	lw	a5,-20(s0)
 300aa0c:	02c7c783          	lbu	a5,44(a5)
 300aa10:	cb89                	beqz	a5,300aa22 <HAL_UART_WriteIT+0x110>
            uartHandle->baseAddress->UART_IMSC.BIT.txim = BASE_CFG_ENABLE;
 300aa12:	fec42783          	lw	a5,-20(s0)
 300aa16:	4398                	lw	a4,0(a5)
 300aa18:	5f1c                	lw	a5,56(a4)
 300aa1a:	0207e793          	ori	a5,a5,32
 300aa1e:	df1c                	sw	a5,56(a4)
 300aa20:	a819                	j	300aa36 <HAL_UART_WriteIT+0x124>
        } else {
            uartHandle->baseAddress->UART_IMSC.BIT.txfeim = BASE_CFG_ENABLE;
 300aa22:	fec42783          	lw	a5,-20(s0)
 300aa26:	4398                	lw	a4,0(a5)
 300aa28:	5f1c                	lw	a5,56(a4)
 300aa2a:	6685                	lui	a3,0x1
 300aa2c:	8fd5                	or	a5,a5,a3
 300aa2e:	df1c                	sw	a5,56(a4)
 300aa30:	a019                	j	300aa36 <HAL_UART_WriteIT+0x124>
        }
    } else {
        return BASE_STATUS_BUSY;
 300aa32:	4789                	li	a5,2
 300aa34:	a011                	j	300aa38 <HAL_UART_WriteIT+0x126>
    }
    return BASE_STATUS_OK;
 300aa36:	4781                	li	a5,0
}
 300aa38:	853e                	mv	a0,a5
 300aa3a:	40f2                	lw	ra,28(sp)
 300aa3c:	4462                	lw	s0,24(sp)
 300aa3e:	6105                	addi	sp,sp,32
 300aa40:	8082                	ret

0300aa42 <WriteITCallBack>:
  *        The hanler function is called when Tx interruption occurs.
  * @param uartHandle UART handle.
  * @retval None.
  */
static void WriteITCallBack(UART_Handle *uartHandle)
{
 300aa42:	1101                	addi	sp,sp,-32
 300aa44:	ce06                	sw	ra,28(sp)
 300aa46:	cc22                	sw	s0,24(sp)
 300aa48:	1000                	addi	s0,sp,32
 300aa4a:	fea42623          	sw	a0,-20(s0)
    UART_ASSERT_PARAM(uartHandle != NULL);
 300aa4e:	fec42783          	lw	a5,-20(s0)
 300aa52:	eb89                	bnez	a5,300aa64 <WriteITCallBack+0x22>
 300aa54:	16200593          	li	a1,354
 300aa58:	030117b7          	lui	a5,0x3011
 300aa5c:	a9c78513          	addi	a0,a5,-1380 # 3010a9c <g_crgIpMatch+0x58c>
 300aa60:	2595                	jal	ra,300b0c4 <AssertErrorLog.trans.9>
 300aa62:	a001                	j	300aa62 <WriteITCallBack+0x20>
    UART_ASSERT_PARAM(IsUARTInstance(uartHandle->baseAddress));
 300aa64:	fec42783          	lw	a5,-20(s0)
 300aa68:	4398                	lw	a4,0(a5)
 300aa6a:	140007b7          	lui	a5,0x14000
 300aa6e:	02f70f63          	beq	a4,a5,300aaac <WriteITCallBack+0x6a>
 300aa72:	fec42783          	lw	a5,-20(s0)
 300aa76:	4398                	lw	a4,0(a5)
 300aa78:	140017b7          	lui	a5,0x14001
 300aa7c:	02f70863          	beq	a4,a5,300aaac <WriteITCallBack+0x6a>
 300aa80:	fec42783          	lw	a5,-20(s0)
 300aa84:	4398                	lw	a4,0(a5)
 300aa86:	140027b7          	lui	a5,0x14002
 300aa8a:	02f70163          	beq	a4,a5,300aaac <WriteITCallBack+0x6a>
 300aa8e:	fec42783          	lw	a5,-20(s0)
 300aa92:	4398                	lw	a4,0(a5)
 300aa94:	140037b7          	lui	a5,0x14003
 300aa98:	00f70a63          	beq	a4,a5,300aaac <WriteITCallBack+0x6a>
 300aa9c:	16300593          	li	a1,355
 300aaa0:	030117b7          	lui	a5,0x3011
 300aaa4:	a9c78513          	addi	a0,a5,-1380 # 3010a9c <g_crgIpMatch+0x58c>
 300aaa8:	2d31                	jal	ra,300b0c4 <AssertErrorLog.trans.9>
 300aaaa:	a001                	j	300aaaa <WriteITCallBack+0x68>
    UART_ASSERT_PARAM(uartHandle->txbuff != NULL);
 300aaac:	fec42783          	lw	a5,-20(s0)
 300aab0:	4fdc                	lw	a5,28(a5)
 300aab2:	eb89                	bnez	a5,300aac4 <WriteITCallBack+0x82>
 300aab4:	16400593          	li	a1,356
 300aab8:	030117b7          	lui	a5,0x3011
 300aabc:	a9c78513          	addi	a0,a5,-1380 # 3010a9c <g_crgIpMatch+0x58c>
 300aac0:	2511                	jal	ra,300b0c4 <AssertErrorLog.trans.9>
 300aac2:	a001                	j	300aac2 <WriteITCallBack+0x80>
    if (uartHandle->txState == UART_STATE_BUSY_TX) {
 300aac4:	fec42783          	lw	a5,-20(s0)
 300aac8:	47b8                	lw	a4,72(a5)
 300aaca:	478d                	li	a5,3
 300aacc:	0af71f63          	bne	a4,a5,300ab8a <WriteITCallBack+0x148>
        while (uartHandle->txBuffSize > 0) {
 300aad0:	a8a1                	j	300ab28 <WriteITCallBack+0xe6>
            if (uartHandle->baseAddress->UART_FR.BIT.txff == 1) {  /* True when the TX FIFO is full */
 300aad2:	fec42783          	lw	a5,-20(s0)
 300aad6:	439c                	lw	a5,0(a5)
 300aad8:	4f9c                	lw	a5,24(a5)
 300aada:	8395                	srli	a5,a5,0x5
 300aadc:	8b85                	andi	a5,a5,1
 300aade:	0ff7f713          	andi	a4,a5,255
 300aae2:	4785                	li	a5,1
 300aae4:	04f70763          	beq	a4,a5,300ab32 <WriteITCallBack+0xf0>
                break;
            }
            uartHandle->baseAddress->UART_DR.BIT.data = *(uartHandle->txbuff);
 300aae8:	fec42783          	lw	a5,-20(s0)
 300aaec:	4fdc                	lw	a5,28(a5)
 300aaee:	fec42703          	lw	a4,-20(s0)
 300aaf2:	4318                	lw	a4,0(a4)
 300aaf4:	239c                	lbu	a5,0(a5)
 300aaf6:	0ff7f693          	andi	a3,a5,255
 300aafa:	431c                	lw	a5,0(a4)
 300aafc:	0ff6f693          	andi	a3,a3,255
 300ab00:	f007f793          	andi	a5,a5,-256
 300ab04:	8fd5                	or	a5,a5,a3
 300ab06:	c31c                	sw	a5,0(a4)
            (uartHandle->txbuff)++;
 300ab08:	fec42783          	lw	a5,-20(s0)
 300ab0c:	4fdc                	lw	a5,28(a5)
 300ab0e:	00178713          	addi	a4,a5,1
 300ab12:	fec42783          	lw	a5,-20(s0)
 300ab16:	cfd8                	sw	a4,28(a5)
            uartHandle->txBuffSize -= 1;
 300ab18:	fec42783          	lw	a5,-20(s0)
 300ab1c:	53dc                	lw	a5,36(a5)
 300ab1e:	fff78713          	addi	a4,a5,-1
 300ab22:	fec42783          	lw	a5,-20(s0)
 300ab26:	d3d8                	sw	a4,36(a5)
        while (uartHandle->txBuffSize > 0) {
 300ab28:	fec42783          	lw	a5,-20(s0)
 300ab2c:	53dc                	lw	a5,36(a5)
 300ab2e:	f3d5                	bnez	a5,300aad2 <WriteITCallBack+0x90>
 300ab30:	a011                	j	300ab34 <WriteITCallBack+0xf2>
                break;
 300ab32:	0001                	nop
        }
        if (uartHandle->txBuffSize == 0) {
 300ab34:	fec42783          	lw	a5,-20(s0)
 300ab38:	53dc                	lw	a5,36(a5)
 300ab3a:	eba1                	bnez	a5,300ab8a <WriteITCallBack+0x148>
            uartHandle->baseAddress->UART_IMSC.reg &= 0xFFFFEFDF;  /* Disable txim and txfeim */
 300ab3c:	fec42783          	lw	a5,-20(s0)
 300ab40:	439c                	lw	a5,0(a5)
 300ab42:	5f94                	lw	a3,56(a5)
 300ab44:	fec42783          	lw	a5,-20(s0)
 300ab48:	439c                	lw	a5,0(a5)
 300ab4a:	777d                	lui	a4,0xfffff
 300ab4c:	fdf70713          	addi	a4,a4,-33 # ffffefdf <RAM_END+0xfbff6fdf>
 300ab50:	8f75                	and	a4,a4,a3
 300ab52:	df98                	sw	a4,56(a5)
            uartHandle->baseAddress->UART_ICR.reg |= 0x1020;       /* Clear txic and txfeic */
 300ab54:	fec42783          	lw	a5,-20(s0)
 300ab58:	439c                	lw	a5,0(a5)
 300ab5a:	43f4                	lw	a3,68(a5)
 300ab5c:	fec42783          	lw	a5,-20(s0)
 300ab60:	439c                	lw	a5,0(a5)
 300ab62:	6705                	lui	a4,0x1
 300ab64:	02070713          	addi	a4,a4,32 # 1020 <__bss_size__+0x3ac>
 300ab68:	8f55                	or	a4,a4,a3
 300ab6a:	c3f8                	sw	a4,68(a5)
            uartHandle->txState = UART_STATE_READY;
 300ab6c:	fec42783          	lw	a5,-20(s0)
 300ab70:	4705                	li	a4,1
 300ab72:	c7b8                	sw	a4,72(a5)
            /* Call user call back function */
            if (uartHandle->userCallBack.WriteItFinishCallBack != NULL) {
 300ab74:	fec42783          	lw	a5,-20(s0)
 300ab78:	4bfc                	lw	a5,84(a5)
 300ab7a:	cb81                	beqz	a5,300ab8a <WriteITCallBack+0x148>
                uartHandle->userCallBack.WriteItFinishCallBack(uartHandle);
 300ab7c:	fec42783          	lw	a5,-20(s0)
 300ab80:	4bfc                	lw	a5,84(a5)
 300ab82:	fec42503          	lw	a0,-20(s0)
 300ab86:	9782                	jalr	a5
            }
        }
    }
    return;
 300ab88:	0001                	nop
 300ab8a:	0001                	nop
}
 300ab8c:	40f2                	lw	ra,28(sp)
 300ab8e:	4462                	lw	s0,24(sp)
 300ab90:	6105                	addi	sp,sp,32
 300ab92:	8082                	ret

0300ab94 <HAL_UART_ReadIT>:
  * @param saveData Address of the data buff to be saved.
  * @param dataLength length of the data int the storage buffer.
  * @retval BASE status type: OK, ERROR, BUSY, TIMEOUT.
  */
BASE_StatusType HAL_UART_ReadIT(UART_Handle *uartHandle, unsigned char *saveData, unsigned int dataLength)
{
 300ab94:	1101                	addi	sp,sp,-32
 300ab96:	ce06                	sw	ra,28(sp)
 300ab98:	cc22                	sw	s0,24(sp)
 300ab9a:	1000                	addi	s0,sp,32
 300ab9c:	fea42623          	sw	a0,-20(s0)
 300aba0:	feb42423          	sw	a1,-24(s0)
 300aba4:	fec42223          	sw	a2,-28(s0)
    UART_ASSERT_PARAM(uartHandle != NULL);
 300aba8:	fec42783          	lw	a5,-20(s0)
 300abac:	eb89                	bnez	a5,300abbe <HAL_UART_ReadIT+0x2a>
 300abae:	1e100593          	li	a1,481
 300abb2:	030117b7          	lui	a5,0x3011
 300abb6:	a9c78513          	addi	a0,a5,-1380 # 3010a9c <g_crgIpMatch+0x58c>
 300abba:	2329                	jal	ra,300b0c4 <AssertErrorLog.trans.9>
 300abbc:	a001                	j	300abbc <HAL_UART_ReadIT+0x28>
    UART_ASSERT_PARAM(IsUARTInstance(uartHandle->baseAddress));
 300abbe:	fec42783          	lw	a5,-20(s0)
 300abc2:	4398                	lw	a4,0(a5)
 300abc4:	140007b7          	lui	a5,0x14000
 300abc8:	02f70f63          	beq	a4,a5,300ac06 <HAL_UART_ReadIT+0x72>
 300abcc:	fec42783          	lw	a5,-20(s0)
 300abd0:	4398                	lw	a4,0(a5)
 300abd2:	140017b7          	lui	a5,0x14001
 300abd6:	02f70863          	beq	a4,a5,300ac06 <HAL_UART_ReadIT+0x72>
 300abda:	fec42783          	lw	a5,-20(s0)
 300abde:	4398                	lw	a4,0(a5)
 300abe0:	140027b7          	lui	a5,0x14002
 300abe4:	02f70163          	beq	a4,a5,300ac06 <HAL_UART_ReadIT+0x72>
 300abe8:	fec42783          	lw	a5,-20(s0)
 300abec:	4398                	lw	a4,0(a5)
 300abee:	140037b7          	lui	a5,0x14003
 300abf2:	00f70a63          	beq	a4,a5,300ac06 <HAL_UART_ReadIT+0x72>
 300abf6:	1e200593          	li	a1,482
 300abfa:	030117b7          	lui	a5,0x3011
 300abfe:	a9c78513          	addi	a0,a5,-1380 # 3010a9c <g_crgIpMatch+0x58c>
 300ac02:	21c9                	jal	ra,300b0c4 <AssertErrorLog.trans.9>
 300ac04:	a001                	j	300ac04 <HAL_UART_ReadIT+0x70>
    UART_ASSERT_PARAM(saveData != NULL);
 300ac06:	fe842783          	lw	a5,-24(s0)
 300ac0a:	eb89                	bnez	a5,300ac1c <HAL_UART_ReadIT+0x88>
 300ac0c:	1e300593          	li	a1,483
 300ac10:	030117b7          	lui	a5,0x3011
 300ac14:	a9c78513          	addi	a0,a5,-1380 # 3010a9c <g_crgIpMatch+0x58c>
 300ac18:	2175                	jal	ra,300b0c4 <AssertErrorLog.trans.9>
 300ac1a:	a001                	j	300ac1a <HAL_UART_ReadIT+0x86>
    UART_PARAM_CHECK_WITH_RET(uartHandle->rxMode == UART_MODE_INTERRUPT, BASE_STATUS_ERROR);
 300ac1c:	fec42783          	lw	a5,-20(s0)
 300ac20:	4f98                	lw	a4,24(a5)
 300ac22:	4785                	li	a5,1
 300ac24:	00f70b63          	beq	a4,a5,300ac3a <HAL_UART_ReadIT+0xa6>
 300ac28:	1e400593          	li	a1,484
 300ac2c:	030117b7          	lui	a5,0x3011
 300ac30:	a9c78513          	addi	a0,a5,-1380 # 3010a9c <g_crgIpMatch+0x58c>
 300ac34:	2941                	jal	ra,300b0c4 <AssertErrorLog.trans.9>
 300ac36:	4785                	li	a5,1
 300ac38:	a051                	j	300acbc <HAL_UART_ReadIT+0x128>
    UART_PARAM_CHECK_WITH_RET(dataLength > 0, BASE_STATUS_ERROR);
 300ac3a:	fe442783          	lw	a5,-28(s0)
 300ac3e:	eb91                	bnez	a5,300ac52 <HAL_UART_ReadIT+0xbe>
 300ac40:	1e500593          	li	a1,485
 300ac44:	030117b7          	lui	a5,0x3011
 300ac48:	a9c78513          	addi	a0,a5,-1380 # 3010a9c <g_crgIpMatch+0x58c>
 300ac4c:	29a5                	jal	ra,300b0c4 <AssertErrorLog.trans.9>
 300ac4e:	4785                	li	a5,1
 300ac50:	a0b5                	j	300acbc <HAL_UART_ReadIT+0x128>
    if (uartHandle->rxState == UART_STATE_READY) {
 300ac52:	fec42783          	lw	a5,-20(s0)
 300ac56:	47f8                	lw	a4,76(a5)
 300ac58:	4785                	li	a5,1
 300ac5a:	04f71e63          	bne	a4,a5,300acb6 <HAL_UART_ReadIT+0x122>
        uartHandle->rxState = UART_STATE_BUSY_RX;
 300ac5e:	fec42783          	lw	a5,-20(s0)
 300ac62:	4711                	li	a4,4
 300ac64:	c7f8                	sw	a4,76(a5)
        uartHandle->rxbuff = saveData;
 300ac66:	fec42783          	lw	a5,-20(s0)
 300ac6a:	fe842703          	lw	a4,-24(s0)
 300ac6e:	d398                	sw	a4,32(a5)
        uartHandle->rxBuffSize = dataLength;
 300ac70:	fec42783          	lw	a5,-20(s0)
 300ac74:	fe442703          	lw	a4,-28(s0)
 300ac78:	d798                	sw	a4,40(a5)
        if (uartHandle->fifoMode == true) {
 300ac7a:	fec42783          	lw	a5,-20(s0)
 300ac7e:	02c7c783          	lbu	a5,44(a5)
 300ac82:	cf81                	beqz	a5,300ac9a <HAL_UART_ReadIT+0x106>
            uartHandle->baseAddress->UART_IMSC.reg |= 0x7D0;  /* Enable rx interrupt and rx timeout interrupt */
 300ac84:	fec42783          	lw	a5,-20(s0)
 300ac88:	439c                	lw	a5,0(a5)
 300ac8a:	5f98                	lw	a4,56(a5)
 300ac8c:	fec42783          	lw	a5,-20(s0)
 300ac90:	439c                	lw	a5,0(a5)
 300ac92:	7d076713          	ori	a4,a4,2000
 300ac96:	df98                	sw	a4,56(a5)
 300ac98:	a00d                	j	300acba <HAL_UART_ReadIT+0x126>
        } else {
            uartHandle->baseAddress->UART_IMSC.reg |= 0x20780;  /* Enable rx not empty interrupt */
 300ac9a:	fec42783          	lw	a5,-20(s0)
 300ac9e:	439c                	lw	a5,0(a5)
 300aca0:	5f94                	lw	a3,56(a5)
 300aca2:	fec42783          	lw	a5,-20(s0)
 300aca6:	439c                	lw	a5,0(a5)
 300aca8:	00020737          	lui	a4,0x20
 300acac:	78070713          	addi	a4,a4,1920 # 20780 <FLASH_SIZE+0x784>
 300acb0:	8f55                	or	a4,a4,a3
 300acb2:	df98                	sw	a4,56(a5)
 300acb4:	a019                	j	300acba <HAL_UART_ReadIT+0x126>
        }
    } else {
        return BASE_STATUS_BUSY;
 300acb6:	4789                	li	a5,2
 300acb8:	a011                	j	300acbc <HAL_UART_ReadIT+0x128>
    }
    return BASE_STATUS_OK;
 300acba:	4781                	li	a5,0
}
 300acbc:	853e                	mv	a0,a5
 300acbe:	40f2                	lw	ra,28(sp)
 300acc0:	4462                	lw	s0,24(sp)
 300acc2:	6105                	addi	sp,sp,32
 300acc4:	8082                	ret

0300acc6 <ReadITCallBack>:
  *        The hanler function is called when Rx interruption occurs.
  * @param uartHandle UART handle.
  * @retval None.
  */
static void ReadITCallBack(UART_Handle *uartHandle)
{
 300acc6:	7179                	addi	sp,sp,-48
 300acc8:	d606                	sw	ra,44(sp)
 300acca:	d422                	sw	s0,40(sp)
 300accc:	1800                	addi	s0,sp,48
 300acce:	fca42e23          	sw	a0,-36(s0)
    UART_ASSERT_PARAM(uartHandle != NULL);
 300acd2:	fdc42783          	lw	a5,-36(s0)
 300acd6:	eb89                	bnez	a5,300ace8 <ReadITCallBack+0x22>
 300acd8:	1fd00593          	li	a1,509
 300acdc:	030117b7          	lui	a5,0x3011
 300ace0:	a9c78513          	addi	a0,a5,-1380 # 3010a9c <g_crgIpMatch+0x58c>
 300ace4:	26c5                	jal	ra,300b0c4 <AssertErrorLog.trans.9>
 300ace6:	a001                	j	300ace6 <ReadITCallBack+0x20>
    UART_ASSERT_PARAM(uartHandle->rxbuff != NULL);
 300ace8:	fdc42783          	lw	a5,-36(s0)
 300acec:	539c                	lw	a5,32(a5)
 300acee:	eb89                	bnez	a5,300ad00 <ReadITCallBack+0x3a>
 300acf0:	1fe00593          	li	a1,510
 300acf4:	030117b7          	lui	a5,0x3011
 300acf8:	a9c78513          	addi	a0,a5,-1380 # 3010a9c <g_crgIpMatch+0x58c>
 300acfc:	26e1                	jal	ra,300b0c4 <AssertErrorLog.trans.9>
 300acfe:	a001                	j	300acfe <ReadITCallBack+0x38>
    UART_ASSERT_PARAM(IsUARTInstance(uartHandle->baseAddress));
 300ad00:	fdc42783          	lw	a5,-36(s0)
 300ad04:	4398                	lw	a4,0(a5)
 300ad06:	140007b7          	lui	a5,0x14000
 300ad0a:	02f70f63          	beq	a4,a5,300ad48 <ReadITCallBack+0x82>
 300ad0e:	fdc42783          	lw	a5,-36(s0)
 300ad12:	4398                	lw	a4,0(a5)
 300ad14:	140017b7          	lui	a5,0x14001
 300ad18:	02f70863          	beq	a4,a5,300ad48 <ReadITCallBack+0x82>
 300ad1c:	fdc42783          	lw	a5,-36(s0)
 300ad20:	4398                	lw	a4,0(a5)
 300ad22:	140027b7          	lui	a5,0x14002
 300ad26:	02f70163          	beq	a4,a5,300ad48 <ReadITCallBack+0x82>
 300ad2a:	fdc42783          	lw	a5,-36(s0)
 300ad2e:	4398                	lw	a4,0(a5)
 300ad30:	140037b7          	lui	a5,0x14003
 300ad34:	00f70a63          	beq	a4,a5,300ad48 <ReadITCallBack+0x82>
 300ad38:	1ff00593          	li	a1,511
 300ad3c:	030117b7          	lui	a5,0x3011
 300ad40:	a9c78513          	addi	a0,a5,-1380 # 3010a9c <g_crgIpMatch+0x58c>
 300ad44:	2641                	jal	ra,300b0c4 <AssertErrorLog.trans.9>
 300ad46:	a001                	j	300ad46 <ReadITCallBack+0x80>
    if (uartHandle->rxState == UART_STATE_BUSY_RX) {
 300ad48:	fdc42783          	lw	a5,-36(s0)
 300ad4c:	47f8                	lw	a4,76(a5)
 300ad4e:	4791                	li	a5,4
 300ad50:	0cf71163          	bne	a4,a5,300ae12 <ReadITCallBack+0x14c>
        unsigned int tmp;
        while (uartHandle->rxBuffSize > 0) {
 300ad54:	a889                	j	300ada6 <ReadITCallBack+0xe0>
            if (uartHandle->baseAddress->UART_FR.BIT.rxfe == 0x01) {    /* True when the RX FIFO is empty */
 300ad56:	fdc42783          	lw	a5,-36(s0)
 300ad5a:	439c                	lw	a5,0(a5)
 300ad5c:	4f9c                	lw	a5,24(a5)
 300ad5e:	8391                	srli	a5,a5,0x4
 300ad60:	8b85                	andi	a5,a5,1
 300ad62:	0ff7f713          	andi	a4,a5,255
 300ad66:	4785                	li	a5,1
 300ad68:	04f70463          	beq	a4,a5,300adb0 <ReadITCallBack+0xea>
                break;
            }
            tmp = uartHandle->baseAddress->UART_DR.reg;
 300ad6c:	fdc42783          	lw	a5,-36(s0)
 300ad70:	439c                	lw	a5,0(a5)
 300ad72:	439c                	lw	a5,0(a5)
 300ad74:	fef42623          	sw	a5,-20(s0)
            *(uartHandle->rxbuff) = (tmp & 0xFF);     /* Read from DR when holding register/FIFO is not empty */
 300ad78:	fdc42783          	lw	a5,-36(s0)
 300ad7c:	539c                	lw	a5,32(a5)
 300ad7e:	fec42703          	lw	a4,-20(s0)
 300ad82:	9f01                	uxtb	a4
 300ad84:	a398                	sb	a4,0(a5)
            uartHandle->rxbuff++;
 300ad86:	fdc42783          	lw	a5,-36(s0)
 300ad8a:	539c                	lw	a5,32(a5)
 300ad8c:	00178713          	addi	a4,a5,1
 300ad90:	fdc42783          	lw	a5,-36(s0)
 300ad94:	d398                	sw	a4,32(a5)
            uartHandle->rxBuffSize -= 1;
 300ad96:	fdc42783          	lw	a5,-36(s0)
 300ad9a:	579c                	lw	a5,40(a5)
 300ad9c:	fff78713          	addi	a4,a5,-1
 300ada0:	fdc42783          	lw	a5,-36(s0)
 300ada4:	d798                	sw	a4,40(a5)
        while (uartHandle->rxBuffSize > 0) {
 300ada6:	fdc42783          	lw	a5,-36(s0)
 300adaa:	579c                	lw	a5,40(a5)
 300adac:	f7cd                	bnez	a5,300ad56 <ReadITCallBack+0x90>
 300adae:	a011                	j	300adb2 <ReadITCallBack+0xec>
                break;
 300adb0:	0001                	nop
        }
        if (uartHandle->rxBuffSize == 0) {
 300adb2:	fdc42783          	lw	a5,-36(s0)
 300adb6:	579c                	lw	a5,40(a5)
 300adb8:	e38d                	bnez	a5,300adda <ReadITCallBack+0x114>
            uartHandle->baseAddress->UART_IMSC.reg &= 0xFFFDFFAF;   /* Disable rxim ,rtim and rxfneim */
 300adba:	fdc42783          	lw	a5,-36(s0)
 300adbe:	439c                	lw	a5,0(a5)
 300adc0:	5f94                	lw	a3,56(a5)
 300adc2:	fdc42783          	lw	a5,-36(s0)
 300adc6:	439c                	lw	a5,0(a5)
 300adc8:	7701                	lui	a4,0xfffe0
 300adca:	faf70713          	addi	a4,a4,-81 # fffdffaf <RAM_END+0xfbfd7faf>
 300adce:	8f75                	and	a4,a4,a3
 300add0:	df98                	sw	a4,56(a5)
            uartHandle->rxState = UART_STATE_READY;
 300add2:	fdc42783          	lw	a5,-36(s0)
 300add6:	4705                	li	a4,1
 300add8:	c7f8                	sw	a4,76(a5)
        }
        uartHandle->baseAddress->UART_ICR.reg |= 0x20050;      /* Clear rxic, rtic and rxfneic */
 300adda:	fdc42783          	lw	a5,-36(s0)
 300adde:	439c                	lw	a5,0(a5)
 300ade0:	43f4                	lw	a3,68(a5)
 300ade2:	fdc42783          	lw	a5,-36(s0)
 300ade6:	439c                	lw	a5,0(a5)
 300ade8:	00020737          	lui	a4,0x20
 300adec:	05070713          	addi	a4,a4,80 # 20050 <FLASH_SIZE+0x54>
 300adf0:	8f55                	or	a4,a4,a3
 300adf2:	c3f8                	sw	a4,68(a5)
        if (uartHandle->userCallBack.ReadItFinishCallBack != NULL && uartHandle->rxBuffSize == 0) {
 300adf4:	fdc42783          	lw	a5,-36(s0)
 300adf8:	4fbc                	lw	a5,88(a5)
 300adfa:	cf81                	beqz	a5,300ae12 <ReadITCallBack+0x14c>
 300adfc:	fdc42783          	lw	a5,-36(s0)
 300ae00:	579c                	lw	a5,40(a5)
 300ae02:	eb81                	bnez	a5,300ae12 <ReadITCallBack+0x14c>
            uartHandle->userCallBack.ReadItFinishCallBack(uartHandle);
 300ae04:	fdc42783          	lw	a5,-36(s0)
 300ae08:	4fbc                	lw	a5,88(a5)
 300ae0a:	fdc42503          	lw	a0,-36(s0)
 300ae0e:	9782                	jalr	a5
        }
    }
    return;
 300ae10:	0001                	nop
 300ae12:	0001                	nop
}
 300ae14:	50b2                	lw	ra,44(sp)
 300ae16:	5422                	lw	s0,40(sp)
 300ae18:	6145                	addi	sp,sp,48
 300ae1a:	8082                	ret

0300ae1c <ErrorServiceCallback>:
  * @brief Error handler function of receiving.
  * @param uartHandle UART handle.
  * @retval None.
  */
static void ErrorServiceCallback(UART_Handle *uartHandle)
{
 300ae1c:	7179                	addi	sp,sp,-48
 300ae1e:	d606                	sw	ra,44(sp)
 300ae20:	d422                	sw	s0,40(sp)
 300ae22:	1800                	addi	s0,sp,48
 300ae24:	fca42e23          	sw	a0,-36(s0)
    unsigned int error = 0x00;
 300ae28:	fe042623          	sw	zero,-20(s0)
    if (uartHandle->baseAddress->UART_MIS.BIT.oemis == BASE_CFG_ENABLE) {            /* Overflow error interrupt */
 300ae2c:	fdc42783          	lw	a5,-36(s0)
 300ae30:	439c                	lw	a5,0(a5)
 300ae32:	43bc                	lw	a5,64(a5)
 300ae34:	83a9                	srli	a5,a5,0xa
 300ae36:	8b85                	andi	a5,a5,1
 300ae38:	0ff7f713          	andi	a4,a5,255
 300ae3c:	4785                	li	a5,1
 300ae3e:	02f71763          	bne	a4,a5,300ae6c <ErrorServiceCallback+0x50>
        error |= uartHandle->baseAddress->UART_MIS.BIT.oemis;
 300ae42:	fdc42783          	lw	a5,-36(s0)
 300ae46:	439c                	lw	a5,0(a5)
 300ae48:	43bc                	lw	a5,64(a5)
 300ae4a:	83a9                	srli	a5,a5,0xa
 300ae4c:	8b85                	andi	a5,a5,1
 300ae4e:	9f81                	uxtb	a5
 300ae50:	873e                	mv	a4,a5
 300ae52:	fec42783          	lw	a5,-20(s0)
 300ae56:	8fd9                	or	a5,a5,a4
 300ae58:	fef42623          	sw	a5,-20(s0)
        uartHandle->baseAddress->UART_ICR.BIT.oeic = BASE_CFG_ENABLE;
 300ae5c:	fdc42783          	lw	a5,-36(s0)
 300ae60:	4398                	lw	a4,0(a5)
 300ae62:	437c                	lw	a5,68(a4)
 300ae64:	4007e793          	ori	a5,a5,1024
 300ae68:	c37c                	sw	a5,68(a4)
 300ae6a:	a0c1                	j	300af2a <ErrorServiceCallback+0x10e>
    } else if (uartHandle->baseAddress->UART_MIS.BIT.bemis == BASE_CFG_ENABLE) {     /* Break error interrupt */
 300ae6c:	fdc42783          	lw	a5,-36(s0)
 300ae70:	439c                	lw	a5,0(a5)
 300ae72:	43bc                	lw	a5,64(a5)
 300ae74:	83a5                	srli	a5,a5,0x9
 300ae76:	8b85                	andi	a5,a5,1
 300ae78:	0ff7f713          	andi	a4,a5,255
 300ae7c:	4785                	li	a5,1
 300ae7e:	02f71763          	bne	a4,a5,300aeac <ErrorServiceCallback+0x90>
        error |= uartHandle->baseAddress->UART_MIS.BIT.bemis;
 300ae82:	fdc42783          	lw	a5,-36(s0)
 300ae86:	439c                	lw	a5,0(a5)
 300ae88:	43bc                	lw	a5,64(a5)
 300ae8a:	83a5                	srli	a5,a5,0x9
 300ae8c:	8b85                	andi	a5,a5,1
 300ae8e:	9f81                	uxtb	a5
 300ae90:	873e                	mv	a4,a5
 300ae92:	fec42783          	lw	a5,-20(s0)
 300ae96:	8fd9                	or	a5,a5,a4
 300ae98:	fef42623          	sw	a5,-20(s0)
        uartHandle->baseAddress->UART_ICR.BIT.beic = BASE_CFG_ENABLE;
 300ae9c:	fdc42783          	lw	a5,-36(s0)
 300aea0:	4398                	lw	a4,0(a5)
 300aea2:	437c                	lw	a5,68(a4)
 300aea4:	2007e793          	ori	a5,a5,512
 300aea8:	c37c                	sw	a5,68(a4)
 300aeaa:	a041                	j	300af2a <ErrorServiceCallback+0x10e>
    } else if (uartHandle->baseAddress->UART_MIS.BIT.pemis == BASE_CFG_ENABLE) {     /* Check error interrupt */
 300aeac:	fdc42783          	lw	a5,-36(s0)
 300aeb0:	439c                	lw	a5,0(a5)
 300aeb2:	43bc                	lw	a5,64(a5)
 300aeb4:	83a1                	srli	a5,a5,0x8
 300aeb6:	8b85                	andi	a5,a5,1
 300aeb8:	0ff7f713          	andi	a4,a5,255
 300aebc:	4785                	li	a5,1
 300aebe:	02f71763          	bne	a4,a5,300aeec <ErrorServiceCallback+0xd0>
        error |= uartHandle->baseAddress->UART_MIS.BIT.pemis;
 300aec2:	fdc42783          	lw	a5,-36(s0)
 300aec6:	439c                	lw	a5,0(a5)
 300aec8:	43bc                	lw	a5,64(a5)
 300aeca:	83a1                	srli	a5,a5,0x8
 300aecc:	8b85                	andi	a5,a5,1
 300aece:	9f81                	uxtb	a5
 300aed0:	873e                	mv	a4,a5
 300aed2:	fec42783          	lw	a5,-20(s0)
 300aed6:	8fd9                	or	a5,a5,a4
 300aed8:	fef42623          	sw	a5,-20(s0)
        uartHandle->baseAddress->UART_ICR.BIT.peic = BASE_CFG_ENABLE;
 300aedc:	fdc42783          	lw	a5,-36(s0)
 300aee0:	4398                	lw	a4,0(a5)
 300aee2:	437c                	lw	a5,68(a4)
 300aee4:	1007e793          	ori	a5,a5,256
 300aee8:	c37c                	sw	a5,68(a4)
 300aeea:	a081                	j	300af2a <ErrorServiceCallback+0x10e>
    } else if (uartHandle->baseAddress->UART_MIS.BIT.femis == BASE_CFG_ENABLE) {     /* Frame error interrupt */
 300aeec:	fdc42783          	lw	a5,-36(s0)
 300aef0:	439c                	lw	a5,0(a5)
 300aef2:	43bc                	lw	a5,64(a5)
 300aef4:	839d                	srli	a5,a5,0x7
 300aef6:	8b85                	andi	a5,a5,1
 300aef8:	0ff7f713          	andi	a4,a5,255
 300aefc:	4785                	li	a5,1
 300aefe:	02f71663          	bne	a4,a5,300af2a <ErrorServiceCallback+0x10e>
        error |= uartHandle->baseAddress->UART_MIS.BIT.femis;
 300af02:	fdc42783          	lw	a5,-36(s0)
 300af06:	439c                	lw	a5,0(a5)
 300af08:	43bc                	lw	a5,64(a5)
 300af0a:	839d                	srli	a5,a5,0x7
 300af0c:	8b85                	andi	a5,a5,1
 300af0e:	9f81                	uxtb	a5
 300af10:	873e                	mv	a4,a5
 300af12:	fec42783          	lw	a5,-20(s0)
 300af16:	8fd9                	or	a5,a5,a4
 300af18:	fef42623          	sw	a5,-20(s0)
        uartHandle->baseAddress->UART_ICR.BIT.feic = BASE_CFG_ENABLE;
 300af1c:	fdc42783          	lw	a5,-36(s0)
 300af20:	4398                	lw	a4,0(a5)
 300af22:	437c                	lw	a5,68(a4)
 300af24:	0807e793          	ori	a5,a5,128
 300af28:	c37c                	sw	a5,68(a4)
    }
    if (error != 0x00) {
 300af2a:	fec42783          	lw	a5,-20(s0)
 300af2e:	c79d                	beqz	a5,300af5c <ErrorServiceCallback+0x140>
        uartHandle->errorType = error;
 300af30:	fdc42783          	lw	a5,-36(s0)
 300af34:	fec42703          	lw	a4,-20(s0)
 300af38:	cbb8                	sw	a4,80(a5)
        if (uartHandle->rxMode == UART_MODE_INTERRUPT && uartHandle->userCallBack.TransmitItErrorCallBack != NULL) {
 300af3a:	fdc42783          	lw	a5,-36(s0)
 300af3e:	4f98                	lw	a4,24(a5)
 300af40:	4785                	li	a5,1
 300af42:	00f71d63          	bne	a4,a5,300af5c <ErrorServiceCallback+0x140>
 300af46:	fdc42783          	lw	a5,-36(s0)
 300af4a:	53fc                	lw	a5,100(a5)
 300af4c:	cb81                	beqz	a5,300af5c <ErrorServiceCallback+0x140>
            uartHandle->userCallBack.TransmitItErrorCallBack(uartHandle);
 300af4e:	fdc42783          	lw	a5,-36(s0)
 300af52:	53fc                	lw	a5,100(a5)
 300af54:	fdc42503          	lw	a0,-36(s0)
 300af58:	9782                	jalr	a5
        }
    }
    return;
 300af5a:	0001                	nop
 300af5c:	0001                	nop
}
 300af5e:	50b2                	lw	ra,44(sp)
 300af60:	5422                	lw	s0,40(sp)
 300af62:	6145                	addi	sp,sp,48
 300af64:	8082                	ret

0300af66 <HAL_UART_IrqHandler>:
  * @brief UART Interrupt service processing function.
  * @param handle UART handle.
  * @retval None.
  */
void HAL_UART_IrqHandler(void *handle)
{
 300af66:	7179                	addi	sp,sp,-48
 300af68:	d606                	sw	ra,44(sp)
 300af6a:	d422                	sw	s0,40(sp)
 300af6c:	1800                	addi	s0,sp,48
 300af6e:	fca42e23          	sw	a0,-36(s0)
    UART_ASSERT_PARAM(handle != NULL);
 300af72:	fdc42783          	lw	a5,-36(s0)
 300af76:	eb89                	bnez	a5,300af88 <HAL_UART_IrqHandler+0x22>
 300af78:	2d200593          	li	a1,722
 300af7c:	030117b7          	lui	a5,0x3011
 300af80:	a9c78513          	addi	a0,a5,-1380 # 3010a9c <g_crgIpMatch+0x58c>
 300af84:	2281                	jal	ra,300b0c4 <AssertErrorLog.trans.9>
 300af86:	a001                	j	300af86 <HAL_UART_IrqHandler+0x20>
    UART_Handle *uartHandle = (UART_Handle *)handle;
 300af88:	fdc42783          	lw	a5,-36(s0)
 300af8c:	fef42623          	sw	a5,-20(s0)
    UART_ASSERT_PARAM(IsUARTInstance(uartHandle->baseAddress));
 300af90:	fec42783          	lw	a5,-20(s0)
 300af94:	4398                	lw	a4,0(a5)
 300af96:	140007b7          	lui	a5,0x14000
 300af9a:	02f70f63          	beq	a4,a5,300afd8 <HAL_UART_IrqHandler+0x72>
 300af9e:	fec42783          	lw	a5,-20(s0)
 300afa2:	4398                	lw	a4,0(a5)
 300afa4:	140017b7          	lui	a5,0x14001
 300afa8:	02f70863          	beq	a4,a5,300afd8 <HAL_UART_IrqHandler+0x72>
 300afac:	fec42783          	lw	a5,-20(s0)
 300afb0:	4398                	lw	a4,0(a5)
 300afb2:	140027b7          	lui	a5,0x14002
 300afb6:	02f70163          	beq	a4,a5,300afd8 <HAL_UART_IrqHandler+0x72>
 300afba:	fec42783          	lw	a5,-20(s0)
 300afbe:	4398                	lw	a4,0(a5)
 300afc0:	140037b7          	lui	a5,0x14003
 300afc4:	00f70a63          	beq	a4,a5,300afd8 <HAL_UART_IrqHandler+0x72>
 300afc8:	2d400593          	li	a1,724
 300afcc:	030117b7          	lui	a5,0x3011
 300afd0:	a9c78513          	addi	a0,a5,-1380 # 3010a9c <g_crgIpMatch+0x58c>
 300afd4:	28c5                	jal	ra,300b0c4 <AssertErrorLog.trans.9>
 300afd6:	a001                	j	300afd6 <HAL_UART_IrqHandler+0x70>
    /* when tx interrupt is generated */
    if ((uartHandle->baseAddress->UART_MIS.BIT.txmis == 0x01) ||
 300afd8:	fec42783          	lw	a5,-20(s0)
 300afdc:	439c                	lw	a5,0(a5)
 300afde:	43bc                	lw	a5,64(a5)
 300afe0:	8395                	srli	a5,a5,0x5
 300afe2:	8b85                	andi	a5,a5,1
 300afe4:	0ff7f713          	andi	a4,a5,255
 300afe8:	4785                	li	a5,1
 300afea:	00f70d63          	beq	a4,a5,300b004 <HAL_UART_IrqHandler+0x9e>
        (uartHandle->baseAddress->UART_MIS.BIT.txfeis == 0x01)) {
 300afee:	fec42783          	lw	a5,-20(s0)
 300aff2:	439c                	lw	a5,0(a5)
 300aff4:	43bc                	lw	a5,64(a5)
 300aff6:	83b1                	srli	a5,a5,0xc
 300aff8:	8b85                	andi	a5,a5,1
 300affa:	0ff7f713          	andi	a4,a5,255
    if ((uartHandle->baseAddress->UART_MIS.BIT.txmis == 0x01) ||
 300affe:	4785                	li	a5,1
 300b000:	00f71563          	bne	a4,a5,300b00a <HAL_UART_IrqHandler+0xa4>
        WriteITCallBack(uartHandle);
 300b004:	fec42503          	lw	a0,-20(s0)
 300b008:	3c2d                	jal	ra,300aa42 <WriteITCallBack>
    }
    /* when rx interrupt is generated */
    if ((uartHandle->baseAddress->UART_MIS.BIT.rxmis == 0x01 || uartHandle->baseAddress->UART_MIS.BIT.rtmis == 0x01) ||
 300b00a:	fec42783          	lw	a5,-20(s0)
 300b00e:	439c                	lw	a5,0(a5)
 300b010:	43bc                	lw	a5,64(a5)
 300b012:	8391                	srli	a5,a5,0x4
 300b014:	8b85                	andi	a5,a5,1
 300b016:	0ff7f713          	andi	a4,a5,255
 300b01a:	4785                	li	a5,1
 300b01c:	02f70863          	beq	a4,a5,300b04c <HAL_UART_IrqHandler+0xe6>
 300b020:	fec42783          	lw	a5,-20(s0)
 300b024:	439c                	lw	a5,0(a5)
 300b026:	43bc                	lw	a5,64(a5)
 300b028:	8399                	srli	a5,a5,0x6
 300b02a:	8b85                	andi	a5,a5,1
 300b02c:	0ff7f713          	andi	a4,a5,255
 300b030:	4785                	li	a5,1
 300b032:	00f70d63          	beq	a4,a5,300b04c <HAL_UART_IrqHandler+0xe6>
        (uartHandle->baseAddress->UART_MIS.BIT.rxfneis == 0x1)) {
 300b036:	fec42783          	lw	a5,-20(s0)
 300b03a:	439c                	lw	a5,0(a5)
 300b03c:	43bc                	lw	a5,64(a5)
 300b03e:	83c5                	srli	a5,a5,0x11
 300b040:	8b85                	andi	a5,a5,1
 300b042:	0ff7f713          	andi	a4,a5,255
    if ((uartHandle->baseAddress->UART_MIS.BIT.rxmis == 0x01 || uartHandle->baseAddress->UART_MIS.BIT.rtmis == 0x01) ||
 300b046:	4785                	li	a5,1
 300b048:	00f71563          	bne	a4,a5,300b052 <HAL_UART_IrqHandler+0xec>
        ReadITCallBack(uartHandle);
 300b04c:	fec42503          	lw	a0,-20(s0)
 300b050:	399d                	jal	ra,300acc6 <ReadITCallBack>
    }
    /* when charter match interrupt is generated */
    if (uartHandle->baseAddress->UART_MIS.BIT.cmis == 0x01) {
 300b052:	fec42783          	lw	a5,-20(s0)
 300b056:	439c                	lw	a5,0(a5)
 300b058:	43bc                	lw	a5,64(a5)
 300b05a:	83d5                	srli	a5,a5,0x15
 300b05c:	8b85                	andi	a5,a5,1
 300b05e:	0ff7f713          	andi	a4,a5,255
 300b062:	4785                	li	a5,1
 300b064:	00f71663          	bne	a4,a5,300b070 <HAL_UART_IrqHandler+0x10a>
        CharterMatchCallBack(uartHandle);
 300b068:	fec42503          	lw	a0,-20(s0)
 300b06c:	c06ff0ef          	jal	ra,300a472 <CharterMatchCallBack>
    }
    /* when baud detect interrupt is generated */
    if (uartHandle->baseAddress->UART_MIS.BIT.abdcis == 0x01 || uartHandle->baseAddress->UART_MIS.BIT.abdeis == 0x01) {
 300b070:	fec42783          	lw	a5,-20(s0)
 300b074:	439c                	lw	a5,0(a5)
 300b076:	43bc                	lw	a5,64(a5)
 300b078:	83cd                	srli	a5,a5,0x13
 300b07a:	8b85                	andi	a5,a5,1
 300b07c:	0ff7f713          	andi	a4,a5,255
 300b080:	4785                	li	a5,1
 300b082:	00f70d63          	beq	a4,a5,300b09c <HAL_UART_IrqHandler+0x136>
 300b086:	fec42783          	lw	a5,-20(s0)
 300b08a:	439c                	lw	a5,0(a5)
 300b08c:	43bc                	lw	a5,64(a5)
 300b08e:	83d1                	srli	a5,a5,0x14
 300b090:	8b85                	andi	a5,a5,1
 300b092:	0ff7f713          	andi	a4,a5,255
 300b096:	4785                	li	a5,1
 300b098:	00f71663          	bne	a4,a5,300b0a4 <HAL_UART_IrqHandler+0x13e>
        BaudDetectCallBack(uartHandle);
 300b09c:	fec42503          	lw	a0,-20(s0)
 300b0a0:	af6ff0ef          	jal	ra,300a396 <BaudDetectCallBack>
    }
    /* when error interrupt is generated */
    if ((uartHandle->baseAddress->UART_MIS.reg & 0x780) != 0) {
 300b0a4:	fec42783          	lw	a5,-20(s0)
 300b0a8:	439c                	lw	a5,0(a5)
 300b0aa:	43bc                	lw	a5,64(a5)
 300b0ac:	7807f793          	andi	a5,a5,1920
 300b0b0:	c789                	beqz	a5,300b0ba <HAL_UART_IrqHandler+0x154>
        ErrorServiceCallback(uartHandle);
 300b0b2:	fec42503          	lw	a0,-20(s0)
 300b0b6:	339d                	jal	ra,300ae1c <ErrorServiceCallback>
    }
    return;
 300b0b8:	0001                	nop
 300b0ba:	0001                	nop
}
 300b0bc:	50b2                	lw	ra,44(sp)
 300b0be:	5422                	lw	s0,40(sp)
 300b0c0:	6145                	addi	sp,sp,48
 300b0c2:	8082                	ret

0300b0c4 <AssertErrorLog.trans.9>:
 300b0c4:	c7bf706f          	j	3002d3e <AssertErrorLog>

0300b0c8 <HAL_UART_RegisterCallBack>:
  * @param pCallback pointer of the specified callbcak function, @ref UART_CallbackType
  * @retval BASE_StatusType: OK, ERROR.
  */
BASE_StatusType HAL_UART_RegisterCallBack(UART_Handle *uartHandle, UART_CallbackFun_Type typeID,
                                          UART_CallbackType pCallback)
{
 300b0c8:	1101                	addi	sp,sp,-32
 300b0ca:	ce06                	sw	ra,28(sp)
 300b0cc:	cc22                	sw	s0,24(sp)
 300b0ce:	1000                	addi	s0,sp,32
 300b0d0:	fea42623          	sw	a0,-20(s0)
 300b0d4:	feb42423          	sw	a1,-24(s0)
 300b0d8:	fec42223          	sw	a2,-28(s0)
    UART_ASSERT_PARAM(uartHandle != NULL);
 300b0dc:	fec42783          	lw	a5,-20(s0)
 300b0e0:	eb89                	bnez	a5,300b0f2 <HAL_UART_RegisterCallBack+0x2a>
 300b0e2:	2f800593          	li	a1,760
 300b0e6:	030117b7          	lui	a5,0x3011
 300b0ea:	a9c78513          	addi	a0,a5,-1380 # 3010a9c <g_crgIpMatch+0x58c>
 300b0ee:	3fd9                	jal	ra,300b0c4 <AssertErrorLog.trans.9>
 300b0f0:	a001                	j	300b0f0 <HAL_UART_RegisterCallBack+0x28>
    UART_ASSERT_PARAM(IsUARTInstance(uartHandle->baseAddress));
 300b0f2:	fec42783          	lw	a5,-20(s0)
 300b0f6:	4398                	lw	a4,0(a5)
 300b0f8:	140007b7          	lui	a5,0x14000
 300b0fc:	02f70f63          	beq	a4,a5,300b13a <HAL_UART_RegisterCallBack+0x72>
 300b100:	fec42783          	lw	a5,-20(s0)
 300b104:	4398                	lw	a4,0(a5)
 300b106:	140017b7          	lui	a5,0x14001
 300b10a:	02f70863          	beq	a4,a5,300b13a <HAL_UART_RegisterCallBack+0x72>
 300b10e:	fec42783          	lw	a5,-20(s0)
 300b112:	4398                	lw	a4,0(a5)
 300b114:	140027b7          	lui	a5,0x14002
 300b118:	02f70163          	beq	a4,a5,300b13a <HAL_UART_RegisterCallBack+0x72>
 300b11c:	fec42783          	lw	a5,-20(s0)
 300b120:	4398                	lw	a4,0(a5)
 300b122:	140037b7          	lui	a5,0x14003
 300b126:	00f70a63          	beq	a4,a5,300b13a <HAL_UART_RegisterCallBack+0x72>
 300b12a:	2f900593          	li	a1,761
 300b12e:	030117b7          	lui	a5,0x3011
 300b132:	a9c78513          	addi	a0,a5,-1380 # 3010a9c <g_crgIpMatch+0x58c>
 300b136:	3779                	jal	ra,300b0c4 <AssertErrorLog.trans.9>
 300b138:	a001                	j	300b138 <HAL_UART_RegisterCallBack+0x70>
    switch (typeID) {
 300b13a:	fe842703          	lw	a4,-24(s0)
 300b13e:	47a1                	li	a5,8
 300b140:	08e7e363          	bltu	a5,a4,300b1c6 <HAL_UART_RegisterCallBack+0xfe>
 300b144:	fe842783          	lw	a5,-24(s0)
 300b148:	00279713          	slli	a4,a5,0x2
 300b14c:	030117b7          	lui	a5,0x3011
 300b150:	ab878793          	addi	a5,a5,-1352 # 3010ab8 <g_crgIpMatch+0x5a8>
 300b154:	97ba                	add	a5,a5,a4
 300b156:	439c                	lw	a5,0(a5)
 300b158:	8782                	jr	a5
        case UART_WRITE_IT_FINISH:
            uartHandle->userCallBack.WriteItFinishCallBack = pCallback;     /* Write INT finish callback register */
 300b15a:	fec42783          	lw	a5,-20(s0)
 300b15e:	fe442703          	lw	a4,-28(s0)
 300b162:	cbf8                	sw	a4,84(a5)
            break;
 300b164:	a09d                	j	300b1ca <HAL_UART_RegisterCallBack+0x102>
        case UART_READ_IT_FINISH:
            uartHandle->userCallBack.ReadItFinishCallBack = pCallback;      /* Read INT finish callback register */
 300b166:	fec42783          	lw	a5,-20(s0)
 300b16a:	fe442703          	lw	a4,-28(s0)
 300b16e:	cfb8                	sw	a4,88(a5)
            break;
 300b170:	a8a9                	j	300b1ca <HAL_UART_RegisterCallBack+0x102>
        case UART_WRITE_DMA_FINISH:
            uartHandle->userCallBack.WriteDmaFinishCallBack = pCallback;    /* DMA write finish callback register */
 300b172:	fec42783          	lw	a5,-20(s0)
 300b176:	fe442703          	lw	a4,-28(s0)
 300b17a:	cff8                	sw	a4,92(a5)
            break;
 300b17c:	a0b9                	j	300b1ca <HAL_UART_RegisterCallBack+0x102>
        case UART_READ_DMA_FINISH:
            uartHandle->userCallBack.ReadDmaFinishCallBack = pCallback;     /* DMA read finish callback register */
 300b17e:	fec42783          	lw	a5,-20(s0)
 300b182:	fe442703          	lw	a4,-28(s0)
 300b186:	d3b8                	sw	a4,96(a5)
            break;
 300b188:	a089                	j	300b1ca <HAL_UART_RegisterCallBack+0x102>
        case UART_TRNS_IT_ERROR:
            uartHandle->userCallBack.TransmitItErrorCallBack = pCallback;   /* INT Trans error callback register */
 300b18a:	fec42783          	lw	a5,-20(s0)
 300b18e:	fe442703          	lw	a4,-28(s0)
 300b192:	d3f8                	sw	a4,100(a5)
            break;
 300b194:	a81d                	j	300b1ca <HAL_UART_RegisterCallBack+0x102>
        case UART_TRNS_DMA_ERROR:
            uartHandle->userCallBack.TransmitDmaErrorCallBack = pCallback;  /* DMA Trans error callback register */
 300b196:	fec42783          	lw	a5,-20(s0)
 300b19a:	fe442703          	lw	a4,-28(s0)
 300b19e:	d7b8                	sw	a4,104(a5)
            break;
 300b1a0:	a02d                	j	300b1ca <HAL_UART_RegisterCallBack+0x102>
        case UART_BAUD_DETECT_FINISH:
            uartHandle->userCallBack.BaudDetectSuccessCallBack = pCallback; /* Baud detect finish callback register */
 300b1a2:	fec42783          	lw	a5,-20(s0)
 300b1a6:	fe442703          	lw	a4,-28(s0)
 300b1aa:	d7f8                	sw	a4,108(a5)
            break;
 300b1ac:	a839                	j	300b1ca <HAL_UART_RegisterCallBack+0x102>
        case UART_BAUD_DETECT_ERROR:
            uartHandle->userCallBack.BaudDetectErrorCallBack = pCallback;   /* Baud detect error callback register */
 300b1ae:	fec42783          	lw	a5,-20(s0)
 300b1b2:	fe442703          	lw	a4,-28(s0)
 300b1b6:	dbb8                	sw	a4,112(a5)
            break;
 300b1b8:	a809                	j	300b1ca <HAL_UART_RegisterCallBack+0x102>
        case UART_CHARACTER_MATCH:
            uartHandle->userCallBack.CharacterMatchCallBack = pCallback;    /* character match callback register */
 300b1ba:	fec42783          	lw	a5,-20(s0)
 300b1be:	fe442703          	lw	a4,-28(s0)
 300b1c2:	dbf8                	sw	a4,116(a5)
            break;
 300b1c4:	a019                	j	300b1ca <HAL_UART_RegisterCallBack+0x102>
        default:
            return BASE_STATUS_ERROR;
 300b1c6:	4785                	li	a5,1
 300b1c8:	a011                	j	300b1cc <HAL_UART_RegisterCallBack+0x104>
    }
    return BASE_STATUS_OK;
 300b1ca:	4781                	li	a5,0
}
 300b1cc:	853e                	mv	a0,a5
 300b1ce:	40f2                	lw	ra,28(sp)
 300b1d0:	4462                	lw	s0,24(sp)
 300b1d2:	6105                	addi	sp,sp,32
 300b1d4:	8082                	ret

0300b1d6 <GPIO1_0_CallbackFunc>:
  * @retval None
  */


void GPIO1_0_CallbackFunc(void *param)
{
 300b1d6:	1101                	addi	sp,sp,-32
 300b1d8:	ce22                	sw	s0,28(sp)
 300b1da:	1000                	addi	s0,sp,32
 300b1dc:	fea42623          	sw	a0,-20(s0)
    BASE_FUNC_UNUSED(param);
    if((g_button1State == 0) && (g_button1_count == 0))
 300b1e0:	eb01a783          	lw	a5,-336(gp) # 40005ac <g_button1State>
 300b1e4:	eb91                	bnez	a5,300b1f8 <GPIO1_0_CallbackFunc+0x22>
 300b1e6:	eb81a783          	lw	a5,-328(gp) # 40005b4 <g_button1_count>
 300b1ea:	e799                	bnez	a5,300b1f8 <GPIO1_0_CallbackFunc+0x22>
    {
        //g_button1State = !g_button1State;
        g_button1State = 1;
 300b1ec:	4705                	li	a4,1
 300b1ee:	eae1a823          	sw	a4,-336(gp) # 40005ac <g_button1State>
        g_button1_count = 1;    //在10ms定时中断里处理按键滤波业务逻辑
 300b1f2:	4705                	li	a4,1
 300b1f4:	eae1ac23          	sw	a4,-328(gp) # 40005b4 <g_button1_count>
    }
}
 300b1f8:	0001                	nop
 300b1fa:	4472                	lw	s0,28(sp)
 300b1fc:	6105                	addi	sp,sp,32
 300b1fe:	8082                	ret

0300b200 <GPIO1_1_CallbackFunc>:

void GPIO1_1_CallbackFunc(void *param)
{
 300b200:	1101                	addi	sp,sp,-32
 300b202:	ce22                	sw	s0,28(sp)
 300b204:	1000                	addi	s0,sp,32
 300b206:	fea42623          	sw	a0,-20(s0)
    BASE_FUNC_UNUSED(param);
   if((g_button2State == 0) && (g_button2_count == 0))
 300b20a:	eb41a783          	lw	a5,-332(gp) # 40005b0 <g_button2State>
 300b20e:	eb91                	bnez	a5,300b222 <GPIO1_1_CallbackFunc+0x22>
 300b210:	ebc1a783          	lw	a5,-324(gp) # 40005b8 <g_button2_count>
 300b214:	e799                	bnez	a5,300b222 <GPIO1_1_CallbackFunc+0x22>
   {
        //g_button2State = !g_button2State;
        g_button2State = 1;
 300b216:	4705                	li	a4,1
 300b218:	eae1aa23          	sw	a4,-332(gp) # 40005b0 <g_button2State>
        g_button2_count = 1;    //在10ms定时中断里处理按键滤波业务逻辑
 300b21c:	4705                	li	a4,1
 300b21e:	eae1ae23          	sw	a4,-324(gp) # 40005b8 <g_button2_count>
   }
}
 300b222:	0001                	nop
 300b224:	4472                	lw	s0,28(sp)
 300b226:	6105                	addi	sp,sp,32
 300b228:	8082                	ret

0300b22a <CANWriteCallbackFunc>:
extern CAN_Handle g_can;
extern bool isRecv;
extern bool isWrite;
unsigned char message = '\0';

void CANWriteCallbackFunc(void* handle){
 300b22a:	1101                	addi	sp,sp,-32
 300b22c:	ce06                	sw	ra,28(sp)
 300b22e:	cc22                	sw	s0,24(sp)
 300b230:	1000                	addi	s0,sp,32
 300b232:	fea42623          	sw	a0,-20(s0)
    DBG_PRINTF("Write Callback\r\n");
 300b236:	030117b7          	lui	a5,0x3011
 300b23a:	adc78513          	addi	a0,a5,-1316 # 3010adc <g_crgIpMatch+0x5cc>
 300b23e:	2b81                	jal	ra,300b78e <DBG_UartPrintf.trans.12>
    BASE_FUNC_UNUSED(handle);
    isWrite = true;
 300b240:	4705                	li	a4,1
 300b242:	6ae188a3          	sb	a4,1713(gp) # 4000dad <isWrite>
}
 300b246:	0001                	nop
 300b248:	40f2                	lw	ra,28(sp)
 300b24a:	4462                	lw	s0,24(sp)
 300b24c:	6105                	addi	sp,sp,32
 300b24e:	8082                	ret

0300b250 <CANReadCallbackFunc>:
void CANReadCallbackFunc(void* handle){
 300b250:	1101                	addi	sp,sp,-32
 300b252:	ce06                	sw	ra,28(sp)
 300b254:	cc22                	sw	s0,24(sp)
 300b256:	1000                	addi	s0,sp,32
 300b258:	fea42623          	sw	a0,-20(s0)
    DBG_PRINTF("Read Callback!\r\n");
 300b25c:	030117b7          	lui	a5,0x3011
 300b260:	af078513          	addi	a0,a5,-1296 # 3010af0 <g_crgIpMatch+0x5e0>
 300b264:	232d                	jal	ra,300b78e <DBG_UartPrintf.trans.12>
    BASE_FUNC_UNUSED(handle);
    isRecv = true;
 300b266:	4705                	li	a4,1
 300b268:	6ae18823          	sb	a4,1712(gp) # 4000dac <isRecv>
}
 300b26c:	0001                	nop
 300b26e:	40f2                	lw	ra,28(sp)
 300b270:	4462                	lw	s0,24(sp)
 300b272:	6105                	addi	sp,sp,32
 300b274:	8082                	ret

0300b276 <ReceiveMsg>:


unsigned char ReceiveMsg(unsigned int CANRxID){
 300b276:	7179                	addi	sp,sp,-48
 300b278:	d606                	sw	ra,44(sp)
 300b27a:	d422                	sw	s0,40(sp)
 300b27c:	1800                	addi	s0,sp,48
 300b27e:	fca42e23          	sw	a0,-36(s0)
    unsigned char msg;
    CAN_FilterConfigure rxFilter;
    g_can.rxFrame = &g_receiveFrame;
 300b282:	fdc18793          	addi	a5,gp,-36 # 40006d8 <g_can>
 300b286:	ed418713          	addi	a4,gp,-300 # 40005d0 <g_receiveFrame>
 300b28a:	d398                	sw	a4,32(a5)
    rxFilter.receiveType = CAN_FILTERFRAME_STD_DATA;
 300b28c:	fe042023          	sw	zero,-32(s0)
    rxFilter.filterID = CANRxID;        /* 0x1014 and 0xFFFFF0FF constitute filtering rules */
 300b290:	fdc42783          	lw	a5,-36(s0)
 300b294:	fef42223          	sw	a5,-28(s0)
    rxFilter.filterMask = 0x7FF;  /* 0xFFFFF0FF is filter ID mask */
 300b298:	7ff00793          	li	a5,2047
 300b29c:	fef42423          	sw	a5,-24(s0)
    HAL_CAN_ReadIT(&g_can, &g_receiveFrame, &rxFilter);
 300b2a0:	fe040793          	addi	a5,s0,-32
 300b2a4:	863e                	mv	a2,a5
 300b2a6:	ed418593          	addi	a1,gp,-300 # 40005d0 <g_receiveFrame>
 300b2aa:	fdc18513          	addi	a0,gp,-36 # 40006d8 <g_can>
 300b2ae:	fabf80ef          	jal	ra,3004258 <HAL_CAN_ReadIT>
    msg = g_receiveFrame.frame[0];
 300b2b2:	ed418793          	addi	a5,gp,-300 # 40005d0 <g_receiveFrame>
 300b2b6:	27dc                	lbu	a5,12(a5)
 300b2b8:	fef407a3          	sb	a5,-17(s0)
    
    return msg;
 300b2bc:	fef44783          	lbu	a5,-17(s0)
}
 300b2c0:	853e                	mv	a0,a5
 300b2c2:	50b2                	lw	ra,44(sp)
 300b2c4:	5422                	lw	s0,40(sp)
 300b2c6:	6145                	addi	sp,sp,48
 300b2c8:	8082                	ret

0300b2ca <TransmitMsg>:

void TransmitMsg(unsigned char* msg, unsigned int CANTxID){   /* Address for storing received frame data */
 300b2ca:	1101                	addi	sp,sp,-32
 300b2cc:	ce06                	sw	ra,28(sp)
 300b2ce:	cc22                	sw	s0,24(sp)
 300b2d0:	1000                	addi	s0,sp,32
 300b2d2:	fea42623          	sw	a0,-20(s0)
 300b2d6:	feb42423          	sw	a1,-24(s0)
    // DBG_PRINTF("CAN interrupt register \r\n");
    g_sendFrame.type = CAN_TYPEFRAME_STD_DATA; /* Transmit extended data frame */
 300b2da:	ec018793          	addi	a5,gp,-320 # 40005bc <g_sendFrame>
 300b2de:	0007a023          	sw	zero,0(a5)
    g_sendFrame.CANId = CANTxID;       /* 0x1314 is ID of transmitted data frames */
 300b2e2:	ec018793          	addi	a5,gp,-320 # 40005bc <g_sendFrame>
 300b2e6:	fe842703          	lw	a4,-24(s0)
 300b2ea:	c798                	sw	a4,8(a5)
    g_sendFrame.dataLength = 1;       /* 1 is length of the sent frame */
 300b2ec:	ec018793          	addi	a5,gp,-320 # 40005bc <g_sendFrame>
 300b2f0:	4705                	li	a4,1
 300b2f2:	c3d8                	sw	a4,4(a5)
    g_sendFrame.frame[0] = *msg;
 300b2f4:	fec42783          	lw	a5,-20(s0)
 300b2f8:	2398                	lbu	a4,0(a5)
 300b2fa:	ec018793          	addi	a5,gp,-320 # 40005bc <g_sendFrame>
 300b2fe:	a7d8                	sb	a4,12(a5)
    HAL_CAN_Write(&g_can, &g_sendFrame);
 300b300:	ec018593          	addi	a1,gp,-320 # 40005bc <g_sendFrame>
 300b304:	fdc18513          	addi	a0,gp,-36 # 40006d8 <g_can>
 300b308:	917f80ef          	jal	ra,3003c1e <HAL_CAN_Write>
}
 300b30c:	0001                	nop
 300b30e:	40f2                	lw	ra,28(sp)
 300b310:	4462                	lw	s0,24(sp)
 300b312:	6105                	addi	sp,sp,32
 300b314:	8082                	ret

0300b316 <UART2WriteInterruptCallback>:
unsigned char get_data;
bool Servo_flag = true;
bool flag = false;
short num = 0;

void UART2WriteInterruptCallback(void* handle){
 300b316:	1101                	addi	sp,sp,-32
 300b318:	ce22                	sw	s0,28(sp)
 300b31a:	1000                	addi	s0,sp,32
 300b31c:	fea42623          	sw	a0,-20(s0)
    BASE_FUNC_UNUSED(handle);
    TxInterruptFlag = true;
 300b320:	4705                	li	a4,1
 300b322:	a0e18aa3          	sb	a4,-1515(gp) # 4000111 <TxInterruptFlag>
}
 300b326:	0001                	nop
 300b328:	4472                	lw	s0,28(sp)
 300b32a:	6105                	addi	sp,sp,32
 300b32c:	8082                	ret

0300b32e <UART2ReadInterruptCallback>:

void UART2ReadInterruptCallback(void* handle){
 300b32e:	1101                	addi	sp,sp,-32
 300b330:	ce22                	sw	s0,28(sp)
 300b332:	1000                	addi	s0,sp,32
 300b334:	fea42623          	sw	a0,-20(s0)
    BASE_FUNC_UNUSED(handle);
    RxInterruptflag = true;
 300b338:	4705                	li	a4,1
 300b33a:	a0e18a23          	sb	a4,-1516(gp) # 4000110 <RxInterruptflag>
    flag = true;
 300b33e:	4705                	li	a4,1
 300b340:	eee18423          	sb	a4,-280(gp) # 40005e4 <flag>
}
 300b344:	0001                	nop
 300b346:	4472                	lw	s0,28(sp)
 300b348:	6105                	addi	sp,sp,32
 300b34a:	8082                	ret

0300b34c <InitGearMotor>:
//编码器读取周期内最大差值
unsigned int g_maxEncodePidDeltaValue;
unsigned int g_maxEncodeAveDeltaValue;

void InitGearMotor(void)
{
 300b34c:	1141                	addi	sp,sp,-16
 300b34e:	0061128b          	stmia	{ra,s0,s2-s3},(sp)
 300b352:	0800                	addi	s0,sp,16
    pidRightMotor.motorSide  = MOTOR_RIGHT;    
 300b354:	eec18793          	addi	a5,gp,-276 # 40005e8 <pidRightMotor>
 300b358:	4705                	li	a4,1
 300b35a:	c398                	sw	a4,0(a5)
    pidRightMotor.curNumber = 0;            /* 当前计数器 */
 300b35c:	eec18793          	addi	a5,gp,-276 # 40005e8 <pidRightMotor>
 300b360:	0007a223          	sw	zero,4(a5)
    pidRightMotor.lastNumber = 0;           /* 上一次计数器 */
 300b364:	eec18793          	addi	a5,gp,-276 # 40005e8 <pidRightMotor>
 300b368:	0007a423          	sw	zero,8(a5)
    pidRightMotor.speedRps = 0;             /* 电机转速，单位每秒多少圈 */
 300b36c:	eec18793          	addi	a5,gp,-276 # 40005e8 <pidRightMotor>
 300b370:	0007a623          	sw	zero,12(a5)
    pidRightMotor.speed = 0;                /* 电机速度，单位mm/s，由转速和轮胎直径计算 */
 300b374:	eec18793          	addi	a5,gp,-276 # 40005e8 <pidRightMotor>
 300b378:	0007a823          	sw	zero,16(a5)
    pidRightMotor.calPeriod = MOTOR_PID_CONTROL_PERIOD; 
 300b37c:	eec18793          	addi	a5,gp,-276 # 40005e8 <pidRightMotor>
 300b380:	4729                	li	a4,10
 300b382:	cbd8                	sw	a4,20(a5)

    pidLeftMotor.motorSide  = MOTOR_LEFT;    
 300b384:	f0818793          	addi	a5,gp,-248 # 4000604 <pidLeftMotor>
 300b388:	0007a023          	sw	zero,0(a5)
    pidLeftMotor.curNumber = 0;             /* 当前计数器 */
 300b38c:	f0818793          	addi	a5,gp,-248 # 4000604 <pidLeftMotor>
 300b390:	0007a223          	sw	zero,4(a5)
    pidLeftMotor.lastNumber = 0;            /* 上一次计数器 */
 300b394:	f0818793          	addi	a5,gp,-248 # 4000604 <pidLeftMotor>
 300b398:	0007a423          	sw	zero,8(a5)
    pidLeftMotor.speedRps = 0;              /* 电机转速，单位每秒多少圈 */    
 300b39c:	f0818793          	addi	a5,gp,-248 # 4000604 <pidLeftMotor>
 300b3a0:	0007a623          	sw	zero,12(a5)
    pidLeftMotor.speed = 0;                 /* 电机速度，单位mm/s，由转速和轮胎直径计算 */
 300b3a4:	f0818793          	addi	a5,gp,-248 # 4000604 <pidLeftMotor>
 300b3a8:	0007a823          	sw	zero,16(a5)
    pidLeftMotor.calPeriod = MOTOR_PID_CONTROL_PERIOD;    
 300b3ac:	f0818793          	addi	a5,gp,-248 # 4000604 <pidLeftMotor>
 300b3b0:	4729                	li	a4,10
 300b3b2:	cbd8                	sw	a4,20(a5)


    aveRightMotor.motorSide  = MOTOR_RIGHT;    
 300b3b4:	f2418793          	addi	a5,gp,-220 # 4000620 <aveRightMotor>
 300b3b8:	4705                	li	a4,1
 300b3ba:	c398                	sw	a4,0(a5)
    aveRightMotor.curNumber = 0;            /* 当前计数器 */
 300b3bc:	f2418793          	addi	a5,gp,-220 # 4000620 <aveRightMotor>
 300b3c0:	0007a223          	sw	zero,4(a5)
    aveRightMotor.lastNumber = 0;           /* 上一次计数器 */
 300b3c4:	f2418793          	addi	a5,gp,-220 # 4000620 <aveRightMotor>
 300b3c8:	0007a423          	sw	zero,8(a5)
    aveRightMotor.speedRps = 0;             /* 电机转速，单位每秒多少圈 */
 300b3cc:	f2418793          	addi	a5,gp,-220 # 4000620 <aveRightMotor>
 300b3d0:	0007a623          	sw	zero,12(a5)
    aveRightMotor.speed = 0;                /* 电机速度，单位mm/s，由转速和轮胎直径计算 */
 300b3d4:	f2418793          	addi	a5,gp,-220 # 4000620 <aveRightMotor>
 300b3d8:	0007a823          	sw	zero,16(a5)
    aveRightMotor.calPeriod = EULER_CAR_DATA_SEND_PERIOD; 
 300b3dc:	f2418793          	addi	a5,gp,-220 # 4000620 <aveRightMotor>
 300b3e0:	06400713          	li	a4,100
 300b3e4:	cbd8                	sw	a4,20(a5)

    aveLeftMotor.motorSide  = MOTOR_LEFT;    
 300b3e6:	f4018793          	addi	a5,gp,-192 # 400063c <aveLeftMotor>
 300b3ea:	0007a023          	sw	zero,0(a5)
    aveLeftMotor.curNumber = 0;             /* 当前计数器 */
 300b3ee:	f4018793          	addi	a5,gp,-192 # 400063c <aveLeftMotor>
 300b3f2:	0007a223          	sw	zero,4(a5)
    aveLeftMotor.lastNumber = 0;            /* 上一次计数器 */
 300b3f6:	f4018793          	addi	a5,gp,-192 # 400063c <aveLeftMotor>
 300b3fa:	0007a423          	sw	zero,8(a5)
    aveLeftMotor.speedRps = 0;              /* 电机转速，单位每秒多少圈 */    
 300b3fe:	f4018793          	addi	a5,gp,-192 # 400063c <aveLeftMotor>
 300b402:	0007a623          	sw	zero,12(a5)
    aveLeftMotor.speed = 0;                 /* 电机速度，单位mm/s，由转速和轮胎直径计算 */
 300b406:	f4018793          	addi	a5,gp,-192 # 400063c <aveLeftMotor>
 300b40a:	0007a823          	sw	zero,16(a5)
    aveLeftMotor.calPeriod = EULER_CAR_DATA_SEND_PERIOD;    
 300b40e:	f4018793          	addi	a5,gp,-192 # 400063c <aveLeftMotor>
 300b412:	06400713          	li	a4,100
 300b416:	cbd8                	sw	a4,20(a5)


    //编码器在一个PID周期内最大差值，电机转速的2倍，主要用于容错处理
    g_maxEncodePidDeltaValue = (int)(g_motorMaxSpeed / MOTOR_TIRE_DIAMETER / PI * g_motorLineNum / (1000.0/MOTOR_PID_CONTROL_PERIOD) * 2.0);
 300b418:	a681a787          	flw	fa5,-1432(gp) # 4000164 <g_motorMaxSpeed>
 300b41c:	20f78553          	fmv.s	fa0,fa5
 300b420:	2e8d                	jal	ra,300b792 <__extendsfdf2.trans.10>
 300b422:	87aa                	mv	a5,a0
 300b424:	882e                	mv	a6,a1
 300b426:	03011737          	lui	a4,0x3011
 300b42a:	b6870713          	addi	a4,a4,-1176 # 3010b68 <g_crgIpMatch+0x658>
 300b42e:	4310                	lw	a2,0(a4)
 300b430:	4354                	lw	a3,4(a4)
 300b432:	853e                	mv	a0,a5
 300b434:	85c2                	mv	a1,a6
 300b436:	2e91                	jal	ra,300b78a <__divdf3.trans.22>
 300b438:	87aa                	mv	a5,a0
 300b43a:	882e                	mv	a6,a1
 300b43c:	03011737          	lui	a4,0x3011
 300b440:	b7070713          	addi	a4,a4,-1168 # 3010b70 <g_crgIpMatch+0x660>
 300b444:	4310                	lw	a2,0(a4)
 300b446:	4354                	lw	a3,4(a4)
 300b448:	853e                	mv	a0,a5
 300b44a:	85c2                	mv	a1,a6
 300b44c:	2e3d                	jal	ra,300b78a <__divdf3.trans.22>
 300b44e:	87aa                	mv	a5,a0
 300b450:	882e                	mv	a6,a1
 300b452:	893e                	mv	s2,a5
 300b454:	89c2                	mv	s3,a6
 300b456:	a701a783          	lw	a5,-1424(gp) # 400016c <g_motorLineNum>
 300b45a:	853e                	mv	a0,a5
 300b45c:	261d                	jal	ra,300b782 <__floatunsidf.trans.43>
 300b45e:	87aa                	mv	a5,a0
 300b460:	882e                	mv	a6,a1
 300b462:	863e                	mv	a2,a5
 300b464:	86c2                	mv	a3,a6
 300b466:	854a                	mv	a0,s2
 300b468:	85ce                	mv	a1,s3
 300b46a:	2e31                	jal	ra,300b786 <__muldf3.trans.25>
 300b46c:	87aa                	mv	a5,a0
 300b46e:	882e                	mv	a6,a1
 300b470:	03011737          	lui	a4,0x3011
 300b474:	b7870713          	addi	a4,a4,-1160 # 3010b78 <g_crgIpMatch+0x668>
 300b478:	4310                	lw	a2,0(a4)
 300b47a:	4354                	lw	a3,4(a4)
 300b47c:	853e                	mv	a0,a5
 300b47e:	85c2                	mv	a1,a6
 300b480:	2629                	jal	ra,300b78a <__divdf3.trans.22>
 300b482:	87aa                	mv	a5,a0
 300b484:	882e                	mv	a6,a1
 300b486:	863e                	mv	a2,a5
 300b488:	86c2                	mv	a3,a6
 300b48a:	853e                	mv	a0,a5
 300b48c:	85c2                	mv	a1,a6
 300b48e:	49f020ef          	jal	ra,300e12c <__adddf3>
 300b492:	87aa                	mv	a5,a0
 300b494:	882e                	mv	a6,a1
 300b496:	853e                	mv	a0,a5
 300b498:	85c2                	mv	a1,a6
 300b49a:	2df040ef          	jal	ra,300ff78 <__fixdfsi>
 300b49e:	87aa                	mv	a5,a0
 300b4a0:	873e                	mv	a4,a5
 300b4a2:	f4e1ae23          	sw	a4,-164(gp) # 4000658 <g_maxEncodePidDeltaValue>
    //编码器在一个底盘数据上报周期内最大差值，电机转速的2倍，主要用于容错处理
    g_maxEncodeAveDeltaValue = (int)(g_motorMaxSpeed / MOTOR_TIRE_DIAMETER / PI * g_motorLineNum / (1000.0/EULER_CAR_DATA_SEND_PERIOD) * 2.0);
 300b4a6:	a681a787          	flw	fa5,-1432(gp) # 4000164 <g_motorMaxSpeed>
 300b4aa:	20f78553          	fmv.s	fa0,fa5
 300b4ae:	24d5                	jal	ra,300b792 <__extendsfdf2.trans.10>
 300b4b0:	87aa                	mv	a5,a0
 300b4b2:	882e                	mv	a6,a1
 300b4b4:	03011737          	lui	a4,0x3011
 300b4b8:	b6870713          	addi	a4,a4,-1176 # 3010b68 <g_crgIpMatch+0x658>
 300b4bc:	4310                	lw	a2,0(a4)
 300b4be:	4354                	lw	a3,4(a4)
 300b4c0:	853e                	mv	a0,a5
 300b4c2:	85c2                	mv	a1,a6
 300b4c4:	24d9                	jal	ra,300b78a <__divdf3.trans.22>
 300b4c6:	87aa                	mv	a5,a0
 300b4c8:	882e                	mv	a6,a1
 300b4ca:	03011737          	lui	a4,0x3011
 300b4ce:	b7070713          	addi	a4,a4,-1168 # 3010b70 <g_crgIpMatch+0x660>
 300b4d2:	4310                	lw	a2,0(a4)
 300b4d4:	4354                	lw	a3,4(a4)
 300b4d6:	853e                	mv	a0,a5
 300b4d8:	85c2                	mv	a1,a6
 300b4da:	2c45                	jal	ra,300b78a <__divdf3.trans.22>
 300b4dc:	87aa                	mv	a5,a0
 300b4de:	882e                	mv	a6,a1
 300b4e0:	893e                	mv	s2,a5
 300b4e2:	89c2                	mv	s3,a6
 300b4e4:	a701a783          	lw	a5,-1424(gp) # 400016c <g_motorLineNum>
 300b4e8:	853e                	mv	a0,a5
 300b4ea:	2c61                	jal	ra,300b782 <__floatunsidf.trans.43>
 300b4ec:	87aa                	mv	a5,a0
 300b4ee:	882e                	mv	a6,a1
 300b4f0:	863e                	mv	a2,a5
 300b4f2:	86c2                	mv	a3,a6
 300b4f4:	854a                	mv	a0,s2
 300b4f6:	85ce                	mv	a1,s3
 300b4f8:	2479                	jal	ra,300b786 <__muldf3.trans.25>
 300b4fa:	87aa                	mv	a5,a0
 300b4fc:	882e                	mv	a6,a1
 300b4fe:	03011737          	lui	a4,0x3011
 300b502:	b8070713          	addi	a4,a4,-1152 # 3010b80 <g_crgIpMatch+0x670>
 300b506:	4310                	lw	a2,0(a4)
 300b508:	4354                	lw	a3,4(a4)
 300b50a:	853e                	mv	a0,a5
 300b50c:	85c2                	mv	a1,a6
 300b50e:	2cb5                	jal	ra,300b78a <__divdf3.trans.22>
 300b510:	87aa                	mv	a5,a0
 300b512:	882e                	mv	a6,a1
 300b514:	863e                	mv	a2,a5
 300b516:	86c2                	mv	a3,a6
 300b518:	853e                	mv	a0,a5
 300b51a:	85c2                	mv	a1,a6
 300b51c:	411020ef          	jal	ra,300e12c <__adddf3>
 300b520:	87aa                	mv	a5,a0
 300b522:	882e                	mv	a6,a1
 300b524:	853e                	mv	a0,a5
 300b526:	85c2                	mv	a1,a6
 300b528:	251040ef          	jal	ra,300ff78 <__fixdfsi>
 300b52c:	87aa                	mv	a5,a0
 300b52e:	873e                	mv	a4,a5
 300b530:	f6e1a023          	sw	a4,-160(gp) # 400065c <g_maxEncodeAveDeltaValue>

    //DBG_PRINTF("g_maxEncodeDeltaValue = %d\r\n", g_maxEncodeDeltaValue);
}
 300b534:	0001                	nop
 300b536:	0061028b          	ldmia	{ra,s0,s2-s3},(sp)
 300b53a:	0141                	addi	sp,sp,16
 300b53c:	8082                	ret

0300b53e <QDM_CalMotorSpeed>:



void QDM_CalMotorSpeed(Gear_Motor_handle *pMotor)
{
 300b53e:	7179                	addi	sp,sp,-48
 300b540:	02010293          	addi	t0,sp,32
 300b544:	0062928b          	stmia	{ra,s0,s2-s3},(t0)
 300b548:	1800                	addi	s0,sp,48
 300b54a:	fca42e23          	sw	a0,-36(s0)
    unsigned int qdm_cnt, qdm_dir;
    unsigned int deltaValue;
    if(pMotor->motorSide == MOTOR_RIGHT )
 300b54e:	fdc42783          	lw	a5,-36(s0)
 300b552:	4398                	lw	a4,0(a5)
 300b554:	4785                	li	a5,1
 300b556:	00f71d63          	bne	a4,a5,300b570 <QDM_CalMotorSpeed+0x32>
        HAL_QDM_ReadPosCountAndDir(&g_qdm0, &qdm_cnt, &qdm_dir);
 300b55a:	fe440713          	addi	a4,s0,-28
 300b55e:	fe840793          	addi	a5,s0,-24
 300b562:	863a                	mv	a2,a4
 300b564:	85be                	mv	a1,a5
 300b566:	01818513          	addi	a0,gp,24 # 4000714 <g_qdm0>
 300b56a:	f2cfe0ef          	jal	ra,3009c96 <HAL_QDM_ReadPosCountAndDir>
 300b56e:	a819                	j	300b584 <QDM_CalMotorSpeed+0x46>
    else    
        HAL_QDM_ReadPosCountAndDir(&g_qdm1, &qdm_cnt, &qdm_dir);
 300b570:	fe440713          	addi	a4,s0,-28
 300b574:	fe840793          	addi	a5,s0,-24
 300b578:	863a                	mv	a2,a4
 300b57a:	85be                	mv	a1,a5
 300b57c:	0a418513          	addi	a0,gp,164 # 40007a0 <g_qdm1>
 300b580:	f16fe0ef          	jal	ra,3009c96 <HAL_QDM_ReadPosCountAndDir>
    
    /* 计算车轮速度 */
    pMotor->curNumber = qdm_cnt;
 300b584:	fe842703          	lw	a4,-24(s0)
 300b588:	fdc42783          	lw	a5,-36(s0)
 300b58c:	c3d8                	sw	a4,4(a5)
    if(qdm_dir == 1){ //电机正转
 300b58e:	fe442703          	lw	a4,-28(s0)
 300b592:	4785                	li	a5,1
 300b594:	04f71363          	bne	a4,a5,300b5da <QDM_CalMotorSpeed+0x9c>
        if(pMotor->curNumber >= pMotor->lastNumber) {
 300b598:	fdc42783          	lw	a5,-36(s0)
 300b59c:	43d8                	lw	a4,4(a5)
 300b59e:	fdc42783          	lw	a5,-36(s0)
 300b5a2:	479c                	lw	a5,8(a5)
 300b5a4:	00f76d63          	bltu	a4,a5,300b5be <QDM_CalMotorSpeed+0x80>
             deltaValue = pMotor->curNumber - pMotor->lastNumber;
 300b5a8:	fdc42783          	lw	a5,-36(s0)
 300b5ac:	43d8                	lw	a4,4(a5)
 300b5ae:	fdc42783          	lw	a5,-36(s0)
 300b5b2:	479c                	lw	a5,8(a5)
 300b5b4:	40f707b3          	sub	a5,a4,a5
 300b5b8:	fef42623          	sw	a5,-20(s0)
 300b5bc:	a8b9                	j	300b61a <QDM_CalMotorSpeed+0xdc>
        }else{ //过零点后的计算编码器差值 
             deltaValue = (pMotor->curNumber +g_motorLineNum) - pMotor->lastNumber; 
 300b5be:	fdc42783          	lw	a5,-36(s0)
 300b5c2:	43d8                	lw	a4,4(a5)
 300b5c4:	a701a783          	lw	a5,-1424(gp) # 400016c <g_motorLineNum>
 300b5c8:	973e                	add	a4,a4,a5
 300b5ca:	fdc42783          	lw	a5,-36(s0)
 300b5ce:	479c                	lw	a5,8(a5)
 300b5d0:	40f707b3          	sub	a5,a4,a5
 300b5d4:	fef42623          	sw	a5,-20(s0)
 300b5d8:	a089                	j	300b61a <QDM_CalMotorSpeed+0xdc>
        }
    }else{  //电机反转
        if(pMotor->curNumber <= pMotor->lastNumber) {
 300b5da:	fdc42783          	lw	a5,-36(s0)
 300b5de:	43d8                	lw	a4,4(a5)
 300b5e0:	fdc42783          	lw	a5,-36(s0)
 300b5e4:	479c                	lw	a5,8(a5)
 300b5e6:	00e7ed63          	bltu	a5,a4,300b600 <QDM_CalMotorSpeed+0xc2>
             deltaValue = pMotor->lastNumber - pMotor->curNumber;
 300b5ea:	fdc42783          	lw	a5,-36(s0)
 300b5ee:	4798                	lw	a4,8(a5)
 300b5f0:	fdc42783          	lw	a5,-36(s0)
 300b5f4:	43dc                	lw	a5,4(a5)
 300b5f6:	40f707b3          	sub	a5,a4,a5
 300b5fa:	fef42623          	sw	a5,-20(s0)
 300b5fe:	a831                	j	300b61a <QDM_CalMotorSpeed+0xdc>
        }else{ //过零点后的计算编码器差值 
             deltaValue = (pMotor->lastNumber + g_motorLineNum) - pMotor->curNumber ; 
 300b600:	fdc42783          	lw	a5,-36(s0)
 300b604:	4798                	lw	a4,8(a5)
 300b606:	a701a783          	lw	a5,-1424(gp) # 400016c <g_motorLineNum>
 300b60a:	973e                	add	a4,a4,a5
 300b60c:	fdc42783          	lw	a5,-36(s0)
 300b610:	43dc                	lw	a5,4(a5)
 300b612:	40f707b3          	sub	a5,a4,a5
 300b616:	fef42623          	sw	a5,-20(s0)
        }
    }

    /* 电机正反转切换时，会出现编码器差值计算错误，设置编码器差值为0 */
    if(pMotor->calPeriod == MOTOR_PID_CONTROL_PERIOD){
 300b61a:	fdc42783          	lw	a5,-36(s0)
 300b61e:	4bd8                	lw	a4,20(a5)
 300b620:	47a9                	li	a5,10
 300b622:	02f71a63          	bne	a4,a5,300b656 <QDM_CalMotorSpeed+0x118>
        if(deltaValue > g_maxEncodePidDeltaValue) {
 300b626:	f5c1a783          	lw	a5,-164(gp) # 4000658 <g_maxEncodePidDeltaValue>
 300b62a:	fec42703          	lw	a4,-20(s0)
 300b62e:	04e7fb63          	bgeu	a5,a4,300b684 <QDM_CalMotorSpeed+0x146>
             DBG_PRINTF("===Motor Encode Error = %d, motor side:%d, calculate period %dms===\r\n", deltaValue,pMotor->motorSide,pMotor->calPeriod);
 300b632:	fdc42783          	lw	a5,-36(s0)
 300b636:	4398                	lw	a4,0(a5)
 300b638:	fdc42783          	lw	a5,-36(s0)
 300b63c:	4bdc                	lw	a5,20(a5)
 300b63e:	86be                	mv	a3,a5
 300b640:	863a                	mv	a2,a4
 300b642:	fec42583          	lw	a1,-20(s0)
 300b646:	030117b7          	lui	a5,0x3011
 300b64a:	b2078513          	addi	a0,a5,-1248 # 3010b20 <g_crgIpMatch+0x610>
 300b64e:	2281                	jal	ra,300b78e <DBG_UartPrintf.trans.12>
             deltaValue = 0;
 300b650:	fe042623          	sw	zero,-20(s0)
 300b654:	a805                	j	300b684 <QDM_CalMotorSpeed+0x146>
        }
    }else{
        if(deltaValue > g_maxEncodeAveDeltaValue) {
 300b656:	f601a783          	lw	a5,-160(gp) # 400065c <g_maxEncodeAveDeltaValue>
 300b65a:	fec42703          	lw	a4,-20(s0)
 300b65e:	02e7f363          	bgeu	a5,a4,300b684 <QDM_CalMotorSpeed+0x146>
             DBG_PRINTF("===Motor Encode Error = %d, motor side:%d, calculate period %dms===\r\n", deltaValue,pMotor->motorSide,pMotor->calPeriod);
 300b662:	fdc42783          	lw	a5,-36(s0)
 300b666:	4398                	lw	a4,0(a5)
 300b668:	fdc42783          	lw	a5,-36(s0)
 300b66c:	4bdc                	lw	a5,20(a5)
 300b66e:	86be                	mv	a3,a5
 300b670:	863a                	mv	a2,a4
 300b672:	fec42583          	lw	a1,-20(s0)
 300b676:	030117b7          	lui	a5,0x3011
 300b67a:	b2078513          	addi	a0,a5,-1248 # 3010b20 <g_crgIpMatch+0x610>
 300b67e:	2a01                	jal	ra,300b78e <DBG_UartPrintf.trans.12>
             deltaValue = 0;
 300b680:	fe042623          	sw	zero,-20(s0)
        }       
    }


    /* 计算右轮电机每秒转速 */
    pMotor->speedRps = ((float)deltaValue * (1000.0 / (float)pMotor->calPeriod))/g_motorLineNum;   
 300b684:	fec42783          	lw	a5,-20(s0)
 300b688:	d017f7d3          	fcvt.s.wu	fa5,a5
 300b68c:	20f78553          	fmv.s	fa0,fa5
 300b690:	2209                	jal	ra,300b792 <__extendsfdf2.trans.10>
 300b692:	892a                	mv	s2,a0
 300b694:	89ae                	mv	s3,a1
 300b696:	fdc42783          	lw	a5,-36(s0)
 300b69a:	4bdc                	lw	a5,20(a5)
 300b69c:	d017f7d3          	fcvt.s.wu	fa5,a5
 300b6a0:	20f78553          	fmv.s	fa0,fa5
 300b6a4:	20fd                	jal	ra,300b792 <__extendsfdf2.trans.10>
 300b6a6:	86aa                	mv	a3,a0
 300b6a8:	872e                	mv	a4,a1
 300b6aa:	030117b7          	lui	a5,0x3011
 300b6ae:	b8878793          	addi	a5,a5,-1144 # 3010b88 <g_crgIpMatch+0x678>
 300b6b2:	8636                	mv	a2,a3
 300b6b4:	86ba                	mv	a3,a4
 300b6b6:	4388                	lw	a0,0(a5)
 300b6b8:	43cc                	lw	a1,4(a5)
 300b6ba:	28c1                	jal	ra,300b78a <__divdf3.trans.22>
 300b6bc:	87aa                	mv	a5,a0
 300b6be:	882e                	mv	a6,a1
 300b6c0:	863e                	mv	a2,a5
 300b6c2:	86c2                	mv	a3,a6
 300b6c4:	854a                	mv	a0,s2
 300b6c6:	85ce                	mv	a1,s3
 300b6c8:	287d                	jal	ra,300b786 <__muldf3.trans.25>
 300b6ca:	87aa                	mv	a5,a0
 300b6cc:	882e                	mv	a6,a1
 300b6ce:	893e                	mv	s2,a5
 300b6d0:	89c2                	mv	s3,a6
 300b6d2:	a701a783          	lw	a5,-1424(gp) # 400016c <g_motorLineNum>
 300b6d6:	853e                	mv	a0,a5
 300b6d8:	206d                	jal	ra,300b782 <__floatunsidf.trans.43>
 300b6da:	87aa                	mv	a5,a0
 300b6dc:	882e                	mv	a6,a1
 300b6de:	863e                	mv	a2,a5
 300b6e0:	86c2                	mv	a3,a6
 300b6e2:	854a                	mv	a0,s2
 300b6e4:	85ce                	mv	a1,s3
 300b6e6:	2055                	jal	ra,300b78a <__divdf3.trans.22>
 300b6e8:	87aa                	mv	a5,a0
 300b6ea:	882e                	mv	a6,a1
 300b6ec:	853e                	mv	a0,a5
 300b6ee:	85c2                	mv	a1,a6
 300b6f0:	21a1                	jal	ra,300bb38 <__truncdfsf2.trans.26>
 300b6f2:	20a507d3          	fmv.s	fa5,fa0
 300b6f6:	fdc42783          	lw	a5,-36(s0)
 300b6fa:	e7dc                	fsw	fa5,12(a5)
    pMotor->speed = pMotor->speedRps * MOTOR_TIRE_DIAMETER * PI;
 300b6fc:	fdc42783          	lw	a5,-36(s0)
 300b700:	67dc                	flw	fa5,12(a5)
 300b702:	20f78553          	fmv.s	fa0,fa5
 300b706:	2071                	jal	ra,300b792 <__extendsfdf2.trans.10>
 300b708:	87aa                	mv	a5,a0
 300b70a:	882e                	mv	a6,a1
 300b70c:	03011737          	lui	a4,0x3011
 300b710:	b6870713          	addi	a4,a4,-1176 # 3010b68 <g_crgIpMatch+0x658>
 300b714:	4310                	lw	a2,0(a4)
 300b716:	4354                	lw	a3,4(a4)
 300b718:	853e                	mv	a0,a5
 300b71a:	85c2                	mv	a1,a6
 300b71c:	20ad                	jal	ra,300b786 <__muldf3.trans.25>
 300b71e:	87aa                	mv	a5,a0
 300b720:	882e                	mv	a6,a1
 300b722:	03011737          	lui	a4,0x3011
 300b726:	b7070713          	addi	a4,a4,-1168 # 3010b70 <g_crgIpMatch+0x660>
 300b72a:	4310                	lw	a2,0(a4)
 300b72c:	4354                	lw	a3,4(a4)
 300b72e:	853e                	mv	a0,a5
 300b730:	85c2                	mv	a1,a6
 300b732:	2891                	jal	ra,300b786 <__muldf3.trans.25>
 300b734:	87aa                	mv	a5,a0
 300b736:	882e                	mv	a6,a1
 300b738:	853e                	mv	a0,a5
 300b73a:	85c2                	mv	a1,a6
 300b73c:	2ef5                	jal	ra,300bb38 <__truncdfsf2.trans.26>
 300b73e:	20a507d3          	fmv.s	fa5,fa0
 300b742:	fdc42783          	lw	a5,-36(s0)
 300b746:	eb9c                	fsw	fa5,16(a5)
    pMotor->lastNumber = pMotor->curNumber;
 300b748:	fdc42783          	lw	a5,-36(s0)
 300b74c:	43d8                	lw	a4,4(a5)
 300b74e:	fdc42783          	lw	a5,-36(s0)
 300b752:	c798                	sw	a4,8(a5)
    pMotor->deltaValue = deltaValue;
 300b754:	fdc42783          	lw	a5,-36(s0)
 300b758:	fec42703          	lw	a4,-20(s0)
 300b75c:	cf98                	sw	a4,24(a5)
    if(qdm_dir == 0){   //电机反转
 300b75e:	fe442783          	lw	a5,-28(s0)
 300b762:	eb89                	bnez	a5,300b774 <QDM_CalMotorSpeed+0x236>
        pMotor->speed = -pMotor->speed;
 300b764:	fdc42783          	lw	a5,-36(s0)
 300b768:	6b9c                	flw	fa5,16(a5)
 300b76a:	20f797d3          	fneg.s	fa5,fa5
 300b76e:	fdc42783          	lw	a5,-36(s0)
 300b772:	eb9c                	fsw	fa5,16(a5)
                                          g_TimerInterruptCount,qdm_cnt,pMotor->deltaValue,qdm_dir,pMotor->speedRps,pMotor->speed);
            }
        }
    }*/

}
 300b774:	0001                	nop
 300b776:	02010293          	addi	t0,sp,32
 300b77a:	0062828b          	ldmia	{ra,s0,s2-s3},(t0)
 300b77e:	6145                	addi	sp,sp,48
 300b780:	8082                	ret

0300b782 <__floatunsidf.trans.43>:
 300b782:	0b90406f          	j	301003a <__floatunsidf>

0300b786 <__muldf3.trans.25>:
 300b786:	1ef0306f          	j	300f174 <__muldf3>

0300b78a <__divdf3.trans.22>:
 300b78a:	1e40306f          	j	300e96e <__divdf3>

0300b78e <DBG_UartPrintf.trans.12>:
 300b78e:	a18fb06f          	j	30069a6 <DBG_UartPrintf>

0300b792 <__extendsfdf2.trans.10>:
 300b792:	10f0406f          	j	30100a0 <__extendsfdf2>

0300b796 <data_transition>:

#define IS_SUPPORT_PID 1

/* 串口发送的数据进行赋值 */
static void data_transition(void)
{
 300b796:	7139                	addi	sp,sp,-64
 300b798:	02010293          	addi	t0,sp,32
 300b79c:	07e2928b          	stmia	{ra,s0,s2-s7},(t0)
 300b7a0:	0080                	addi	s0,sp,64
    float A_Move_X,A_Move_Z;
  
    g_SendData.SensorStr.Frame_Header = FRAME_HEADER; //帧头
 300b7a2:	f6818793          	addi	a5,gp,-152 # 4000664 <g_SendData>
 300b7a6:	07b00713          	li	a4,123
 300b7aa:	af98                	sb	a4,24(a5)
    g_SendData.SensorStr.Frame_Tail = FRAME_TAIL;     //帧尾
 300b7ac:	f6818793          	addi	a5,gp,-152 # 4000664 <g_SendData>
 300b7b0:	07d00713          	li	a4,125
 300b7b4:	02e78723          	sb	a4,46(a5)

    //从各车轮当前速度求出三轴当前速度
    A_Move_X = (aveRightMotor.speed + aveLeftMotor.speed) / 2.0; //小车x轴速度，单位mm/s
 300b7b8:	f2418793          	addi	a5,gp,-220 # 4000620 <aveRightMotor>
 300b7bc:	6b98                	flw	fa4,16(a5)
 300b7be:	f4018793          	addi	a5,gp,-192 # 400063c <aveLeftMotor>
 300b7c2:	6b9c                	flw	fa5,16(a5)
 300b7c4:	00f77753          	fadd.s	fa4,fa4,fa5
 300b7c8:	030117b7          	lui	a5,0x3011
 300b7cc:	e307a787          	flw	fa5,-464(a5) # 3010e30 <g_crgIpMatch+0x920>
 300b7d0:	18f777d3          	fdiv.s	fa5,fa4,fa5
 300b7d4:	fcf42c27          	fsw	fa5,-40(s0)
    A_Move_Z = (aveRightMotor.speed - aveLeftMotor.speed) / (EULERCAR_WHEEL_TRACK * 2.0) * 1000.0; //小车角速度, 单位mrad/s
 300b7d8:	f2418793          	addi	a5,gp,-220 # 4000620 <aveRightMotor>
 300b7dc:	6b98                	flw	fa4,16(a5)
 300b7de:	f4018793          	addi	a5,gp,-192 # 400063c <aveLeftMotor>
 300b7e2:	6b9c                	flw	fa5,16(a5)
 300b7e4:	08f777d3          	fsub.s	fa5,fa4,fa5
 300b7e8:	20f78553          	fmv.s	fa0,fa5
 300b7ec:	375d                	jal	ra,300b792 <__extendsfdf2.trans.10>
 300b7ee:	87aa                	mv	a5,a0
 300b7f0:	882e                	mv	a6,a1
 300b7f2:	03011737          	lui	a4,0x3011
 300b7f6:	e3870713          	addi	a4,a4,-456 # 3010e38 <g_crgIpMatch+0x928>
 300b7fa:	4310                	lw	a2,0(a4)
 300b7fc:	4354                	lw	a3,4(a4)
 300b7fe:	853e                	mv	a0,a5
 300b800:	85c2                	mv	a1,a6
 300b802:	3761                	jal	ra,300b78a <__divdf3.trans.22>
 300b804:	87aa                	mv	a5,a0
 300b806:	882e                	mv	a6,a1
 300b808:	03011737          	lui	a4,0x3011
 300b80c:	e4070713          	addi	a4,a4,-448 # 3010e40 <g_crgIpMatch+0x930>
 300b810:	4310                	lw	a2,0(a4)
 300b812:	4354                	lw	a3,4(a4)
 300b814:	853e                	mv	a0,a5
 300b816:	85c2                	mv	a1,a6
 300b818:	37bd                	jal	ra,300b786 <__muldf3.trans.25>
 300b81a:	87aa                	mv	a5,a0
 300b81c:	882e                	mv	a6,a1
 300b81e:	853e                	mv	a0,a5
 300b820:	85c2                	mv	a1,a6
 300b822:	2e19                	jal	ra,300bb38 <__truncdfsf2.trans.26>
 300b824:	20a507d3          	fmv.s	fa5,fa0
 300b828:	fcf42a27          	fsw	fa5,-44(s0)

    g_SendData.SensorStr.X_speed = (short)(round(A_Move_X)); //小车x轴速度，单位mm/s
 300b82c:	fd842507          	flw	fa0,-40(s0)
 300b830:	378d                	jal	ra,300b792 <__extendsfdf2.trans.10>
 300b832:	87aa                	mv	a5,a0
 300b834:	882e                	mv	a6,a1
 300b836:	853e                	mv	a0,a5
 300b838:	85c2                	mv	a1,a6
 300b83a:	3b7040ef          	jal	ra,30103f0 <round>
 300b83e:	87aa                	mv	a5,a0
 300b840:	882e                	mv	a6,a1
 300b842:	853e                	mv	a0,a5
 300b844:	85c2                	mv	a1,a6
 300b846:	732040ef          	jal	ra,300ff78 <__fixdfsi>
 300b84a:	87aa                	mv	a5,a0
 300b84c:	01079713          	slli	a4,a5,0x10
 300b850:	8741                	srai	a4,a4,0x10
 300b852:	f6818793          	addi	a5,gp,-152 # 4000664 <g_SendData>
 300b856:	afba                	sh	a4,26(a5)
    g_SendData.SensorStr.Y_speed = 0;
 300b858:	f6818793          	addi	a5,gp,-152 # 4000664 <g_SendData>
 300b85c:	00079e23          	sh	zero,28(a5)
    g_SendData.SensorStr.Z_speed = (short)(round(A_Move_Z)); //小车角速度，单位mm/s
 300b860:	fd442507          	flw	fa0,-44(s0)
 300b864:	373d                	jal	ra,300b792 <__extendsfdf2.trans.10>
 300b866:	87aa                	mv	a5,a0
 300b868:	882e                	mv	a6,a1
 300b86a:	853e                	mv	a0,a5
 300b86c:	85c2                	mv	a1,a6
 300b86e:	383040ef          	jal	ra,30103f0 <round>
 300b872:	87aa                	mv	a5,a0
 300b874:	882e                	mv	a6,a1
 300b876:	853e                	mv	a0,a5
 300b878:	85c2                	mv	a1,a6
 300b87a:	6fe040ef          	jal	ra,300ff78 <__fixdfsi>
 300b87e:	87aa                	mv	a5,a0
 300b880:	01079713          	slli	a4,a5,0x10
 300b884:	8741                	srai	a4,a4,0x10
 300b886:	f6818793          	addi	a5,gp,-152 # 4000664 <g_SendData>
 300b88a:	affa                	sh	a4,30(a5)

    DBG_PRINTF("ActualeftSpeed:%.2fmm/s,ActualRightSpeed:%.2fmm/s,A_Move_X=%.2fmm/s,A_Move_Z=%.2fmrad/s\r\n", 
                                                          aveLeftMotor.speed,aveRightMotor.speed,A_Move_X,A_Move_Z);
 300b88c:	f4018793          	addi	a5,gp,-192 # 400063c <aveLeftMotor>
 300b890:	6b9c                	flw	fa5,16(a5)
    DBG_PRINTF("ActualeftSpeed:%.2fmm/s,ActualRightSpeed:%.2fmm/s,A_Move_X=%.2fmm/s,A_Move_Z=%.2fmrad/s\r\n", 
 300b892:	20f78553          	fmv.s	fa0,fa5
 300b896:	3df5                	jal	ra,300b792 <__extendsfdf2.trans.10>
 300b898:	892a                	mv	s2,a0
 300b89a:	89ae                	mv	s3,a1
                                                          aveLeftMotor.speed,aveRightMotor.speed,A_Move_X,A_Move_Z);
 300b89c:	f2418793          	addi	a5,gp,-220 # 4000620 <aveRightMotor>
 300b8a0:	6b9c                	flw	fa5,16(a5)
    DBG_PRINTF("ActualeftSpeed:%.2fmm/s,ActualRightSpeed:%.2fmm/s,A_Move_X=%.2fmm/s,A_Move_Z=%.2fmrad/s\r\n", 
 300b8a2:	20f78553          	fmv.s	fa0,fa5
 300b8a6:	35f5                	jal	ra,300b792 <__extendsfdf2.trans.10>
 300b8a8:	8a2a                	mv	s4,a0
 300b8aa:	8aae                	mv	s5,a1
 300b8ac:	fd842507          	flw	fa0,-40(s0)
 300b8b0:	35cd                	jal	ra,300b792 <__extendsfdf2.trans.10>
 300b8b2:	8b2a                	mv	s6,a0
 300b8b4:	8bae                	mv	s7,a1
 300b8b6:	fd442507          	flw	fa0,-44(s0)
 300b8ba:	3de1                	jal	ra,300b792 <__extendsfdf2.trans.10>
 300b8bc:	87aa                	mv	a5,a0
 300b8be:	882e                	mv	a6,a1
 300b8c0:	c03e                	sw	a5,0(sp)
 300b8c2:	c242                	sw	a6,4(sp)
 300b8c4:	885a                	mv	a6,s6
 300b8c6:	88de                	mv	a7,s7
 300b8c8:	8752                	mv	a4,s4
 300b8ca:	87d6                	mv	a5,s5
 300b8cc:	864a                	mv	a2,s2
 300b8ce:	86ce                	mv	a3,s3
 300b8d0:	030115b7          	lui	a1,0x3011
 300b8d4:	b9058513          	addi	a0,a1,-1136 # 3010b90 <g_crgIpMatch+0x680>
 300b8d8:	3d5d                	jal	ra,300b78e <DBG_UartPrintf.trans.12>

    //加速度计三轴加速度
    g_SendData.SensorStr.Accelerometer.X_data = 1;  //加速度计Y轴转换到ROS坐标X轴
 300b8da:	f6818793          	addi	a5,gp,-152 # 4000664 <g_SendData>
 300b8de:	4705                	li	a4,1
 300b8e0:	b3ba                	sh	a4,34(a5)
    g_SendData.SensorStr.Accelerometer.Y_data = 1;  //加速度计X轴转换到ROS坐标Y轴
 300b8e2:	f6818793          	addi	a5,gp,-152 # 4000664 <g_SendData>
 300b8e6:	4705                	li	a4,1
 300b8e8:	b3da                	sh	a4,36(a5)
    g_SendData.SensorStr.Accelerometer.Z_data = 1;  //加速度计Z轴转换到ROS坐标Z轴
 300b8ea:	f6818793          	addi	a5,gp,-152 # 4000664 <g_SendData>
 300b8ee:	4705                	li	a4,1
 300b8f0:	b3fa                	sh	a4,38(a5)

    //角速度计三轴角速度
    g_SendData.SensorStr.Gyroscope.X_data = 2;     //角速度计Y轴转换到ROS坐标X轴
 300b8f2:	f6818793          	addi	a5,gp,-152 # 4000664 <g_SendData>
 300b8f6:	4709                	li	a4,2
 300b8f8:	b79a                	sh	a4,40(a5)
    g_SendData.SensorStr.Gyroscope.Y_data = 2;     //角速度计X轴转换到ROS坐标Y轴
 300b8fa:	f6818793          	addi	a5,gp,-152 # 4000664 <g_SendData>
 300b8fe:	4709                	li	a4,2
 300b900:	b7ba                	sh	a4,42(a5)
    if (g_MotorState == 0)
 300b902:	f641c783          	lbu	a5,-156(gp) # 4000660 <g_MotorState>
 300b906:	e791                	bnez	a5,300b912 <data_transition+0x17c>
        //如果电机控制位使能状态，那么正常发送Z轴角速度
        g_SendData.SensorStr.Gyroscope.Z_data = 1;
 300b908:	f6818793          	addi	a5,gp,-152 # 4000664 <g_SendData>
 300b90c:	4705                	li	a4,1
 300b90e:	b7da                	sh	a4,44(a5)
 300b910:	a029                	j	300b91a <data_transition+0x184>
    else
        //如果机器人是静止的（电机控制位失能），那么发送的Z轴角速度为0
        g_SendData.SensorStr.Gyroscope.Z_data = 0;
 300b912:	f6818793          	addi	a5,gp,-152 # 4000664 <g_SendData>
 300b916:	02079623          	sh	zero,44(a5)

    //电池电压(这里将浮点数放大一千倍传输，相应的在接收端在接收到数据后也会缩小一千倍)
    g_SendData.SensorStr.Power_Voltage = 90;
 300b91a:	f6818793          	addi	a5,gp,-152 # 4000664 <g_SendData>
 300b91e:	05a00713          	li	a4,90
 300b922:	b39a                	sh	a4,32(a5)

    g_SendData.buffer[0] = g_SendData.SensorStr.Frame_Header; // 帧头
 300b924:	f6818793          	addi	a5,gp,-152 # 4000664 <g_SendData>
 300b928:	2f98                	lbu	a4,24(a5)
 300b92a:	f6818793          	addi	a5,gp,-152 # 4000664 <g_SendData>
 300b92e:	a398                	sb	a4,0(a5)
    g_SendData.buffer[1] = g_MotorState;                      // 小车软件失能标志位
 300b930:	f641c703          	lbu	a4,-156(gp) # 4000660 <g_MotorState>
 300b934:	f6818793          	addi	a5,gp,-152 # 4000664 <g_SendData>
 300b938:	b398                	sb	a4,1(a5)

    //小车三轴速度,各轴都拆分为两个8位数据再发送
    g_SendData.buffer[2] = g_SendData.SensorStr.X_speed >> 8;
 300b93a:	f6818793          	addi	a5,gp,-152 # 4000664 <g_SendData>
 300b93e:	01a79783          	lh	a5,26(a5)
 300b942:	87a1                	srai	a5,a5,0x8
 300b944:	07c2                	slli	a5,a5,0x10
 300b946:	87c1                	srai	a5,a5,0x10
 300b948:	0ff7f713          	andi	a4,a5,255
 300b94c:	f6818793          	addi	a5,gp,-152 # 4000664 <g_SendData>
 300b950:	a3b8                	sb	a4,2(a5)
    g_SendData.buffer[3] = g_SendData.SensorStr.X_speed;
 300b952:	f6818793          	addi	a5,gp,-152 # 4000664 <g_SendData>
 300b956:	01a79783          	lh	a5,26(a5)
 300b95a:	0ff7f713          	andi	a4,a5,255
 300b95e:	f6818793          	addi	a5,gp,-152 # 4000664 <g_SendData>
 300b962:	b3b8                	sb	a4,3(a5)
    g_SendData.buffer[4] = g_SendData.SensorStr.Y_speed >> 8;
 300b964:	f6818793          	addi	a5,gp,-152 # 4000664 <g_SendData>
 300b968:	01c79783          	lh	a5,28(a5)
 300b96c:	87a1                	srai	a5,a5,0x8
 300b96e:	07c2                	slli	a5,a5,0x10
 300b970:	87c1                	srai	a5,a5,0x10
 300b972:	0ff7f713          	andi	a4,a5,255
 300b976:	f6818793          	addi	a5,gp,-152 # 4000664 <g_SendData>
 300b97a:	a3d8                	sb	a4,4(a5)
    g_SendData.buffer[5] = g_SendData.SensorStr.Y_speed;
 300b97c:	f6818793          	addi	a5,gp,-152 # 4000664 <g_SendData>
 300b980:	01c79783          	lh	a5,28(a5)
 300b984:	0ff7f713          	andi	a4,a5,255
 300b988:	f6818793          	addi	a5,gp,-152 # 4000664 <g_SendData>
 300b98c:	b3d8                	sb	a4,5(a5)
    g_SendData.buffer[6] = g_SendData.SensorStr.Z_speed >> 8;
 300b98e:	f6818793          	addi	a5,gp,-152 # 4000664 <g_SendData>
 300b992:	01e79783          	lh	a5,30(a5)
 300b996:	87a1                	srai	a5,a5,0x8
 300b998:	07c2                	slli	a5,a5,0x10
 300b99a:	87c1                	srai	a5,a5,0x10
 300b99c:	0ff7f713          	andi	a4,a5,255
 300b9a0:	f6818793          	addi	a5,gp,-152 # 4000664 <g_SendData>
 300b9a4:	a3f8                	sb	a4,6(a5)
    g_SendData.buffer[7] = g_SendData.SensorStr.Z_speed;
 300b9a6:	f6818793          	addi	a5,gp,-152 # 4000664 <g_SendData>
 300b9aa:	01e79783          	lh	a5,30(a5)
 300b9ae:	0ff7f713          	andi	a4,a5,255
 300b9b2:	f6818793          	addi	a5,gp,-152 # 4000664 <g_SendData>
 300b9b6:	b3f8                	sb	a4,7(a5)

    //IMU加速度计三轴加速度,各轴都拆分为两个8位数据再发送
    g_SendData.buffer[8] = g_SendData.SensorStr.Accelerometer.X_data >> 8;
 300b9b8:	f6818793          	addi	a5,gp,-152 # 4000664 <g_SendData>
 300b9bc:	02279783          	lh	a5,34(a5)
 300b9c0:	87a1                	srai	a5,a5,0x8
 300b9c2:	07c2                	slli	a5,a5,0x10
 300b9c4:	87c1                	srai	a5,a5,0x10
 300b9c6:	0ff7f713          	andi	a4,a5,255
 300b9ca:	f6818793          	addi	a5,gp,-152 # 4000664 <g_SendData>
 300b9ce:	a798                	sb	a4,8(a5)
    g_SendData.buffer[9] = g_SendData.SensorStr.Accelerometer.X_data;
 300b9d0:	f6818793          	addi	a5,gp,-152 # 4000664 <g_SendData>
 300b9d4:	02279783          	lh	a5,34(a5)
 300b9d8:	0ff7f713          	andi	a4,a5,255
 300b9dc:	f6818793          	addi	a5,gp,-152 # 4000664 <g_SendData>
 300b9e0:	b798                	sb	a4,9(a5)
    g_SendData.buffer[10] = g_SendData.SensorStr.Accelerometer.Y_data >> 8;
 300b9e2:	f6818793          	addi	a5,gp,-152 # 4000664 <g_SendData>
 300b9e6:	02479783          	lh	a5,36(a5)
 300b9ea:	87a1                	srai	a5,a5,0x8
 300b9ec:	07c2                	slli	a5,a5,0x10
 300b9ee:	87c1                	srai	a5,a5,0x10
 300b9f0:	0ff7f713          	andi	a4,a5,255
 300b9f4:	f6818793          	addi	a5,gp,-152 # 4000664 <g_SendData>
 300b9f8:	a7b8                	sb	a4,10(a5)
    g_SendData.buffer[11] = g_SendData.SensorStr.Accelerometer.Y_data;
 300b9fa:	f6818793          	addi	a5,gp,-152 # 4000664 <g_SendData>
 300b9fe:	02479783          	lh	a5,36(a5)
 300ba02:	0ff7f713          	andi	a4,a5,255
 300ba06:	f6818793          	addi	a5,gp,-152 # 4000664 <g_SendData>
 300ba0a:	b7b8                	sb	a4,11(a5)
    g_SendData.buffer[12] = g_SendData.SensorStr.Accelerometer.Z_data >> 8;
 300ba0c:	f6818793          	addi	a5,gp,-152 # 4000664 <g_SendData>
 300ba10:	02679783          	lh	a5,38(a5)
 300ba14:	87a1                	srai	a5,a5,0x8
 300ba16:	07c2                	slli	a5,a5,0x10
 300ba18:	87c1                	srai	a5,a5,0x10
 300ba1a:	0ff7f713          	andi	a4,a5,255
 300ba1e:	f6818793          	addi	a5,gp,-152 # 4000664 <g_SendData>
 300ba22:	a7d8                	sb	a4,12(a5)
    g_SendData.buffer[13] = g_SendData.SensorStr.Accelerometer.Z_data;
 300ba24:	f6818793          	addi	a5,gp,-152 # 4000664 <g_SendData>
 300ba28:	02679783          	lh	a5,38(a5)
 300ba2c:	0ff7f713          	andi	a4,a5,255
 300ba30:	f6818793          	addi	a5,gp,-152 # 4000664 <g_SendData>
 300ba34:	b7d8                	sb	a4,13(a5)

    //IMU角速度计三轴角速度,各轴都拆分为两个8位数据再发送
    g_SendData.buffer[14] = g_SendData.SensorStr.Gyroscope.X_data >> 8;
 300ba36:	f6818793          	addi	a5,gp,-152 # 4000664 <g_SendData>
 300ba3a:	02879783          	lh	a5,40(a5)
 300ba3e:	87a1                	srai	a5,a5,0x8
 300ba40:	07c2                	slli	a5,a5,0x10
 300ba42:	87c1                	srai	a5,a5,0x10
 300ba44:	0ff7f713          	andi	a4,a5,255
 300ba48:	f6818793          	addi	a5,gp,-152 # 4000664 <g_SendData>
 300ba4c:	a7f8                	sb	a4,14(a5)
    g_SendData.buffer[15] = g_SendData.SensorStr.Gyroscope.X_data;
 300ba4e:	f6818793          	addi	a5,gp,-152 # 4000664 <g_SendData>
 300ba52:	02879783          	lh	a5,40(a5)
 300ba56:	0ff7f713          	andi	a4,a5,255
 300ba5a:	f6818793          	addi	a5,gp,-152 # 4000664 <g_SendData>
 300ba5e:	b7f8                	sb	a4,15(a5)
    g_SendData.buffer[16] = g_SendData.SensorStr.Gyroscope.Y_data >> 8;
 300ba60:	f6818793          	addi	a5,gp,-152 # 4000664 <g_SendData>
 300ba64:	02a79783          	lh	a5,42(a5)
 300ba68:	87a1                	srai	a5,a5,0x8
 300ba6a:	07c2                	slli	a5,a5,0x10
 300ba6c:	87c1                	srai	a5,a5,0x10
 300ba6e:	0ff7f713          	andi	a4,a5,255
 300ba72:	f6818793          	addi	a5,gp,-152 # 4000664 <g_SendData>
 300ba76:	ab98                	sb	a4,16(a5)
    g_SendData.buffer[17] = g_SendData.SensorStr.Gyroscope.Y_data;
 300ba78:	f6818793          	addi	a5,gp,-152 # 4000664 <g_SendData>
 300ba7c:	02a79783          	lh	a5,42(a5)
 300ba80:	0ff7f713          	andi	a4,a5,255
 300ba84:	f6818793          	addi	a5,gp,-152 # 4000664 <g_SendData>
 300ba88:	bb98                	sb	a4,17(a5)
    g_SendData.buffer[18] = g_SendData.SensorStr.Gyroscope.Z_data >> 8;
 300ba8a:	f6818793          	addi	a5,gp,-152 # 4000664 <g_SendData>
 300ba8e:	02c79783          	lh	a5,44(a5)
 300ba92:	87a1                	srai	a5,a5,0x8
 300ba94:	07c2                	slli	a5,a5,0x10
 300ba96:	87c1                	srai	a5,a5,0x10
 300ba98:	0ff7f713          	andi	a4,a5,255
 300ba9c:	f6818793          	addi	a5,gp,-152 # 4000664 <g_SendData>
 300baa0:	abb8                	sb	a4,18(a5)
    g_SendData.buffer[19] = g_SendData.SensorStr.Gyroscope.Z_data;
 300baa2:	f6818793          	addi	a5,gp,-152 # 4000664 <g_SendData>
 300baa6:	02c79783          	lh	a5,44(a5)
 300baaa:	0ff7f713          	andi	a4,a5,255
 300baae:	f6818793          	addi	a5,gp,-152 # 4000664 <g_SendData>
 300bab2:	bbb8                	sb	a4,19(a5)

    //电池电压,拆分为两个8位数据发送
    g_SendData.buffer[20] = g_SendData.SensorStr.Power_Voltage >> 8;
 300bab4:	f6818793          	addi	a5,gp,-152 # 4000664 <g_SendData>
 300bab8:	02079783          	lh	a5,32(a5)
 300babc:	87a1                	srai	a5,a5,0x8
 300babe:	07c2                	slli	a5,a5,0x10
 300bac0:	87c1                	srai	a5,a5,0x10
 300bac2:	0ff7f713          	andi	a4,a5,255
 300bac6:	f6818793          	addi	a5,gp,-152 # 4000664 <g_SendData>
 300baca:	abd8                	sb	a4,20(a5)
    g_SendData.buffer[21] = g_SendData.SensorStr.Power_Voltage;
 300bacc:	f6818793          	addi	a5,gp,-152 # 4000664 <g_SendData>
 300bad0:	02079783          	lh	a5,32(a5)
 300bad4:	0ff7f713          	andi	a4,a5,255
 300bad8:	f6818793          	addi	a5,gp,-152 # 4000664 <g_SendData>
 300badc:	bbd8                	sb	a4,21(a5)

    //数据校验位计算
    unsigned char check_sum = 0, k;
 300bade:	fc040fa3          	sb	zero,-33(s0)
    for (k = 0; k < 22; k++) {
 300bae2:	fc040f23          	sb	zero,-34(s0)
 300bae6:	a00d                	j	300bb08 <data_transition+0x372>
        check_sum = check_sum ^ g_SendData.buffer[k];
 300bae8:	fde44783          	lbu	a5,-34(s0)
 300baec:	f6818713          	addi	a4,gp,-152 # 4000664 <g_SendData>
 300baf0:	97ba                	add	a5,a5,a4
 300baf2:	2398                	lbu	a4,0(a5)
 300baf4:	fdf44783          	lbu	a5,-33(s0)
 300baf8:	8fb9                	xor	a5,a5,a4
 300bafa:	fcf40fa3          	sb	a5,-33(s0)
    for (k = 0; k < 22; k++) {
 300bafe:	fde44783          	lbu	a5,-34(s0)
 300bb02:	0785                	addi	a5,a5,1
 300bb04:	fcf40f23          	sb	a5,-34(s0)
 300bb08:	fde44703          	lbu	a4,-34(s0)
 300bb0c:	47d5                	li	a5,21
 300bb0e:	fce7fde3          	bgeu	a5,a4,300bae8 <data_transition+0x352>
    }
    g_SendData.buffer[22] = check_sum;
 300bb12:	f6818793          	addi	a5,gp,-152 # 4000664 <g_SendData>
 300bb16:	fdf44703          	lbu	a4,-33(s0)
 300bb1a:	abf8                	sb	a4,22(a5)
    g_SendData.buffer[23] = g_SendData.SensorStr.Frame_Tail; //帧尾
 300bb1c:	f6818793          	addi	a5,gp,-152 # 4000664 <g_SendData>
 300bb20:	02e7c703          	lbu	a4,46(a5)
 300bb24:	f6818793          	addi	a5,gp,-152 # 4000664 <g_SendData>
 300bb28:	bbf8                	sb	a4,23(a5)
}
 300bb2a:	0001                	nop
 300bb2c:	02010293          	addi	t0,sp,32
 300bb30:	07e2828b          	ldmia	{ra,s0,s2-s7},(t0)
 300bb34:	6121                	addi	sp,sp,64
 300bb36:	8082                	ret

0300bb38 <__truncdfsf2.trans.26>:
 300bb38:	6460406f          	j	301017e <__truncdfsf2>

0300bb3c <UART3WriteInterruptCallback>:
    }
    DBG_PRINTF("  \r\n");
}

void UART3WriteInterruptCallback(void *handle)
{
 300bb3c:	1101                	addi	sp,sp,-32
 300bb3e:	ce22                	sw	s0,28(sp)
 300bb40:	1000                	addi	s0,sp,32
 300bb42:	fea42623          	sw	a0,-20(s0)
    BASE_FUNC_UNUSED(handle);
    //DBG_PRINTF("\r\nUART Write Finish\r\n");
    g_TxInterruptFlag = true;
 300bb46:	4705                	li	a4,1
 300bb48:	a0e18ba3          	sb	a4,-1513(gp) # 4000113 <g_TxInterruptFlag>
    return;
 300bb4c:	0001                	nop
}
 300bb4e:	4472                	lw	s0,28(sp)
 300bb50:	6105                	addi	sp,sp,32
 300bb52:	8082                	ret

0300bb54 <UART3ReadInterruptCallback>:

void UART3ReadInterruptCallback(void *handle)
{
 300bb54:	1101                	addi	sp,sp,-32
 300bb56:	ce22                	sw	s0,28(sp)
 300bb58:	1000                	addi	s0,sp,32
 300bb5a:	fea42623          	sw	a0,-20(s0)
    BASE_FUNC_UNUSED(handle);
    g_RxInterruptflag = 1;
 300bb5e:	4705                	li	a4,1
 300bb60:	a0e18b23          	sb	a4,-1514(gp) # 4000112 <g_RxInterruptflag>
    return;
 300bb64:	0001                	nop
}
 300bb66:	4472                	lw	s0,28(sp)
 300bb68:	6105                	addi	sp,sp,32
 300bb6a:	8082                	ret

0300bb6c <TIMER0_InterruptProcess>:

// 定时器10ms产生一个中断
void TIMER0_InterruptProcess(void *handle)
{
 300bb6c:	7179                	addi	sp,sp,-48
 300bb6e:	d606                	sw	ra,44(sp)
 300bb70:	d422                	sw	s0,40(sp)
 300bb72:	1800                	addi	s0,sp,48
 300bb74:	fca42e23          	sw	a0,-36(s0)
    BASE_StatusType ret;
    /* USER CODE BEGIN TIMER0_InterruptProcess */
    TIMER_Handle *timerHandle = (TIMER_Handle *)handle;
 300bb78:	fdc42783          	lw	a5,-36(s0)
 300bb7c:	fef42623          	sw	a5,-20(s0)
    BASE_FUNC_UNUSED(timerHandle);
    g_TimerInterruptCount++;
 300bb80:	fbc1a783          	lw	a5,-68(gp) # 40006b8 <g_TimerInterruptCount>
 300bb84:	00178713          	addi	a4,a5,1
 300bb88:	fae1ae23          	sw	a4,-68(gp) # 40006b8 <g_TimerInterruptCount>

    //按键滤波，500毫秒内算一次按键
    if(g_button1_count > 0)
 300bb8c:	eb81a783          	lw	a5,-328(gp) # 40005b4 <g_button1_count>
 300bb90:	02f05063          	blez	a5,300bbb0 <TIMER0_InterruptProcess+0x44>
    {
        g_button1_count ++;
 300bb94:	eb81a783          	lw	a5,-328(gp) # 40005b4 <g_button1_count>
 300bb98:	00178713          	addi	a4,a5,1
 300bb9c:	eae1ac23          	sw	a4,-328(gp) # 40005b4 <g_button1_count>
        if(g_button1_count > 50){
 300bba0:	eb81a703          	lw	a4,-328(gp) # 40005b4 <g_button1_count>
 300bba4:	03200793          	li	a5,50
 300bba8:	00e7d463          	bge	a5,a4,300bbb0 <TIMER0_InterruptProcess+0x44>
           g_button1_count = 0;
 300bbac:	ea01ac23          	sw	zero,-328(gp) # 40005b4 <g_button1_count>
           //DBG_PRINTF("Button1 Count Reset 0\r\n");
        }
    }

    if(g_button2_count > 0)
 300bbb0:	ebc1a783          	lw	a5,-324(gp) # 40005b8 <g_button2_count>
 300bbb4:	02f05063          	blez	a5,300bbd4 <TIMER0_InterruptProcess+0x68>
    {
        g_button2_count ++;
 300bbb8:	ebc1a783          	lw	a5,-324(gp) # 40005b8 <g_button2_count>
 300bbbc:	00178713          	addi	a4,a5,1
 300bbc0:	eae1ae23          	sw	a4,-324(gp) # 40005b8 <g_button2_count>
        if(g_button2_count > 50){
 300bbc4:	ebc1a703          	lw	a4,-324(gp) # 40005b8 <g_button2_count>
 300bbc8:	03200793          	li	a5,50
 300bbcc:	00e7d463          	bge	a5,a4,300bbd4 <TIMER0_InterruptProcess+0x68>
           g_button2_count = 0;
 300bbd0:	ea01ae23          	sw	zero,-324(gp) # 40005b8 <g_button2_count>
           //DBG_PRINTF("Button2 Count Reset 0\r\n");
        }
    }

    //按设置周期上报底盘数据
    if ((g_TimerInterruptCount % (EULER_CAR_DATA_SEND_PERIOD/10)) == 0) {
 300bbd4:	fbc1a703          	lw	a4,-68(gp) # 40006b8 <g_TimerInterruptCount>
 300bbd8:	47a9                	li	a5,10
 300bbda:	02f777b3          	remu	a5,a4,a5
 300bbde:	e7b9                	bnez	a5,300bc2c <TIMER0_InterruptProcess+0xc0>
        if (g_TxInterruptFlag) {
 300bbe0:	a171c783          	lbu	a5,-1513(gp) # 4000113 <g_TxInterruptFlag>
 300bbe4:	9f81                	uxtb	a5
 300bbe6:	c3b9                	beqz	a5,300bc2c <TIMER0_InterruptProcess+0xc0>
            g_TxInterruptFlag = false;
 300bbe8:	a0018ba3          	sb	zero,-1513(gp) # 4000113 <g_TxInterruptFlag>
            //获取小车要发送的数据
            QDM_CalMotorSpeed(&aveLeftMotor);    //计算左轮平均速度           
 300bbec:	f4018513          	addi	a0,gp,-192 # 400063c <aveLeftMotor>
 300bbf0:	28c9                	jal	ra,300bcc2 <QDM_CalMotorSpeed.trans.39>
            QDM_CalMotorSpeed(&aveRightMotor);   //计算右轮平均速度
 300bbf2:	f2418513          	addi	a0,gp,-220 # 4000620 <aveRightMotor>
 300bbf6:	20f1                	jal	ra,300bcc2 <QDM_CalMotorSpeed.trans.39>
            data_transition();
 300bbf8:	3e79                	jal	ra,300b796 <data_transition>

            ret = HAL_UART_WriteIT(&g_uart3, g_SendData.buffer, SEND_DATA_SIZE);
 300bbfa:	4661                	li	a2,24
 300bbfc:	f6818593          	addi	a1,gp,-152 # 4000664 <g_SendData>
 300bc00:	32818513          	addi	a0,gp,808 # 4000a24 <g_uart3>
 300bc04:	d0ffe0ef          	jal	ra,300a912 <HAL_UART_WriteIT>
 300bc08:	fea42423          	sw	a0,-24(s0)
           
            if(ret == BASE_STATUS_OK) {
 300bc0c:	fe842783          	lw	a5,-24(s0)
 300bc10:	cb81                	beqz	a5,300bc20 <TIMER0_InterruptProcess+0xb4>
                //DBG_PRINTF("Data send OK, send count = %d\r\n",g_SendCount);
            }else{
                DBG_PRINTF("Data send error, code = %d\r\n",ret);
 300bc12:	fe842583          	lw	a1,-24(s0)
 300bc16:	030117b7          	lui	a5,0x3011
 300bc1a:	c3078513          	addi	a0,a5,-976 # 3010c30 <g_crgIpMatch+0x720>
 300bc1e:	3e85                	jal	ra,300b78e <DBG_UartPrintf.trans.12>
            }
            g_SendCount++;
 300bc20:	fc01a783          	lw	a5,-64(gp) # 40006bc <g_SendCount>
 300bc24:	00178713          	addi	a4,a5,1
 300bc28:	fce1a023          	sw	a4,-64(gp) # 40006bc <g_SendCount>
    }

    //每间隔10毫秒进行一次PID电机控制
    if (g_TimerInterruptCount % (MOTOR_PID_CONTROL_PERIOD / 10) == 0) {
         //获取小车运行实际速度
         QDM_CalMotorSpeed(&pidLeftMotor);    //计算一个PID周期内左轮速度           
 300bc2c:	f0818513          	addi	a0,gp,-248 # 4000604 <pidLeftMotor>
 300bc30:	2849                	jal	ra,300bcc2 <QDM_CalMotorSpeed.trans.39>
         QDM_CalMotorSpeed(&pidRightMotor);   //计算一个PID周期内右轮速度
 300bc32:	eec18513          	addi	a0,gp,-276 # 40005e8 <pidRightMotor>
 300bc36:	2071                	jal	ra,300bcc2 <QDM_CalMotorSpeed.trans.39>
       
         g_pidEulerCarLeft.ActualSpeed = pidLeftMotor.speed;
 300bc38:	f0818793          	addi	a5,gp,-248 # 4000604 <pidLeftMotor>
 300bc3c:	6b9c                	flw	fa5,16(a5)
 300bc3e:	6d818793          	addi	a5,gp,1752 # 4000dd4 <g_pidEulerCarLeft>
 300bc42:	e3dc                	fsw	fa5,4(a5)
         g_pidEulerCarRight.ActualSpeed = pidRightMotor.speed;
 300bc44:	eec18793          	addi	a5,gp,-276 # 40005e8 <pidRightMotor>
 300bc48:	6b9c                	flw	fa5,16(a5)
 300bc4a:	6b818793          	addi	a5,gp,1720 # 4000db4 <g_pidEulerCarRight>
 300bc4e:	e3dc                	fsw	fa5,4(a5)
         
         //如果上位机下发速度大于0.1mm/s，则启动PID控制
         if ((fabsf(modelCalLeftSpeed) > 0.1) || (fabsf(modelCalRightSpeed) > 0.1)) {
 300bc50:	fd41a787          	flw	fa5,-44(gp) # 40006d0 <modelCalLeftSpeed>
 300bc54:	20f78553          	fmv.s	fa0,fa5
 300bc58:	2961                	jal	ra,300c0f0 <fabsf.trans.24>
 300bc5a:	20a507d3          	fmv.s	fa5,fa0
 300bc5e:	20f78553          	fmv.s	fa0,fa5
 300bc62:	3e05                	jal	ra,300b792 <__extendsfdf2.trans.10>
 300bc64:	87aa                	mv	a5,a0
 300bc66:	882e                	mv	a6,a1
 300bc68:	03011737          	lui	a4,0x3011
 300bc6c:	e4870713          	addi	a4,a4,-440 # 3010e48 <g_crgIpMatch+0x938>
 300bc70:	4310                	lw	a2,0(a4)
 300bc72:	4354                	lw	a3,4(a4)
 300bc74:	853e                	mv	a0,a5
 300bc76:	85c2                	mv	a1,a6
 300bc78:	394030ef          	jal	ra,300f00c <__gedf2>
 300bc7c:	87aa                	mv	a5,a0
 300bc7e:	02f04c63          	bgtz	a5,300bcb6 <TIMER0_InterruptProcess+0x14a>
 300bc82:	fd81a787          	flw	fa5,-40(gp) # 40006d4 <modelCalRightSpeed>
 300bc86:	20f78553          	fmv.s	fa0,fa5
 300bc8a:	219d                	jal	ra,300c0f0 <fabsf.trans.24>
 300bc8c:	20a507d3          	fmv.s	fa5,fa0
 300bc90:	20f78553          	fmv.s	fa0,fa5
 300bc94:	3cfd                	jal	ra,300b792 <__extendsfdf2.trans.10>
 300bc96:	87aa                	mv	a5,a0
 300bc98:	882e                	mv	a6,a1
 300bc9a:	03011737          	lui	a4,0x3011
 300bc9e:	e4870713          	addi	a4,a4,-440 # 3010e48 <g_crgIpMatch+0x938>
 300bca2:	4310                	lw	a2,0(a4)
 300bca4:	4354                	lw	a3,4(a4)
 300bca6:	853e                	mv	a0,a5
 300bca8:	85c2                	mv	a1,a6
 300bcaa:	362030ef          	jal	ra,300f00c <__gedf2>
 300bcae:	87aa                	mv	a5,a0
 300bcb0:	00f04363          	bgtz	a5,300bcb6 <TIMER0_InterruptProcess+0x14a>
             Pid_Process();
         }
    }

}
 300bcb4:	a011                	j	300bcb8 <TIMER0_InterruptProcess+0x14c>
             Pid_Process();
 300bcb6:	2429                	jal	ra,300bec0 <Pid_Process>
}
 300bcb8:	0001                	nop
 300bcba:	50b2                	lw	ra,44(sp)
 300bcbc:	5422                	lw	s0,40(sp)
 300bcbe:	6145                	addi	sp,sp,48
 300bcc0:	8082                	ret

0300bcc2 <QDM_CalMotorSpeed.trans.39>:
 300bcc2:	87dff06f          	j	300b53e <QDM_CalMotorSpeed>

0300bcc6 <XYZ_transition>:

static float XYZ_transition(unsigned char High, unsigned char Low)
{
 300bcc6:	7179                	addi	sp,sp,-48
 300bcc8:	d622                	sw	s0,44(sp)
 300bcca:	1800                	addi	s0,sp,48
 300bccc:	87aa                	mv	a5,a0
 300bcce:	872e                	mv	a4,a1
 300bcd0:	fcf40fa3          	sb	a5,-33(s0)
 300bcd4:	87ba                	mv	a5,a4
 300bcd6:	fcf40f23          	sb	a5,-34(s0)
    short transition = ((High << 8) + Low);                    //将高8位和低8位整合成一个16位的short型数据
 300bcda:	fdf44783          	lbu	a5,-33(s0)
 300bcde:	9fa1                	uxth	a5
 300bce0:	07a2                	slli	a5,a5,0x8
 300bce2:	01079713          	slli	a4,a5,0x10
 300bce6:	8341                	srli	a4,a4,0x10
 300bce8:	fde44783          	lbu	a5,-34(s0)
 300bcec:	9fa1                	uxth	a5
 300bcee:	97ba                	add	a5,a5,a4
 300bcf0:	9fa1                	uxth	a5
 300bcf2:	fef41723          	sh	a5,-18(s0)
    //return transition / 1000 + (transition % 1000) * 0.001;  //单位转换, mm/s->m/s
    return (float)transition;
 300bcf6:	fee41783          	lh	a5,-18(s0)
 300bcfa:	d007f7d3          	fcvt.s.w	fa5,a5
}
 300bcfe:	20f78553          	fmv.s	fa0,fa5
 300bd02:	5432                	lw	s0,44(sp)
 300bd04:	6145                	addi	sp,sp,48
 300bd06:	8082                	ret

0300bd08 <EulerCarSpeedCtrlLeft>:

int EulerCarSpeedCtrlLeft(float LeftSpeed)
{
 300bd08:	7179                	addi	sp,sp,-48
 300bd0a:	d606                	sw	ra,44(sp)
 300bd0c:	d422                	sw	s0,40(sp)
 300bd0e:	1800                	addi	s0,sp,48
 300bd10:	fca42e27          	fsw	fa0,-36(s0)

    unsigned int duty = (abs)((int)(LeftSpeed/g_motorMaxSpeed * 100)); 
 300bd14:	a681a787          	flw	fa5,-1432(gp) # 4000164 <g_motorMaxSpeed>
 300bd18:	fdc42707          	flw	fa4,-36(s0)
 300bd1c:	18f77753          	fdiv.s	fa4,fa4,fa5
 300bd20:	030117b7          	lui	a5,0x3011
 300bd24:	e507a787          	flw	fa5,-432(a5) # 3010e50 <g_crgIpMatch+0x940>
 300bd28:	10f777d3          	fmul.s	fa5,fa4,fa5
 300bd2c:	c00797d3          	fcvt.w.s	a5,fa5,rtz
 300bd30:	853e                	mv	a0,a5
 300bd32:	7ce040ef          	jal	ra,3010500 <abs>
 300bd36:	87aa                	mv	a5,a0
 300bd38:	fef42623          	sw	a5,-20(s0)
    if (duty > 99) {
 300bd3c:	fec42703          	lw	a4,-20(s0)
 300bd40:	06300793          	li	a5,99
 300bd44:	00e7f663          	bgeu	a5,a4,300bd50 <EulerCarSpeedCtrlLeft+0x48>
        duty = 35;
 300bd48:	02300793          	li	a5,35
 300bd4c:	fef42623          	sw	a5,-20(s0)
    }
    //DBG_PRINTF("left wheel duty:%d\r\n", duty);
    HAL_APT_SetPWMDutyByNumber(&g_apt1, duty);
 300bd50:	fec42583          	lw	a1,-20(s0)
 300bd54:	4d818513          	addi	a0,gp,1240 # 4000bd4 <g_apt1>
 300bd58:	913f60ef          	jal	ra,300266a <HAL_APT_SetPWMDutyByNumber>

    //如果电机小于0.1mm/s，则停止电机转动
    if (fabsf(LeftSpeed) < 0.1) {
 300bd5c:	fdc42507          	flw	fa0,-36(s0)
 300bd60:	2e41                	jal	ra,300c0f0 <fabsf.trans.24>
 300bd62:	20a507d3          	fmv.s	fa5,fa0
 300bd66:	20f78553          	fmv.s	fa0,fa5
 300bd6a:	2679                	jal	ra,300c0f8 <__extendsfdf2.trans.11>
 300bd6c:	87aa                	mv	a5,a0
 300bd6e:	882e                	mv	a6,a1
 300bd70:	03011737          	lui	a4,0x3011
 300bd74:	e4870713          	addi	a4,a4,-440 # 3010e48 <g_crgIpMatch+0x938>
 300bd78:	4310                	lw	a2,0(a4)
 300bd7a:	4354                	lw	a3,4(a4)
 300bd7c:	853e                	mv	a0,a5
 300bd7e:	85c2                	mv	a1,a6
 300bd80:	26b5                	jal	ra,300c0ec <__ltdf2.trans.40>
 300bd82:	87aa                	mv	a5,a0
 300bd84:	0007d763          	bgez	a5,300bd92 <EulerCarSpeedCtrlLeft+0x8a>
        HAL_APT_StopModule(RUN_APT1);
 300bd88:	4509                	li	a0,2
 300bd8a:	8b1f60ef          	jal	ra,300263a <HAL_APT_StopModule>
        return 0;
 300bd8e:	4781                	li	a5,0
 300bd90:	a0a9                	j	300bdda <EulerCarSpeedCtrlLeft+0xd2>
    }
    if (LeftSpeed > 0) {
 300bd92:	fdc42787          	flw	fa5,-36(s0)
 300bd96:	f0000753          	fmv.w.x	fa4,zero
 300bd9a:	a0f717d3          	flt.s	a5,fa4,fa5
 300bd9e:	cf91                	beqz	a5,300bdba <EulerCarSpeedCtrlLeft+0xb2>
        User_APTPwmARecovery(g_apt1.baseAddress);  
 300bda0:	4d818793          	addi	a5,gp,1240 # 4000bd4 <g_apt1>
 300bda4:	439c                	lw	a5,0(a5)
 300bda6:	853e                	mv	a0,a5
 300bda8:	4e1000ef          	jal	ra,300ca88 <User_APTPwmARecovery>
        User_APTForcePWMBOutputLow(g_apt1.baseAddress);
 300bdac:	4d818793          	addi	a5,gp,1240 # 4000bd4 <g_apt1>
 300bdb0:	439c                	lw	a5,0(a5)
 300bdb2:	853e                	mv	a0,a5
 300bdb4:	49f000ef          	jal	ra,300ca52 <User_APTForcePWMBOutputLow>
 300bdb8:	a829                	j	300bdd2 <EulerCarSpeedCtrlLeft+0xca>
    } else {
        User_APTPwmBRecovery(g_apt1.baseAddress);
 300bdba:	4d818793          	addi	a5,gp,1240 # 4000bd4 <g_apt1>
 300bdbe:	439c                	lw	a5,0(a5)
 300bdc0:	853e                	mv	a0,a5
 300bdc2:	4e7000ef          	jal	ra,300caa8 <User_APTPwmBRecovery>
        User_APTForcePWMAOutputLow(g_apt1.baseAddress);
 300bdc6:	4d818793          	addi	a5,gp,1240 # 4000bd4 <g_apt1>
 300bdca:	439c                	lw	a5,0(a5)
 300bdcc:	853e                	mv	a0,a5
 300bdce:	451000ef          	jal	ra,300ca1e <User_APTForcePWMAOutputLow>
    }
    HAL_APT_StartModule(RUN_APT1);
 300bdd2:	4509                	li	a0,2
 300bdd4:	83bf60ef          	jal	ra,300260e <HAL_APT_StartModule>
    //DBG_PRINTF("Left wheel set duty:%d, run ok!\r\n",duty);

    return 0;
 300bdd8:	4781                	li	a5,0
}
 300bdda:	853e                	mv	a0,a5
 300bddc:	50b2                	lw	ra,44(sp)
 300bdde:	5422                	lw	s0,40(sp)
 300bde0:	6145                	addi	sp,sp,48
 300bde2:	8082                	ret

0300bde4 <EulerCarSpeedCtrlRight>:

int EulerCarSpeedCtrlRight(float rightSpeed)
{
 300bde4:	7179                	addi	sp,sp,-48
 300bde6:	d606                	sw	ra,44(sp)
 300bde8:	d422                	sw	s0,40(sp)
 300bdea:	1800                	addi	s0,sp,48
 300bdec:	fca42e27          	fsw	fa0,-36(s0)
    unsigned int duty = (abs)((int)(rightSpeed/g_motorMaxSpeed * 100));   
 300bdf0:	a681a787          	flw	fa5,-1432(gp) # 4000164 <g_motorMaxSpeed>
 300bdf4:	fdc42707          	flw	fa4,-36(s0)
 300bdf8:	18f77753          	fdiv.s	fa4,fa4,fa5
 300bdfc:	030117b7          	lui	a5,0x3011
 300be00:	e507a787          	flw	fa5,-432(a5) # 3010e50 <g_crgIpMatch+0x940>
 300be04:	10f777d3          	fmul.s	fa5,fa4,fa5
 300be08:	c00797d3          	fcvt.w.s	a5,fa5,rtz
 300be0c:	853e                	mv	a0,a5
 300be0e:	6f2040ef          	jal	ra,3010500 <abs>
 300be12:	87aa                	mv	a5,a0
 300be14:	fef42623          	sw	a5,-20(s0)
    if (duty > 99) {
 300be18:	fec42703          	lw	a4,-20(s0)
 300be1c:	06300793          	li	a5,99
 300be20:	00e7f663          	bgeu	a5,a4,300be2c <EulerCarSpeedCtrlRight+0x48>
        duty = 35;
 300be24:	02300793          	li	a5,35
 300be28:	fef42623          	sw	a5,-20(s0)
    }
    HAL_APT_SetPWMDutyByNumber(&g_apt0, duty);
 300be2c:	fec42583          	lw	a1,-20(s0)
 300be30:	47818513          	addi	a0,gp,1144 # 4000b74 <g_apt0>
 300be34:	837f60ef          	jal	ra,300266a <HAL_APT_SetPWMDutyByNumber>

    //如果电机小于0.1mm/s，则停止电机转动
    if (fabsf(rightSpeed) < 0.1) {
 300be38:	fdc42507          	flw	fa0,-36(s0)
 300be3c:	2c55                	jal	ra,300c0f0 <fabsf.trans.24>
 300be3e:	20a507d3          	fmv.s	fa5,fa0
 300be42:	20f78553          	fmv.s	fa0,fa5
 300be46:	2c4d                	jal	ra,300c0f8 <__extendsfdf2.trans.11>
 300be48:	87aa                	mv	a5,a0
 300be4a:	882e                	mv	a6,a1
 300be4c:	03011737          	lui	a4,0x3011
 300be50:	e4870713          	addi	a4,a4,-440 # 3010e48 <g_crgIpMatch+0x938>
 300be54:	4310                	lw	a2,0(a4)
 300be56:	4354                	lw	a3,4(a4)
 300be58:	853e                	mv	a0,a5
 300be5a:	85c2                	mv	a1,a6
 300be5c:	2c41                	jal	ra,300c0ec <__ltdf2.trans.40>
 300be5e:	87aa                	mv	a5,a0
 300be60:	0007d763          	bgez	a5,300be6e <EulerCarSpeedCtrlRight+0x8a>
        HAL_APT_StopModule(RUN_APT0);
 300be64:	4505                	li	a0,1
 300be66:	fd4f60ef          	jal	ra,300263a <HAL_APT_StopModule>
        return 0;
 300be6a:	4781                	li	a5,0
 300be6c:	a0a9                	j	300beb6 <EulerCarSpeedCtrlRight+0xd2>
    }
    if (rightSpeed > 0) { 
 300be6e:	fdc42787          	flw	fa5,-36(s0)
 300be72:	f0000753          	fmv.w.x	fa4,zero
 300be76:	a0f717d3          	flt.s	a5,fa4,fa5
 300be7a:	cf91                	beqz	a5,300be96 <EulerCarSpeedCtrlRight+0xb2>
        User_APTPwmARecovery(g_apt0.baseAddress); 
 300be7c:	47818793          	addi	a5,gp,1144 # 4000b74 <g_apt0>
 300be80:	439c                	lw	a5,0(a5)
 300be82:	853e                	mv	a0,a5
 300be84:	405000ef          	jal	ra,300ca88 <User_APTPwmARecovery>
        User_APTForcePWMBOutputLow(g_apt0.baseAddress);
 300be88:	47818793          	addi	a5,gp,1144 # 4000b74 <g_apt0>
 300be8c:	439c                	lw	a5,0(a5)
 300be8e:	853e                	mv	a0,a5
 300be90:	3c3000ef          	jal	ra,300ca52 <User_APTForcePWMBOutputLow>
 300be94:	a829                	j	300beae <EulerCarSpeedCtrlRight+0xca>
    } else {
        User_APTPwmBRecovery(g_apt0.baseAddress);
 300be96:	47818793          	addi	a5,gp,1144 # 4000b74 <g_apt0>
 300be9a:	439c                	lw	a5,0(a5)
 300be9c:	853e                	mv	a0,a5
 300be9e:	40b000ef          	jal	ra,300caa8 <User_APTPwmBRecovery>
        User_APTForcePWMAOutputLow(g_apt0.baseAddress);
 300bea2:	47818793          	addi	a5,gp,1144 # 4000b74 <g_apt0>
 300bea6:	439c                	lw	a5,0(a5)
 300bea8:	853e                	mv	a0,a5
 300beaa:	375000ef          	jal	ra,300ca1e <User_APTForcePWMAOutputLow>
    }
    HAL_APT_StartModule(RUN_APT0);
 300beae:	4505                	li	a0,1
 300beb0:	f5ef60ef          	jal	ra,300260e <HAL_APT_StartModule>
    //DBG_PRINTF("Right wheel set duty:%d, run ok!\r\n",duty);

    return 0;
 300beb4:	4781                	li	a5,0
}
 300beb6:	853e                	mv	a0,a5
 300beb8:	50b2                	lw	ra,44(sp)
 300beba:	5422                	lw	s0,40(sp)
 300bebc:	6145                	addi	sp,sp,48
 300bebe:	8082                	ret

0300bec0 <Pid_Process>:

void Pid_Process(void)
{
 300bec0:	1101                	addi	sp,sp,-32
 300bec2:	ce06                	sw	ra,28(sp)
 300bec4:	cc22                	sw	s0,24(sp)
 300bec6:	1000                	addi	s0,sp,32
    float pidTargetSpeed;
    g_pid_count++;
 300bec8:	6b41a783          	lw	a5,1716(gp) # 4000db0 <g_pid_count>
 300becc:	00178713          	addi	a4,a5,1
 300bed0:	6ae1aa23          	sw	a4,1716(gp) # 4000db0 <g_pid_count>

    /* 通过PID算法计算右轮目标速度 */
    pidTargetSpeed = Pid_Ctrl(&g_pidEulerCarRight);
 300bed4:	6b818513          	addi	a0,gp,1720 # 4000db4 <g_pidEulerCarRight>
 300bed8:	031000ef          	jal	ra,300c708 <Pid_Ctrl>
 300bedc:	fea42627          	fsw	fa0,-20(s0)
    EulerCarSpeedCtrlRight(pidTargetSpeed);   
 300bee0:	fec42507          	flw	fa0,-20(s0)
 300bee4:	3701                	jal	ra,300bde4 <EulerCarSpeedCtrlRight>
    
    /* 通过PID算法计算左轮目标速度 */
    pidTargetSpeed = Pid_Ctrl(&g_pidEulerCarLeft);
 300bee6:	6d818513          	addi	a0,gp,1752 # 4000dd4 <g_pidEulerCarLeft>
 300beea:	01f000ef          	jal	ra,300c708 <Pid_Ctrl>
 300beee:	fea42627          	fsw	fa0,-20(s0)
    EulerCarSpeedCtrlLeft(pidTargetSpeed); 
 300bef2:	fec42507          	flw	fa0,-20(s0)
 300bef6:	3d09                	jal	ra,300bd08 <EulerCarSpeedCtrlLeft>
        DBG_PRINTF("N=%d,P=%.02f,I=%.02f,D=%.02f|L-SS:%.1f,AS:%.1f,err:%.1f,nr:%.1f,lr:%.1f,in:%.1f,TS:%.1f,dt:%d\r\n", 
                         g_pid_count,g_KP,g_KI,g_KD,g_pidEulerCarLeft.SetSpeed,
                         g_pidEulerCarLeft.ActualSpeed,g_pidEulerCarLeft.err,g_pidEulerCarLeft.err_next,g_pidEulerCarLeft.err_last,
                                   g_pidEulerCarLeft.IncSpeed,g_pidEulerCarLeft.TargetIncSpeed,g_pidEulerCarLeft.duty);
    } */
}
 300bef8:	0001                	nop
 300befa:	40f2                	lw	ra,28(sp)
 300befc:	4462                	lw	s0,24(sp)
 300befe:	6105                	addi	sp,sp,32
 300bf00:	8082                	ret

0300bf02 <recv_data_cal>:

void recv_data_cal(void)
{   
 300bf02:	1101                	addi	sp,sp,-32
 300bf04:	01010293          	addi	t0,sp,16
 300bf08:	0062928b          	stmia	{ra,s0,s2-s3},(t0)
 300bf0c:	1000                	addi	s0,sp,32
    float x_linear,z_angular;
    
    g_ReceiveData.ControlStr.X_speed = Move_X;
 300bf0e:	fc81a787          	flw	fa5,-56(gp) # 40006c4 <Move_X>
 300bf12:	f9818793          	addi	a5,gp,-104 # 4000694 <g_ReceiveData>
 300bf16:	eb9c                	fsw	fa5,16(a5)
    g_ReceiveData.ControlStr.Y_speed = Move_Y;
 300bf18:	fcc1a787          	flw	fa5,-52(gp) # 40006c8 <Move_Y>
 300bf1c:	f9818793          	addi	a5,gp,-104 # 4000694 <g_ReceiveData>
 300bf20:	ebdc                	fsw	fa5,20(a5)
    g_ReceiveData.ControlStr.Z_speed = Move_Z;
 300bf22:	fd01a787          	flw	fa5,-48(gp) # 40006cc <Move_Z>
 300bf26:	f9818793          	addi	a5,gp,-104 # 4000694 <g_ReceiveData>
 300bf2a:	ef9c                	fsw	fa5,24(a5)
    x_linear = g_ReceiveData.ControlStr.X_speed; 
 300bf2c:	f9818793          	addi	a5,gp,-104 # 4000694 <g_ReceiveData>
 300bf30:	6b9c                	flw	fa5,16(a5)
 300bf32:	fef42627          	fsw	fa5,-20(s0)
    z_angular = g_ReceiveData.ControlStr.Z_speed;
 300bf36:	f9818793          	addi	a5,gp,-104 # 4000694 <g_ReceiveData>
 300bf3a:	6f9c                	flw	fa5,24(a5)
 300bf3c:	fef42427          	fsw	fa5,-24(s0)
    //DBG_PRINTF("x_speed:%.02f, Z_speed:%.02f\r\n", g_ReceiveData.ControlStr.X_speed, g_ReceiveData.ControlStr.Z_speed);
    //差分轮运动学模型求解
    modelCalLeftSpeed  = x_linear - z_angular * EULERCAR_WHEEL_TRACK / 2.0 / 1000.0;    //左轮速度，单位mm/s
 300bf40:	fec42507          	flw	fa0,-20(s0)
 300bf44:	2a55                	jal	ra,300c0f8 <__extendsfdf2.trans.11>
 300bf46:	892a                	mv	s2,a0
 300bf48:	89ae                	mv	s3,a1
 300bf4a:	fe842507          	flw	fa0,-24(s0)
 300bf4e:	226d                	jal	ra,300c0f8 <__extendsfdf2.trans.11>
 300bf50:	87aa                	mv	a5,a0
 300bf52:	882e                	mv	a6,a1
 300bf54:	03011737          	lui	a4,0x3011
 300bf58:	e5870713          	addi	a4,a4,-424 # 3010e58 <g_crgIpMatch+0x948>
 300bf5c:	4310                	lw	a2,0(a4)
 300bf5e:	4354                	lw	a3,4(a4)
 300bf60:	853e                	mv	a0,a5
 300bf62:	85c2                	mv	a1,a6
 300bf64:	210030ef          	jal	ra,300f174 <__muldf3>
 300bf68:	87aa                	mv	a5,a0
 300bf6a:	882e                	mv	a6,a1
 300bf6c:	03011737          	lui	a4,0x3011
 300bf70:	e6070713          	addi	a4,a4,-416 # 3010e60 <g_crgIpMatch+0x950>
 300bf74:	4310                	lw	a2,0(a4)
 300bf76:	4354                	lw	a3,4(a4)
 300bf78:	853e                	mv	a0,a5
 300bf7a:	85c2                	mv	a1,a6
 300bf7c:	2aa5                	jal	ra,300c0f4 <__divdf3.trans.23>
 300bf7e:	87aa                	mv	a5,a0
 300bf80:	882e                	mv	a6,a1
 300bf82:	03011737          	lui	a4,0x3011
 300bf86:	e4070713          	addi	a4,a4,-448 # 3010e40 <g_crgIpMatch+0x930>
 300bf8a:	4310                	lw	a2,0(a4)
 300bf8c:	4354                	lw	a3,4(a4)
 300bf8e:	853e                	mv	a0,a5
 300bf90:	85c2                	mv	a1,a6
 300bf92:	228d                	jal	ra,300c0f4 <__divdf3.trans.23>
 300bf94:	87aa                	mv	a5,a0
 300bf96:	882e                	mv	a6,a1
 300bf98:	863e                	mv	a2,a5
 300bf9a:	86c2                	mv	a3,a6
 300bf9c:	854a                	mv	a0,s2
 300bf9e:	85ce                	mv	a1,s3
 300bfa0:	78a030ef          	jal	ra,300f72a <__subdf3>
 300bfa4:	87aa                	mv	a5,a0
 300bfa6:	882e                	mv	a6,a1
 300bfa8:	853e                	mv	a0,a5
 300bfaa:	85c2                	mv	a1,a6
 300bfac:	3671                	jal	ra,300bb38 <__truncdfsf2.trans.26>
 300bfae:	20a507d3          	fmv.s	fa5,fa0
 300bfb2:	fcf1aa27          	fsw	fa5,-44(gp) # 40006d0 <modelCalLeftSpeed>
    modelCalRightSpeed = x_linear + z_angular * EULERCAR_WHEEL_TRACK / 2.0 / 1000.0;    //右轮速度，单位mm/s
 300bfb6:	fec42507          	flw	fa0,-20(s0)
 300bfba:	2a3d                	jal	ra,300c0f8 <__extendsfdf2.trans.11>
 300bfbc:	892a                	mv	s2,a0
 300bfbe:	89ae                	mv	s3,a1
 300bfc0:	fe842507          	flw	fa0,-24(s0)
 300bfc4:	2a15                	jal	ra,300c0f8 <__extendsfdf2.trans.11>
 300bfc6:	87aa                	mv	a5,a0
 300bfc8:	882e                	mv	a6,a1
 300bfca:	03011737          	lui	a4,0x3011
 300bfce:	e5870713          	addi	a4,a4,-424 # 3010e58 <g_crgIpMatch+0x948>
 300bfd2:	4310                	lw	a2,0(a4)
 300bfd4:	4354                	lw	a3,4(a4)
 300bfd6:	853e                	mv	a0,a5
 300bfd8:	85c2                	mv	a1,a6
 300bfda:	19a030ef          	jal	ra,300f174 <__muldf3>
 300bfde:	87aa                	mv	a5,a0
 300bfe0:	882e                	mv	a6,a1
 300bfe2:	03011737          	lui	a4,0x3011
 300bfe6:	e6070713          	addi	a4,a4,-416 # 3010e60 <g_crgIpMatch+0x950>
 300bfea:	4310                	lw	a2,0(a4)
 300bfec:	4354                	lw	a3,4(a4)
 300bfee:	853e                	mv	a0,a5
 300bff0:	85c2                	mv	a1,a6
 300bff2:	2209                	jal	ra,300c0f4 <__divdf3.trans.23>
 300bff4:	87aa                	mv	a5,a0
 300bff6:	882e                	mv	a6,a1
 300bff8:	03011737          	lui	a4,0x3011
 300bffc:	e4070713          	addi	a4,a4,-448 # 3010e40 <g_crgIpMatch+0x930>
 300c000:	4310                	lw	a2,0(a4)
 300c002:	4354                	lw	a3,4(a4)
 300c004:	853e                	mv	a0,a5
 300c006:	85c2                	mv	a1,a6
 300c008:	20f5                	jal	ra,300c0f4 <__divdf3.trans.23>
 300c00a:	87aa                	mv	a5,a0
 300c00c:	882e                	mv	a6,a1
 300c00e:	863e                	mv	a2,a5
 300c010:	86c2                	mv	a3,a6
 300c012:	854a                	mv	a0,s2
 300c014:	85ce                	mv	a1,s3
 300c016:	116020ef          	jal	ra,300e12c <__adddf3>
 300c01a:	87aa                	mv	a5,a0
 300c01c:	882e                	mv	a6,a1
 300c01e:	853e                	mv	a0,a5
 300c020:	85c2                	mv	a1,a6
 300c022:	3e19                	jal	ra,300bb38 <__truncdfsf2.trans.26>
 300c024:	20a507d3          	fmv.s	fa5,fa0
 300c028:	fcf1ac27          	fsw	fa5,-40(gp) # 40006d4 <modelCalRightSpeed>
    DBG_PRINTF("modelCalLeftSpeed:%.2fmm/s, modelCalRightSpeed:%.2fmm/s\r\n", modelCalLeftSpeed, modelCalRightSpeed);
 300c02c:	fd41a787          	flw	fa5,-44(gp) # 40006d0 <modelCalLeftSpeed>
 300c030:	20f78553          	fmv.s	fa0,fa5
 300c034:	20d1                	jal	ra,300c0f8 <__extendsfdf2.trans.11>
 300c036:	892a                	mv	s2,a0
 300c038:	89ae                	mv	s3,a1
 300c03a:	fd81a787          	flw	fa5,-40(gp) # 40006d4 <modelCalRightSpeed>
 300c03e:	20f78553          	fmv.s	fa0,fa5
 300c042:	285d                	jal	ra,300c0f8 <__extendsfdf2.trans.11>
 300c044:	87aa                	mv	a5,a0
 300c046:	882e                	mv	a6,a1
 300c048:	873e                	mv	a4,a5
 300c04a:	87c2                	mv	a5,a6
 300c04c:	864a                	mv	a2,s2
 300c04e:	86ce                	mv	a3,s3
 300c050:	030115b7          	lui	a1,0x3011
 300c054:	c5058513          	addi	a0,a1,-944 # 3010c50 <g_crgIpMatch+0x740>
 300c058:	21c5                	jal	ra,300c538 <DBG_UartPrintf.trans.13>
   
    //将上位机设置轮速存到PID控制结构体
    g_pidEulerCarLeft.SetSpeed = modelCalLeftSpeed;
 300c05a:	fd41a787          	flw	fa5,-44(gp) # 40006d0 <modelCalLeftSpeed>
 300c05e:	6d818793          	addi	a5,gp,1752 # 4000dd4 <g_pidEulerCarLeft>
 300c062:	e39c                	fsw	fa5,0(a5)
    g_pidEulerCarRight.SetSpeed = modelCalRightSpeed;
 300c064:	fd81a787          	flw	fa5,-40(gp) # 40006d4 <modelCalRightSpeed>
 300c068:	6b818793          	addi	a5,gp,1720 # 4000db4 <g_pidEulerCarRight>
 300c06c:	e39c                	fsw	fa5,0(a5)

    //如果上位机下发速度小于0.1mm/s，小车停止运动
    if((fabsf(modelCalLeftSpeed) < 0.1) && (fabsf(modelCalRightSpeed) < 0.1))
 300c06e:	fd41a787          	flw	fa5,-44(gp) # 40006d0 <modelCalLeftSpeed>
 300c072:	20f78553          	fmv.s	fa0,fa5
 300c076:	28ad                	jal	ra,300c0f0 <fabsf.trans.24>
 300c078:	20a507d3          	fmv.s	fa5,fa0
 300c07c:	20f78553          	fmv.s	fa0,fa5
 300c080:	28a5                	jal	ra,300c0f8 <__extendsfdf2.trans.11>
 300c082:	87aa                	mv	a5,a0
 300c084:	882e                	mv	a6,a1
 300c086:	03011737          	lui	a4,0x3011
 300c08a:	e4870713          	addi	a4,a4,-440 # 3010e48 <g_crgIpMatch+0x938>
 300c08e:	4310                	lw	a2,0(a4)
 300c090:	4354                	lw	a3,4(a4)
 300c092:	853e                	mv	a0,a5
 300c094:	85c2                	mv	a1,a6
 300c096:	2899                	jal	ra,300c0ec <__ltdf2.trans.40>
 300c098:	87aa                	mv	a5,a0
 300c09a:	0007c363          	bltz	a5,300c0a0 <recv_data_cal+0x19e>
    {
        EulerCarSpeedCtrlRight(0);
        EulerCarSpeedCtrlLeft(0);
        //DBG_PRINTF("EulerCar stoped!!!\r\n");
    }
}
 300c09e:	a081                	j	300c0de <recv_data_cal+0x1dc>
    if((fabsf(modelCalLeftSpeed) < 0.1) && (fabsf(modelCalRightSpeed) < 0.1))
 300c0a0:	fd81a787          	flw	fa5,-40(gp) # 40006d4 <modelCalRightSpeed>
 300c0a4:	20f78553          	fmv.s	fa0,fa5
 300c0a8:	20a1                	jal	ra,300c0f0 <fabsf.trans.24>
 300c0aa:	20a507d3          	fmv.s	fa5,fa0
 300c0ae:	20f78553          	fmv.s	fa0,fa5
 300c0b2:	2099                	jal	ra,300c0f8 <__extendsfdf2.trans.11>
 300c0b4:	87aa                	mv	a5,a0
 300c0b6:	882e                	mv	a6,a1
 300c0b8:	03011737          	lui	a4,0x3011
 300c0bc:	e4870713          	addi	a4,a4,-440 # 3010e48 <g_crgIpMatch+0x938>
 300c0c0:	4310                	lw	a2,0(a4)
 300c0c2:	4354                	lw	a3,4(a4)
 300c0c4:	853e                	mv	a0,a5
 300c0c6:	85c2                	mv	a1,a6
 300c0c8:	2015                	jal	ra,300c0ec <__ltdf2.trans.40>
 300c0ca:	87aa                	mv	a5,a0
 300c0cc:	0007c363          	bltz	a5,300c0d2 <recv_data_cal+0x1d0>
}
 300c0d0:	a039                	j	300c0de <recv_data_cal+0x1dc>
        EulerCarSpeedCtrlRight(0);
 300c0d2:	f0000553          	fmv.w.x	fa0,zero
 300c0d6:	3339                	jal	ra,300bde4 <EulerCarSpeedCtrlRight>
        EulerCarSpeedCtrlLeft(0);
 300c0d8:	f0000553          	fmv.w.x	fa0,zero
 300c0dc:	3135                	jal	ra,300bd08 <EulerCarSpeedCtrlLeft>
}
 300c0de:	0001                	nop
 300c0e0:	01010293          	addi	t0,sp,16
 300c0e4:	0062828b          	ldmia	{ra,s0,s2-s3},(t0)
 300c0e8:	6105                	addi	sp,sp,32
 300c0ea:	8082                	ret

0300c0ec <__ltdf2.trans.40>:
 300c0ec:	7d50206f          	j	300f0c0 <__ledf2>

0300c0f0 <fabsf.trans.24>:
 300c0f0:	2ec0406f          	j	30103dc <fabsf>

0300c0f4 <__divdf3.trans.23>:
 300c0f4:	07b0206f          	j	300e96e <__divdf3>

0300c0f8 <__extendsfdf2.trans.11>:
 300c0f8:	7a90306f          	j	30100a0 <__extendsfdf2>

0300c0fc <UART3_INTRxSimultaneously>:

void UART3_INTRxSimultaneously(void)
{
 300c0fc:	715d                	addi	sp,sp,-80
 300c0fe:	03010293          	addi	t0,sp,48
 300c102:	03e2968b          	stmia	{ra,s0-s6},(t0)
 300c106:	0880                	addi	s0,sp,80
    float tmp_X,tmp_Y,tmp_Z; 
    unsigned char k,Usart_Receive,check_sum;

    while (1) {
        if (g_RxInterruptflag) {
 300c108:	a161c783          	lbu	a5,-1514(gp) # 4000112 <g_RxInterruptflag>
 300c10c:	9f81                	uxtb	a5
 300c10e:	24078c63          	beqz	a5,300c366 <UART3_INTRxSimultaneously+0x26a>
            g_RxInterruptflag = false;
 300c112:	a0018b23          	sb	zero,-1514(gp) # 4000112 <g_RxInterruptflag>
            HAL_UART_ReadIT(&g_uart3, &Usart_Receive, 1); // 读取数据
 300c116:	fcf40793          	addi	a5,s0,-49
 300c11a:	4605                	li	a2,1
 300c11c:	85be                	mv	a1,a5
 300c11e:	32818513          	addi	a0,gp,808 # 4000a24 <g_uart3>
 300c122:	a73fe0ef          	jal	ra,300ab94 <HAL_UART_ReadIT>
            g_ReceiveData.buffer[g_ReceiveDataCount] = Usart_Receive;
 300c126:	fb81c783          	lbu	a5,-72(gp) # 40006b4 <g_ReceiveDataCount>
 300c12a:	86be                	mv	a3,a5
 300c12c:	fcf44703          	lbu	a4,-49(s0)
 300c130:	f9818793          	addi	a5,gp,-104 # 4000694 <g_ReceiveData>
 300c134:	97b6                	add	a5,a5,a3
 300c136:	a398                	sb	a4,0(a5)
            //确保数组第一个数据为FRAME_HEADER
            if (Usart_Receive == FRAME_HEADER || g_ReceiveDataCount > 0) {
 300c138:	fcf44703          	lbu	a4,-49(s0)
 300c13c:	07b00793          	li	a5,123
 300c140:	00f70563          	beq	a4,a5,300c14a <UART3_INTRxSimultaneously+0x4e>
 300c144:	fb81c783          	lbu	a5,-72(gp) # 40006b4 <g_ReceiveDataCount>
 300c148:	cb89                	beqz	a5,300c15a <UART3_INTRxSimultaneously+0x5e>
                g_ReceiveDataCount++;
 300c14a:	fb81c783          	lbu	a5,-72(gp) # 40006b4 <g_ReceiveDataCount>
 300c14e:	0785                	addi	a5,a5,1
 300c150:	0ff7f713          	andi	a4,a5,255
 300c154:	fae18c23          	sb	a4,-72(gp) # 40006b4 <g_ReceiveDataCount>
 300c158:	a019                	j	300c15e <UART3_INTRxSimultaneously+0x62>
            }
            else {
                g_ReceiveDataCount = 0;
 300c15a:	fa018c23          	sb	zero,-72(gp) # 40006b4 <g_ReceiveDataCount>
            }
            // 验证数据包的长度
            if (g_ReceiveDataCount == RECEIVE_DATA_SIZE) {
 300c15e:	fb81c703          	lbu	a4,-72(gp) # 40006b4 <g_ReceiveDataCount>
 300c162:	47ad                	li	a5,11
 300c164:	20f71163          	bne	a4,a5,300c366 <UART3_INTRxSimultaneously+0x26a>
                g_ReceiveDataCount = 0; //为串口数据重新填入数组做准备
 300c168:	fa018c23          	sb	zero,-72(gp) # 40006b4 <g_ReceiveDataCount>
                //验证数据包的帧尾
                if (g_ReceiveData.buffer[10] == FRAME_TAIL) {
 300c16c:	f9818793          	addi	a5,gp,-104 # 4000694 <g_ReceiveData>
 300c170:	27b8                	lbu	a4,10(a5)
 300c172:	07d00793          	li	a5,125
 300c176:	1ef71863          	bne	a4,a5,300c366 <UART3_INTRxSimultaneously+0x26a>
                    check_sum = 0;
 300c17a:	fc040f23          	sb	zero,-34(s0)
                    for (k = 0; k < 9; k++) {
 300c17e:	fc040fa3          	sb	zero,-33(s0)
 300c182:	a00d                	j	300c1a4 <UART3_INTRxSimultaneously+0xa8>
                        check_sum = check_sum ^ g_ReceiveData.buffer[k];
 300c184:	fdf44783          	lbu	a5,-33(s0)
 300c188:	f9818713          	addi	a4,gp,-104 # 4000694 <g_ReceiveData>
 300c18c:	97ba                	add	a5,a5,a4
 300c18e:	2398                	lbu	a4,0(a5)
 300c190:	fde44783          	lbu	a5,-34(s0)
 300c194:	8fb9                	xor	a5,a5,a4
 300c196:	fcf40f23          	sb	a5,-34(s0)
                    for (k = 0; k < 9; k++) {
 300c19a:	fdf44783          	lbu	a5,-33(s0)
 300c19e:	0785                	addi	a5,a5,1
 300c1a0:	fcf40fa3          	sb	a5,-33(s0)
 300c1a4:	fdf44703          	lbu	a4,-33(s0)
 300c1a8:	47a1                	li	a5,8
 300c1aa:	fce7fde3          	bgeu	a5,a4,300c184 <UART3_INTRxSimultaneously+0x88>
                    }
                    //数据异或位校验计算，模式0是发送数据校验
                    if (g_ReceiveData.buffer[9] == check_sum) {  
 300c1ae:	f9818793          	addi	a5,gp,-104 # 4000694 <g_ReceiveData>
 300c1b2:	379c                	lbu	a5,9(a5)
 300c1b4:	fde44703          	lbu	a4,-34(s0)
 300c1b8:	1af71763          	bne	a4,a5,300c366 <UART3_INTRxSimultaneously+0x26a>
                        g_RecvCount++;
 300c1bc:	fc41a783          	lw	a5,-60(gp) # 40006c0 <g_RecvCount>
 300c1c0:	00178713          	addi	a4,a5,1
 300c1c4:	fce1a223          	sw	a4,-60(gp) # 40006c0 <g_RecvCount>
                        //从串口数据求三轴目标速度， 单位mm/s
                        tmp_X = XYZ_transition(g_ReceiveData.buffer[3], g_ReceiveData.buffer[4]);
 300c1c8:	f9818793          	addi	a5,gp,-104 # 4000694 <g_ReceiveData>
 300c1cc:	33b8                	lbu	a4,3(a5)
 300c1ce:	f9818793          	addi	a5,gp,-104 # 4000694 <g_ReceiveData>
 300c1d2:	23dc                	lbu	a5,4(a5)
 300c1d4:	85be                	mv	a1,a5
 300c1d6:	853a                	mv	a0,a4
 300c1d8:	34fd                	jal	ra,300bcc6 <XYZ_transition>
 300c1da:	fca42c27          	fsw	fa0,-40(s0)
                        tmp_Y = XYZ_transition(g_ReceiveData.buffer[5], g_ReceiveData.buffer[6]);
 300c1de:	f9818793          	addi	a5,gp,-104 # 4000694 <g_ReceiveData>
 300c1e2:	33d8                	lbu	a4,5(a5)
 300c1e4:	f9818793          	addi	a5,gp,-104 # 4000694 <g_ReceiveData>
 300c1e8:	23fc                	lbu	a5,6(a5)
 300c1ea:	85be                	mv	a1,a5
 300c1ec:	853a                	mv	a0,a4
 300c1ee:	3ce1                	jal	ra,300bcc6 <XYZ_transition>
 300c1f0:	fca42a27          	fsw	fa0,-44(s0)
                        tmp_Z = XYZ_transition(g_ReceiveData.buffer[7], g_ReceiveData.buffer[8]);
 300c1f4:	f9818793          	addi	a5,gp,-104 # 4000694 <g_ReceiveData>
 300c1f8:	33f8                	lbu	a4,7(a5)
 300c1fa:	f9818793          	addi	a5,gp,-104 # 4000694 <g_ReceiveData>
 300c1fe:	279c                	lbu	a5,8(a5)
 300c200:	85be                	mv	a1,a5
 300c202:	853a                	mv	a0,a4
 300c204:	34c9                	jal	ra,300bcc6 <XYZ_transition>
 300c206:	fca42827          	fsw	fa0,-48(s0)
                        //合法性检查，设置速度必须小于当前电机支持的最高速度
                        if( (fabsf(tmp_X) < g_motorMaxSpeed) && (fabsf(tmp_Y) < g_motorMaxSpeed) && (fabsf(tmp_Z) < MOTOR_MAX_ANGULAR_SPEED) ) {  
 300c20a:	fd842507          	flw	fa0,-40(s0)
 300c20e:	35cd                	jal	ra,300c0f0 <fabsf.trans.24>
 300c210:	20a50753          	fmv.s	fa4,fa0
 300c214:	a681a787          	flw	fa5,-1432(gp) # 4000164 <g_motorMaxSpeed>
 300c218:	a0f717d3          	flt.s	a5,fa4,fa5
 300c21c:	cbd9                	beqz	a5,300c2b2 <UART3_INTRxSimultaneously+0x1b6>
 300c21e:	fd442507          	flw	fa0,-44(s0)
 300c222:	35f9                	jal	ra,300c0f0 <fabsf.trans.24>
 300c224:	20a50753          	fmv.s	fa4,fa0
 300c228:	a681a787          	flw	fa5,-1432(gp) # 4000164 <g_motorMaxSpeed>
 300c22c:	a0f717d3          	flt.s	a5,fa4,fa5
 300c230:	c3c9                	beqz	a5,300c2b2 <UART3_INTRxSimultaneously+0x1b6>
 300c232:	fd042507          	flw	fa0,-48(s0)
 300c236:	3d6d                	jal	ra,300c0f0 <fabsf.trans.24>
 300c238:	20a50753          	fmv.s	fa4,fa0
 300c23c:	030117b7          	lui	a5,0x3011
 300c240:	e687a787          	flw	fa5,-408(a5) # 3010e68 <g_crgIpMatch+0x958>
 300c244:	a0f717d3          	flt.s	a5,fa4,fa5
 300c248:	c7ad                	beqz	a5,300c2b2 <UART3_INTRxSimultaneously+0x1b6>
                            Move_X = tmp_X;
 300c24a:	fd842787          	flw	fa5,-40(s0)
 300c24e:	fcf1a427          	fsw	fa5,-56(gp) # 40006c4 <Move_X>
                            Move_Y = tmp_Y;
 300c252:	fd442787          	flw	fa5,-44(s0)
 300c256:	fcf1a627          	fsw	fa5,-52(gp) # 40006c8 <Move_Y>
                            Move_Z = tmp_Z;
 300c25a:	fd042787          	flw	fa5,-48(s0)
 300c25e:	fcf1a827          	fsw	fa5,-48(gp) # 40006cc <Move_Z>
                            DBG_PRINTF("\r\ng_TimerCount=%d,g_RecvCount=%d,Move_X=%.2fmm/s,Move_Y=%.2fmm/s,Move_Z=%.2fmrad/s\r\n",
 300c262:	fbc1a483          	lw	s1,-68(gp) # 40006b8 <g_TimerInterruptCount>
 300c266:	fc41ab03          	lw	s6,-60(gp) # 40006c0 <g_RecvCount>
 300c26a:	fc81a787          	flw	fa5,-56(gp) # 40006c4 <Move_X>
 300c26e:	20f78553          	fmv.s	fa0,fa5
 300c272:	3559                	jal	ra,300c0f8 <__extendsfdf2.trans.11>
 300c274:	892a                	mv	s2,a0
 300c276:	89ae                	mv	s3,a1
 300c278:	fcc1a787          	flw	fa5,-52(gp) # 40006c8 <Move_Y>
 300c27c:	20f78553          	fmv.s	fa0,fa5
 300c280:	3da5                	jal	ra,300c0f8 <__extendsfdf2.trans.11>
 300c282:	8a2a                	mv	s4,a0
 300c284:	8aae                	mv	s5,a1
 300c286:	fd01a787          	flw	fa5,-48(gp) # 40006cc <Move_Z>
 300c28a:	20f78553          	fmv.s	fa0,fa5
 300c28e:	35ad                	jal	ra,300c0f8 <__extendsfdf2.trans.11>
 300c290:	87aa                	mv	a5,a0
 300c292:	882e                	mv	a6,a1
 300c294:	c03e                	sw	a5,0(sp)
 300c296:	c242                	sw	a6,4(sp)
 300c298:	8852                	mv	a6,s4
 300c29a:	88d6                	mv	a7,s5
 300c29c:	874a                	mv	a4,s2
 300c29e:	87ce                	mv	a5,s3
 300c2a0:	865a                	mv	a2,s6
 300c2a2:	85a6                	mv	a1,s1
 300c2a4:	030116b7          	lui	a3,0x3011
 300c2a8:	c8c68513          	addi	a0,a3,-884 # 3010c8c <g_crgIpMatch+0x77c>
 300c2ac:	2471                	jal	ra,300c538 <DBG_UartPrintf.trans.13>
                                                                              g_TimerInterruptCount,g_RecvCount, Move_X, Move_Y, Move_Z);
                            recv_data_cal();
 300c2ae:	3991                	jal	ra,300bf02 <recv_data_cal>
 300c2b0:	a85d                	j	300c366 <UART3_INTRxSimultaneously+0x26a>
						}
                        else{
                            DBG_PRINTF("\r\ng_TimerCount=%d,g_RecvCount=%d",g_TimerInterruptCount,g_RecvCount);
 300c2b2:	fbc1a703          	lw	a4,-68(gp) # 40006b8 <g_TimerInterruptCount>
 300c2b6:	fc41a783          	lw	a5,-60(gp) # 40006c0 <g_RecvCount>
 300c2ba:	863e                	mv	a2,a5
 300c2bc:	85ba                	mv	a1,a4
 300c2be:	030117b7          	lui	a5,0x3011
 300c2c2:	ce478513          	addi	a0,a5,-796 # 3010ce4 <g_crgIpMatch+0x7d4>
 300c2c6:	2c8d                	jal	ra,300c538 <DBG_UartPrintf.trans.13>
                            if((fabsf(tmp_X) > g_motorMaxSpeed) || (fabsf(tmp_Y) > g_motorMaxSpeed))
 300c2c8:	fd842507          	flw	fa0,-40(s0)
 300c2cc:	3515                	jal	ra,300c0f0 <fabsf.trans.24>
 300c2ce:	20a50753          	fmv.s	fa4,fa0
 300c2d2:	a681a787          	flw	fa5,-1432(gp) # 4000164 <g_motorMaxSpeed>
 300c2d6:	a0e797d3          	flt.s	a5,fa5,fa4
 300c2da:	eb99                	bnez	a5,300c2f0 <UART3_INTRxSimultaneously+0x1f4>
 300c2dc:	fd442507          	flw	fa0,-44(s0)
 300c2e0:	3d01                	jal	ra,300c0f0 <fabsf.trans.24>
 300c2e2:	20a50753          	fmv.s	fa4,fa0
 300c2e6:	a681a787          	flw	fa5,-1432(gp) # 4000164 <g_motorMaxSpeed>
 300c2ea:	a0e797d3          	flt.s	a5,fa5,fa4
 300c2ee:	cf8d                	beqz	a5,300c328 <UART3_INTRxSimultaneously+0x22c>
                                DBG_PRINTF("\r\nLinear speed set error: X=%.2fmm/s Y=%.2fmm/s, must less %.2fmm/s\r\n", tmp_X, tmp_Y,g_motorMaxSpeed);
 300c2f0:	fd842507          	flw	fa0,-40(s0)
 300c2f4:	3511                	jal	ra,300c0f8 <__extendsfdf2.trans.11>
 300c2f6:	892a                	mv	s2,a0
 300c2f8:	89ae                	mv	s3,a1
 300c2fa:	fd442507          	flw	fa0,-44(s0)
 300c2fe:	3bed                	jal	ra,300c0f8 <__extendsfdf2.trans.11>
 300c300:	8a2a                	mv	s4,a0
 300c302:	8aae                	mv	s5,a1
 300c304:	a681a787          	flw	fa5,-1432(gp) # 4000164 <g_motorMaxSpeed>
 300c308:	20f78553          	fmv.s	fa0,fa5
 300c30c:	33f5                	jal	ra,300c0f8 <__extendsfdf2.trans.11>
 300c30e:	87aa                	mv	a5,a0
 300c310:	882e                	mv	a6,a1
 300c312:	88c2                	mv	a7,a6
 300c314:	883e                	mv	a6,a5
 300c316:	8752                	mv	a4,s4
 300c318:	87d6                	mv	a5,s5
 300c31a:	864a                	mv	a2,s2
 300c31c:	86ce                	mv	a3,s3
 300c31e:	030115b7          	lui	a1,0x3011
 300c322:	d0858513          	addi	a0,a1,-760 # 3010d08 <g_crgIpMatch+0x7f8>
 300c326:	2c09                	jal	ra,300c538 <DBG_UartPrintf.trans.13>
                            if((fabsf(tmp_Z) > MOTOR_MAX_ANGULAR_SPEED))
 300c328:	fd042507          	flw	fa0,-48(s0)
 300c32c:	33d1                	jal	ra,300c0f0 <fabsf.trans.24>
 300c32e:	20a50753          	fmv.s	fa4,fa0
 300c332:	030117b7          	lui	a5,0x3011
 300c336:	e687a787          	flw	fa5,-408(a5) # 3010e68 <g_crgIpMatch+0x958>
 300c33a:	a0e797d3          	flt.s	a5,fa5,fa4
 300c33e:	c785                	beqz	a5,300c366 <UART3_INTRxSimultaneously+0x26a>
                                DBG_PRINTF("\r\nAngular speed set error: Z=%.2fmrad/s, must less %.1fmrad/s\r\n", tmp_Z, MOTOR_MAX_ANGULAR_SPEED);
 300c340:	fd042507          	flw	fa0,-48(s0)
 300c344:	3b55                	jal	ra,300c0f8 <__extendsfdf2.trans.11>
 300c346:	862a                	mv	a2,a0
 300c348:	86ae                	mv	a3,a1
 300c34a:	030117b7          	lui	a5,0x3011
 300c34e:	e7078793          	addi	a5,a5,-400 # 3010e70 <g_crgIpMatch+0x960>
 300c352:	0047a803          	lw	a6,4(a5)
 300c356:	439c                	lw	a5,0(a5)
 300c358:	873e                	mv	a4,a5
 300c35a:	87c2                	mv	a5,a6
 300c35c:	030115b7          	lui	a1,0x3011
 300c360:	d5058513          	addi	a0,a1,-688 # 3010d50 <g_crgIpMatch+0x840>
 300c364:	2ad1                	jal	ra,300c538 <DBG_UartPrintf.trans.13>
                    }
                }
            }
        }

        ServoMsg = ReceiveMsg(RxID);
 300c366:	28700513          	li	a0,647
 300c36a:	f0dfe0ef          	jal	ra,300b276 <ReceiveMsg>
 300c36e:	87aa                	mv	a5,a0
 300c370:	873e                	mv	a4,a5
 300c372:	6ae18923          	sb	a4,1714(gp) # 4000dae <ServoMsg>
        if(isRecv){
 300c376:	6b01c783          	lbu	a5,1712(gp) # 4000dac <isRecv>
 300c37a:	0c078463          	beqz	a5,300c442 <UART3_INTRxSimultaneously+0x346>
            DBG_PRINTF("Receieved!\r\n");
 300c37e:	030117b7          	lui	a5,0x3011
 300c382:	d9078513          	addi	a0,a5,-624 # 3010d90 <g_crgIpMatch+0x880>
 300c386:	2a4d                	jal	ra,300c538 <DBG_UartPrintf.trans.13>
            isRecv = false;
 300c388:	6a018823          	sb	zero,1712(gp) # 4000dac <isRecv>
            DBG_PRINTF("Receive message: %x \r\n", ServoMsg);
 300c38c:	6b21c783          	lbu	a5,1714(gp) # 4000dae <ServoMsg>
 300c390:	85be                	mv	a1,a5
 300c392:	030117b7          	lui	a5,0x3011
 300c396:	da078513          	addi	a0,a5,-608 # 3010da0 <g_crgIpMatch+0x890>
 300c39a:	2a79                	jal	ra,300c538 <DBG_UartPrintf.trans.13>
            HAL_GPIO_SetValue(&g_gpio2, GPIO_PIN_5, GPIO_LOW_LEVEL);
 300c39c:	4601                	li	a2,0
 300c39e:	02000593          	li	a1,32
 300c3a2:	62018513          	addi	a0,gp,1568 # 4000d1c <g_gpio2>
 300c3a6:	2cc1                	jal	ra,300c676 <HAL_GPIO_SetValue.trans.32>
            if(is_servo_done){
 300c3a8:	a741c783          	lbu	a5,-1420(gp) # 4000170 <is_servo_done>
 300c3ac:	cfad                	beqz	a5,300c426 <UART3_INTRxSimultaneously+0x32a>
                is_servo_done = false;
 300c3ae:	a6018a23          	sb	zero,-1420(gp) # 4000170 <is_servo_done>
                if(ServoMsg & CLOSE){
 300c3b2:	6b21c783          	lbu	a5,1714(gp) # 4000dae <ServoMsg>
 300c3b6:	8b89                	andi	a5,a5,2
 300c3b8:	cf89                	beqz	a5,300c3d2 <UART3_INTRxSimultaneously+0x2d6>
                    _close(200, 700);
 300c3ba:	2bc00593          	li	a1,700
 300c3be:	0c800513          	li	a0,200
 300c3c2:	62a000ef          	jal	ra,300c9ec <_close>
                    DBG_PRINTF("CLOSE!\r\n");
 300c3c6:	030117b7          	lui	a5,0x3011
 300c3ca:	db878513          	addi	a0,a5,-584 # 3010db8 <g_crgIpMatch+0x8a8>
 300c3ce:	22ad                	jal	ra,300c538 <DBG_UartPrintf.trans.13>
 300c3d0:	a821                	j	300c3e8 <UART3_INTRxSimultaneously+0x2ec>
                }
                else{
                    open(100, 300);
 300c3d2:	12c00593          	li	a1,300
 300c3d6:	06400513          	li	a0,100
 300c3da:	5e0000ef          	jal	ra,300c9ba <open>
                    DBG_PRINTF("OPEN!\r\n");
 300c3de:	030117b7          	lui	a5,0x3011
 300c3e2:	dc478513          	addi	a0,a5,-572 # 3010dc4 <g_crgIpMatch+0x8b4>
 300c3e6:	2a89                	jal	ra,300c538 <DBG_UartPrintf.trans.13>
                }
                if(ServoMsg & UP){
 300c3e8:	6b21c783          	lbu	a5,1714(gp) # 4000dae <ServoMsg>
 300c3ec:	8ba1                	andi	a5,a5,8
 300c3ee:	cf89                	beqz	a5,300c408 <UART3_INTRxSimultaneously+0x30c>
                    up(50, 650);
 300c3f0:	28a00593          	li	a1,650
 300c3f4:	03200513          	li	a0,50
 300c3f8:	55e000ef          	jal	ra,300c956 <up>
                    DBG_PRINTF("UP!\r\n");
 300c3fc:	030117b7          	lui	a5,0x3011
 300c400:	dcc78513          	addi	a0,a5,-564 # 3010dcc <g_crgIpMatch+0x8bc>
 300c404:	2a15                	jal	ra,300c538 <DBG_UartPrintf.trans.13>
 300c406:	a821                	j	300c41e <UART3_INTRxSimultaneously+0x322>
                }
                else{
                    down(50, 400);
 300c408:	19000593          	li	a1,400
 300c40c:	03200513          	li	a0,50
 300c410:	578000ef          	jal	ra,300c988 <down>
                    DBG_PRINTF("DOWN!\r\n");
 300c414:	030117b7          	lui	a5,0x3011
 300c418:	dd478513          	addi	a0,a5,-556 # 3010dd4 <g_crgIpMatch+0x8c4>
 300c41c:	2a31                	jal	ra,300c538 <DBG_UartPrintf.trans.13>
                }
                is_servo_done = true;
 300c41e:	4705                	li	a4,1
 300c420:	a6e18a23          	sb	a4,-1420(gp) # 4000170 <is_servo_done>
 300c424:	a019                	j	300c42a <UART3_INTRxSimultaneously+0x32e>
            }
            else{
                BackMsg = (BackMsg << 1) & 0;    // 第7位表示动作类型: 0表示举起 1表示放下. 第八位表示动作是否完成: 1表示完成 0表示失败
 300c426:	6a0189a3          	sb	zero,1715(gp) # 4000daf <BackMsg>
            }
            
            TransmitMsg(&BackMsg, TxID);
 300c42a:	18700593          	li	a1,391
 300c42e:	6b318513          	addi	a0,gp,1715 # 4000daf <BackMsg>
 300c432:	e99fe0ef          	jal	ra,300b2ca <TransmitMsg>
            
            HAL_GPIO_SetValue(&g_gpio2, GPIO_PIN_5, GPIO_HIGH_LEVEL);
 300c436:	4605                	li	a2,1
 300c438:	02000593          	li	a1,32
 300c43c:	62018513          	addi	a0,gp,1568 # 4000d1c <g_gpio2>
 300c440:	2c1d                	jal	ra,300c676 <HAL_GPIO_SetValue.trans.32>
        }

        //检测按键是否按下，修改PID参数
        if (g_button1State == 1) {
 300c442:	eb01a703          	lw	a4,-336(gp) # 40005ac <g_button1State>
 300c446:	4785                	li	a5,1
 300c448:	06f71a63          	bne	a4,a5,300c4bc <UART3_INTRxSimultaneously+0x3c0>
            g_button1State = 0;
 300c44c:	ea01a823          	sw	zero,-336(gp) # 40005ac <g_button1State>
            g_KP = g_KP + g_KP_Step;
 300c450:	a781a707          	flw	fa4,-1416(gp) # 4000174 <g_KP>
 300c454:	a801a787          	flw	fa5,-1408(gp) # 400017c <g_KP_Step>
 300c458:	00f777d3          	fadd.s	fa5,fa4,fa5
 300c45c:	a6f1ac27          	fsw	fa5,-1416(gp) # 4000174 <g_KP>
            DBG_PRINTF("Button1 Evnet, g_KP + %f\r\n",g_KP_Step);            
 300c460:	a801a787          	flw	fa5,-1408(gp) # 400017c <g_KP_Step>
 300c464:	20f78553          	fmv.s	fa0,fa5
 300c468:	3941                	jal	ra,300c0f8 <__extendsfdf2.trans.11>
 300c46a:	87aa                	mv	a5,a0
 300c46c:	882e                	mv	a6,a1
 300c46e:	863e                	mv	a2,a5
 300c470:	86c2                	mv	a3,a6
 300c472:	030117b7          	lui	a5,0x3011
 300c476:	ddc78513          	addi	a0,a5,-548 # 3010ddc <g_crgIpMatch+0x8cc>
 300c47a:	287d                	jal	ra,300c538 <DBG_UartPrintf.trans.13>
            DBG_PRINTF("g_KP=%f g_KI=%f g_KD=%f\r\n", g_KP, g_KI, g_KD);
 300c47c:	a781a787          	flw	fa5,-1416(gp) # 4000174 <g_KP>
 300c480:	20f78553          	fmv.s	fa0,fa5
 300c484:	3995                	jal	ra,300c0f8 <__extendsfdf2.trans.11>
 300c486:	892a                	mv	s2,a0
 300c488:	89ae                	mv	s3,a1
 300c48a:	a7c1a787          	flw	fa5,-1412(gp) # 4000178 <g_KI>
 300c48e:	20f78553          	fmv.s	fa0,fa5
 300c492:	319d                	jal	ra,300c0f8 <__extendsfdf2.trans.11>
 300c494:	8a2a                	mv	s4,a0
 300c496:	8aae                	mv	s5,a1
 300c498:	6f81a787          	flw	fa5,1784(gp) # 4000df4 <g_KD>
 300c49c:	20f78553          	fmv.s	fa0,fa5
 300c4a0:	39a1                	jal	ra,300c0f8 <__extendsfdf2.trans.11>
 300c4a2:	87aa                	mv	a5,a0
 300c4a4:	882e                	mv	a6,a1
 300c4a6:	88c2                	mv	a7,a6
 300c4a8:	883e                	mv	a6,a5
 300c4aa:	8752                	mv	a4,s4
 300c4ac:	87d6                	mv	a5,s5
 300c4ae:	864a                	mv	a2,s2
 300c4b0:	86ce                	mv	a3,s3
 300c4b2:	030115b7          	lui	a1,0x3011
 300c4b6:	df858513          	addi	a0,a1,-520 # 3010df8 <g_crgIpMatch+0x8e8>
 300c4ba:	28bd                	jal	ra,300c538 <DBG_UartPrintf.trans.13>
        }
        
        if (g_button2State == 1) {
 300c4bc:	eb41a703          	lw	a4,-332(gp) # 40005b0 <g_button2State>
 300c4c0:	4785                	li	a5,1
 300c4c2:	c4f713e3          	bne	a4,a5,300c108 <UART3_INTRxSimultaneously+0xc>
            g_button2State = 0;
 300c4c6:	ea01aa23          	sw	zero,-332(gp) # 40005b0 <g_button2State>
            g_KI = g_KI + g_KI_Step;           
 300c4ca:	a7c1a707          	flw	fa4,-1412(gp) # 4000178 <g_KI>
 300c4ce:	a841a787          	flw	fa5,-1404(gp) # 4000180 <g_KI_Step>
 300c4d2:	00f777d3          	fadd.s	fa5,fa4,fa5
 300c4d6:	a6f1ae27          	fsw	fa5,-1412(gp) # 4000178 <g_KI>
            DBG_PRINTF("Button2 Evnet, g_KI + %f\r\n",g_KI_Step);               
 300c4da:	a841a787          	flw	fa5,-1404(gp) # 4000180 <g_KI_Step>
 300c4de:	20f78553          	fmv.s	fa0,fa5
 300c4e2:	3919                	jal	ra,300c0f8 <__extendsfdf2.trans.11>
 300c4e4:	87aa                	mv	a5,a0
 300c4e6:	882e                	mv	a6,a1
 300c4e8:	863e                	mv	a2,a5
 300c4ea:	86c2                	mv	a3,a6
 300c4ec:	030117b7          	lui	a5,0x3011
 300c4f0:	e1478513          	addi	a0,a5,-492 # 3010e14 <g_crgIpMatch+0x904>
 300c4f4:	2091                	jal	ra,300c538 <DBG_UartPrintf.trans.13>
            DBG_PRINTF("g_KP=%f g_KI=%f g_KD=%f\r\n", g_KP, g_KI, g_KD);
 300c4f6:	a781a787          	flw	fa5,-1416(gp) # 4000174 <g_KP>
 300c4fa:	20f78553          	fmv.s	fa0,fa5
 300c4fe:	3eed                	jal	ra,300c0f8 <__extendsfdf2.trans.11>
 300c500:	892a                	mv	s2,a0
 300c502:	89ae                	mv	s3,a1
 300c504:	a7c1a787          	flw	fa5,-1412(gp) # 4000178 <g_KI>
 300c508:	20f78553          	fmv.s	fa0,fa5
 300c50c:	36f5                	jal	ra,300c0f8 <__extendsfdf2.trans.11>
 300c50e:	8a2a                	mv	s4,a0
 300c510:	8aae                	mv	s5,a1
 300c512:	6f81a787          	flw	fa5,1784(gp) # 4000df4 <g_KD>
 300c516:	20f78553          	fmv.s	fa0,fa5
 300c51a:	3ef9                	jal	ra,300c0f8 <__extendsfdf2.trans.11>
 300c51c:	87aa                	mv	a5,a0
 300c51e:	882e                	mv	a6,a1
 300c520:	88c2                	mv	a7,a6
 300c522:	883e                	mv	a6,a5
 300c524:	8752                	mv	a4,s4
 300c526:	87d6                	mv	a5,s5
 300c528:	864a                	mv	a2,s2
 300c52a:	86ce                	mv	a3,s3
 300c52c:	030115b7          	lui	a1,0x3011
 300c530:	df858513          	addi	a0,a1,-520 # 3010df8 <g_crgIpMatch+0x8e8>
 300c534:	2011                	jal	ra,300c538 <DBG_UartPrintf.trans.13>
        if (g_RxInterruptflag) {
 300c536:	bec9                	j	300c108 <UART3_INTRxSimultaneously+0xc>

0300c538 <DBG_UartPrintf.trans.13>:
 300c538:	c6efa06f          	j	30069a6 <DBG_UartPrintf>

0300c53c <main>:
bool Action = 1;  // 1 表示放下; 0表示举起
/* 建议用户定义全局变量、结构体、宏定义或函数声明等 */
/* USER CODE END 1 */

int main(void)
{
 300c53c:	1101                	addi	sp,sp,-32
 300c53e:	00810293          	addi	t0,sp,8
 300c542:	01e2928b          	stmia	{ra,s0,s2-s5},(t0)
 300c546:	1000                	addi	s0,sp,32
    SystemInit();
 300c548:	38d010ef          	jal	ra,300e0d4 <SystemInit>
    InitGearMotor();
 300c54c:	e01fe0ef          	jal	ra,300b34c <InitGearMotor>
    Pid_Init();
 300c550:	222d                	jal	ra,300c67a <Pid_Init>
    // ssd1306_Init();
    // HAL_GPT_Start(&g_gpt0);
    // HAL_GPT_Start(&g_gpt1);
    
    DBG_PRINTF("==============================================================\r\n");
 300c552:	030117b7          	lui	a5,0x3011
 300c556:	e7878513          	addi	a0,a5,-392 # 3010e78 <g_crgIpMatch+0x968>
 300c55a:	3ff9                	jal	ra,300c538 <DBG_UartPrintf.trans.13>
    DBG_PRINTF("                • EulerCar Controller 1.0 •                   \r\n");
 300c55c:	030117b7          	lui	a5,0x3011
 300c560:	ebc78513          	addi	a0,a5,-324 # 3010ebc <g_crgIpMatch+0x9ac>
 300c564:	3fd1                	jal	ra,300c538 <DBG_UartPrintf.trans.13>
    DBG_PRINTF("                                                              \r\n");
 300c566:	030117b7          	lui	a5,0x3011
 300c56a:	f0478513          	addi	a0,a5,-252 # 3010f04 <g_crgIpMatch+0x9f4>
 300c56e:	37e9                	jal	ra,300c538 <DBG_UartPrintf.trans.13>
    DBG_PRINTF("  ➤ System Information:                                      \r\n");
 300c570:	030117b7          	lui	a5,0x3011
 300c574:	f4878513          	addi	a0,a5,-184 # 3010f48 <g_crgIpMatch+0xa38>
 300c578:	37c1                	jal	ra,300c538 <DBG_UartPrintf.trans.13>
    DBG_PRINTF("      • Motor Type:%s\r\n",g_motorTypeStr[g_curMotorType]);
 300c57a:	a6c1a703          	lw	a4,-1428(gp) # 4000168 <g_curMotorType>
 300c57e:	47d1                	li	a5,20
 300c580:	02f70733          	mul	a4,a4,a5
 300c584:	a1818793          	addi	a5,gp,-1512 # 4000114 <g_motorTypeStr>
 300c588:	97ba                	add	a5,a5,a4
 300c58a:	85be                	mv	a1,a5
 300c58c:	030117b7          	lui	a5,0x3011
 300c590:	f8c78513          	addi	a0,a5,-116 # 3010f8c <g_crgIpMatch+0xa7c>
 300c594:	3755                	jal	ra,300c538 <DBG_UartPrintf.trans.13>
    DBG_PRINTF("      • Motor Encode Line Number:%05d\r\n",g_motorLineNum);
 300c596:	a701a783          	lw	a5,-1424(gp) # 400016c <g_motorLineNum>
 300c59a:	85be                	mv	a1,a5
 300c59c:	030117b7          	lui	a5,0x3011
 300c5a0:	fa878513          	addi	a0,a5,-88 # 3010fa8 <g_crgIpMatch+0xa98>
 300c5a4:	3f51                	jal	ra,300c538 <DBG_UartPrintf.trans.13>
    DBG_PRINTF("      • Motor Max Speed:%.02fmm/s\r\n", g_motorMaxSpeed);
 300c5a6:	a681a787          	flw	fa5,-1432(gp) # 4000164 <g_motorMaxSpeed>
 300c5aa:	20f78553          	fmv.s	fa0,fa5
 300c5ae:	36a9                	jal	ra,300c0f8 <__extendsfdf2.trans.11>
 300c5b0:	87aa                	mv	a5,a0
 300c5b2:	882e                	mv	a6,a1
 300c5b4:	863e                	mv	a2,a5
 300c5b6:	86c2                	mv	a3,a6
 300c5b8:	030117b7          	lui	a5,0x3011
 300c5bc:	fd478513          	addi	a0,a5,-44 # 3010fd4 <g_crgIpMatch+0xac4>
 300c5c0:	3fa5                	jal	ra,300c538 <DBG_UartPrintf.trans.13>
    DBG_PRINTF("      • EulerCar Data Send Period:%dms,%dHZ\r\n", EULER_CAR_DATA_SEND_PERIOD, 1000/EULER_CAR_DATA_SEND_PERIOD);
 300c5c2:	4629                	li	a2,10
 300c5c4:	06400593          	li	a1,100
 300c5c8:	030117b7          	lui	a5,0x3011
 300c5cc:	ffc78513          	addi	a0,a5,-4 # 3010ffc <g_crgIpMatch+0xaec>
 300c5d0:	37a5                	jal	ra,300c538 <DBG_UartPrintf.trans.13>
    DBG_PRINTF("                                                              \r\n");                                    
 300c5d2:	030117b7          	lui	a5,0x3011
 300c5d6:	f0478513          	addi	a0,a5,-252 # 3010f04 <g_crgIpMatch+0x9f4>
 300c5da:	3fb9                	jal	ra,300c538 <DBG_UartPrintf.trans.13>
    DBG_PRINTF("  ➤ PID Information:                                         \r\n");
 300c5dc:	030117b7          	lui	a5,0x3011
 300c5e0:	02c78513          	addi	a0,a5,44 # 301102c <g_crgIpMatch+0xb1c>
 300c5e4:	3f91                	jal	ra,300c538 <DBG_UartPrintf.trans.13>
    DBG_PRINTF("      • KP:%.02f    • KI:%.02f    • KD:%.02f\r\n",g_KP,g_KI,g_KD);
 300c5e6:	a781a787          	flw	fa5,-1416(gp) # 4000174 <g_KP>
 300c5ea:	20f78553          	fmv.s	fa0,fa5
 300c5ee:	3629                	jal	ra,300c0f8 <__extendsfdf2.trans.11>
 300c5f0:	892a                	mv	s2,a0
 300c5f2:	89ae                	mv	s3,a1
 300c5f4:	a7c1a787          	flw	fa5,-1412(gp) # 4000178 <g_KI>
 300c5f8:	20f78553          	fmv.s	fa0,fa5
 300c5fc:	3cf5                	jal	ra,300c0f8 <__extendsfdf2.trans.11>
 300c5fe:	8a2a                	mv	s4,a0
 300c600:	8aae                	mv	s5,a1
 300c602:	6f81a787          	flw	fa5,1784(gp) # 4000df4 <g_KD>
 300c606:	20f78553          	fmv.s	fa0,fa5
 300c60a:	34fd                	jal	ra,300c0f8 <__extendsfdf2.trans.11>
 300c60c:	87aa                	mv	a5,a0
 300c60e:	882e                	mv	a6,a1
 300c610:	88c2                	mv	a7,a6
 300c612:	883e                	mv	a6,a5
 300c614:	8752                	mv	a4,s4
 300c616:	87d6                	mv	a5,s5
 300c618:	864a                	mv	a2,s2
 300c61a:	86ce                	mv	a3,s3
 300c61c:	030115b7          	lui	a1,0x3011
 300c620:	07058513          	addi	a0,a1,112 # 3011070 <g_crgIpMatch+0xb60>
 300c624:	3f11                	jal	ra,300c538 <DBG_UartPrintf.trans.13>
    DBG_PRINTF("      • PID Control Period:%dms\r\n",MOTOR_PID_CONTROL_PERIOD);
 300c626:	45a9                	li	a1,10
 300c628:	030117b7          	lui	a5,0x3011
 300c62c:	0a878513          	addi	a0,a5,168 # 30110a8 <g_crgIpMatch+0xb98>
 300c630:	3721                	jal	ra,300c538 <DBG_UartPrintf.trans.13>
    DBG_PRINTF("==============================================================\r\n");
 300c632:	030117b7          	lui	a5,0x3011
 300c636:	e7878513          	addi	a0,a5,-392 # 3010e78 <g_crgIpMatch+0x968>
 300c63a:	3dfd                	jal	ra,300c538 <DBG_UartPrintf.trans.13>
    DBG_PRINTF("EulerCar MCU init success!!!\r\n");
 300c63c:	030117b7          	lui	a5,0x3011
 300c640:	0cc78513          	addi	a0,a5,204 # 30110cc <g_crgIpMatch+0xbbc>
 300c644:	3dd5                	jal	ra,300c538 <DBG_UartPrintf.trans.13>
    HAL_TIMER_Start(&g_timer0);
 300c646:	20018513          	addi	a0,gp,512 # 40008fc <g_timer0>
 300c64a:	a2ffd0ef          	jal	ra,300a078 <HAL_TIMER_Start>
    DBG_PRINTF("TIMER start\r\n");
 300c64e:	030117b7          	lui	a5,0x3011
 300c652:	0ec78513          	addi	a0,a5,236 # 30110ec <g_crgIpMatch+0xbdc>
 300c656:	35cd                	jal	ra,300c538 <DBG_UartPrintf.trans.13>
    // InitButtonFunction();
    // test_can();
    HAL_GPIO_SetValue(&g_gpio2, GPIO_PIN_6, GPIO_LOW_LEVEL);
 300c658:	4601                	li	a2,0
 300c65a:	04000593          	li	a1,64
 300c65e:	62018513          	addi	a0,gp,1568 # 4000d1c <g_gpio2>
 300c662:	2811                	jal	ra,300c676 <HAL_GPIO_SetValue.trans.32>
    UART3_INTRxSimultaneously();
 300c664:	3c61                	jal	ra,300c0fc <UART3_INTRxSimultaneously>
    // test_uart();
    /* USER CODE END 5 */
    return BASE_STATUS_OK;
 300c666:	4781                	li	a5,0
}
 300c668:	853e                	mv	a0,a5
 300c66a:	00810293          	addi	t0,sp,8
 300c66e:	01e2828b          	ldmia	{ra,s0,s2-s5},(t0)
 300c672:	6105                	addi	sp,sp,32
 300c674:	8082                	ret

0300c676 <HAL_GPIO_SetValue.trans.32>:
 300c676:	c05fa06f          	j	300727a <HAL_GPIO_SetValue>

0300c67a <Pid_Init>:
float g_KP_Step  = 0.1;
float g_KI_Step  = 0.1;
float g_KD_Step  = 0;

void Pid_Init(void)
{
 300c67a:	1141                	addi	sp,sp,-16
 300c67c:	c622                	sw	s0,12(sp)
 300c67e:	0800                	addi	s0,sp,16
    g_pidEulerCarRight.SetSpeed = 0;
 300c680:	6b818793          	addi	a5,gp,1720 # 4000db4 <g_pidEulerCarRight>
 300c684:	0007a023          	sw	zero,0(a5)
    g_pidEulerCarRight.ActualSpeed = 0;
 300c688:	6b818793          	addi	a5,gp,1720 # 4000db4 <g_pidEulerCarRight>
 300c68c:	0007a223          	sw	zero,4(a5)
    g_pidEulerCarRight.duty = 0;       
 300c690:	6b818793          	addi	a5,gp,1720 # 4000db4 <g_pidEulerCarRight>
 300c694:	0007ae23          	sw	zero,28(a5)
    g_pidEulerCarRight.err = 0;
 300c698:	6b818793          	addi	a5,gp,1720 # 4000db4 <g_pidEulerCarRight>
 300c69c:	0007a423          	sw	zero,8(a5)
    g_pidEulerCarRight.err_next = 0;
 300c6a0:	6b818793          	addi	a5,gp,1720 # 4000db4 <g_pidEulerCarRight>
 300c6a4:	0007a623          	sw	zero,12(a5)
    g_pidEulerCarRight.err_last = 0;
 300c6a8:	6b818793          	addi	a5,gp,1720 # 4000db4 <g_pidEulerCarRight>
 300c6ac:	0007a823          	sw	zero,16(a5)
    g_pidEulerCarRight.IncSpeed = 0; 
 300c6b0:	6b818793          	addi	a5,gp,1720 # 4000db4 <g_pidEulerCarRight>
 300c6b4:	0007aa23          	sw	zero,20(a5)
    g_pidEulerCarRight.TargetIncSpeed = 0; 
 300c6b8:	6b818793          	addi	a5,gp,1720 # 4000db4 <g_pidEulerCarRight>
 300c6bc:	0007ac23          	sw	zero,24(a5)
    //DBG_PRINTF("pid right init success\r\n");

    g_pidEulerCarLeft.SetSpeed = 0;
 300c6c0:	6d818793          	addi	a5,gp,1752 # 4000dd4 <g_pidEulerCarLeft>
 300c6c4:	0007a023          	sw	zero,0(a5)
    g_pidEulerCarLeft.ActualSpeed = 0;
 300c6c8:	6d818793          	addi	a5,gp,1752 # 4000dd4 <g_pidEulerCarLeft>
 300c6cc:	0007a223          	sw	zero,4(a5)
    g_pidEulerCarLeft.duty = 0;   
 300c6d0:	6d818793          	addi	a5,gp,1752 # 4000dd4 <g_pidEulerCarLeft>
 300c6d4:	0007ae23          	sw	zero,28(a5)
    g_pidEulerCarLeft.err = 0;
 300c6d8:	6d818793          	addi	a5,gp,1752 # 4000dd4 <g_pidEulerCarLeft>
 300c6dc:	0007a423          	sw	zero,8(a5)
    g_pidEulerCarLeft.err_next = 0;
 300c6e0:	6d818793          	addi	a5,gp,1752 # 4000dd4 <g_pidEulerCarLeft>
 300c6e4:	0007a623          	sw	zero,12(a5)
    g_pidEulerCarLeft.err_last = 0;
 300c6e8:	6d818793          	addi	a5,gp,1752 # 4000dd4 <g_pidEulerCarLeft>
 300c6ec:	0007a823          	sw	zero,16(a5)
    g_pidEulerCarLeft.IncSpeed = 0; 
 300c6f0:	6d818793          	addi	a5,gp,1752 # 4000dd4 <g_pidEulerCarLeft>
 300c6f4:	0007aa23          	sw	zero,20(a5)
    g_pidEulerCarLeft.TargetIncSpeed = 0; 
 300c6f8:	6d818793          	addi	a5,gp,1752 # 4000dd4 <g_pidEulerCarLeft>
 300c6fc:	0007ac23          	sw	zero,24(a5)
    //DBG_PRINTF("pid left init success\r\n");
}
 300c700:	0001                	nop
 300c702:	4432                	lw	s0,12(sp)
 300c704:	0141                	addi	sp,sp,16
 300c706:	8082                	ret

0300c708 <Pid_Ctrl>:


float Pid_Ctrl(PidEulerCar *pMotor)
{
 300c708:	7179                	addi	sp,sp,-48
 300c70a:	d606                	sw	ra,44(sp)
 300c70c:	d422                	sw	s0,40(sp)
 300c70e:	1800                	addi	s0,sp,48
 300c710:	fca42e23          	sw	a0,-36(s0)
    float IncrementSpeed;
    unsigned int duty;
   
    //计算当前误差
    pMotor->err = pMotor->SetSpeed - pMotor->ActualSpeed;
 300c714:	fdc42783          	lw	a5,-36(s0)
 300c718:	6398                	flw	fa4,0(a5)
 300c71a:	fdc42783          	lw	a5,-36(s0)
 300c71e:	63dc                	flw	fa5,4(a5)
 300c720:	08f777d3          	fsub.s	fa5,fa4,fa5
 300c724:	fdc42783          	lw	a5,-36(s0)
 300c728:	e79c                	fsw	fa5,8(a5)
  
    //增量式PID算法计算出增量，越接近目标速度，增量越接近零
    //增量式PID算法参数设定策略，先确定KI，再调KP，最后式KD
    IncrementSpeed =  g_KP * (pMotor->err - pMotor->err_next)
 300c72a:	fdc42783          	lw	a5,-36(s0)
 300c72e:	6798                	flw	fa4,8(a5)
 300c730:	fdc42783          	lw	a5,-36(s0)
 300c734:	67dc                	flw	fa5,12(a5)
 300c736:	08f77753          	fsub.s	fa4,fa4,fa5
 300c73a:	a781a787          	flw	fa5,-1416(gp) # 4000174 <g_KP>
 300c73e:	10f77753          	fmul.s	fa4,fa4,fa5
                    + g_KI * pMotor->err 
 300c742:	fdc42783          	lw	a5,-36(s0)
 300c746:	6794                	flw	fa3,8(a5)
 300c748:	a7c1a787          	flw	fa5,-1412(gp) # 4000178 <g_KI>
 300c74c:	10f6f7d3          	fmul.s	fa5,fa3,fa5
 300c750:	00f77753          	fadd.s	fa4,fa4,fa5
                    + g_KD * (pMotor->err - 2 * pMotor->err_next + pMotor->err_last);
 300c754:	fdc42783          	lw	a5,-36(s0)
 300c758:	6794                	flw	fa3,8(a5)
 300c75a:	fdc42783          	lw	a5,-36(s0)
 300c75e:	67dc                	flw	fa5,12(a5)
 300c760:	00f7f7d3          	fadd.s	fa5,fa5,fa5
 300c764:	08f6f6d3          	fsub.s	fa3,fa3,fa5
 300c768:	fdc42783          	lw	a5,-36(s0)
 300c76c:	6b9c                	flw	fa5,16(a5)
 300c76e:	00f6f6d3          	fadd.s	fa3,fa3,fa5
 300c772:	6f81a787          	flw	fa5,1784(gp) # 4000df4 <g_KD>
 300c776:	10f6f7d3          	fmul.s	fa5,fa3,fa5
    IncrementSpeed =  g_KP * (pMotor->err - pMotor->err_next)
 300c77a:	00f777d3          	fadd.s	fa5,fa4,fa5
 300c77e:	fef42427          	fsw	fa5,-24(s0)

    pMotor->TargetIncSpeed =  pMotor->TargetIncSpeed + IncrementSpeed;
 300c782:	fdc42783          	lw	a5,-36(s0)
 300c786:	6f98                	flw	fa4,24(a5)
 300c788:	fe842787          	flw	fa5,-24(s0)
 300c78c:	00f777d3          	fadd.s	fa5,fa4,fa5
 300c790:	fdc42783          	lw	a5,-36(s0)
 300c794:	ef9c                	fsw	fa5,24(a5)
    pMotor->IncSpeed = IncrementSpeed;
 300c796:	fdc42783          	lw	a5,-36(s0)
 300c79a:	fe842787          	flw	fa5,-24(s0)
 300c79e:	ebdc                	fsw	fa5,20(a5)

    //限制幅度
    if(pMotor->SetSpeed > 0){
 300c7a0:	fdc42783          	lw	a5,-36(s0)
 300c7a4:	639c                	flw	fa5,0(a5)
 300c7a6:	f0000753          	fmv.w.x	fa4,zero
 300c7aa:	a0f717d3          	flt.s	a5,fa4,fa5
 300c7ae:	cb95                	beqz	a5,300c7e2 <Pid_Ctrl+0xda>
        if (pMotor->TargetIncSpeed > g_motorMaxSpeed){
 300c7b0:	fdc42783          	lw	a5,-36(s0)
 300c7b4:	6f98                	flw	fa4,24(a5)
 300c7b6:	a681a787          	flw	fa5,-1432(gp) # 4000164 <g_motorMaxSpeed>
 300c7ba:	a0e797d3          	flt.s	a5,fa5,fa4
 300c7be:	c791                	beqz	a5,300c7ca <Pid_Ctrl+0xc2>
            pMotor->TargetIncSpeed = g_motorMaxSpeed;
 300c7c0:	a681a787          	flw	fa5,-1432(gp) # 4000164 <g_motorMaxSpeed>
 300c7c4:	fdc42783          	lw	a5,-36(s0)
 300c7c8:	ef9c                	fsw	fa5,24(a5)
        }
        if (pMotor->TargetIncSpeed < 0){
 300c7ca:	fdc42783          	lw	a5,-36(s0)
 300c7ce:	6f9c                	flw	fa5,24(a5)
 300c7d0:	f0000753          	fmv.w.x	fa4,zero
 300c7d4:	a0e797d3          	flt.s	a5,fa5,fa4
 300c7d8:	c789                	beqz	a5,300c7e2 <Pid_Ctrl+0xda>
            pMotor->TargetIncSpeed = 0;
 300c7da:	fdc42783          	lw	a5,-36(s0)
 300c7de:	0007ac23          	sw	zero,24(a5)
        }
    }

    if(pMotor->SetSpeed < 0){
 300c7e2:	fdc42783          	lw	a5,-36(s0)
 300c7e6:	639c                	flw	fa5,0(a5)
 300c7e8:	f0000753          	fmv.w.x	fa4,zero
 300c7ec:	a0e797d3          	flt.s	a5,fa5,fa4
 300c7f0:	cf95                	beqz	a5,300c82c <Pid_Ctrl+0x124>
        if (pMotor->TargetIncSpeed < -g_motorMaxSpeed){
 300c7f2:	fdc42783          	lw	a5,-36(s0)
 300c7f6:	6f98                	flw	fa4,24(a5)
 300c7f8:	a681a787          	flw	fa5,-1432(gp) # 4000164 <g_motorMaxSpeed>
 300c7fc:	20f797d3          	fneg.s	fa5,fa5
 300c800:	a0f717d3          	flt.s	a5,fa4,fa5
 300c804:	cb81                	beqz	a5,300c814 <Pid_Ctrl+0x10c>
            pMotor->TargetIncSpeed = -g_motorMaxSpeed;
 300c806:	a681a787          	flw	fa5,-1432(gp) # 4000164 <g_motorMaxSpeed>
 300c80a:	20f797d3          	fneg.s	fa5,fa5
 300c80e:	fdc42783          	lw	a5,-36(s0)
 300c812:	ef9c                	fsw	fa5,24(a5)
        }
        if (pMotor->TargetIncSpeed > 0){
 300c814:	fdc42783          	lw	a5,-36(s0)
 300c818:	6f9c                	flw	fa5,24(a5)
 300c81a:	f0000753          	fmv.w.x	fa4,zero
 300c81e:	a0f717d3          	flt.s	a5,fa4,fa5
 300c822:	c789                	beqz	a5,300c82c <Pid_Ctrl+0x124>
            pMotor->TargetIncSpeed = 0;
 300c824:	fdc42783          	lw	a5,-36(s0)
 300c828:	0007ac23          	sw	zero,24(a5)
        }
    }
     
    //电机需要设置的占空比
    duty = (abs)((int)(pMotor->TargetIncSpeed/g_motorMaxSpeed * 100.0));   
 300c82c:	fdc42783          	lw	a5,-36(s0)
 300c830:	6f98                	flw	fa4,24(a5)
 300c832:	a681a787          	flw	fa5,-1432(gp) # 4000164 <g_motorMaxSpeed>
 300c836:	18f777d3          	fdiv.s	fa5,fa4,fa5
 300c83a:	20f78553          	fmv.s	fa0,fa5
 300c83e:	063030ef          	jal	ra,30100a0 <__extendsfdf2>
 300c842:	87aa                	mv	a5,a0
 300c844:	882e                	mv	a6,a1
 300c846:	03011737          	lui	a4,0x3011
 300c84a:	10070713          	addi	a4,a4,256 # 3011100 <g_crgIpMatch+0xbf0>
 300c84e:	4310                	lw	a2,0(a4)
 300c850:	4354                	lw	a3,4(a4)
 300c852:	853e                	mv	a0,a5
 300c854:	85c2                	mv	a1,a6
 300c856:	11f020ef          	jal	ra,300f174 <__muldf3>
 300c85a:	87aa                	mv	a5,a0
 300c85c:	882e                	mv	a6,a1
 300c85e:	853e                	mv	a0,a5
 300c860:	85c2                	mv	a1,a6
 300c862:	716030ef          	jal	ra,300ff78 <__fixdfsi>
 300c866:	87aa                	mv	a5,a0
 300c868:	853e                	mv	a0,a5
 300c86a:	497030ef          	jal	ra,3010500 <abs>
 300c86e:	87aa                	mv	a5,a0
 300c870:	fef42623          	sw	a5,-20(s0)
    if (duty > 99) {
 300c874:	fec42703          	lw	a4,-20(s0)
 300c878:	06300793          	li	a5,99
 300c87c:	00e7f663          	bgeu	a5,a4,300c888 <Pid_Ctrl+0x180>
        duty = 99;
 300c880:	06300793          	li	a5,99
 300c884:	fef42623          	sw	a5,-20(s0)
    }
    pMotor->duty = duty;
 300c888:	fdc42783          	lw	a5,-36(s0)
 300c88c:	fec42703          	lw	a4,-20(s0)
 300c890:	cfd8                	sw	a4,28(a5)

    pMotor->err_last = pMotor->err_next;
 300c892:	fdc42783          	lw	a5,-36(s0)
 300c896:	67dc                	flw	fa5,12(a5)
 300c898:	fdc42783          	lw	a5,-36(s0)
 300c89c:	eb9c                	fsw	fa5,16(a5)
    pMotor->err_next = pMotor->err;
 300c89e:	fdc42783          	lw	a5,-36(s0)
 300c8a2:	679c                	flw	fa5,8(a5)
 300c8a4:	fdc42783          	lw	a5,-36(s0)
 300c8a8:	e7dc                	fsw	fa5,12(a5)

    return pMotor->TargetIncSpeed;
 300c8aa:	fdc42783          	lw	a5,-36(s0)
 300c8ae:	6f9c                	flw	fa5,24(a5)
}
 300c8b0:	20f78553          	fmv.s	fa0,fa5
 300c8b4:	50b2                	lw	ra,44(sp)
 300c8b6:	5422                	lw	s0,40(sp)
 300c8b8:	6145                	addi	sp,sp,48
 300c8ba:	8082                	ret

0300c8bc <set_duty>:
#include "pwm.h"
#include "uart.h"
#include "debug.h"


void set_duty(GPT_Handle* gpt_handle, int duty){
 300c8bc:	1101                	addi	sp,sp,-32
 300c8be:	ce06                	sw	ra,28(sp)
 300c8c0:	cc22                	sw	s0,24(sp)
 300c8c2:	1000                	addi	s0,sp,32
 300c8c4:	fea42623          	sw	a0,-20(s0)
 300c8c8:	feb42423          	sw	a1,-24(s0)
    // unsigned int period = HAL_GPT_GetCountPeriod(gpt_handle);
    HAL_GPT_GetConfig(gpt_handle);
 300c8cc:	fec42503          	lw	a0,-20(s0)
 300c8d0:	e60fb0ef          	jal	ra,3007f30 <HAL_GPT_GetConfig>
    gpt_handle->refA0.refAction = GPT_ACTION_OUTPUT_HIGH;
 300c8d4:	fec42783          	lw	a5,-20(s0)
 300c8d8:	4709                	li	a4,2
 300c8da:	cb98                	sw	a4,16(a5)
    gpt_handle->refA0.refdot = 1;
 300c8dc:	fec42783          	lw	a5,-20(s0)
 300c8e0:	4705                	li	a4,1
 300c8e2:	c7d8                	sw	a4,12(a5)
    gpt_handle->refB0.refAction = GPT_ACTION_OUTPUT_LOW;
 300c8e4:	fec42783          	lw	a5,-20(s0)
 300c8e8:	4705                	li	a4,1
 300c8ea:	cf98                	sw	a4,24(a5)
    gpt_handle->refB0.refdot = duty;
 300c8ec:	fe842703          	lw	a4,-24(s0)
 300c8f0:	fec42783          	lw	a5,-20(s0)
 300c8f4:	cbd8                	sw	a4,20(a5)
    HAL_GPT_Config(gpt_handle);
 300c8f6:	fec42503          	lw	a0,-20(s0)
 300c8fa:	b2afb0ef          	jal	ra,3007c24 <HAL_GPT_Config>
}
 300c8fe:	0001                	nop
 300c900:	40f2                	lw	ra,28(sp)
 300c902:	4462                	lw	s0,24(sp)
 300c904:	6105                	addi	sp,sp,32
 300c906:	8082                	ret

0300c908 <Rotate>:
//     BASE_FUNC_DELAY_MS(time);
//     HAL_GPT_Stop(gpt_handle);
// }


void Rotate(GPT_Handle* gpt_handle, unsigned short time,  unsigned short duty){
 300c908:	1101                	addi	sp,sp,-32
 300c90a:	ce06                	sw	ra,28(sp)
 300c90c:	cc22                	sw	s0,24(sp)
 300c90e:	1000                	addi	s0,sp,32
 300c910:	fea42623          	sw	a0,-20(s0)
 300c914:	87ae                	mv	a5,a1
 300c916:	8732                	mv	a4,a2
 300c918:	fef41523          	sh	a5,-22(s0)
 300c91c:	87ba                	mv	a5,a4
 300c91e:	fef41423          	sh	a5,-24(s0)
    // DBG_PRINTF("CLOCKWISE\r\n");
    set_duty(gpt_handle, duty); //350
 300c922:	fe845783          	lhu	a5,-24(s0)
 300c926:	85be                	mv	a1,a5
 300c928:	fec42503          	lw	a0,-20(s0)
 300c92c:	3f41                	jal	ra,300c8bc <set_duty>
    HAL_GPT_Start(gpt_handle);
 300c92e:	fec42503          	lw	a0,-20(s0)
 300c932:	9d8fb0ef          	jal	ra,3007b0a <HAL_GPT_Start>
    BASE_FUNC_DELAY_MS(time);
 300c936:	fea45783          	lhu	a5,-22(s0)
 300c93a:	3e800593          	li	a1,1000
 300c93e:	853e                	mv	a0,a5
 300c940:	d0cf60ef          	jal	ra,3002e4c <BASE_FUNC_Delay>
    HAL_GPT_Stop(gpt_handle);
 300c944:	fec42503          	lw	a0,-20(s0)
 300c948:	a50fb0ef          	jal	ra,3007b98 <HAL_GPT_Stop>
}
 300c94c:	0001                	nop
 300c94e:	40f2                	lw	ra,28(sp)
 300c950:	4462                	lw	s0,24(sp)
 300c952:	6105                	addi	sp,sp,32
 300c954:	8082                	ret

0300c956 <up>:

void up(unsigned short time, unsigned short duty){
 300c956:	1101                	addi	sp,sp,-32
 300c958:	ce06                	sw	ra,28(sp)
 300c95a:	cc22                	sw	s0,24(sp)
 300c95c:	1000                	addi	s0,sp,32
 300c95e:	87aa                	mv	a5,a0
 300c960:	872e                	mv	a4,a1
 300c962:	fef41723          	sh	a5,-18(s0)
 300c966:	87ba                	mv	a5,a4
 300c968:	fef41623          	sh	a5,-20(s0)
    Rotate(&g_gpt2, time, duty);
 300c96c:	fec45703          	lhu	a4,-20(s0)
 300c970:	fee45783          	lhu	a5,-18(s0)
 300c974:	863a                	mv	a2,a4
 300c976:	85be                	mv	a1,a5
 300c978:	19818513          	addi	a0,gp,408 # 4000894 <g_gpt2>
 300c97c:	3771                	jal	ra,300c908 <Rotate>
}
 300c97e:	0001                	nop
 300c980:	40f2                	lw	ra,28(sp)
 300c982:	4462                	lw	s0,24(sp)
 300c984:	6105                	addi	sp,sp,32
 300c986:	8082                	ret

0300c988 <down>:

void down(unsigned short time, unsigned short duty){
 300c988:	1101                	addi	sp,sp,-32
 300c98a:	ce06                	sw	ra,28(sp)
 300c98c:	cc22                	sw	s0,24(sp)
 300c98e:	1000                	addi	s0,sp,32
 300c990:	87aa                	mv	a5,a0
 300c992:	872e                	mv	a4,a1
 300c994:	fef41723          	sh	a5,-18(s0)
 300c998:	87ba                	mv	a5,a4
 300c99a:	fef41623          	sh	a5,-20(s0)
    Rotate(&g_gpt2, time, duty);
 300c99e:	fec45703          	lhu	a4,-20(s0)
 300c9a2:	fee45783          	lhu	a5,-18(s0)
 300c9a6:	863a                	mv	a2,a4
 300c9a8:	85be                	mv	a1,a5
 300c9aa:	19818513          	addi	a0,gp,408 # 4000894 <g_gpt2>
 300c9ae:	3fa9                	jal	ra,300c908 <Rotate>
}
 300c9b0:	0001                	nop
 300c9b2:	40f2                	lw	ra,28(sp)
 300c9b4:	4462                	lw	s0,24(sp)
 300c9b6:	6105                	addi	sp,sp,32
 300c9b8:	8082                	ret

0300c9ba <open>:

void open(unsigned short time, unsigned short duty){
 300c9ba:	1101                	addi	sp,sp,-32
 300c9bc:	ce06                	sw	ra,28(sp)
 300c9be:	cc22                	sw	s0,24(sp)
 300c9c0:	1000                	addi	s0,sp,32
 300c9c2:	87aa                	mv	a5,a0
 300c9c4:	872e                	mv	a4,a1
 300c9c6:	fef41723          	sh	a5,-18(s0)
 300c9ca:	87ba                	mv	a5,a4
 300c9cc:	fef41623          	sh	a5,-20(s0)
    Rotate(&g_gpt0, time, duty);
 300c9d0:	fec45703          	lhu	a4,-20(s0)
 300c9d4:	fee45783          	lhu	a5,-18(s0)
 300c9d8:	863a                	mv	a2,a4
 300c9da:	85be                	mv	a1,a5
 300c9dc:	13018513          	addi	a0,gp,304 # 400082c <g_gpt0>
 300c9e0:	3725                	jal	ra,300c908 <Rotate>
}
 300c9e2:	0001                	nop
 300c9e4:	40f2                	lw	ra,28(sp)
 300c9e6:	4462                	lw	s0,24(sp)
 300c9e8:	6105                	addi	sp,sp,32
 300c9ea:	8082                	ret

0300c9ec <_close>:

void _close(unsigned short time, unsigned short duty){
 300c9ec:	1101                	addi	sp,sp,-32
 300c9ee:	ce06                	sw	ra,28(sp)
 300c9f0:	cc22                	sw	s0,24(sp)
 300c9f2:	1000                	addi	s0,sp,32
 300c9f4:	87aa                	mv	a5,a0
 300c9f6:	872e                	mv	a4,a1
 300c9f8:	fef41723          	sh	a5,-18(s0)
 300c9fc:	87ba                	mv	a5,a4
 300c9fe:	fef41623          	sh	a5,-20(s0)
    Rotate(&g_gpt0, time, duty);
 300ca02:	fec45703          	lhu	a4,-20(s0)
 300ca06:	fee45783          	lhu	a5,-18(s0)
 300ca0a:	863a                	mv	a2,a4
 300ca0c:	85be                	mv	a1,a5
 300ca0e:	13018513          	addi	a0,gp,304 # 400082c <g_gpt0>
 300ca12:	3ddd                	jal	ra,300c908 <Rotate>
 300ca14:	0001                	nop
 300ca16:	40f2                	lw	ra,28(sp)
 300ca18:	4462                	lw	s0,24(sp)
 300ca1a:	6105                	addi	sp,sp,32
 300ca1c:	8082                	ret

0300ca1e <User_APTForcePWMAOutputLow>:

unsigned int g_testCount = 0;
unsigned int g_testNum = 0;

void User_APTForcePWMAOutputLow(APT_RegStruct *aptx)
{
 300ca1e:	1101                	addi	sp,sp,-32
 300ca20:	ce22                	sw	s0,28(sp)
 300ca22:	1000                	addi	s0,sp,32
 300ca24:	fea42623          	sw	a0,-20(s0)
    /* Enable force output. */


    aptx->PG_OUT_FRC.BIT.rg_pga_frc_act = APT_PWM_CONTINUOUS_ACTION_LOW; /* if not invert, set low */
 300ca28:	fec42703          	lw	a4,-20(s0)
 300ca2c:	11472783          	lw	a5,276(a4)
 300ca30:	9bf1                	andi	a5,a5,-4
 300ca32:	0017e793          	ori	a5,a5,1
 300ca36:	10f72a23          	sw	a5,276(a4)
    aptx->PG_OUT_FRC.BIT.rg_pga_frc_en = BASE_CFG_ENABLE;
 300ca3a:	fec42703          	lw	a4,-20(s0)
 300ca3e:	11472783          	lw	a5,276(a4)
 300ca42:	0047e793          	ori	a5,a5,4
 300ca46:	10f72a23          	sw	a5,276(a4)
    /* if PWMA invert */
    return;
 300ca4a:	0001                	nop
}
 300ca4c:	4472                	lw	s0,28(sp)
 300ca4e:	6105                	addi	sp,sp,32
 300ca50:	8082                	ret

0300ca52 <User_APTForcePWMBOutputLow>:

void User_APTForcePWMBOutputLow(APT_RegStruct *aptx)
{
 300ca52:	1101                	addi	sp,sp,-32
 300ca54:	ce22                	sw	s0,28(sp)
 300ca56:	1000                	addi	s0,sp,32
 300ca58:	fea42623          	sw	a0,-20(s0)
    aptx->PG_OUT_FRC.BIT.rg_pgb_frc_act = APT_PWM_CONTINUOUS_ACTION_HIGH; /* if not invert, set low */
 300ca5c:	fec42703          	lw	a4,-20(s0)
 300ca60:	11472783          	lw	a5,276(a4)
 300ca64:	fcf7f793          	andi	a5,a5,-49
 300ca68:	0207e793          	ori	a5,a5,32
 300ca6c:	10f72a23          	sw	a5,276(a4)
   /* Enable force output. */
    aptx->PG_OUT_FRC.BIT.rg_pgb_frc_en = BASE_CFG_ENABLE;
 300ca70:	fec42703          	lw	a4,-20(s0)
 300ca74:	11472783          	lw	a5,276(a4)
 300ca78:	0407e793          	ori	a5,a5,64
 300ca7c:	10f72a23          	sw	a5,276(a4)
    return;
 300ca80:	0001                	nop
}
 300ca82:	4472                	lw	s0,28(sp)
 300ca84:	6105                	addi	sp,sp,32
 300ca86:	8082                	ret

0300ca88 <User_APTPwmARecovery>:


void User_APTPwmARecovery(APT_RegStruct *aptx)
{
 300ca88:	1101                	addi	sp,sp,-32
 300ca8a:	ce22                	sw	s0,28(sp)
 300ca8c:	1000                	addi	s0,sp,32
 300ca8e:	fea42623          	sw	a0,-20(s0)
    /* Enable force output. */
    aptx->PG_OUT_FRC.BIT.rg_pga_frc_en = BASE_CFG_DISABLE;
 300ca92:	fec42703          	lw	a4,-20(s0)
 300ca96:	11472783          	lw	a5,276(a4)
 300ca9a:	9bed                	andi	a5,a5,-5
 300ca9c:	10f72a23          	sw	a5,276(a4)
    return;
 300caa0:	0001                	nop
}
 300caa2:	4472                	lw	s0,28(sp)
 300caa4:	6105                	addi	sp,sp,32
 300caa6:	8082                	ret

0300caa8 <User_APTPwmBRecovery>:

void User_APTPwmBRecovery(APT_RegStruct *aptx)
{
 300caa8:	1101                	addi	sp,sp,-32
 300caaa:	ce22                	sw	s0,28(sp)
 300caac:	1000                	addi	s0,sp,32
 300caae:	fea42623          	sw	a0,-20(s0)
    /* Enable force output. */
    aptx->PG_OUT_FRC.BIT.rg_pgb_frc_en = BASE_CFG_DISABLE;
 300cab2:	fec42703          	lw	a4,-20(s0)
 300cab6:	11472783          	lw	a5,276(a4)
 300caba:	fbf7f793          	andi	a5,a5,-65
 300cabe:	10f72a23          	sw	a5,276(a4)
    return;
 300cac2:	0001                	nop
}
 300cac4:	4472                	lw	s0,28(sp)
 300cac6:	6105                	addi	sp,sp,32
 300cac8:	8082                	ret

0300caca <CRG_Config>:
#define UART0_BAND_RATE 115200
#define UART2_BAND_RATE 115200
#define UART3_BAND_RATE 9600

BASE_StatusType CRG_Config(CRG_CoreClkSelect *coreClkSelect)
{
 300caca:	715d                	addi	sp,sp,-80
 300cacc:	c686                	sw	ra,76(sp)
 300cace:	c4a2                	sw	s0,72(sp)
 300cad0:	0880                	addi	s0,sp,80
 300cad2:	faa42e23          	sw	a0,-68(s0)
    CRG_Handle crg;
    crg.baseAddress     = CRG;
 300cad6:	100007b7          	lui	a5,0x10000
 300cada:	fcf42423          	sw	a5,-56(s0)
    crg.pllRefClkSelect = CRG_PLL_REF_CLK_SELECT_HOSC;
 300cade:	fc042623          	sw	zero,-52(s0)
    crg.pllPreDiv       = CRG_PLL_PREDIV_4;
 300cae2:	478d                	li	a5,3
 300cae4:	fcf42823          	sw	a5,-48(s0)
    crg.pllFbDiv        = 48; /* PLL Multiplier 48 */
 300cae8:	03000793          	li	a5,48
 300caec:	fcf42a23          	sw	a5,-44(s0)
    crg.pllPostDiv      = CRG_PLL_POSTDIV_2;
 300caf0:	4785                	li	a5,1
 300caf2:	fcf42c23          	sw	a5,-40(s0)
    crg.coreClkSelect   = CRG_CORE_CLK_SELECT_PLL;
 300caf6:	4789                	li	a5,2
 300caf8:	fef42023          	sw	a5,-32(s0)
    crg.handleEx.pllPostDiv2   = CRG_PLL_POSTDIV2_3;
 300cafc:	4789                	li	a5,2
 300cafe:	fef42223          	sw	a5,-28(s0)
    crg.handleEx.clk1MSelect   = CRG_1M_CLK_SELECT_HOSC;
 300cb02:	fe042423          	sw	zero,-24(s0)
    crg.handleEx.clk1MDiv = (25 - 1); /* The 1 MHz freq is equal to the input clock frequency / (clk_1m_div + 1). */
 300cb06:	47e1                	li	a5,24
 300cb08:	fef42623          	sw	a5,-20(s0)

    if (HAL_CRG_Init(&crg) != BASE_STATUS_OK) {
 300cb0c:	fc840793          	addi	a5,s0,-56
 300cb10:	853e                	mv	a0,a5
 300cb12:	efdf70ef          	jal	ra,3004a0e <HAL_CRG_Init>
 300cb16:	87aa                	mv	a5,a0
 300cb18:	c399                	beqz	a5,300cb1e <CRG_Config+0x54>
        return BASE_STATUS_ERROR;
 300cb1a:	4785                	li	a5,1
 300cb1c:	a039                	j	300cb2a <CRG_Config+0x60>
    }
    *coreClkSelect = crg.coreClkSelect;
 300cb1e:	fe042703          	lw	a4,-32(s0)
 300cb22:	fbc42783          	lw	a5,-68(s0)
 300cb26:	c398                	sw	a4,0(a5)
    return BASE_STATUS_OK;
 300cb28:	4781                	li	a5,0
}
 300cb2a:	853e                	mv	a0,a5
 300cb2c:	40b6                	lw	ra,76(sp)
 300cb2e:	4426                	lw	s0,72(sp)
 300cb30:	6161                	addi	sp,sp,80
 300cb32:	8082                	ret

0300cb34 <ADC0_Init>:

static void ADC0_Init(void)
{
 300cb34:	7179                	addi	sp,sp,-48
 300cb36:	d606                	sw	ra,44(sp)
 300cb38:	d422                	sw	s0,40(sp)
 300cb3a:	1800                	addi	s0,sp,48
    HAL_CRG_IpEnableSet(ADC0_BASE, IP_CLK_ENABLE);
 300cb3c:	4585                	li	a1,1
 300cb3e:	18000537          	lui	a0,0x18000
 300cb42:	2301                	jal	ra,300d042 <HAL_CRG_IpEnableSet.trans.20>
    HAL_CRG_IpClkSelectSet(ADC0_BASE, CRG_ADC_CLK_ASYN_PLL_DIV);
 300cb44:	4589                	li	a1,2
 300cb46:	18000537          	lui	a0,0x18000
 300cb4a:	d64f80ef          	jal	ra,30050ae <HAL_CRG_IpClkSelectSet>
    HAL_CRG_IpClkDivSet(ADC0_BASE, CRG_ADC_DIV_1);
 300cb4e:	4581                	li	a1,0
 300cb50:	18000537          	lui	a0,0x18000
 300cb54:	e04f80ef          	jal	ra,3005158 <HAL_CRG_IpClkDivSet>

    g_adc0.baseAddress = ADC0;
 300cb58:	53818793          	addi	a5,gp,1336 # 4000c34 <g_adc0>
 300cb5c:	18000737          	lui	a4,0x18000
 300cb60:	c398                	sw	a4,0(a5)
    g_adc0.socPriority = ADC_PRIMODE_ALL_ROUND;
 300cb62:	53818793          	addi	a5,gp,1336 # 4000c34 <g_adc0>
 300cb66:	0007a223          	sw	zero,4(a5) # 10000004 <RAM_END+0xbff8004>

    HAL_ADC_Init(&g_adc0);
 300cb6a:	53818513          	addi	a0,gp,1336 # 4000c34 <g_adc0>
 300cb6e:	b13f40ef          	jal	ra,3001680 <HAL_ADC_Init>

    SOC_Param socParam = {0};
 300cb72:	fc042e23          	sw	zero,-36(s0)
 300cb76:	fe042023          	sw	zero,-32(s0)
 300cb7a:	fe042223          	sw	zero,-28(s0)
 300cb7e:	fe042423          	sw	zero,-24(s0)
 300cb82:	fe042623          	sw	zero,-20(s0)
    socParam.adcInput = ADC_CH_ADCINA12; /* PIN10(ADC AIN12) */
 300cb86:	47b1                	li	a5,12
 300cb88:	fcf42e23          	sw	a5,-36(s0)
    socParam.sampleTotalTime = ADC_SOCSAMPLE_5CLK; /* adc sample total time 5 adc_clk */
 300cb8c:	fe042023          	sw	zero,-32(s0)
    socParam.trigSource = ADC_TRIGSOC_SOFT;
 300cb90:	fe042223          	sw	zero,-28(s0)
    socParam.continueMode = BASE_CFG_DISABLE;
 300cb94:	fe040423          	sb	zero,-24(s0)
    socParam.finishMode = ADC_SOCFINISH_NONE;
 300cb98:	4785                	li	a5,1
 300cb9a:	fef42623          	sw	a5,-20(s0)
    HAL_ADC_ConfigureSoc(&g_adc0, ADC_SOC_NUM1, &socParam);
 300cb9e:	fdc40793          	addi	a5,s0,-36
 300cba2:	863e                	mv	a2,a5
 300cba4:	4585                	li	a1,1
 300cba6:	53818513          	addi	a0,gp,1336 # 4000c34 <g_adc0>
 300cbaa:	b8bf40ef          	jal	ra,3001734 <HAL_ADC_ConfigureSoc>
}
 300cbae:	0001                	nop
 300cbb0:	50b2                	lw	ra,44(sp)
 300cbb2:	5422                	lw	s0,40(sp)
 300cbb4:	6145                	addi	sp,sp,48
 300cbb6:	8082                	ret

0300cbb8 <APT0_Init>:

static void APT0_Init(void)
{
 300cbb8:	1141                	addi	sp,sp,-16
 300cbba:	c606                	sw	ra,12(sp)
 300cbbc:	c422                	sw	s0,8(sp)
 300cbbe:	0800                	addi	s0,sp,16
    HAL_CRG_IpEnableSet(APT0_BASE, IP_CLK_ENABLE);
 300cbc0:	4585                	li	a1,1
 300cbc2:	14a00537          	lui	a0,0x14a00
 300cbc6:	29b5                	jal	ra,300d042 <HAL_CRG_IpEnableSet.trans.20>

    g_apt0.baseAddress = APT0;
 300cbc8:	47818793          	addi	a5,gp,1144 # 4000b74 <g_apt0>
 300cbcc:	14a00737          	lui	a4,0x14a00
 300cbd0:	c398                	sw	a4,0(a5)

    /* Clock Settings */
    g_apt0.waveform.dividerFactor = 1 - 1;
 300cbd2:	47818793          	addi	a5,gp,1144 # 4000b74 <g_apt0>
 300cbd6:	00079a23          	sh	zero,20(a5)
    /* Timer Settings */
    g_apt0.waveform.timerPeriod = 1500;
 300cbda:	47818793          	addi	a5,gp,1144 # 4000b74 <g_apt0>
 300cbde:	5dc00713          	li	a4,1500
 300cbe2:	abfa                	sh	a4,22(a5)
    g_apt0.waveform.cntMode = APT_COUNT_MODE_UP_DOWN;
 300cbe4:	47818793          	addi	a5,gp,1144 # 4000b74 <g_apt0>
 300cbe8:	4709                	li	a4,2
 300cbea:	cb98                	sw	a4,16(a5)

    /* Wave Form */
    g_apt0.waveform.basicType = APT_PWM_BASIC_A_HIGH_B_LOW;
 300cbec:	47818793          	addi	a5,gp,1144 # 4000b74 <g_apt0>
 300cbf0:	0007a223          	sw	zero,4(a5)
    g_apt0.waveform.chAOutType = APT_PWM_OUT_BASIC_TYPE;
 300cbf4:	47818793          	addi	a5,gp,1144 # 4000b74 <g_apt0>
 300cbf8:	0007a423          	sw	zero,8(a5)
    g_apt0.waveform.chBOutType = APT_PWM_OUT_BASIC_TYPE;
 300cbfc:	47818793          	addi	a5,gp,1144 # 4000b74 <g_apt0>
 300cc00:	0007a623          	sw	zero,12(a5)
    g_apt0.waveform.divInitVal = 0;
 300cc04:	47818793          	addi	a5,gp,1144 # 4000b74 <g_apt0>
 300cc08:	00079c23          	sh	zero,24(a5)
    g_apt0.waveform.cntInitVal = 0;
 300cc0c:	47818793          	addi	a5,gp,1144 # 4000b74 <g_apt0>
 300cc10:	00079d23          	sh	zero,26(a5)
    g_apt0.waveform.cntCmpLeftEdge = 250;
 300cc14:	47818793          	addi	a5,gp,1144 # 4000b74 <g_apt0>
 300cc18:	0fa00713          	li	a4,250
 300cc1c:	afda                	sh	a4,28(a5)
    g_apt0.waveform.cntCmpRightEdge = 250;
 300cc1e:	47818793          	addi	a5,gp,1144 # 4000b74 <g_apt0>
 300cc22:	0fa00713          	li	a4,250
 300cc26:	affa                	sh	a4,30(a5)
    g_apt0.waveform.cntCmpLoadMode = APT_BUFFER_DISABLE;
 300cc28:	47818793          	addi	a5,gp,1144 # 4000b74 <g_apt0>
 300cc2c:	0207a023          	sw	zero,32(a5)
    g_apt0.waveform.cntCmpLoadEvt = APT_COMPARE_LOAD_EVENT_ZERO;
 300cc30:	47818793          	addi	a5,gp,1144 # 4000b74 <g_apt0>
 300cc34:	4705                	li	a4,1
 300cc36:	d3d8                	sw	a4,36(a5)
    g_apt0.waveform.deadBandCnt = 10;
 300cc38:	47818793          	addi	a5,gp,1144 # 4000b74 <g_apt0>
 300cc3c:	4729                	li	a4,10
 300cc3e:	b79a                	sh	a4,40(a5)

    HAL_APT_PWMInit(&g_apt0);
 300cc40:	47818513          	addi	a0,gp,1144 # 4000b74 <g_apt0>
 300cc44:	809f50ef          	jal	ra,300244c <HAL_APT_PWMInit>
}
 300cc48:	0001                	nop
 300cc4a:	40b2                	lw	ra,12(sp)
 300cc4c:	4422                	lw	s0,8(sp)
 300cc4e:	0141                	addi	sp,sp,16
 300cc50:	8082                	ret

0300cc52 <APT1_Init>:

static void APT1_Init(void)
{
 300cc52:	1141                	addi	sp,sp,-16
 300cc54:	c606                	sw	ra,12(sp)
 300cc56:	c422                	sw	s0,8(sp)
 300cc58:	0800                	addi	s0,sp,16
    HAL_CRG_IpEnableSet(APT1_BASE, IP_CLK_ENABLE);
 300cc5a:	4585                	li	a1,1
 300cc5c:	14a01537          	lui	a0,0x14a01
 300cc60:	26cd                	jal	ra,300d042 <HAL_CRG_IpEnableSet.trans.20>

    g_apt1.baseAddress = APT1;
 300cc62:	4d818793          	addi	a5,gp,1240 # 4000bd4 <g_apt1>
 300cc66:	14a01737          	lui	a4,0x14a01
 300cc6a:	c398                	sw	a4,0(a5)

    /* Clock Settings */
    g_apt1.waveform.dividerFactor = 1 - 1;
 300cc6c:	4d818793          	addi	a5,gp,1240 # 4000bd4 <g_apt1>
 300cc70:	00079a23          	sh	zero,20(a5)
    /* Timer Settings */
    g_apt1.waveform.timerPeriod = 1500;
 300cc74:	4d818793          	addi	a5,gp,1240 # 4000bd4 <g_apt1>
 300cc78:	5dc00713          	li	a4,1500
 300cc7c:	abfa                	sh	a4,22(a5)
    g_apt1.waveform.cntMode = APT_COUNT_MODE_UP_DOWN;
 300cc7e:	4d818793          	addi	a5,gp,1240 # 4000bd4 <g_apt1>
 300cc82:	4709                	li	a4,2
 300cc84:	cb98                	sw	a4,16(a5)

    /* Wave Form */
    g_apt1.waveform.basicType = APT_PWM_BASIC_A_HIGH_B_LOW;
 300cc86:	4d818793          	addi	a5,gp,1240 # 4000bd4 <g_apt1>
 300cc8a:	0007a223          	sw	zero,4(a5)
    g_apt1.waveform.chAOutType = APT_PWM_OUT_BASIC_TYPE;
 300cc8e:	4d818793          	addi	a5,gp,1240 # 4000bd4 <g_apt1>
 300cc92:	0007a423          	sw	zero,8(a5)
    g_apt1.waveform.chBOutType = APT_PWM_OUT_BASIC_TYPE;
 300cc96:	4d818793          	addi	a5,gp,1240 # 4000bd4 <g_apt1>
 300cc9a:	0007a623          	sw	zero,12(a5)
    g_apt1.waveform.divInitVal = 0;
 300cc9e:	4d818793          	addi	a5,gp,1240 # 4000bd4 <g_apt1>
 300cca2:	00079c23          	sh	zero,24(a5)
    g_apt1.waveform.cntInitVal = 0;
 300cca6:	4d818793          	addi	a5,gp,1240 # 4000bd4 <g_apt1>
 300ccaa:	00079d23          	sh	zero,26(a5)
    g_apt1.waveform.cntCmpLeftEdge = 250;
 300ccae:	4d818793          	addi	a5,gp,1240 # 4000bd4 <g_apt1>
 300ccb2:	0fa00713          	li	a4,250
 300ccb6:	afda                	sh	a4,28(a5)
    g_apt1.waveform.cntCmpRightEdge = 250;
 300ccb8:	4d818793          	addi	a5,gp,1240 # 4000bd4 <g_apt1>
 300ccbc:	0fa00713          	li	a4,250
 300ccc0:	affa                	sh	a4,30(a5)
    g_apt1.waveform.cntCmpLoadMode = APT_BUFFER_DISABLE;
 300ccc2:	4d818793          	addi	a5,gp,1240 # 4000bd4 <g_apt1>
 300ccc6:	0207a023          	sw	zero,32(a5)
    g_apt1.waveform.cntCmpLoadEvt = APT_COMPARE_LOAD_EVENT_ZERO;
 300ccca:	4d818793          	addi	a5,gp,1240 # 4000bd4 <g_apt1>
 300ccce:	4705                	li	a4,1
 300ccd0:	d3d8                	sw	a4,36(a5)
    g_apt1.waveform.deadBandCnt = 10;
 300ccd2:	4d818793          	addi	a5,gp,1240 # 4000bd4 <g_apt1>
 300ccd6:	4729                	li	a4,10
 300ccd8:	b79a                	sh	a4,40(a5)

    HAL_APT_PWMInit(&g_apt1);
 300ccda:	4d818513          	addi	a0,gp,1240 # 4000bd4 <g_apt1>
 300ccde:	f6ef50ef          	jal	ra,300244c <HAL_APT_PWMInit>
}
 300cce2:	0001                	nop
 300cce4:	40b2                	lw	ra,12(sp)
 300cce6:	4422                	lw	s0,8(sp)
 300cce8:	0141                	addi	sp,sp,16
 300ccea:	8082                	ret

0300ccec <CAN_Init>:

static void CAN_Init(void){
 300ccec:	1141                	addi	sp,sp,-16
 300ccee:	c606                	sw	ra,12(sp)
 300ccf0:	c422                	sw	s0,8(sp)
 300ccf2:	0800                	addi	s0,sp,16
    HAL_CRG_IpEnableSet(CAN_BASE, IP_CLK_ENABLE);
 300ccf4:	4585                	li	a1,1
 300ccf6:	14600537          	lui	a0,0x14600
 300ccfa:	26a1                	jal	ra,300d042 <HAL_CRG_IpEnableSet.trans.20>

    g_can.baseAddress = CAN;
 300ccfc:	fdc18793          	addi	a5,gp,-36 # 40006d8 <g_can>
 300cd00:	14600737          	lui	a4,0x14600
 300cd04:	c398                	sw	a4,0(a5)

    g_can.typeMode = CAN_MODE_NORMAL;
 300cd06:	fdc18793          	addi	a5,gp,-36 # 40006d8 <g_can>
 300cd0a:	0007a223          	sw	zero,4(a5)
    g_can.seg1Phase = CAN_SEG1_5TQ;
 300cd0e:	fdc18793          	addi	a5,gp,-36 # 40006d8 <g_can>
 300cd12:	4715                	li	a4,5
 300cd14:	c7d8                	sw	a4,12(a5)
    g_can.seg2Phase = CAN_SEG2_4TQ;
 300cd16:	fdc18793          	addi	a5,gp,-36 # 40006d8 <g_can>
 300cd1a:	4711                	li	a4,4
 300cd1c:	cb98                	sw	a4,16(a5)
    g_can.sjw = CAN_SJW_1TQ; // 2
 300cd1e:	fdc18793          	addi	a5,gp,-36 # 40006d8 <g_can>
 300cd22:	4705                	li	a4,1
 300cd24:	cf98                	sw	a4,24(a5)
    g_can.prescalser = 5;  /* 25 is frequency division coefficient */
 300cd26:	fdc18793          	addi	a5,gp,-36 # 40006d8 <g_can>
 300cd2a:	4715                	li	a4,5
 300cd2c:	cbd8                	sw	a4,20(a5)
    g_can.rxFIFODepth = 4;  /* A maximum of 4 packet objects are in RX FIFO */ 
 300cd2e:	fdc18793          	addi	a5,gp,-36 # 40006d8 <g_can>
 300cd32:	4711                	li	a4,4
 300cd34:	d798                	sw	a4,40(a5)
    g_can.autoRetrans = BASE_CFG_ENABLE;
 300cd36:	fdc18793          	addi	a5,gp,-36 # 40006d8 <g_can>
 300cd3a:	4705                	li	a4,1
 300cd3c:	02e78623          	sb	a4,44(a5)
    HAL_CAN_Init(&g_can);
 300cd40:	fdc18513          	addi	a0,gp,-36 # 40006d8 <g_can>
 300cd44:	bcbf60ef          	jal	ra,300390e <HAL_CAN_Init>

    HAL_CAN_RegisterCallBack(&g_can, CAN_WRITE_FINISH, (CAN_CallbackType)CANWriteCallbackFunc);
 300cd48:	0300b7b7          	lui	a5,0x300b
 300cd4c:	22a78613          	addi	a2,a5,554 # 300b22a <CANWriteCallbackFunc>
 300cd50:	4581                	li	a1,0
 300cd52:	fdc18513          	addi	a0,gp,-36 # 40006d8 <g_can>
 300cd56:	2889                	jal	ra,300cda8 <HAL_CAN_RegisterCallBack.trans.44>
    HAL_CAN_RegisterCallBack(&g_can, CAN_READ_FINISH, (CAN_CallbackType)CANReadCallbackFunc);
 300cd58:	0300b7b7          	lui	a5,0x300b
 300cd5c:	25078613          	addi	a2,a5,592 # 300b250 <CANReadCallbackFunc>
 300cd60:	4585                	li	a1,1
 300cd62:	fdc18513          	addi	a0,gp,-36 # 40006d8 <g_can>
 300cd66:	2089                	jal	ra,300cda8 <HAL_CAN_RegisterCallBack.trans.44>
    HAL_CAN_RegisterCallBack(&g_can, CAN_TRNS_ERROR, (CAN_CallbackType)CANTransCallbackFunc);
 300cd68:	0300d7b7          	lui	a5,0x300d
 300cd6c:	dac78613          	addi	a2,a5,-596 # 300cdac <CANTransCallbackFunc>
 300cd70:	4589                	li	a1,2
 300cd72:	fdc18513          	addi	a0,gp,-36 # 40006d8 <g_can>
 300cd76:	280d                	jal	ra,300cda8 <HAL_CAN_RegisterCallBack.trans.44>

    IRQ_Register(IRQ_CAN, HAL_CAN_IrqHandler, &g_can);
 300cd78:	fdc18613          	addi	a2,gp,-36 # 40006d8 <g_can>
 300cd7c:	030047b7          	lui	a5,0x3004
 300cd80:	4a478593          	addi	a1,a5,1188 # 30044a4 <HAL_CAN_IrqHandler>
 300cd84:	02e00513          	li	a0,46
 300cd88:	9d2f60ef          	jal	ra,3002f5a <IRQ_Register>
    IRQ_SetPriority(IRQ_CAN, 2);
 300cd8c:	4589                	li	a1,2
 300cd8e:	02e00513          	li	a0,46
 300cd92:	9e3f60ef          	jal	ra,3003774 <IRQ_SetPriority>
    IRQ_EnableN(IRQ_CAN);
 300cd96:	02e00513          	li	a0,46
 300cd9a:	a46f60ef          	jal	ra,3002fe0 <IRQ_EnableN>
}
 300cd9e:	0001                	nop
 300cda0:	40b2                	lw	ra,12(sp)
 300cda2:	4422                	lw	s0,8(sp)
 300cda4:	0141                	addi	sp,sp,16
 300cda6:	8082                	ret

0300cda8 <HAL_CAN_RegisterCallBack.trans.44>:
 300cda8:	ff6f706f          	j	300459e <HAL_CAN_RegisterCallBack>

0300cdac <CANTransCallbackFunc>:

__weak void CANReadCallbackFunc(void* handle){
    BASE_FUNC_UNUSED(handle);
}

__weak void CANTransCallbackFunc(void* handle){
 300cdac:	1101                	addi	sp,sp,-32
 300cdae:	ce22                	sw	s0,28(sp)
 300cdb0:	1000                	addi	s0,sp,32
 300cdb2:	fea42623          	sw	a0,-20(s0)
    BASE_FUNC_UNUSED(handle);
}
 300cdb6:	0001                	nop
 300cdb8:	4472                	lw	s0,28(sp)
 300cdba:	6105                	addi	sp,sp,32
 300cdbc:	8082                	ret

0300cdbe <GPIO_Init>:

static void GPIO_Init(void)
{
 300cdbe:	1141                	addi	sp,sp,-16
 300cdc0:	c606                	sw	ra,12(sp)
 300cdc2:	c422                	sw	s0,8(sp)
 300cdc4:	0800                	addi	s0,sp,16
    HAL_CRG_IpEnableSet(GPIO1_BASE, IP_CLK_ENABLE);
 300cdc6:	4585                	li	a1,1
 300cdc8:	14501537          	lui	a0,0x14501
 300cdcc:	2c9d                	jal	ra,300d042 <HAL_CRG_IpEnableSet.trans.20>
    g_gpio1.baseAddress = GPIO1;
 300cdce:	5d818793          	addi	a5,gp,1496 # 4000cd4 <g_gpio1>
 300cdd2:	14501737          	lui	a4,0x14501
 300cdd6:	c398                	sw	a4,0(a5)

    g_gpio1.pins = GPIO_PIN_0 | GPIO_PIN_1;
 300cdd8:	5d818793          	addi	a5,gp,1496 # 4000cd4 <g_gpio1>
 300cddc:	470d                	li	a4,3
 300cdde:	c3d8                	sw	a4,4(a5)
    HAL_GPIO_Init(&g_gpio1);
 300cde0:	5d818513          	addi	a0,gp,1496 # 4000cd4 <g_gpio1>
 300cde4:	2a05                	jal	ra,300cf14 <HAL_GPIO_Init.trans.45>
    HAL_GPIO_SetDirection(&g_gpio1, g_gpio1.pins, GPIO_INPUT_MODE);
 300cde6:	5d818793          	addi	a5,gp,1496 # 4000cd4 <g_gpio1>
 300cdea:	43dc                	lw	a5,4(a5)
 300cdec:	4601                	li	a2,0
 300cdee:	85be                	mv	a1,a5
 300cdf0:	5d818513          	addi	a0,gp,1496 # 4000cd4 <g_gpio1>
 300cdf4:	2a31                	jal	ra,300cf10 <HAL_GPIO_SetDirection.trans.46>
    HAL_GPIO_SetValue(&g_gpio1, g_gpio1.pins, GPIO_LOW_LEVEL);
 300cdf6:	5d818793          	addi	a5,gp,1496 # 4000cd4 <g_gpio1>
 300cdfa:	43dc                	lw	a5,4(a5)
 300cdfc:	4601                	li	a2,0
 300cdfe:	85be                	mv	a1,a5
 300ce00:	5d818513          	addi	a0,gp,1496 # 4000cd4 <g_gpio1>
 300ce04:	2a11                	jal	ra,300cf18 <HAL_GPIO_SetValue.trans.33>
    HAL_GPIO_SetIrqType(&g_gpio1, g_gpio1.pins, GPIO_INT_TYPE_RISE_EDGE);
 300ce06:	5d818793          	addi	a5,gp,1496 # 4000cd4 <g_gpio1>
 300ce0a:	43dc                	lw	a5,4(a5)
 300ce0c:	4605                	li	a2,1
 300ce0e:	85be                	mv	a1,a5
 300ce10:	5d818513          	addi	a0,gp,1496 # 4000cd4 <g_gpio1>
 300ce14:	28e5                	jal	ra,300cf0c <HAL_GPIO_SetIrqType.trans.47>

    HAL_CRG_IpEnableSet(GPIO2_BASE, IP_CLK_ENABLE);
 300ce16:	4585                	li	a1,1
 300ce18:	14502537          	lui	a0,0x14502
 300ce1c:	241d                	jal	ra,300d042 <HAL_CRG_IpEnableSet.trans.20>
    g_gpio2.baseAddress = GPIO2;
 300ce1e:	62018793          	addi	a5,gp,1568 # 4000d1c <g_gpio2>
 300ce22:	14502737          	lui	a4,0x14502
 300ce26:	c398                	sw	a4,0(a5)

    g_gpio2.pins = GPIO_PIN_5 | GPIO_PIN_6 | GPIO_PIN_7;
 300ce28:	62018793          	addi	a5,gp,1568 # 4000d1c <g_gpio2>
 300ce2c:	0e000713          	li	a4,224
 300ce30:	c3d8                	sw	a4,4(a5)
    HAL_GPIO_Init(&g_gpio2);
 300ce32:	62018513          	addi	a0,gp,1568 # 4000d1c <g_gpio2>
 300ce36:	28f9                	jal	ra,300cf14 <HAL_GPIO_Init.trans.45>
    HAL_GPIO_SetDirection(&g_gpio2, g_gpio2.pins, GPIO_OUTPUT_MODE);
 300ce38:	62018793          	addi	a5,gp,1568 # 4000d1c <g_gpio2>
 300ce3c:	43dc                	lw	a5,4(a5)
 300ce3e:	4605                	li	a2,1
 300ce40:	85be                	mv	a1,a5
 300ce42:	62018513          	addi	a0,gp,1568 # 4000d1c <g_gpio2>
 300ce46:	20e9                	jal	ra,300cf10 <HAL_GPIO_SetDirection.trans.46>
    HAL_GPIO_SetValue(&g_gpio2, g_gpio2.pins, GPIO_HIGH_LEVEL);
 300ce48:	62018793          	addi	a5,gp,1568 # 4000d1c <g_gpio2>
 300ce4c:	43dc                	lw	a5,4(a5)
 300ce4e:	4605                	li	a2,1
 300ce50:	85be                	mv	a1,a5
 300ce52:	62018513          	addi	a0,gp,1568 # 4000d1c <g_gpio2>
 300ce56:	20c9                	jal	ra,300cf18 <HAL_GPIO_SetValue.trans.33>
    HAL_GPIO_SetIrqType(&g_gpio2, g_gpio2.pins, GPIO_INT_TYPE_NONE);
 300ce58:	62018793          	addi	a5,gp,1568 # 4000d1c <g_gpio2>
 300ce5c:	43dc                	lw	a5,4(a5)
 300ce5e:	4615                	li	a2,5
 300ce60:	85be                	mv	a1,a5
 300ce62:	62018513          	addi	a0,gp,1568 # 4000d1c <g_gpio2>
 300ce66:	205d                	jal	ra,300cf0c <HAL_GPIO_SetIrqType.trans.47>

    HAL_CRG_IpEnableSet(GPIO5_BASE, IP_CLK_ENABLE);
 300ce68:	4585                	li	a1,1
 300ce6a:	14505537          	lui	a0,0x14505
 300ce6e:	2ad1                	jal	ra,300d042 <HAL_CRG_IpEnableSet.trans.20>
    g_gpio5.baseAddress = GPIO5;
 300ce70:	66818793          	addi	a5,gp,1640 # 4000d64 <g_gpio5>
 300ce74:	14505737          	lui	a4,0x14505
 300ce78:	c398                	sw	a4,0(a5)

    g_gpio5.pins = GPIO_PIN_1;
 300ce7a:	66818793          	addi	a5,gp,1640 # 4000d64 <g_gpio5>
 300ce7e:	4709                	li	a4,2
 300ce80:	c3d8                	sw	a4,4(a5)
    HAL_GPIO_Init(&g_gpio5);
 300ce82:	66818513          	addi	a0,gp,1640 # 4000d64 <g_gpio5>
 300ce86:	2079                	jal	ra,300cf14 <HAL_GPIO_Init.trans.45>
    HAL_GPIO_SetDirection(&g_gpio5, g_gpio5.pins, GPIO_OUTPUT_MODE);
 300ce88:	66818793          	addi	a5,gp,1640 # 4000d64 <g_gpio5>
 300ce8c:	43dc                	lw	a5,4(a5)
 300ce8e:	4605                	li	a2,1
 300ce90:	85be                	mv	a1,a5
 300ce92:	66818513          	addi	a0,gp,1640 # 4000d64 <g_gpio5>
 300ce96:	28ad                	jal	ra,300cf10 <HAL_GPIO_SetDirection.trans.46>
    HAL_GPIO_SetValue(&g_gpio5, g_gpio5.pins, GPIO_LOW_LEVEL);
 300ce98:	66818793          	addi	a5,gp,1640 # 4000d64 <g_gpio5>
 300ce9c:	43dc                	lw	a5,4(a5)
 300ce9e:	4601                	li	a2,0
 300cea0:	85be                	mv	a1,a5
 300cea2:	66818513          	addi	a0,gp,1640 # 4000d64 <g_gpio5>
 300cea6:	288d                	jal	ra,300cf18 <HAL_GPIO_SetValue.trans.33>
    HAL_GPIO_SetIrqType(&g_gpio5, g_gpio5.pins, GPIO_INT_TYPE_NONE);
 300cea8:	66818793          	addi	a5,gp,1640 # 4000d64 <g_gpio5>
 300ceac:	43dc                	lw	a5,4(a5)
 300ceae:	4615                	li	a2,5
 300ceb0:	85be                	mv	a1,a5
 300ceb2:	66818513          	addi	a0,gp,1640 # 4000d64 <g_gpio5>
 300ceb6:	2899                	jal	ra,300cf0c <HAL_GPIO_SetIrqType.trans.47>

    HAL_GPIO_RegisterCallBack(&g_gpio1, GPIO_PIN_0, GPIO1_0_CallbackFunc);
 300ceb8:	0300b7b7          	lui	a5,0x300b
 300cebc:	1d678613          	addi	a2,a5,470 # 300b1d6 <GPIO1_0_CallbackFunc>
 300cec0:	4585                	li	a1,1
 300cec2:	5d818513          	addi	a0,gp,1496 # 4000cd4 <g_gpio1>
 300cec6:	9f1fa0ef          	jal	ra,30078b6 <HAL_GPIO_RegisterCallBack>
    HAL_GPIO_RegisterCallBack(&g_gpio1, GPIO_PIN_1, GPIO1_1_CallbackFunc);
 300ceca:	0300b7b7          	lui	a5,0x300b
 300cece:	20078613          	addi	a2,a5,512 # 300b200 <GPIO1_1_CallbackFunc>
 300ced2:	4589                	li	a1,2
 300ced4:	5d818513          	addi	a0,gp,1496 # 4000cd4 <g_gpio1>
 300ced8:	9dffa0ef          	jal	ra,30078b6 <HAL_GPIO_RegisterCallBack>
    IRQ_Register(IRQ_GPIO1, HAL_GPIO_IrqHandler, &g_gpio1);
 300cedc:	5d818613          	addi	a2,gp,1496 # 4000cd4 <g_gpio1>
 300cee0:	030077b7          	lui	a5,0x3007
 300cee4:	7ac78593          	addi	a1,a5,1964 # 30077ac <HAL_GPIO_IrqHandler>
 300cee8:	06e00513          	li	a0,110
 300ceec:	86ef60ef          	jal	ra,3002f5a <IRQ_Register>
    IRQ_SetPriority(IRQ_GPIO1, 1); /* set gpio1 interrupt priority to 1, 1~15 */
 300cef0:	4585                	li	a1,1
 300cef2:	06e00513          	li	a0,110
 300cef6:	87ff60ef          	jal	ra,3003774 <IRQ_SetPriority>
    IRQ_EnableN(IRQ_GPIO1); /* gpio interrupt enable */
 300cefa:	06e00513          	li	a0,110
 300cefe:	8e2f60ef          	jal	ra,3002fe0 <IRQ_EnableN>

    return;
 300cf02:	0001                	nop
}
 300cf04:	40b2                	lw	ra,12(sp)
 300cf06:	4422                	lw	s0,8(sp)
 300cf08:	0141                	addi	sp,sp,16
 300cf0a:	8082                	ret

0300cf0c <HAL_GPIO_SetIrqType.trans.47>:
 300cf0c:	d8cfa06f          	j	3007498 <HAL_GPIO_SetIrqType>

0300cf10 <HAL_GPIO_SetDirection.trans.46>:
 300cf10:	a82fa06f          	j	3007192 <HAL_GPIO_SetDirection>

0300cf14 <HAL_GPIO_Init.trans.45>:
 300cf14:	998fa06f          	j	30070ac <HAL_GPIO_Init>

0300cf18 <HAL_GPIO_SetValue.trans.33>:
 300cf18:	b62fa06f          	j	300727a <HAL_GPIO_SetValue>

0300cf1c <GPT0_Init>:

static void GPT0_Init(void)
{
 300cf1c:	1141                	addi	sp,sp,-16
 300cf1e:	c606                	sw	ra,12(sp)
 300cf20:	c422                	sw	s0,8(sp)
 300cf22:	0800                	addi	s0,sp,16
    HAL_CRG_IpEnableSet(GPT0_BASE, IP_CLK_ENABLE);
 300cf24:	4585                	li	a1,1
 300cf26:	14700537          	lui	a0,0x14700
 300cf2a:	2a21                	jal	ra,300d042 <HAL_CRG_IpEnableSet.trans.20>

    g_gpt0.baseAddress = GPT0;
 300cf2c:	13018793          	addi	a5,gp,304 # 400082c <g_gpt0>
 300cf30:	14700737          	lui	a4,0x14700
 300cf34:	c398                	sw	a4,0(a5)
    g_gpt0.clockDiv = 500 - 1;  /* 1000 is the internal frequency division of GPT */
 300cf36:	13018793          	addi	a5,gp,304 # 400082c <g_gpt0>
 300cf3a:	1f300713          	li	a4,499
 300cf3e:	c798                	sw	a4,8(a5)
    g_gpt0.period = 1000;  /* 2996 is the number of GPT counting cycles. */
 300cf40:	13018793          	addi	a5,gp,304 # 400082c <g_gpt0>
 300cf44:	3e800713          	li	a4,1000
 300cf48:	cfd8                	sw	a4,28(a5)
    g_gpt0.refA0.refdot = 1;  /* 1 is the value of PWM reference point A. */
 300cf4a:	13018793          	addi	a5,gp,304 # 400082c <g_gpt0>
 300cf4e:	4705                	li	a4,1
 300cf50:	c7d8                	sw	a4,12(a5)
    g_gpt0.refA0.refAction = GPT_ACTION_OUTPUT_HIGH;  /* GPT Action High */
 300cf52:	13018793          	addi	a5,gp,304 # 400082c <g_gpt0>
 300cf56:	4709                	li	a4,2
 300cf58:	cb98                	sw	a4,16(a5)
    g_gpt0.refB0.refdot = 76;  /* 76 is the value of PWM reference point B. */
 300cf5a:	13018793          	addi	a5,gp,304 # 400082c <g_gpt0>
 300cf5e:	04c00713          	li	a4,76
 300cf62:	cbd8                	sw	a4,20(a5)
    g_gpt0.refB0.refAction = GPT_ACTION_OUTPUT_LOW; /* GPT Action Low */
 300cf64:	13018793          	addi	a5,gp,304 # 400082c <g_gpt0>
 300cf68:	4705                	li	a4,1
 300cf6a:	cf98                	sw	a4,24(a5)
    g_gpt0.bufLoad = BASE_CFG_ENABLE;
 300cf6c:	13018793          	addi	a5,gp,304 # 400082c <g_gpt0>
 300cf70:	4705                	li	a4,1
 300cf72:	02e782a3          	sb	a4,37(a5)
    g_gpt0.pwmKeep = BASE_CFG_ENABLE;
 300cf76:	13018793          	addi	a5,gp,304 # 400082c <g_gpt0>
 300cf7a:	4705                	li	a4,1
 300cf7c:	02e78223          	sb	a4,36(a5)
    g_gpt0.handleEx.periodIntEnable = BASE_CFG_DISABLE;
 300cf80:	13018793          	addi	a5,gp,304 # 400082c <g_gpt0>
 300cf84:	02078823          	sb	zero,48(a5)
    g_gpt0.handleEx.outputFinIntEnable = BASE_CFG_DISABLE;
 300cf88:	13018793          	addi	a5,gp,304 # 400082c <g_gpt0>
 300cf8c:	020788a3          	sb	zero,49(a5)
    g_gpt0.triggleAdcOutFinish = BASE_CFG_DISABLE;
 300cf90:	13018793          	addi	a5,gp,304 # 400082c <g_gpt0>
 300cf94:	020783a3          	sb	zero,39(a5)
    g_gpt0.triggleAdcPeriod = BASE_CFG_DISABLE;
 300cf98:	13018793          	addi	a5,gp,304 # 400082c <g_gpt0>
 300cf9c:	02078323          	sb	zero,38(a5)

    HAL_GPT_Init(&g_gpt0);
 300cfa0:	13018513          	addi	a0,gp,304 # 400082c <g_gpt0>
 300cfa4:	22e1                	jal	ra,300d16c <HAL_GPT_Init.trans.42>
}
 300cfa6:	0001                	nop
 300cfa8:	40b2                	lw	ra,12(sp)
 300cfaa:	4422                	lw	s0,8(sp)
 300cfac:	0141                	addi	sp,sp,16
 300cfae:	8082                	ret

0300cfb0 <GPT1_Init>:

static void GPT1_Init(void)
{
 300cfb0:	1141                	addi	sp,sp,-16
 300cfb2:	c606                	sw	ra,12(sp)
 300cfb4:	c422                	sw	s0,8(sp)
 300cfb6:	0800                	addi	s0,sp,16
    HAL_CRG_IpEnableSet(GPT1_BASE, IP_CLK_ENABLE);
 300cfb8:	4585                	li	a1,1
 300cfba:	14701537          	lui	a0,0x14701
 300cfbe:	2051                	jal	ra,300d042 <HAL_CRG_IpEnableSet.trans.20>

    g_gpt1.baseAddress = GPT1;
 300cfc0:	16418793          	addi	a5,gp,356 # 4000860 <g_gpt1>
 300cfc4:	14701737          	lui	a4,0x14701
 300cfc8:	c398                	sw	a4,0(a5)
    g_gpt1.clockDiv = 500 - 1;  /* 1000 is the internal frequency division of GPT */
 300cfca:	16418793          	addi	a5,gp,356 # 4000860 <g_gpt1>
 300cfce:	1f300713          	li	a4,499
 300cfd2:	c798                	sw	a4,8(a5)
    g_gpt1.period = 1000 - 1;  /* 49999 is the number of GPT counting cycles. */
 300cfd4:	16418793          	addi	a5,gp,356 # 4000860 <g_gpt1>
 300cfd8:	3e700713          	li	a4,999
 300cfdc:	cfd8                	sw	a4,28(a5)
    g_gpt1.refA0.refdot = 1;  /* 10000 is the value of PWM reference point A. */
 300cfde:	16418793          	addi	a5,gp,356 # 4000860 <g_gpt1>
 300cfe2:	4705                	li	a4,1
 300cfe4:	c7d8                	sw	a4,12(a5)
    g_gpt1.refA0.refAction = GPT_ACTION_OUTPUT_HIGH;  /* GPT Action High */
 300cfe6:	16418793          	addi	a5,gp,356 # 4000860 <g_gpt1>
 300cfea:	4709                	li	a4,2
 300cfec:	cb98                	sw	a4,16(a5)
    g_gpt1.refB0.refdot = 2;  /* 30000 is the value of PWM reference point B. */
 300cfee:	16418793          	addi	a5,gp,356 # 4000860 <g_gpt1>
 300cff2:	4709                	li	a4,2
 300cff4:	cbd8                	sw	a4,20(a5)
    g_gpt1.refB0.refAction = GPT_ACTION_OUTPUT_LOW; /* GPT Action Low */
 300cff6:	16418793          	addi	a5,gp,356 # 4000860 <g_gpt1>
 300cffa:	4705                	li	a4,1
 300cffc:	cf98                	sw	a4,24(a5)
    g_gpt1.bufLoad = BASE_CFG_ENABLE;
 300cffe:	16418793          	addi	a5,gp,356 # 4000860 <g_gpt1>
 300d002:	4705                	li	a4,1
 300d004:	02e782a3          	sb	a4,37(a5)
    g_gpt1.pwmKeep = BASE_CFG_ENABLE;
 300d008:	16418793          	addi	a5,gp,356 # 4000860 <g_gpt1>
 300d00c:	4705                	li	a4,1
 300d00e:	02e78223          	sb	a4,36(a5)
    g_gpt1.handleEx.periodIntEnable = BASE_CFG_DISABLE;
 300d012:	16418793          	addi	a5,gp,356 # 4000860 <g_gpt1>
 300d016:	02078823          	sb	zero,48(a5)
    g_gpt1.handleEx.outputFinIntEnable = BASE_CFG_DISABLE;
 300d01a:	16418793          	addi	a5,gp,356 # 4000860 <g_gpt1>
 300d01e:	020788a3          	sb	zero,49(a5)
    g_gpt1.triggleAdcOutFinish = BASE_CFG_DISABLE;
 300d022:	16418793          	addi	a5,gp,356 # 4000860 <g_gpt1>
 300d026:	020783a3          	sb	zero,39(a5)
    g_gpt1.triggleAdcPeriod = BASE_CFG_DISABLE;
 300d02a:	16418793          	addi	a5,gp,356 # 4000860 <g_gpt1>
 300d02e:	02078323          	sb	zero,38(a5)

    HAL_GPT_Init(&g_gpt1);
 300d032:	16418513          	addi	a0,gp,356 # 4000860 <g_gpt1>
 300d036:	2a1d                	jal	ra,300d16c <HAL_GPT_Init.trans.42>
}
 300d038:	0001                	nop
 300d03a:	40b2                	lw	ra,12(sp)
 300d03c:	4422                	lw	s0,8(sp)
 300d03e:	0141                	addi	sp,sp,16
 300d040:	8082                	ret

0300d042 <HAL_CRG_IpEnableSet.trans.20>:
 300d042:	fa1f706f          	j	3004fe2 <HAL_CRG_IpEnableSet>

0300d046 <GPT2_Init>:

static void GPT2_Init(void)
{
 300d046:	1141                	addi	sp,sp,-16
 300d048:	c606                	sw	ra,12(sp)
 300d04a:	c422                	sw	s0,8(sp)
 300d04c:	0800                	addi	s0,sp,16
    HAL_CRG_IpEnableSet(GPT2_BASE, IP_CLK_ENABLE);
 300d04e:	4585                	li	a1,1
 300d050:	14702537          	lui	a0,0x14702
 300d054:	37fd                	jal	ra,300d042 <HAL_CRG_IpEnableSet.trans.20>

    g_gpt2.baseAddress = GPT2;
 300d056:	19818793          	addi	a5,gp,408 # 4000894 <g_gpt2>
 300d05a:	14702737          	lui	a4,0x14702
 300d05e:	c398                	sw	a4,0(a5)
    g_gpt2.clockDiv = 500 - 1;  /* 1000 is the internal frequency division of GPT */
 300d060:	19818793          	addi	a5,gp,408 # 4000894 <g_gpt2>
 300d064:	1f300713          	li	a4,499
 300d068:	c798                	sw	a4,8(a5)
    g_gpt2.period = 1000 - 1;  /* 49999 is the number of GPT counting cycles. */
 300d06a:	19818793          	addi	a5,gp,408 # 4000894 <g_gpt2>
 300d06e:	3e700713          	li	a4,999
 300d072:	cfd8                	sw	a4,28(a5)
    g_gpt2.refA0.refdot = 1;  /* 10000 is the value of PWM reference point A. */
 300d074:	19818793          	addi	a5,gp,408 # 4000894 <g_gpt2>
 300d078:	4705                	li	a4,1
 300d07a:	c7d8                	sw	a4,12(a5)
    g_gpt2.refA0.refAction = GPT_ACTION_OUTPUT_HIGH;  /* GPT Action High */
 300d07c:	19818793          	addi	a5,gp,408 # 4000894 <g_gpt2>
 300d080:	4709                	li	a4,2
 300d082:	cb98                	sw	a4,16(a5)
    g_gpt2.refB0.refdot = 2;  /* 30000 is the value of PWM reference point B. */
 300d084:	19818793          	addi	a5,gp,408 # 4000894 <g_gpt2>
 300d088:	4709                	li	a4,2
 300d08a:	cbd8                	sw	a4,20(a5)
    g_gpt2.refB0.refAction = GPT_ACTION_OUTPUT_LOW; /* GPT Action Low */
 300d08c:	19818793          	addi	a5,gp,408 # 4000894 <g_gpt2>
 300d090:	4705                	li	a4,1
 300d092:	cf98                	sw	a4,24(a5)
    g_gpt2.bufLoad = BASE_CFG_ENABLE;
 300d094:	19818793          	addi	a5,gp,408 # 4000894 <g_gpt2>
 300d098:	4705                	li	a4,1
 300d09a:	02e782a3          	sb	a4,37(a5)
    g_gpt2.pwmKeep = BASE_CFG_ENABLE;
 300d09e:	19818793          	addi	a5,gp,408 # 4000894 <g_gpt2>
 300d0a2:	4705                	li	a4,1
 300d0a4:	02e78223          	sb	a4,36(a5)
    g_gpt2.handleEx.periodIntEnable = BASE_CFG_DISABLE;
 300d0a8:	19818793          	addi	a5,gp,408 # 4000894 <g_gpt2>
 300d0ac:	02078823          	sb	zero,48(a5)
    g_gpt2.handleEx.outputFinIntEnable = BASE_CFG_DISABLE;
 300d0b0:	19818793          	addi	a5,gp,408 # 4000894 <g_gpt2>
 300d0b4:	020788a3          	sb	zero,49(a5)
    g_gpt2.triggleAdcOutFinish = BASE_CFG_DISABLE;
 300d0b8:	19818793          	addi	a5,gp,408 # 4000894 <g_gpt2>
 300d0bc:	020783a3          	sb	zero,39(a5)
    g_gpt2.triggleAdcPeriod = BASE_CFG_DISABLE;
 300d0c0:	19818793          	addi	a5,gp,408 # 4000894 <g_gpt2>
 300d0c4:	02078323          	sb	zero,38(a5)

    HAL_GPT_Init(&g_gpt2);
 300d0c8:	19818513          	addi	a0,gp,408 # 4000894 <g_gpt2>
 300d0cc:	2045                	jal	ra,300d16c <HAL_GPT_Init.trans.42>
}
 300d0ce:	0001                	nop
 300d0d0:	40b2                	lw	ra,12(sp)
 300d0d2:	4422                	lw	s0,8(sp)
 300d0d4:	0141                	addi	sp,sp,16
 300d0d6:	8082                	ret

0300d0d8 <GPT3_Init>:

static void GPT3_Init(void)
{
 300d0d8:	1141                	addi	sp,sp,-16
 300d0da:	c606                	sw	ra,12(sp)
 300d0dc:	c422                	sw	s0,8(sp)
 300d0de:	0800                	addi	s0,sp,16
    HAL_CRG_IpEnableSet(GPT3_BASE, IP_CLK_ENABLE);
 300d0e0:	4585                	li	a1,1
 300d0e2:	14703537          	lui	a0,0x14703
 300d0e6:	3fb1                	jal	ra,300d042 <HAL_CRG_IpEnableSet.trans.20>

    g_gpt3.baseAddress = GPT3;
 300d0e8:	1cc18793          	addi	a5,gp,460 # 40008c8 <g_gpt3>
 300d0ec:	14703737          	lui	a4,0x14703
 300d0f0:	c398                	sw	a4,0(a5)
    g_gpt3.clockDiv = 500 - 1;  /* 1000 is the internal frequency division of GPT */
 300d0f2:	1cc18793          	addi	a5,gp,460 # 40008c8 <g_gpt3>
 300d0f6:	1f300713          	li	a4,499
 300d0fa:	c798                	sw	a4,8(a5)
    g_gpt3.period = 1000 - 1;  /* 300 is the number of GPT counting cycles. */
 300d0fc:	1cc18793          	addi	a5,gp,460 # 40008c8 <g_gpt3>
 300d100:	3e700713          	li	a4,999
 300d104:	cfd8                	sw	a4,28(a5)
    g_gpt3.refA0.refdot = 1;  /* 100 is the value of PWM reference point A. */
 300d106:	1cc18793          	addi	a5,gp,460 # 40008c8 <g_gpt3>
 300d10a:	4705                	li	a4,1
 300d10c:	c7d8                	sw	a4,12(a5)
    g_gpt3.refA0.refAction = GPT_ACTION_OUTPUT_HIGH;  /* GPT Action High */
 300d10e:	1cc18793          	addi	a5,gp,460 # 40008c8 <g_gpt3>
 300d112:	4709                	li	a4,2
 300d114:	cb98                	sw	a4,16(a5)
    g_gpt3.refB0.refdot = 200;  /* 200 is the value of PWM reference point B. */
 300d116:	1cc18793          	addi	a5,gp,460 # 40008c8 <g_gpt3>
 300d11a:	0c800713          	li	a4,200
 300d11e:	cbd8                	sw	a4,20(a5)
    g_gpt3.refB0.refAction = GPT_ACTION_OUTPUT_LOW; /* GPT Action Low */
 300d120:	1cc18793          	addi	a5,gp,460 # 40008c8 <g_gpt3>
 300d124:	4705                	li	a4,1
 300d126:	cf98                	sw	a4,24(a5)
    g_gpt3.bufLoad = BASE_CFG_ENABLE;
 300d128:	1cc18793          	addi	a5,gp,460 # 40008c8 <g_gpt3>
 300d12c:	4705                	li	a4,1
 300d12e:	02e782a3          	sb	a4,37(a5)
    g_gpt3.pwmKeep = BASE_CFG_ENABLE;
 300d132:	1cc18793          	addi	a5,gp,460 # 40008c8 <g_gpt3>
 300d136:	4705                	li	a4,1
 300d138:	02e78223          	sb	a4,36(a5)
    g_gpt3.handleEx.periodIntEnable = BASE_CFG_DISABLE;
 300d13c:	1cc18793          	addi	a5,gp,460 # 40008c8 <g_gpt3>
 300d140:	02078823          	sb	zero,48(a5)
    g_gpt3.handleEx.outputFinIntEnable = BASE_CFG_DISABLE;
 300d144:	1cc18793          	addi	a5,gp,460 # 40008c8 <g_gpt3>
 300d148:	020788a3          	sb	zero,49(a5)
    g_gpt3.triggleAdcOutFinish = BASE_CFG_DISABLE;
 300d14c:	1cc18793          	addi	a5,gp,460 # 40008c8 <g_gpt3>
 300d150:	020783a3          	sb	zero,39(a5)
    g_gpt3.triggleAdcPeriod = BASE_CFG_DISABLE;
 300d154:	1cc18793          	addi	a5,gp,460 # 40008c8 <g_gpt3>
 300d158:	02078323          	sb	zero,38(a5)

    HAL_GPT_Init(&g_gpt3);
 300d15c:	1cc18513          	addi	a0,gp,460 # 40008c8 <g_gpt3>
 300d160:	2031                	jal	ra,300d16c <HAL_GPT_Init.trans.42>
}
 300d162:	0001                	nop
 300d164:	40b2                	lw	ra,12(sp)
 300d166:	4422                	lw	s0,8(sp)
 300d168:	0141                	addi	sp,sp,16
 300d16a:	8082                	ret

0300d16c <HAL_GPT_Init.trans.42>:
 300d16c:	911fa06f          	j	3007a7c <HAL_GPT_Init>

0300d170 <I2C0_Init>:

static void I2C0_Init(void)
{
 300d170:	1141                	addi	sp,sp,-16
 300d172:	c606                	sw	ra,12(sp)
 300d174:	c422                	sw	s0,8(sp)
 300d176:	0800                	addi	s0,sp,16
    HAL_CRG_IpEnableSet(I2C0_BASE, IP_CLK_ENABLE);
 300d178:	4585                	li	a1,1
 300d17a:	14100537          	lui	a0,0x14100
 300d17e:	35d1                	jal	ra,300d042 <HAL_CRG_IpEnableSet.trans.20>
    HAL_CRG_IpClkSelectSet(I2C0_BASE, CRG_AHB_CLK_NO_PREDV);
 300d180:	4581                	li	a1,0
 300d182:	14100537          	lui	a0,0x14100
 300d186:	29e1                	jal	ra,300d65e <HAL_CRG_IpClkSelectSet.trans.27>

    g_i2c0.baseAddress = I2C0;
 300d188:	3a818793          	addi	a5,gp,936 # 4000aa4 <g_i2c0>
 300d18c:	14100737          	lui	a4,0x14100
 300d190:	c398                	sw	a4,0(a5)

    g_i2c0.functionMode = I2C_MODE_SELECT_MASTER_ONLY;
 300d192:	3a818793          	addi	a5,gp,936 # 4000aa4 <g_i2c0>
 300d196:	4705                	li	a4,1
 300d198:	c3d8                	sw	a4,4(a5)
    g_i2c0.addrMode = I2C_7_BITS;
 300d19a:	3a818793          	addi	a5,gp,936 # 4000aa4 <g_i2c0>
 300d19e:	0007a423          	sw	zero,8(a5)
    g_i2c0.sdaHoldTime = 10;
 300d1a2:	3a818793          	addi	a5,gp,936 # 4000aa4 <g_i2c0>
 300d1a6:	4729                	li	a4,10
 300d1a8:	cb98                	sw	a4,16(a5)
    g_i2c0.freq = 400000;
 300d1aa:	3a818793          	addi	a5,gp,936 # 4000aa4 <g_i2c0>
 300d1ae:	00062737          	lui	a4,0x62
 300d1b2:	a8070713          	addi	a4,a4,-1408 # 61a80 <FLASH_SIZE+0x41a84>
 300d1b6:	cbd8                	sw	a4,20(a5)
    g_i2c0.transferBuff = NULL;
 300d1b8:	3a818793          	addi	a5,gp,936 # 4000aa4 <g_i2c0>
 300d1bc:	0207a023          	sw	zero,32(a5)
    g_i2c0.ignoreAckFlag = BASE_CFG_DISABLE;
 300d1c0:	3a818793          	addi	a5,gp,936 # 4000aa4 <g_i2c0>
 300d1c4:	0007ac23          	sw	zero,24(a5)
    g_i2c0.handleEx.spikeFilterTime = 0;
 300d1c8:	3a818793          	addi	a5,gp,936 # 4000aa4 <g_i2c0>
 300d1cc:	0407ac23          	sw	zero,88(a5)
    g_i2c0.handleEx.sdaDelayTime = 0;
 300d1d0:	3a818793          	addi	a5,gp,936 # 4000aa4 <g_i2c0>
 300d1d4:	0407ae23          	sw	zero,92(a5)
    g_i2c0.timeout = 10000;
 300d1d8:	3a818793          	addi	a5,gp,936 # 4000aa4 <g_i2c0>
 300d1dc:	6709                	lui	a4,0x2
 300d1de:	71070713          	addi	a4,a4,1808 # 2710 <__bss_size__+0x1a9c>
 300d1e2:	d7d8                	sw	a4,44(a5)
    g_i2c0.state = I2C_STATE_RESET;
 300d1e4:	3a818793          	addi	a5,gp,936 # 4000aa4 <g_i2c0>
 300d1e8:	0407a223          	sw	zero,68(a5)
    HAL_I2C_Init(&g_i2c0);
 300d1ec:	3a818513          	addi	a0,gp,936 # 4000aa4 <g_i2c0>
 300d1f0:	b02fb0ef          	jal	ra,30084f2 <HAL_I2C_Init>
}
 300d1f4:	0001                	nop
 300d1f6:	40b2                	lw	ra,12(sp)
 300d1f8:	4422                	lw	s0,8(sp)
 300d1fa:	0141                	addi	sp,sp,16
 300d1fc:	8082                	ret

0300d1fe <I2C1_Init>:

static void I2C1_Init(void)
{
 300d1fe:	1141                	addi	sp,sp,-16
 300d200:	c606                	sw	ra,12(sp)
 300d202:	c422                	sw	s0,8(sp)
 300d204:	0800                	addi	s0,sp,16
    HAL_CRG_IpEnableSet(I2C1_BASE, IP_CLK_ENABLE);
 300d206:	4585                	li	a1,1
 300d208:	14101537          	lui	a0,0x14101
 300d20c:	3d1d                	jal	ra,300d042 <HAL_CRG_IpEnableSet.trans.20>
    HAL_CRG_IpClkSelectSet(I2C1_BASE, CRG_AHB_CLK_NO_PREDV);
 300d20e:	4581                	li	a1,0
 300d210:	14101537          	lui	a0,0x14101
 300d214:	21a9                	jal	ra,300d65e <HAL_CRG_IpClkSelectSet.trans.27>

    g_i2c1.baseAddress = I2C1;
 300d216:	41018793          	addi	a5,gp,1040 # 4000b0c <g_i2c1>
 300d21a:	14101737          	lui	a4,0x14101
 300d21e:	c398                	sw	a4,0(a5)

    g_i2c1.functionMode = I2C_MODE_SELECT_MASTER_ONLY;
 300d220:	41018793          	addi	a5,gp,1040 # 4000b0c <g_i2c1>
 300d224:	4705                	li	a4,1
 300d226:	c3d8                	sw	a4,4(a5)
    g_i2c1.addrMode = I2C_7_BITS;
 300d228:	41018793          	addi	a5,gp,1040 # 4000b0c <g_i2c1>
 300d22c:	0007a423          	sw	zero,8(a5)
    g_i2c1.sdaHoldTime = 10;
 300d230:	41018793          	addi	a5,gp,1040 # 4000b0c <g_i2c1>
 300d234:	4729                	li	a4,10
 300d236:	cb98                	sw	a4,16(a5)
    g_i2c1.freq = 200000;
 300d238:	41018793          	addi	a5,gp,1040 # 4000b0c <g_i2c1>
 300d23c:	00031737          	lui	a4,0x31
 300d240:	d4070713          	addi	a4,a4,-704 # 30d40 <FLASH_SIZE+0x10d44>
 300d244:	cbd8                	sw	a4,20(a5)
    g_i2c1.transferBuff = NULL;
 300d246:	41018793          	addi	a5,gp,1040 # 4000b0c <g_i2c1>
 300d24a:	0207a023          	sw	zero,32(a5)
    g_i2c1.ignoreAckFlag = BASE_CFG_DISABLE;
 300d24e:	41018793          	addi	a5,gp,1040 # 4000b0c <g_i2c1>
 300d252:	0007ac23          	sw	zero,24(a5)
    g_i2c1.handleEx.spikeFilterTime = 0;
 300d256:	41018793          	addi	a5,gp,1040 # 4000b0c <g_i2c1>
 300d25a:	0407ac23          	sw	zero,88(a5)
    g_i2c1.handleEx.sdaDelayTime = 0;
 300d25e:	41018793          	addi	a5,gp,1040 # 4000b0c <g_i2c1>
 300d262:	0407ae23          	sw	zero,92(a5)
    g_i2c1.timeout = 10000;
 300d266:	41018793          	addi	a5,gp,1040 # 4000b0c <g_i2c1>
 300d26a:	6709                	lui	a4,0x2
 300d26c:	71070713          	addi	a4,a4,1808 # 2710 <__bss_size__+0x1a9c>
 300d270:	d7d8                	sw	a4,44(a5)
    g_i2c1.state = I2C_STATE_RESET;
 300d272:	41018793          	addi	a5,gp,1040 # 4000b0c <g_i2c1>
 300d276:	0407a223          	sw	zero,68(a5)
    HAL_I2C_Init(&g_i2c1);
 300d27a:	41018513          	addi	a0,gp,1040 # 4000b0c <g_i2c1>
 300d27e:	a74fb0ef          	jal	ra,30084f2 <HAL_I2C_Init>
}
 300d282:	0001                	nop
 300d284:	40b2                	lw	ra,12(sp)
 300d286:	4422                	lw	s0,8(sp)
 300d288:	0141                	addi	sp,sp,16
 300d28a:	8082                	ret

0300d28c <QDM0PTUCycleCallback>:

__weak void QDM0PTUCycleCallback(void *handle)
{
 300d28c:	1101                	addi	sp,sp,-32
 300d28e:	ce22                	sw	s0,28(sp)
 300d290:	1000                	addi	s0,sp,32
 300d292:	fea42623          	sw	a0,-20(s0)
    BASE_FUNC_UNUSED(handle);
    /* USER CODE BEGIN QDM0_TSU_CYCLE */
    /* USER CODE END QDM0_TSU_CYCLE */
}
 300d296:	0001                	nop
 300d298:	4472                	lw	s0,28(sp)
 300d29a:	6105                	addi	sp,sp,32
 300d29c:	8082                	ret

0300d29e <QDM0ZIndexLockedCallback>:

__weak void QDM0ZIndexLockedCallback(void *handle)
{
 300d29e:	1101                	addi	sp,sp,-32
 300d2a0:	ce22                	sw	s0,28(sp)
 300d2a2:	1000                	addi	s0,sp,32
 300d2a4:	fea42623          	sw	a0,-20(s0)
    BASE_FUNC_UNUSED(handle);
    /* USER CODE BEGIN QDM0_INDEX_LOCKED */
    /* USER CODE END QDM0_INDEX_LOCKED */
}
 300d2a8:	0001                	nop
 300d2aa:	4472                	lw	s0,28(sp)
 300d2ac:	6105                	addi	sp,sp,32
 300d2ae:	8082                	ret

0300d2b0 <QDM0QuadraturePhaseErrorCallback>:

__weak void QDM0QuadraturePhaseErrorCallback(void *handle)
{
 300d2b0:	1101                	addi	sp,sp,-32
 300d2b2:	ce22                	sw	s0,28(sp)
 300d2b4:	1000                	addi	s0,sp,32
 300d2b6:	fea42623          	sw	a0,-20(s0)
    BASE_FUNC_UNUSED(handle);
    /* USER CODE QDM0_PHASE_ERROR */
    /* USER CODE QDM0_PHASE_ERROR */
}
 300d2ba:	0001                	nop
 300d2bc:	4472                	lw	s0,28(sp)
 300d2be:	6105                	addi	sp,sp,32
 300d2c0:	8082                	ret

0300d2c2 <QDM0_Init>:

static void QDM0_Init(void)
{
 300d2c2:	1141                	addi	sp,sp,-16
 300d2c4:	c606                	sw	ra,12(sp)
 300d2c6:	c422                	sw	s0,8(sp)
 300d2c8:	0800                	addi	s0,sp,16
    HAL_CRG_IpEnableSet(QDM0_BASE, IP_CLK_ENABLE);
 300d2ca:	4585                	li	a1,1
 300d2cc:	14c00537          	lui	a0,0x14c00
 300d2d0:	3b8d                	jal	ra,300d042 <HAL_CRG_IpEnableSet.trans.20>

    g_qdm0.baseAddress = QDM0_BASE;
 300d2d2:	01818793          	addi	a5,gp,24 # 4000714 <g_qdm0>
 300d2d6:	14c00737          	lui	a4,0x14c00
 300d2da:	c398                	sw	a4,0(a5)

    /* emulation config */
    g_qdm0.emuMode = QDM_EMULATION_MODE_STOP_IMMEDIATELY;
 300d2dc:	01818793          	addi	a5,gp,24 # 4000714 <g_qdm0>
 300d2e0:	0007a223          	sw	zero,4(a5)
    /* input config */
    g_qdm0.ctrlConfig.decoderMode = QDM_QUADRATURE_COUNT;
 300d2e4:	01818793          	addi	a5,gp,24 # 4000714 <g_qdm0>
 300d2e8:	0007aa23          	sw	zero,20(a5)
    g_qdm0.ctrlConfig.polarity = 0;
 300d2ec:	01818793          	addi	a5,gp,24 # 4000714 <g_qdm0>
 300d2f0:	0207a423          	sw	zero,40(a5)
    g_qdm0.ctrlConfig.resolution = QDM_1X_RESOLUTION;
 300d2f4:	01818793          	addi	a5,gp,24 # 4000714 <g_qdm0>
 300d2f8:	0007ac23          	sw	zero,24(a5)
    g_qdm0.ctrlConfig.trgLockMode = QDM_TRG_BY_CYCLE;
 300d2fc:	01818793          	addi	a5,gp,24 # 4000714 <g_qdm0>
 300d300:	4705                	li	a4,1
 300d302:	cfd8                	sw	a4,28(a5)
    g_qdm0.ctrlConfig.swap = QDM_SWAP_DISABLE;
 300d304:	01818793          	addi	a5,gp,24 # 4000714 <g_qdm0>
 300d308:	0207a223          	sw	zero,36(a5)
    g_qdm0.ctrlConfig.ptuMode = QDM_PTU_MODE_CYCLE;
 300d30c:	01818793          	addi	a5,gp,24 # 4000714 <g_qdm0>
 300d310:	0207a023          	sw	zero,32(a5)
    /* filter config */
    g_qdm0.inputFilter.qdmAFilterLevel = 0;
 300d314:	01818793          	addi	a5,gp,24 # 4000714 <g_qdm0>
 300d318:	0007a423          	sw	zero,8(a5)
    g_qdm0.inputFilter.qdmBFilterLevel = 0;
 300d31c:	01818793          	addi	a5,gp,24 # 4000714 <g_qdm0>
 300d320:	0007a623          	sw	zero,12(a5)
    g_qdm0.inputFilter.qdmZFilterLevel = 0;
 300d324:	01818793          	addi	a5,gp,24 # 4000714 <g_qdm0>
 300d328:	0007a823          	sw	zero,16(a5)
    /* other config */
    g_qdm0.lock_mode = QDM_LOCK_RESERVE;
 300d32c:	01818793          	addi	a5,gp,24 # 4000714 <g_qdm0>
 300d330:	0607a023          	sw	zero,96(a5)
    g_qdm0.pcntMode = QDM_PCNT_MODE_BY_DIR;
 300d334:	01818793          	addi	a5,gp,24 # 4000714 <g_qdm0>
 300d338:	0207a623          	sw	zero,44(a5)
    //g_qdm0.pcntRstMode = QDM_PCNT_RST_BY_PTU;
    g_qdm0.pcntRstMode = QDM_PCNT_RST_OVF; // 单独调试脉冲数
 300d33c:	01818793          	addi	a5,gp,24 # 4000714 <g_qdm0>
 300d340:	4705                	li	a4,1
 300d342:	db98                	sw	a4,48(a5)
    g_qdm0.pcntIdxInitMode = QDM_IDX_INIT_DISABLE;
 300d344:	01818793          	addi	a5,gp,24 # 4000714 <g_qdm0>
 300d348:	0207aa23          	sw	zero,52(a5)
    g_qdm0.qcMax = 4294967295;
 300d34c:	01818793          	addi	a5,gp,24 # 4000714 <g_qdm0>
 300d350:	577d                	li	a4,-1
 300d352:	c7f8                	sw	a4,76(a5)
    g_qdm0.subModeEn = true;
 300d354:	01818793          	addi	a5,gp,24 # 4000714 <g_qdm0>
 300d358:	4705                	li	a4,1
 300d35a:	02e78c23          	sb	a4,56(a5)
    g_qdm0.tsuPrescaler = 0;
 300d35e:	01818793          	addi	a5,gp,24 # 4000714 <g_qdm0>
 300d362:	0207ae23          	sw	zero,60(a5)
    g_qdm0.cevtPrescaler = QDM_CEVT_PRESCALER_DIVI1;
 300d366:	01818793          	addi	a5,gp,24 # 4000714 <g_qdm0>
 300d36a:	0407a023          	sw	zero,64(a5)
    //g_qdm0.posMax = 4294967295;
    g_qdm0.posMax = g_motorLineNum;    
 300d36e:	a701a703          	lw	a4,-1424(gp) # 400016c <g_motorLineNum>
 300d372:	01818793          	addi	a5,gp,24 # 4000714 <g_qdm0>
 300d376:	c7b8                	sw	a4,72(a5)
    g_qdm0.posInit = 0;
 300d378:	01818793          	addi	a5,gp,24 # 4000714 <g_qdm0>
 300d37c:	0407a223          	sw	zero,68(a5)
    g_qdm0.period = 150000000;
 300d380:	01818793          	addi	a5,gp,24 # 4000714 <g_qdm0>
 300d384:	08f0d737          	lui	a4,0x8f0d
 300d388:	18070713          	addi	a4,a4,384 # 8f0d180 <RAM_END+0x4f05180>
 300d38c:	cbb8                	sw	a4,80(a5)

    g_qdm0.motorLineNum = g_motorLineNum;  /* 设置编码器线数 */      
 300d38e:	a701a783          	lw	a5,-1424(gp) # 400016c <g_motorLineNum>
 300d392:	873e                	mv	a4,a5
 300d394:	01818793          	addi	a5,gp,24 # 4000714 <g_qdm0>
 300d398:	cfb8                	sw	a4,88(a5)
    //DBG_PRINTF("g_qdm0.motorLineNum:%d\r\n", g_qdm0.motorLineNum);
    g_qdm0.interruptEn = QDM_INT_WATCHDOG | 
 300d39a:	01818793          	addi	a5,gp,24 # 4000714 <g_qdm0>
 300d39e:	30400713          	li	a4,772
 300d3a2:	cbf8                	sw	a4,84(a5)
        QDM_INT_INDEX_EVNT_LATCH | 
        QDM_INT_UNIT_TIME_OUT;

    HAL_QDM_Init(&g_qdm0);
 300d3a4:	01818513          	addi	a0,gp,24 # 4000714 <g_qdm0>
 300d3a8:	fbafc0ef          	jal	ra,3009b62 <HAL_QDM_Init>

    HAL_QDM_RegisterCallback(&g_qdm0, QDM_TSU_CYCLE, QDM0PTUCycleCallback);
 300d3ac:	0300d7b7          	lui	a5,0x300d
 300d3b0:	28c78613          	addi	a2,a5,652 # 300d28c <QDM0PTUCycleCallback>
 300d3b4:	4581                	li	a1,0
 300d3b6:	01818513          	addi	a0,gp,24 # 4000714 <g_qdm0>
 300d3ba:	22e9                	jal	ra,300d584 <HAL_QDM_RegisterCallback.trans.34>
    HAL_QDM_RegisterCallback(&g_qdm0, QDM_INDEX_LOCKED, QDM0ZIndexLockedCallback);
 300d3bc:	0300d7b7          	lui	a5,0x300d
 300d3c0:	29e78613          	addi	a2,a5,670 # 300d29e <QDM0ZIndexLockedCallback>
 300d3c4:	4589                	li	a1,2
 300d3c6:	01818513          	addi	a0,gp,24 # 4000714 <g_qdm0>
 300d3ca:	2a6d                	jal	ra,300d584 <HAL_QDM_RegisterCallback.trans.34>
    HAL_QDM_RegisterCallback(&g_qdm0, QDM_PHASE_ERROR, QDM0QuadraturePhaseErrorCallback);
 300d3cc:	0300d7b7          	lui	a5,0x300d
 300d3d0:	2b078613          	addi	a2,a5,688 # 300d2b0 <QDM0QuadraturePhaseErrorCallback>
 300d3d4:	4591                	li	a1,4
 300d3d6:	01818513          	addi	a0,gp,24 # 4000714 <g_qdm0>
 300d3da:	226d                	jal	ra,300d584 <HAL_QDM_RegisterCallback.trans.34>
    IRQ_Register(IRQ_QDM0, HAL_QDM_IrqHandler, &g_qdm0);
 300d3dc:	01818613          	addi	a2,gp,24 # 4000714 <g_qdm0>
 300d3e0:	0300a7b7          	lui	a5,0x300a
 300d3e4:	8d278593          	addi	a1,a5,-1838 # 30098d2 <HAL_QDM_IrqHandler>
 300d3e8:	04900513          	li	a0,73
 300d3ec:	506000ef          	jal	ra,300d8f2 <IRQ_Register.trans.28>
    IRQ_SetPriority(IRQ_QDM0, 1);
 300d3f0:	4585                	li	a1,1
 300d3f2:	04900513          	li	a0,73
 300d3f6:	4f8000ef          	jal	ra,300d8ee <IRQ_SetPriority.trans.29>
    IRQ_EnableN(IRQ_QDM0);
 300d3fa:	04900513          	li	a0,73
 300d3fe:	21f5                	jal	ra,300d8ea <IRQ_EnableN.trans.30>
}
 300d400:	0001                	nop
 300d402:	40b2                	lw	ra,12(sp)
 300d404:	4422                	lw	s0,8(sp)
 300d406:	0141                	addi	sp,sp,16
 300d408:	8082                	ret

0300d40a <QDM1PTUCycleCallback>:

__weak void QDM1PTUCycleCallback(void *handle)
{
 300d40a:	1101                	addi	sp,sp,-32
 300d40c:	ce22                	sw	s0,28(sp)
 300d40e:	1000                	addi	s0,sp,32
 300d410:	fea42623          	sw	a0,-20(s0)
    BASE_FUNC_UNUSED(handle);
    /* USER CODE BEGIN QDM1_TSU_CYCLE */
    /* USER CODE END QDM1_TSU_CYCLE */
}
 300d414:	0001                	nop
 300d416:	4472                	lw	s0,28(sp)
 300d418:	6105                	addi	sp,sp,32
 300d41a:	8082                	ret

0300d41c <QDM1ZIndexLockedCallback>:

__weak void QDM1ZIndexLockedCallback(void *handle)
{
 300d41c:	1101                	addi	sp,sp,-32
 300d41e:	ce22                	sw	s0,28(sp)
 300d420:	1000                	addi	s0,sp,32
 300d422:	fea42623          	sw	a0,-20(s0)
    BASE_FUNC_UNUSED(handle);
    /* USER CODE BEGIN QDM1_INDEX_LOCKED */
    /* USER CODE END QDM1_INDEX_LOCKED */
}
 300d426:	0001                	nop
 300d428:	4472                	lw	s0,28(sp)
 300d42a:	6105                	addi	sp,sp,32
 300d42c:	8082                	ret

0300d42e <QDM1QuadraturePhaseErrorCallback>:

__weak void QDM1QuadraturePhaseErrorCallback(void *handle)
{
 300d42e:	1101                	addi	sp,sp,-32
 300d430:	ce22                	sw	s0,28(sp)
 300d432:	1000                	addi	s0,sp,32
 300d434:	fea42623          	sw	a0,-20(s0)
    BASE_FUNC_UNUSED(handle);
    /* USER CODE QDM1_PHASE_ERROR */
    /* USER CODE QDM1_PHASE_ERROR */
}
 300d438:	0001                	nop
 300d43a:	4472                	lw	s0,28(sp)
 300d43c:	6105                	addi	sp,sp,32
 300d43e:	8082                	ret

0300d440 <QDM1_Init>:

static void QDM1_Init(void)
{
 300d440:	1141                	addi	sp,sp,-16
 300d442:	c606                	sw	ra,12(sp)
 300d444:	c422                	sw	s0,8(sp)
 300d446:	0800                	addi	s0,sp,16
    HAL_CRG_IpEnableSet(QDM1_BASE, IP_CLK_ENABLE);
 300d448:	4585                	li	a1,1
 300d44a:	14c01537          	lui	a0,0x14c01
 300d44e:	3ed5                	jal	ra,300d042 <HAL_CRG_IpEnableSet.trans.20>

    g_qdm1.baseAddress = QDM1_BASE;
 300d450:	0a418793          	addi	a5,gp,164 # 40007a0 <g_qdm1>
 300d454:	14c01737          	lui	a4,0x14c01
 300d458:	c398                	sw	a4,0(a5)

    /* emulation config */
    g_qdm1.emuMode = QDM_EMULATION_MODE_STOP_IMMEDIATELY;
 300d45a:	0a418793          	addi	a5,gp,164 # 40007a0 <g_qdm1>
 300d45e:	0007a223          	sw	zero,4(a5)
    /* input config */
    g_qdm1.ctrlConfig.decoderMode = QDM_QUADRATURE_COUNT;
 300d462:	0a418793          	addi	a5,gp,164 # 40007a0 <g_qdm1>
 300d466:	0007aa23          	sw	zero,20(a5)
    g_qdm1.ctrlConfig.polarity = 0;
 300d46a:	0a418793          	addi	a5,gp,164 # 40007a0 <g_qdm1>
 300d46e:	0207a423          	sw	zero,40(a5)
    g_qdm1.ctrlConfig.resolution = QDM_1X_RESOLUTION; /* 1倍频：只统计A相上升沿，4倍频：统计A、B两项上升沿和下降沿 */
 300d472:	0a418793          	addi	a5,gp,164 # 40007a0 <g_qdm1>
 300d476:	0007ac23          	sw	zero,24(a5)
    g_qdm1.ctrlConfig.trgLockMode = QDM_TRG_BY_CYCLE;
 300d47a:	0a418793          	addi	a5,gp,164 # 40007a0 <g_qdm1>
 300d47e:	4705                	li	a4,1
 300d480:	cfd8                	sw	a4,28(a5)
    g_qdm1.ctrlConfig.swap = QDM_SWAP_DISABLE;
 300d482:	0a418793          	addi	a5,gp,164 # 40007a0 <g_qdm1>
 300d486:	0207a223          	sw	zero,36(a5)
    g_qdm1.ctrlConfig.ptuMode = QDM_PTU_MODE_CYCLE;
 300d48a:	0a418793          	addi	a5,gp,164 # 40007a0 <g_qdm1>
 300d48e:	0207a023          	sw	zero,32(a5)
    /* filter config */
    g_qdm1.inputFilter.qdmAFilterLevel = 0;
 300d492:	0a418793          	addi	a5,gp,164 # 40007a0 <g_qdm1>
 300d496:	0007a423          	sw	zero,8(a5)
    g_qdm1.inputFilter.qdmBFilterLevel = 0;
 300d49a:	0a418793          	addi	a5,gp,164 # 40007a0 <g_qdm1>
 300d49e:	0007a623          	sw	zero,12(a5)
    g_qdm1.inputFilter.qdmZFilterLevel = 0;
 300d4a2:	0a418793          	addi	a5,gp,164 # 40007a0 <g_qdm1>
 300d4a6:	0007a823          	sw	zero,16(a5)
    /* other config */
    g_qdm1.lock_mode = QDM_LOCK_RESERVE;
 300d4aa:	0a418793          	addi	a5,gp,164 # 40007a0 <g_qdm1>
 300d4ae:	0607a023          	sw	zero,96(a5)
    g_qdm1.pcntMode = QDM_PCNT_MODE_BY_DIR;
 300d4b2:	0a418793          	addi	a5,gp,164 # 40007a0 <g_qdm1>
 300d4b6:	0207a623          	sw	zero,44(a5)
    //g_qdm1.pcntRstMode = QDM_PCNT_RST_BY_PTU;
    g_qdm1.pcntRstMode = QDM_PCNT_RST_OVF;
 300d4ba:	0a418793          	addi	a5,gp,164 # 40007a0 <g_qdm1>
 300d4be:	4705                	li	a4,1
 300d4c0:	db98                	sw	a4,48(a5)
    g_qdm1.pcntIdxInitMode = QDM_IDX_INIT_DISABLE;
 300d4c2:	0a418793          	addi	a5,gp,164 # 40007a0 <g_qdm1>
 300d4c6:	0207aa23          	sw	zero,52(a5)
    g_qdm1.qcMax = 4294967295;
 300d4ca:	0a418793          	addi	a5,gp,164 # 40007a0 <g_qdm1>
 300d4ce:	577d                	li	a4,-1
 300d4d0:	c7f8                	sw	a4,76(a5)
    g_qdm1.subModeEn = true;
 300d4d2:	0a418793          	addi	a5,gp,164 # 40007a0 <g_qdm1>
 300d4d6:	4705                	li	a4,1
 300d4d8:	02e78c23          	sb	a4,56(a5)
    g_qdm1.tsuPrescaler = 0U;
 300d4dc:	0a418793          	addi	a5,gp,164 # 40007a0 <g_qdm1>
 300d4e0:	0207ae23          	sw	zero,60(a5)
    g_qdm1.cevtPrescaler = QDM_CEVT_PRESCALER_DIVI1;
 300d4e4:	0a418793          	addi	a5,gp,164 # 40007a0 <g_qdm1>
 300d4e8:	0407a023          	sw	zero,64(a5)
    //g_qdm1.posMax = 4294967295;
    g_qdm1.posMax = g_motorLineNum;
 300d4ec:	a701a703          	lw	a4,-1424(gp) # 400016c <g_motorLineNum>
 300d4f0:	0a418793          	addi	a5,gp,164 # 40007a0 <g_qdm1>
 300d4f4:	c7b8                	sw	a4,72(a5)
    g_qdm1.posInit = 0;
 300d4f6:	0a418793          	addi	a5,gp,164 # 40007a0 <g_qdm1>
 300d4fa:	0407a223          	sw	zero,68(a5)
    g_qdm1.period = 150000000;
 300d4fe:	0a418793          	addi	a5,gp,164 # 40007a0 <g_qdm1>
 300d502:	08f0d737          	lui	a4,0x8f0d
 300d506:	18070713          	addi	a4,a4,384 # 8f0d180 <RAM_END+0x4f05180>
 300d50a:	cbb8                	sw	a4,80(a5)

    g_qdm1.motorLineNum = g_motorLineNum;   /* 设置编码器线数 */
 300d50c:	a701a783          	lw	a5,-1424(gp) # 400016c <g_motorLineNum>
 300d510:	873e                	mv	a4,a5
 300d512:	0a418793          	addi	a5,gp,164 # 40007a0 <g_qdm1>
 300d516:	cfb8                	sw	a4,88(a5)
    //DBG_PRINTF("g_qdm0.motorLineNum:%d\r\n", g_qdm0.motorLineNum);

    g_qdm1.interruptEn = QDM_INT_WATCHDOG | 
 300d518:	0a418793          	addi	a5,gp,164 # 40007a0 <g_qdm1>
 300d51c:	30400713          	li	a4,772
 300d520:	cbf8                	sw	a4,84(a5)
        QDM_INT_INDEX_EVNT_LATCH | 
        QDM_INT_UNIT_TIME_OUT;

    HAL_QDM_Init(&g_qdm1);
 300d522:	0a418513          	addi	a0,gp,164 # 40007a0 <g_qdm1>
 300d526:	e3cfc0ef          	jal	ra,3009b62 <HAL_QDM_Init>

    HAL_QDM_RegisterCallback(&g_qdm1, QDM_TSU_CYCLE, QDM1PTUCycleCallback);
 300d52a:	0300d7b7          	lui	a5,0x300d
 300d52e:	40a78613          	addi	a2,a5,1034 # 300d40a <QDM1PTUCycleCallback>
 300d532:	4581                	li	a1,0
 300d534:	0a418513          	addi	a0,gp,164 # 40007a0 <g_qdm1>
 300d538:	20b1                	jal	ra,300d584 <HAL_QDM_RegisterCallback.trans.34>
    HAL_QDM_RegisterCallback(&g_qdm1, QDM_INDEX_LOCKED, QDM1ZIndexLockedCallback);
 300d53a:	0300d7b7          	lui	a5,0x300d
 300d53e:	41c78613          	addi	a2,a5,1052 # 300d41c <QDM1ZIndexLockedCallback>
 300d542:	4589                	li	a1,2
 300d544:	0a418513          	addi	a0,gp,164 # 40007a0 <g_qdm1>
 300d548:	2835                	jal	ra,300d584 <HAL_QDM_RegisterCallback.trans.34>
    HAL_QDM_RegisterCallback(&g_qdm1, QDM_PHASE_ERROR, QDM1QuadraturePhaseErrorCallback);
 300d54a:	0300d7b7          	lui	a5,0x300d
 300d54e:	42e78613          	addi	a2,a5,1070 # 300d42e <QDM1QuadraturePhaseErrorCallback>
 300d552:	4591                	li	a1,4
 300d554:	0a418513          	addi	a0,gp,164 # 40007a0 <g_qdm1>
 300d558:	2035                	jal	ra,300d584 <HAL_QDM_RegisterCallback.trans.34>
    IRQ_Register(IRQ_QDM1, HAL_QDM_IrqHandler, &g_qdm1);
 300d55a:	0a418613          	addi	a2,gp,164 # 40007a0 <g_qdm1>
 300d55e:	0300a7b7          	lui	a5,0x300a
 300d562:	8d278593          	addi	a1,a5,-1838 # 30098d2 <HAL_QDM_IrqHandler>
 300d566:	04a00513          	li	a0,74
 300d56a:	2661                	jal	ra,300d8f2 <IRQ_Register.trans.28>
    IRQ_SetPriority(IRQ_QDM1, 1);
 300d56c:	4585                	li	a1,1
 300d56e:	04a00513          	li	a0,74
 300d572:	2eb5                	jal	ra,300d8ee <IRQ_SetPriority.trans.29>
    IRQ_EnableN(IRQ_QDM1);
 300d574:	04a00513          	li	a0,74
 300d578:	2e8d                	jal	ra,300d8ea <IRQ_EnableN.trans.30>
}
 300d57a:	0001                	nop
 300d57c:	40b2                	lw	ra,12(sp)
 300d57e:	4422                	lw	s0,8(sp)
 300d580:	0141                	addi	sp,sp,16
 300d582:	8082                	ret

0300d584 <HAL_QDM_RegisterCallback.trans.34>:
 300d584:	d5afc06f          	j	3009ade <HAL_QDM_RegisterCallback>

0300d588 <TIMER0_Init>:
    /* USER CODE BEGIN TIMER0_InterruptProcess */
    /* USER CODE END TIMER0_InterruptProcess */
}

static void TIMER0_Init(void)
{
 300d588:	1101                	addi	sp,sp,-32
 300d58a:	ce06                	sw	ra,28(sp)
 300d58c:	cc22                	sw	s0,24(sp)
 300d58e:	1000                	addi	s0,sp,32

    HAL_CRG_IpEnableSet(TIMER0_BASE, IP_CLK_ENABLE);
 300d590:	4585                	li	a1,1
 300d592:	14300537          	lui	a0,0x14300
 300d596:	3475                	jal	ra,300d042 <HAL_CRG_IpEnableSet.trans.20>
    HAL_CRG_IpClkSelectSet(TIMER0_BASE, CRG_AHB_CLK_NO_PREDV);
 300d598:	4581                	li	a1,0
 300d59a:	14300537          	lui	a0,0x14300
 300d59e:	20c1                	jal	ra,300d65e <HAL_CRG_IpClkSelectSet.trans.27>

    unsigned int load = (HAL_CRG_GetIpFreq((void *)TIMER0) / (1u << (TIMERPRESCALER_NO_DIV * 4)) / 1000000u) * 10000;
 300d5a0:	14300537          	lui	a0,0x14300
 300d5a4:	94ff70ef          	jal	ra,3004ef2 <HAL_CRG_GetIpFreq>
 300d5a8:	872a                	mv	a4,a0
 300d5aa:	000f47b7          	lui	a5,0xf4
 300d5ae:	24078793          	addi	a5,a5,576 # f4240 <FLASH_SIZE+0xd4244>
 300d5b2:	02f75733          	divu	a4,a4,a5
 300d5b6:	6789                	lui	a5,0x2
 300d5b8:	71078793          	addi	a5,a5,1808 # 2710 <__bss_size__+0x1a9c>
 300d5bc:	02f707b3          	mul	a5,a4,a5
 300d5c0:	fef42623          	sw	a5,-20(s0)

    g_timer0.baseAddress = TIMER0;
 300d5c4:	20018793          	addi	a5,gp,512 # 40008fc <g_timer0>
 300d5c8:	14300737          	lui	a4,0x14300
 300d5cc:	c398                	sw	a4,0(a5)
    g_timer0.load        = load - 1; /* Set timer value immediately */
 300d5ce:	fec42783          	lw	a5,-20(s0)
 300d5d2:	fff78713          	addi	a4,a5,-1
 300d5d6:	20018793          	addi	a5,gp,512 # 40008fc <g_timer0>
 300d5da:	cbd8                	sw	a4,20(a5)
    g_timer0.bgLoad      = load - 1; /* Set timer value */
 300d5dc:	fec42783          	lw	a5,-20(s0)
 300d5e0:	fff78713          	addi	a4,a5,-1
 300d5e4:	20018793          	addi	a5,gp,512 # 40008fc <g_timer0>
 300d5e8:	cf98                	sw	a4,24(a5)
    g_timer0.mode        = TIMER_MODE_RUN_PERIODIC; /* Run in period mode */
 300d5ea:	20018793          	addi	a5,gp,512 # 40008fc <g_timer0>
 300d5ee:	4705                	li	a4,1
 300d5f0:	c798                	sw	a4,8(a5)
    g_timer0.prescaler   = TIMERPRESCALER_NO_DIV; /* Don't frequency division */
 300d5f2:	20018793          	addi	a5,gp,512 # 40008fc <g_timer0>
 300d5f6:	0007a623          	sw	zero,12(a5)
    g_timer0.size        = TIMER_SIZE_32BIT; /* 1 for 32bit, 0 for 16bit */
 300d5fa:	20018793          	addi	a5,gp,512 # 40008fc <g_timer0>
 300d5fe:	4705                	li	a4,1
 300d600:	cb98                	sw	a4,16(a5)
    g_timer0.interruptEn = BASE_CFG_ENABLE;
 300d602:	20018793          	addi	a5,gp,512 # 40008fc <g_timer0>
 300d606:	4705                	li	a4,1
 300d608:	afd8                	sb	a4,28(a5)
    g_timer0.adcSocReqEnable = BASE_CFG_DISABLE;
 300d60a:	20018793          	addi	a5,gp,512 # 40008fc <g_timer0>
 300d60e:	00078ea3          	sb	zero,29(a5)
    g_timer0.dmaReqEnable = BASE_CFG_DISABLE;
 300d612:	20018793          	addi	a5,gp,512 # 40008fc <g_timer0>
 300d616:	00078f23          	sb	zero,30(a5)
    HAL_TIMER_Init(&g_timer0);
 300d61a:	20018513          	addi	a0,gp,512 # 40008fc <g_timer0>
 300d61e:	809fc0ef          	jal	ra,3009e26 <HAL_TIMER_Init>
    IRQ_Register(IRQ_TIMER0, HAL_TIMER_IrqHandler, &g_timer0);
 300d622:	20018613          	addi	a2,gp,512 # 40008fc <g_timer0>
 300d626:	0300a7b7          	lui	a5,0x300a
 300d62a:	0fa78593          	addi	a1,a5,250 # 300a0fa <HAL_TIMER_IrqHandler>
 300d62e:	02000513          	li	a0,32
 300d632:	24c1                	jal	ra,300d8f2 <IRQ_Register.trans.28>

    HAL_TIMER_RegisterCallback(&g_timer0, TIMER_PERIOD_FIN, TIMER0_InterruptProcess);
 300d634:	0300c7b7          	lui	a5,0x300c
 300d638:	b6c78613          	addi	a2,a5,-1172 # 300bb6c <TIMER0_InterruptProcess>
 300d63c:	4581                	li	a1,0
 300d63e:	20018513          	addi	a0,gp,512 # 40008fc <g_timer0>
 300d642:	ba1fc0ef          	jal	ra,300a1e2 <HAL_TIMER_RegisterCallback>
    IRQ_SetPriority(IRQ_TIMER0, 1);
 300d646:	4585                	li	a1,1
 300d648:	02000513          	li	a0,32
 300d64c:	244d                	jal	ra,300d8ee <IRQ_SetPriority.trans.29>
    IRQ_EnableN(IRQ_TIMER0);
 300d64e:	02000513          	li	a0,32
 300d652:	2c61                	jal	ra,300d8ea <IRQ_EnableN.trans.30>
}
 300d654:	0001                	nop
 300d656:	40f2                	lw	ra,28(sp)
 300d658:	4462                	lw	s0,24(sp)
 300d65a:	6105                	addi	sp,sp,32
 300d65c:	8082                	ret

0300d65e <HAL_CRG_IpClkSelectSet.trans.27>:
 300d65e:	a51f706f          	j	30050ae <HAL_CRG_IpClkSelectSet>

0300d662 <UART0_Init>:

static void UART0_Init(void)
{
 300d662:	1141                	addi	sp,sp,-16
 300d664:	c606                	sw	ra,12(sp)
 300d666:	c422                	sw	s0,8(sp)
 300d668:	0800                	addi	s0,sp,16
    HAL_CRG_IpEnableSet(UART0_BASE, IP_CLK_ENABLE);
 300d66a:	4585                	li	a1,1
 300d66c:	14000537          	lui	a0,0x14000
 300d670:	2459                	jal	ra,300d8f6 <HAL_CRG_IpEnableSet.trans.21>
    HAL_CRG_IpClkSelectSet(UART0_BASE, CRG_AHB_CLK_NO_PREDV);
 300d672:	4581                	li	a1,0
 300d674:	14000537          	lui	a0,0x14000
 300d678:	37dd                	jal	ra,300d65e <HAL_CRG_IpClkSelectSet.trans.27>

    g_uart0.baseAddress = UART0;
 300d67a:	22818793          	addi	a5,gp,552 # 4000924 <g_uart0>
 300d67e:	14000737          	lui	a4,0x14000
 300d682:	c398                	sw	a4,0(a5)

    g_uart0.baudRate = UART0_BAND_RATE;
 300d684:	22818793          	addi	a5,gp,552 # 4000924 <g_uart0>
 300d688:	6771                	lui	a4,0x1c
 300d68a:	20070713          	addi	a4,a4,512 # 1c200 <RAM_SIZE+0x17200>
 300d68e:	c3d8                	sw	a4,4(a5)
    g_uart0.dataLength = UART_DATALENGTH_8BIT;
 300d690:	22818793          	addi	a5,gp,552 # 4000924 <g_uart0>
 300d694:	470d                	li	a4,3
 300d696:	c798                	sw	a4,8(a5)
    g_uart0.stopBits = UART_STOPBITS_ONE;
 300d698:	22818793          	addi	a5,gp,552 # 4000924 <g_uart0>
 300d69c:	0007a623          	sw	zero,12(a5)
    g_uart0.parity = UART_PARITY_NONE;
 300d6a0:	22818793          	addi	a5,gp,552 # 4000924 <g_uart0>
 300d6a4:	4711                	li	a4,4
 300d6a6:	cb98                	sw	a4,16(a5)
    g_uart0.txMode = UART_MODE_BLOCKING;
 300d6a8:	22818793          	addi	a5,gp,552 # 4000924 <g_uart0>
 300d6ac:	0007aa23          	sw	zero,20(a5)
    g_uart0.rxMode = UART_MODE_BLOCKING;
 300d6b0:	22818793          	addi	a5,gp,552 # 4000924 <g_uart0>
 300d6b4:	0007ac23          	sw	zero,24(a5)
    g_uart0.fifoMode = BASE_CFG_ENABLE;
 300d6b8:	22818793          	addi	a5,gp,552 # 4000924 <g_uart0>
 300d6bc:	4705                	li	a4,1
 300d6be:	02e78623          	sb	a4,44(a5)
    g_uart0.fifoTxThr = UART_FIFODEPTH_SIZE8;
 300d6c2:	22818793          	addi	a5,gp,552 # 4000924 <g_uart0>
 300d6c6:	4721                	li	a4,8
 300d6c8:	db98                	sw	a4,48(a5)
    g_uart0.fifoRxThr = UART_FIFODEPTH_SIZE8;
 300d6ca:	22818793          	addi	a5,gp,552 # 4000924 <g_uart0>
 300d6ce:	4721                	li	a4,8
 300d6d0:	dbd8                	sw	a4,52(a5)
    g_uart0.hwFlowCtr = BASE_CFG_DISABLE;
 300d6d2:	22818793          	addi	a5,gp,552 # 4000924 <g_uart0>
 300d6d6:	0207ac23          	sw	zero,56(a5)
    g_uart0.handleEx.overSampleMultiple = UART_OVERSAMPLING_16X;
 300d6da:	22818793          	addi	a5,gp,552 # 4000924 <g_uart0>
 300d6de:	0607ac23          	sw	zero,120(a5)
    g_uart0.handleEx.msbFirst = BASE_CFG_DISABLE;   
 300d6e2:	22818793          	addi	a5,gp,552 # 4000924 <g_uart0>
 300d6e6:	06078e23          	sb	zero,124(a5)
    HAL_UART_Init(&g_uart0);
 300d6ea:	22818513          	addi	a0,gp,552 # 4000924 <g_uart0>
 300d6ee:	2ad5                	jal	ra,300d8e2 <HAL_UART_Init.trans.48>
}
 300d6f0:	0001                	nop
 300d6f2:	40b2                	lw	ra,12(sp)
 300d6f4:	4422                	lw	s0,8(sp)
 300d6f6:	0141                	addi	sp,sp,16
 300d6f8:	8082                	ret

0300d6fa <UART2InterruptErrorCallback>:

__weak void UART2InterruptErrorCallback(void *handle)
{
 300d6fa:	1101                	addi	sp,sp,-32
 300d6fc:	ce22                	sw	s0,28(sp)
 300d6fe:	1000                	addi	s0,sp,32
 300d700:	fea42623          	sw	a0,-20(s0)
    BASE_FUNC_UNUSED(handle);
    /* USER CODE BEGIN UART2_TRNS_IT_ERROR */
    /* USER CODE END UART2_TRNS_IT_ERROR */
}
 300d704:	0001                	nop
 300d706:	4472                	lw	s0,28(sp)
 300d708:	6105                	addi	sp,sp,32
 300d70a:	8082                	ret

0300d70c <UART2_Init>:
    /* USER CODE BEGIN UART2_READ_IT_FINISH */
    /* USER CODE END UART2_READ_IT_FINISH */
}

static void UART2_Init(void)
{
 300d70c:	1141                	addi	sp,sp,-16
 300d70e:	c606                	sw	ra,12(sp)
 300d710:	c422                	sw	s0,8(sp)
 300d712:	0800                	addi	s0,sp,16
    HAL_CRG_IpEnableSet(UART2_BASE, IP_CLK_ENABLE);
 300d714:	4585                	li	a1,1
 300d716:	14002537          	lui	a0,0x14002
 300d71a:	2af1                	jal	ra,300d8f6 <HAL_CRG_IpEnableSet.trans.21>
    HAL_CRG_IpClkSelectSet(UART2_BASE, CRG_AHB_CLK_NO_PREDV);
 300d71c:	4581                	li	a1,0
 300d71e:	14002537          	lui	a0,0x14002
 300d722:	3f35                	jal	ra,300d65e <HAL_CRG_IpClkSelectSet.trans.27>

    g_uart2.baseAddress = UART2;
 300d724:	2a818793          	addi	a5,gp,680 # 40009a4 <g_uart2>
 300d728:	14002737          	lui	a4,0x14002
 300d72c:	c398                	sw	a4,0(a5)

    g_uart2.baudRate = UART2_BAND_RATE;
 300d72e:	2a818793          	addi	a5,gp,680 # 40009a4 <g_uart2>
 300d732:	6771                	lui	a4,0x1c
 300d734:	20070713          	addi	a4,a4,512 # 1c200 <RAM_SIZE+0x17200>
 300d738:	c3d8                	sw	a4,4(a5)
    g_uart2.dataLength = UART_DATALENGTH_8BIT;
 300d73a:	2a818793          	addi	a5,gp,680 # 40009a4 <g_uart2>
 300d73e:	470d                	li	a4,3
 300d740:	c798                	sw	a4,8(a5)
    g_uart2.stopBits = UART_STOPBITS_ONE;
 300d742:	2a818793          	addi	a5,gp,680 # 40009a4 <g_uart2>
 300d746:	0007a623          	sw	zero,12(a5)
    g_uart2.parity = UART_PARITY_NONE;
 300d74a:	2a818793          	addi	a5,gp,680 # 40009a4 <g_uart2>
 300d74e:	4711                	li	a4,4
 300d750:	cb98                	sw	a4,16(a5)
    g_uart2.txMode = UART_MODE_INTERRUPT;
 300d752:	2a818793          	addi	a5,gp,680 # 40009a4 <g_uart2>
 300d756:	4705                	li	a4,1
 300d758:	cbd8                	sw	a4,20(a5)
    g_uart2.rxMode = UART_MODE_INTERRUPT;
 300d75a:	2a818793          	addi	a5,gp,680 # 40009a4 <g_uart2>
 300d75e:	4705                	li	a4,1
 300d760:	cf98                	sw	a4,24(a5)
    g_uart2.fifoMode = BASE_CFG_ENABLE;
 300d762:	2a818793          	addi	a5,gp,680 # 40009a4 <g_uart2>
 300d766:	4705                	li	a4,1
 300d768:	02e78623          	sb	a4,44(a5)
    g_uart2.fifoTxThr = UART_FIFODEPTH_SIZE4;
 300d76c:	2a818793          	addi	a5,gp,680 # 40009a4 <g_uart2>
 300d770:	4711                	li	a4,4
 300d772:	db98                	sw	a4,48(a5)
    g_uart2.fifoRxThr = UART_FIFODEPTH_SIZE4;
 300d774:	2a818793          	addi	a5,gp,680 # 40009a4 <g_uart2>
 300d778:	4711                	li	a4,4
 300d77a:	dbd8                	sw	a4,52(a5)
    g_uart2.hwFlowCtr = BASE_CFG_DISABLE;
 300d77c:	2a818793          	addi	a5,gp,680 # 40009a4 <g_uart2>
 300d780:	0207ac23          	sw	zero,56(a5)
    g_uart2.handleEx.overSampleMultiple = UART_OVERSAMPLING_16X;
 300d784:	2a818793          	addi	a5,gp,680 # 40009a4 <g_uart2>
 300d788:	0607ac23          	sw	zero,120(a5)
    g_uart2.handleEx.msbFirst = BASE_CFG_DISABLE;   
 300d78c:	2a818793          	addi	a5,gp,680 # 40009a4 <g_uart2>
 300d790:	06078e23          	sb	zero,124(a5)
    HAL_UART_Init(&g_uart2);
 300d794:	2a818513          	addi	a0,gp,680 # 40009a4 <g_uart2>
 300d798:	22a9                	jal	ra,300d8e2 <HAL_UART_Init.trans.48>
    HAL_UART_RegisterCallBack(&g_uart2, UART_TRNS_IT_ERROR, (UART_CallbackType)UART2InterruptErrorCallback);
 300d79a:	0300d7b7          	lui	a5,0x300d
 300d79e:	6fa78613          	addi	a2,a5,1786 # 300d6fa <UART2InterruptErrorCallback>
 300d7a2:	4591                	li	a1,4
 300d7a4:	2a818513          	addi	a0,gp,680 # 40009a4 <g_uart2>
 300d7a8:	2a3d                	jal	ra,300d8e6 <HAL_UART_RegisterCallBack.trans.35>
    HAL_UART_RegisterCallBack(&g_uart2, UART_WRITE_IT_FINISH, (UART_CallbackType)UART2WriteInterruptCallback);
 300d7aa:	0300b7b7          	lui	a5,0x300b
 300d7ae:	31678613          	addi	a2,a5,790 # 300b316 <UART2WriteInterruptCallback>
 300d7b2:	4581                	li	a1,0
 300d7b4:	2a818513          	addi	a0,gp,680 # 40009a4 <g_uart2>
 300d7b8:	223d                	jal	ra,300d8e6 <HAL_UART_RegisterCallBack.trans.35>
    HAL_UART_RegisterCallBack(&g_uart2, UART_READ_IT_FINISH, (UART_CallbackType)UART2ReadInterruptCallback);
 300d7ba:	0300b7b7          	lui	a5,0x300b
 300d7be:	32e78613          	addi	a2,a5,814 # 300b32e <UART2ReadInterruptCallback>
 300d7c2:	4585                	li	a1,1
 300d7c4:	2a818513          	addi	a0,gp,680 # 40009a4 <g_uart2>
 300d7c8:	2a39                	jal	ra,300d8e6 <HAL_UART_RegisterCallBack.trans.35>

    IRQ_Register(IRQ_UART2, HAL_UART_IrqHandler, &g_uart2);
 300d7ca:	2a818613          	addi	a2,gp,680 # 40009a4 <g_uart2>
 300d7ce:	0300b7b7          	lui	a5,0x300b
 300d7d2:	f6678593          	addi	a1,a5,-154 # 300af66 <HAL_UART_IrqHandler>
 300d7d6:	4579                	li	a0,30
 300d7d8:	2a29                	jal	ra,300d8f2 <IRQ_Register.trans.28>
    IRQ_SetPriority(IRQ_UART2, 1);
 300d7da:	4585                	li	a1,1
 300d7dc:	4579                	li	a0,30
 300d7de:	2a01                	jal	ra,300d8ee <IRQ_SetPriority.trans.29>
    IRQ_EnableN(IRQ_UART2);
 300d7e0:	4579                	li	a0,30
 300d7e2:	2221                	jal	ra,300d8ea <IRQ_EnableN.trans.30>
}
 300d7e4:	0001                	nop
 300d7e6:	40b2                	lw	ra,12(sp)
 300d7e8:	4422                	lw	s0,8(sp)
 300d7ea:	0141                	addi	sp,sp,16
 300d7ec:	8082                	ret

0300d7ee <UART3InterruptErrorCallback>:

__weak void UART3InterruptErrorCallback(void *handle)
{
 300d7ee:	1101                	addi	sp,sp,-32
 300d7f0:	ce22                	sw	s0,28(sp)
 300d7f2:	1000                	addi	s0,sp,32
 300d7f4:	fea42623          	sw	a0,-20(s0)
    BASE_FUNC_UNUSED(handle);
    /* USER CODE BEGIN UART3InterruptErrorCallback */
    /* USER CODE END UART3InterruptErrorCallback */
}
 300d7f8:	0001                	nop
 300d7fa:	4472                	lw	s0,28(sp)
 300d7fc:	6105                	addi	sp,sp,32
 300d7fe:	8082                	ret

0300d800 <UART3_Init>:
    /* USER CODE BEGIN UART3ReadInterruptCallback */
    /* USER CODE END UART3ReadInterruptCallback */
}

static void UART3_Init(void)
{
 300d800:	1141                	addi	sp,sp,-16
 300d802:	c606                	sw	ra,12(sp)
 300d804:	c422                	sw	s0,8(sp)
 300d806:	0800                	addi	s0,sp,16
    HAL_CRG_IpEnableSet(UART3_BASE, IP_CLK_ENABLE);
 300d808:	4585                	li	a1,1
 300d80a:	14003537          	lui	a0,0x14003
 300d80e:	20e5                	jal	ra,300d8f6 <HAL_CRG_IpEnableSet.trans.21>
    HAL_CRG_IpClkSelectSet(UART3_BASE, CRG_AHB_CLK_NO_PREDV);
 300d810:	4581                	li	a1,0
 300d812:	14003537          	lui	a0,0x14003
 300d816:	35a1                	jal	ra,300d65e <HAL_CRG_IpClkSelectSet.trans.27>

    g_uart3.baseAddress = UART3;
 300d818:	32818793          	addi	a5,gp,808 # 4000a24 <g_uart3>
 300d81c:	14003737          	lui	a4,0x14003
 300d820:	c398                	sw	a4,0(a5)

    g_uart3.baudRate = UART3_BAND_RATE;
 300d822:	32818793          	addi	a5,gp,808 # 4000a24 <g_uart3>
 300d826:	6709                	lui	a4,0x2
 300d828:	58070713          	addi	a4,a4,1408 # 2580 <__bss_size__+0x190c>
 300d82c:	c3d8                	sw	a4,4(a5)
    g_uart3.dataLength = UART_DATALENGTH_8BIT;
 300d82e:	32818793          	addi	a5,gp,808 # 4000a24 <g_uart3>
 300d832:	470d                	li	a4,3
 300d834:	c798                	sw	a4,8(a5)
    g_uart3.stopBits = UART_STOPBITS_ONE;
 300d836:	32818793          	addi	a5,gp,808 # 4000a24 <g_uart3>
 300d83a:	0007a623          	sw	zero,12(a5)
    g_uart3.parity = UART_PARITY_NONE;
 300d83e:	32818793          	addi	a5,gp,808 # 4000a24 <g_uart3>
 300d842:	4711                	li	a4,4
 300d844:	cb98                	sw	a4,16(a5)
    g_uart3.txMode = UART_MODE_INTERRUPT;
 300d846:	32818793          	addi	a5,gp,808 # 4000a24 <g_uart3>
 300d84a:	4705                	li	a4,1
 300d84c:	cbd8                	sw	a4,20(a5)
    g_uart3.rxMode = UART_MODE_INTERRUPT;
 300d84e:	32818793          	addi	a5,gp,808 # 4000a24 <g_uart3>
 300d852:	4705                	li	a4,1
 300d854:	cf98                	sw	a4,24(a5)
    g_uart3.fifoMode = BASE_CFG_ENABLE;
 300d856:	32818793          	addi	a5,gp,808 # 4000a24 <g_uart3>
 300d85a:	4705                	li	a4,1
 300d85c:	02e78623          	sb	a4,44(a5)
    g_uart3.fifoTxThr = UART_FIFODEPTH_SIZE4;
 300d860:	32818793          	addi	a5,gp,808 # 4000a24 <g_uart3>
 300d864:	4711                	li	a4,4
 300d866:	db98                	sw	a4,48(a5)
    g_uart3.fifoRxThr = UART_FIFODEPTH_SIZE4;
 300d868:	32818793          	addi	a5,gp,808 # 4000a24 <g_uart3>
 300d86c:	4711                	li	a4,4
 300d86e:	dbd8                	sw	a4,52(a5)
    g_uart3.hwFlowCtr = BASE_CFG_DISABLE;
 300d870:	32818793          	addi	a5,gp,808 # 4000a24 <g_uart3>
 300d874:	0207ac23          	sw	zero,56(a5)
    g_uart3.handleEx.overSampleMultiple = UART_OVERSAMPLING_16X;
 300d878:	32818793          	addi	a5,gp,808 # 4000a24 <g_uart3>
 300d87c:	0607ac23          	sw	zero,120(a5)
    g_uart3.handleEx.msbFirst = BASE_CFG_DISABLE;   
 300d880:	32818793          	addi	a5,gp,808 # 4000a24 <g_uart3>
 300d884:	06078e23          	sb	zero,124(a5)
    HAL_UART_Init(&g_uart3);
 300d888:	32818513          	addi	a0,gp,808 # 4000a24 <g_uart3>
 300d88c:	2899                	jal	ra,300d8e2 <HAL_UART_Init.trans.48>
    HAL_UART_RegisterCallBack(&g_uart3, UART_TRNS_IT_ERROR, (UART_CallbackType)UART3InterruptErrorCallback);
 300d88e:	0300d7b7          	lui	a5,0x300d
 300d892:	7ee78613          	addi	a2,a5,2030 # 300d7ee <UART3InterruptErrorCallback>
 300d896:	4591                	li	a1,4
 300d898:	32818513          	addi	a0,gp,808 # 4000a24 <g_uart3>
 300d89c:	20a9                	jal	ra,300d8e6 <HAL_UART_RegisterCallBack.trans.35>
    HAL_UART_RegisterCallBack(&g_uart3, UART_WRITE_IT_FINISH, (UART_CallbackType)UART3WriteInterruptCallback);
 300d89e:	0300c7b7          	lui	a5,0x300c
 300d8a2:	b3c78613          	addi	a2,a5,-1220 # 300bb3c <UART3WriteInterruptCallback>
 300d8a6:	4581                	li	a1,0
 300d8a8:	32818513          	addi	a0,gp,808 # 4000a24 <g_uart3>
 300d8ac:	282d                	jal	ra,300d8e6 <HAL_UART_RegisterCallBack.trans.35>
    HAL_UART_RegisterCallBack(&g_uart3, UART_READ_IT_FINISH, (UART_CallbackType)UART3ReadInterruptCallback);
 300d8ae:	0300c7b7          	lui	a5,0x300c
 300d8b2:	b5478613          	addi	a2,a5,-1196 # 300bb54 <UART3ReadInterruptCallback>
 300d8b6:	4585                	li	a1,1
 300d8b8:	32818513          	addi	a0,gp,808 # 4000a24 <g_uart3>
 300d8bc:	202d                	jal	ra,300d8e6 <HAL_UART_RegisterCallBack.trans.35>

    IRQ_Register(IRQ_UART3, HAL_UART_IrqHandler, &g_uart3);
 300d8be:	32818613          	addi	a2,gp,808 # 4000a24 <g_uart3>
 300d8c2:	0300b7b7          	lui	a5,0x300b
 300d8c6:	f6678593          	addi	a1,a5,-154 # 300af66 <HAL_UART_IrqHandler>
 300d8ca:	456d                	li	a0,27
 300d8cc:	201d                	jal	ra,300d8f2 <IRQ_Register.trans.28>
    IRQ_SetPriority(IRQ_UART3, 1);
 300d8ce:	4585                	li	a1,1
 300d8d0:	456d                	li	a0,27
 300d8d2:	2831                	jal	ra,300d8ee <IRQ_SetPriority.trans.29>
    IRQ_EnableN(IRQ_UART3);
 300d8d4:	456d                	li	a0,27
 300d8d6:	2811                	jal	ra,300d8ea <IRQ_EnableN.trans.30>
}
 300d8d8:	0001                	nop
 300d8da:	40b2                	lw	ra,12(sp)
 300d8dc:	4422                	lw	s0,8(sp)
 300d8de:	0141                	addi	sp,sp,16
 300d8e0:	8082                	ret

0300d8e2 <HAL_UART_Init.trans.48>:
 300d8e2:	c73fc06f          	j	300a554 <HAL_UART_Init>

0300d8e6 <HAL_UART_RegisterCallBack.trans.35>:
 300d8e6:	fe2fd06f          	j	300b0c8 <HAL_UART_RegisterCallBack>

0300d8ea <IRQ_EnableN.trans.30>:
 300d8ea:	ef6f506f          	j	3002fe0 <IRQ_EnableN>

0300d8ee <IRQ_SetPriority.trans.29>:
 300d8ee:	e87f506f          	j	3003774 <IRQ_SetPriority>

0300d8f2 <IRQ_Register.trans.28>:
 300d8f2:	e68f506f          	j	3002f5a <IRQ_Register>

0300d8f6 <HAL_CRG_IpEnableSet.trans.21>:
 300d8f6:	eecf706f          	j	3004fe2 <HAL_CRG_IpEnableSet>

0300d8fa <IOConfig>:

static void IOConfig(void)
{
 300d8fa:	1141                	addi	sp,sp,-16
 300d8fc:	c606                	sw	ra,12(sp)
 300d8fe:	c422                	sw	s0,8(sp)
 300d900:	0800                	addi	s0,sp,16
    HAL_IOCMG_SetPinAltFuncMode(GPIO2_2_AS_UART0_TXD);  /* Check function selection */
 300d902:	018007b7          	lui	a5,0x1800
 300d906:	23278513          	addi	a0,a5,562 # 1800232 <FLASH_SIZE+0x17e0236>
 300d90a:	936fb0ef          	jal	ra,3008a40 <HAL_IOCMG_SetPinAltFuncMode>
    HAL_IOCMG_SetPinPullMode(GPIO2_2_AS_UART0_TXD, PULL_NONE);  /* Pull-up and pull-down */
 300d90e:	4581                	li	a1,0
 300d910:	018007b7          	lui	a5,0x1800
 300d914:	23278513          	addi	a0,a5,562 # 1800232 <FLASH_SIZE+0x17e0236>
 300d918:	962fb0ef          	jal	ra,3008a7a <HAL_IOCMG_SetPinPullMode>
    HAL_IOCMG_SetPinSchmidtMode(GPIO2_2_AS_UART0_TXD, SCHMIDT_DISABLE);  /* Schmitt input on/off */
 300d91c:	4581                	li	a1,0
 300d91e:	018007b7          	lui	a5,0x1800
 300d922:	23278513          	addi	a0,a5,562 # 1800232 <FLASH_SIZE+0x17e0236>
 300d926:	9a0fb0ef          	jal	ra,3008ac6 <HAL_IOCMG_SetPinSchmidtMode>
    HAL_IOCMG_SetPinLevelShiftRate(GPIO2_2_AS_UART0_TXD, LEVEL_SHIFT_RATE_SLOW);  /* Output drive capability */
 300d92a:	4585                	li	a1,1
 300d92c:	018007b7          	lui	a5,0x1800
 300d930:	23278513          	addi	a0,a5,562 # 1800232 <FLASH_SIZE+0x17e0236>
 300d934:	9defb0ef          	jal	ra,3008b12 <HAL_IOCMG_SetPinLevelShiftRate>
    HAL_IOCMG_SetPinDriveRate(GPIO2_2_AS_UART0_TXD, DRIVER_RATE_2);  /* Output signal edge fast/slow */
 300d938:	4589                	li	a1,2
 300d93a:	018007b7          	lui	a5,0x1800
 300d93e:	23278513          	addi	a0,a5,562 # 1800232 <FLASH_SIZE+0x17e0236>
 300d942:	a1cfb0ef          	jal	ra,3008b5e <HAL_IOCMG_SetPinDriveRate>

    HAL_IOCMG_SetPinAltFuncMode(GPIO2_3_AS_UART0_RXD);  /* Check function selection */
 300d946:	018407b7          	lui	a5,0x1840
 300d94a:	23278513          	addi	a0,a5,562 # 1840232 <FLASH_SIZE+0x1820236>
 300d94e:	8f2fb0ef          	jal	ra,3008a40 <HAL_IOCMG_SetPinAltFuncMode>
    HAL_IOCMG_SetPinPullMode(GPIO2_3_AS_UART0_RXD, PULL_NONE);  /* Pull-up and pull-down */
 300d952:	4581                	li	a1,0
 300d954:	018407b7          	lui	a5,0x1840
 300d958:	23278513          	addi	a0,a5,562 # 1840232 <FLASH_SIZE+0x1820236>
 300d95c:	91efb0ef          	jal	ra,3008a7a <HAL_IOCMG_SetPinPullMode>
    HAL_IOCMG_SetPinSchmidtMode(GPIO2_3_AS_UART0_RXD, SCHMIDT_DISABLE);  /* Schmitt input on/off */
 300d960:	4581                	li	a1,0
 300d962:	018407b7          	lui	a5,0x1840
 300d966:	23278513          	addi	a0,a5,562 # 1840232 <FLASH_SIZE+0x1820236>
 300d96a:	95cfb0ef          	jal	ra,3008ac6 <HAL_IOCMG_SetPinSchmidtMode>
    HAL_IOCMG_SetPinLevelShiftRate(GPIO2_3_AS_UART0_RXD, LEVEL_SHIFT_RATE_SLOW);  /* Output drive capability */
 300d96e:	4585                	li	a1,1
 300d970:	018407b7          	lui	a5,0x1840
 300d974:	23278513          	addi	a0,a5,562 # 1840232 <FLASH_SIZE+0x1820236>
 300d978:	99afb0ef          	jal	ra,3008b12 <HAL_IOCMG_SetPinLevelShiftRate>
    HAL_IOCMG_SetPinDriveRate(GPIO2_3_AS_UART0_RXD, DRIVER_RATE_2);  /* Output signal edge fast/slow */
 300d97c:	4589                	li	a1,2
 300d97e:	018407b7          	lui	a5,0x1840
 300d982:	23278513          	addi	a0,a5,562 # 1840232 <FLASH_SIZE+0x1820236>
 300d986:	9d8fb0ef          	jal	ra,3008b5e <HAL_IOCMG_SetPinDriveRate>

    HAL_IOCMG_SetPinAltFuncMode(GPIO3_0_AS_APT0_PWMA);  /* Check function selection */
 300d98a:	014807b7          	lui	a5,0x1480
 300d98e:	23178513          	addi	a0,a5,561 # 1480231 <FLASH_SIZE+0x1460235>
 300d992:	8aefb0ef          	jal	ra,3008a40 <HAL_IOCMG_SetPinAltFuncMode>
    HAL_IOCMG_SetPinPullMode(GPIO3_0_AS_APT0_PWMA, PULL_NONE);  /* Pull-up and pull-down */
 300d996:	4581                	li	a1,0
 300d998:	014807b7          	lui	a5,0x1480
 300d99c:	23178513          	addi	a0,a5,561 # 1480231 <FLASH_SIZE+0x1460235>
 300d9a0:	8dafb0ef          	jal	ra,3008a7a <HAL_IOCMG_SetPinPullMode>
    HAL_IOCMG_SetPinSchmidtMode(GPIO3_0_AS_APT0_PWMA, SCHMIDT_DISABLE);  /* Schmitt input on/off */
 300d9a4:	4581                	li	a1,0
 300d9a6:	014807b7          	lui	a5,0x1480
 300d9aa:	23178513          	addi	a0,a5,561 # 1480231 <FLASH_SIZE+0x1460235>
 300d9ae:	918fb0ef          	jal	ra,3008ac6 <HAL_IOCMG_SetPinSchmidtMode>
    HAL_IOCMG_SetPinLevelShiftRate(GPIO3_0_AS_APT0_PWMA, LEVEL_SHIFT_RATE_SLOW);  /* Output drive capability */
 300d9b2:	4585                	li	a1,1
 300d9b4:	014807b7          	lui	a5,0x1480
 300d9b8:	23178513          	addi	a0,a5,561 # 1480231 <FLASH_SIZE+0x1460235>
 300d9bc:	956fb0ef          	jal	ra,3008b12 <HAL_IOCMG_SetPinLevelShiftRate>
    HAL_IOCMG_SetPinDriveRate(GPIO3_0_AS_APT0_PWMA, DRIVER_RATE_2);  /* Output signal edge fast/slow */
 300d9c0:	4589                	li	a1,2
 300d9c2:	014807b7          	lui	a5,0x1480
 300d9c6:	23178513          	addi	a0,a5,561 # 1480231 <FLASH_SIZE+0x1460235>
 300d9ca:	994fb0ef          	jal	ra,3008b5e <HAL_IOCMG_SetPinDriveRate>

    HAL_IOCMG_SetPinAltFuncMode(GPIO4_0_AS_APT0_PWMB);  /* Check function selection */
 300d9ce:	015407b7          	lui	a5,0x1540
 300d9d2:	23178513          	addi	a0,a5,561 # 1540231 <FLASH_SIZE+0x1520235>
 300d9d6:	86afb0ef          	jal	ra,3008a40 <HAL_IOCMG_SetPinAltFuncMode>
    HAL_IOCMG_SetPinPullMode(GPIO4_0_AS_APT0_PWMB, PULL_NONE);  /* Pull-up and pull-down */
 300d9da:	4581                	li	a1,0
 300d9dc:	015407b7          	lui	a5,0x1540
 300d9e0:	23178513          	addi	a0,a5,561 # 1540231 <FLASH_SIZE+0x1520235>
 300d9e4:	896fb0ef          	jal	ra,3008a7a <HAL_IOCMG_SetPinPullMode>
    HAL_IOCMG_SetPinSchmidtMode(GPIO4_0_AS_APT0_PWMB, SCHMIDT_DISABLE);  /* Schmitt input on/off */
 300d9e8:	4581                	li	a1,0
 300d9ea:	015407b7          	lui	a5,0x1540
 300d9ee:	23178513          	addi	a0,a5,561 # 1540231 <FLASH_SIZE+0x1520235>
 300d9f2:	8d4fb0ef          	jal	ra,3008ac6 <HAL_IOCMG_SetPinSchmidtMode>
    HAL_IOCMG_SetPinLevelShiftRate(GPIO4_0_AS_APT0_PWMB, LEVEL_SHIFT_RATE_SLOW);  /* Output drive capability */
 300d9f6:	4585                	li	a1,1
 300d9f8:	015407b7          	lui	a5,0x1540
 300d9fc:	23178513          	addi	a0,a5,561 # 1540231 <FLASH_SIZE+0x1520235>
 300da00:	912fb0ef          	jal	ra,3008b12 <HAL_IOCMG_SetPinLevelShiftRate>
    HAL_IOCMG_SetPinDriveRate(GPIO4_0_AS_APT0_PWMB, DRIVER_RATE_2);  /* Output signal edge fast/slow */
 300da04:	4589                	li	a1,2
 300da06:	015407b7          	lui	a5,0x1540
 300da0a:	23178513          	addi	a0,a5,561 # 1540231 <FLASH_SIZE+0x1520235>
 300da0e:	950fb0ef          	jal	ra,3008b5e <HAL_IOCMG_SetPinDriveRate>

    HAL_IOCMG_SetPinAltFuncMode(GPIO3_1_AS_APT1_PWMA);  /* Check function selection */
 300da12:	014c07b7          	lui	a5,0x14c0
 300da16:	23178513          	addi	a0,a5,561 # 14c0231 <FLASH_SIZE+0x14a0235>
 300da1a:	826fb0ef          	jal	ra,3008a40 <HAL_IOCMG_SetPinAltFuncMode>
    HAL_IOCMG_SetPinPullMode(GPIO3_1_AS_APT1_PWMA, PULL_NONE);  /* Pull-up and pull-down */
 300da1e:	4581                	li	a1,0
 300da20:	014c07b7          	lui	a5,0x14c0
 300da24:	23178513          	addi	a0,a5,561 # 14c0231 <FLASH_SIZE+0x14a0235>
 300da28:	852fb0ef          	jal	ra,3008a7a <HAL_IOCMG_SetPinPullMode>
    HAL_IOCMG_SetPinSchmidtMode(GPIO3_1_AS_APT1_PWMA, SCHMIDT_DISABLE);  /* Schmitt input on/off */
 300da2c:	4581                	li	a1,0
 300da2e:	014c07b7          	lui	a5,0x14c0
 300da32:	23178513          	addi	a0,a5,561 # 14c0231 <FLASH_SIZE+0x14a0235>
 300da36:	890fb0ef          	jal	ra,3008ac6 <HAL_IOCMG_SetPinSchmidtMode>
    HAL_IOCMG_SetPinLevelShiftRate(GPIO3_1_AS_APT1_PWMA, LEVEL_SHIFT_RATE_SLOW);  /* Output drive capability */
 300da3a:	4585                	li	a1,1
 300da3c:	014c07b7          	lui	a5,0x14c0
 300da40:	23178513          	addi	a0,a5,561 # 14c0231 <FLASH_SIZE+0x14a0235>
 300da44:	8cefb0ef          	jal	ra,3008b12 <HAL_IOCMG_SetPinLevelShiftRate>
    HAL_IOCMG_SetPinDriveRate(GPIO3_1_AS_APT1_PWMA, DRIVER_RATE_2);  /* Output signal edge fast/slow */
 300da48:	4589                	li	a1,2
 300da4a:	014c07b7          	lui	a5,0x14c0
 300da4e:	23178513          	addi	a0,a5,561 # 14c0231 <FLASH_SIZE+0x14a0235>
 300da52:	90cfb0ef          	jal	ra,3008b5e <HAL_IOCMG_SetPinDriveRate>

    HAL_IOCMG_SetPinAltFuncMode(GPIO4_1_AS_APT1_PWMB);  /* Check function selection */
 300da56:	015c07b7          	lui	a5,0x15c0
 300da5a:	23178513          	addi	a0,a5,561 # 15c0231 <FLASH_SIZE+0x15a0235>
 300da5e:	fe3fa0ef          	jal	ra,3008a40 <HAL_IOCMG_SetPinAltFuncMode>
    HAL_IOCMG_SetPinPullMode(GPIO4_1_AS_APT1_PWMB, PULL_NONE);  /* Pull-up and pull-down */
 300da62:	4581                	li	a1,0
 300da64:	015c07b7          	lui	a5,0x15c0
 300da68:	23178513          	addi	a0,a5,561 # 15c0231 <FLASH_SIZE+0x15a0235>
 300da6c:	80efb0ef          	jal	ra,3008a7a <HAL_IOCMG_SetPinPullMode>
    HAL_IOCMG_SetPinSchmidtMode(GPIO4_1_AS_APT1_PWMB, SCHMIDT_DISABLE);  /* Schmitt input on/off */
 300da70:	4581                	li	a1,0
 300da72:	015c07b7          	lui	a5,0x15c0
 300da76:	23178513          	addi	a0,a5,561 # 15c0231 <FLASH_SIZE+0x15a0235>
 300da7a:	84cfb0ef          	jal	ra,3008ac6 <HAL_IOCMG_SetPinSchmidtMode>
    HAL_IOCMG_SetPinLevelShiftRate(GPIO4_1_AS_APT1_PWMB, LEVEL_SHIFT_RATE_SLOW);  /* Output drive capability */
 300da7e:	4585                	li	a1,1
 300da80:	015c07b7          	lui	a5,0x15c0
 300da84:	23178513          	addi	a0,a5,561 # 15c0231 <FLASH_SIZE+0x15a0235>
 300da88:	88afb0ef          	jal	ra,3008b12 <HAL_IOCMG_SetPinLevelShiftRate>
    HAL_IOCMG_SetPinDriveRate(GPIO4_1_AS_APT1_PWMB, DRIVER_RATE_2);  /* Output signal edge fast/slow */
 300da8c:	4589                	li	a1,2
 300da8e:	015c07b7          	lui	a5,0x15c0
 300da92:	23178513          	addi	a0,a5,561 # 15c0231 <FLASH_SIZE+0x15a0235>
 300da96:	8c8fb0ef          	jal	ra,3008b5e <HAL_IOCMG_SetPinDriveRate>

    HAL_IOCMG_SetPinAltFuncMode(GPIO2_0_AS_QDM1_A);  /* Check function selection */
 300da9a:	017807b7          	lui	a5,0x1780
 300da9e:	23578513          	addi	a0,a5,565 # 1780235 <FLASH_SIZE+0x1760239>
 300daa2:	f9ffa0ef          	jal	ra,3008a40 <HAL_IOCMG_SetPinAltFuncMode>
    HAL_IOCMG_SetPinPullMode(GPIO2_0_AS_QDM1_A, PULL_NONE);  /* Pull-up and pull-down */
 300daa6:	4581                	li	a1,0
 300daa8:	017807b7          	lui	a5,0x1780
 300daac:	23578513          	addi	a0,a5,565 # 1780235 <FLASH_SIZE+0x1760239>
 300dab0:	fcbfa0ef          	jal	ra,3008a7a <HAL_IOCMG_SetPinPullMode>
    HAL_IOCMG_SetPinSchmidtMode(GPIO2_0_AS_QDM1_A, SCHMIDT_DISABLE);  /* Schmitt input on/off */
 300dab4:	4581                	li	a1,0
 300dab6:	017807b7          	lui	a5,0x1780
 300daba:	23578513          	addi	a0,a5,565 # 1780235 <FLASH_SIZE+0x1760239>
 300dabe:	808fb0ef          	jal	ra,3008ac6 <HAL_IOCMG_SetPinSchmidtMode>
    HAL_IOCMG_SetPinLevelShiftRate(GPIO2_0_AS_QDM1_A, LEVEL_SHIFT_RATE_SLOW);  /* Output drive capability */
 300dac2:	4585                	li	a1,1
 300dac4:	017807b7          	lui	a5,0x1780
 300dac8:	23578513          	addi	a0,a5,565 # 1780235 <FLASH_SIZE+0x1760239>
 300dacc:	846fb0ef          	jal	ra,3008b12 <HAL_IOCMG_SetPinLevelShiftRate>
    HAL_IOCMG_SetPinDriveRate(GPIO2_0_AS_QDM1_A, DRIVER_RATE_2);  /* Output signal edge fast/slow */
 300dad0:	4589                	li	a1,2
 300dad2:	017807b7          	lui	a5,0x1780
 300dad6:	23578513          	addi	a0,a5,565 # 1780235 <FLASH_SIZE+0x1760239>
 300dada:	884fb0ef          	jal	ra,3008b5e <HAL_IOCMG_SetPinDriveRate>

    HAL_IOCMG_SetPinAltFuncMode(GPIO2_1_AS_QDM1_B);  /* Check function selection */
 300dade:	017c07b7          	lui	a5,0x17c0
 300dae2:	23578513          	addi	a0,a5,565 # 17c0235 <FLASH_SIZE+0x17a0239>
 300dae6:	f5bfa0ef          	jal	ra,3008a40 <HAL_IOCMG_SetPinAltFuncMode>
    HAL_IOCMG_SetPinPullMode(GPIO2_1_AS_QDM1_B, PULL_NONE);  /* Pull-up and pull-down */
 300daea:	4581                	li	a1,0
 300daec:	017c07b7          	lui	a5,0x17c0
 300daf0:	23578513          	addi	a0,a5,565 # 17c0235 <FLASH_SIZE+0x17a0239>
 300daf4:	f87fa0ef          	jal	ra,3008a7a <HAL_IOCMG_SetPinPullMode>
    HAL_IOCMG_SetPinSchmidtMode(GPIO2_1_AS_QDM1_B, SCHMIDT_DISABLE);  /* Schmitt input on/off */
 300daf8:	4581                	li	a1,0
 300dafa:	017c07b7          	lui	a5,0x17c0
 300dafe:	23578513          	addi	a0,a5,565 # 17c0235 <FLASH_SIZE+0x17a0239>
 300db02:	fc5fa0ef          	jal	ra,3008ac6 <HAL_IOCMG_SetPinSchmidtMode>
    HAL_IOCMG_SetPinLevelShiftRate(GPIO2_1_AS_QDM1_B, LEVEL_SHIFT_RATE_SLOW);  /* Output drive capability */
 300db06:	4585                	li	a1,1
 300db08:	017c07b7          	lui	a5,0x17c0
 300db0c:	23578513          	addi	a0,a5,565 # 17c0235 <FLASH_SIZE+0x17a0239>
 300db10:	802fb0ef          	jal	ra,3008b12 <HAL_IOCMG_SetPinLevelShiftRate>
    HAL_IOCMG_SetPinDriveRate(GPIO2_1_AS_QDM1_B, DRIVER_RATE_2);  /* Output signal edge fast/slow */
 300db14:	4589                	li	a1,2
 300db16:	017c07b7          	lui	a5,0x17c0
 300db1a:	23578513          	addi	a0,a5,565 # 17c0235 <FLASH_SIZE+0x17a0239>
 300db1e:	840fb0ef          	jal	ra,3008b5e <HAL_IOCMG_SetPinDriveRate>

    HAL_IOCMG_SetPinAltFuncMode(GPIO5_0_AS_QDM1_INDEX);  /* Check function selection */
 300db22:	001007b7          	lui	a5,0x100
 300db26:	23578513          	addi	a0,a5,565 # 100235 <FLASH_SIZE+0xe0239>
 300db2a:	f17fa0ef          	jal	ra,3008a40 <HAL_IOCMG_SetPinAltFuncMode>
    HAL_IOCMG_SetPinPullMode(GPIO5_0_AS_QDM1_INDEX, PULL_NONE);  /* Pull-up and pull-down */
 300db2e:	4581                	li	a1,0
 300db30:	001007b7          	lui	a5,0x100
 300db34:	23578513          	addi	a0,a5,565 # 100235 <FLASH_SIZE+0xe0239>
 300db38:	f43fa0ef          	jal	ra,3008a7a <HAL_IOCMG_SetPinPullMode>
    HAL_IOCMG_SetPinSchmidtMode(GPIO5_0_AS_QDM1_INDEX, SCHMIDT_DISABLE);  /* Schmitt input on/off */
 300db3c:	4581                	li	a1,0
 300db3e:	001007b7          	lui	a5,0x100
 300db42:	23578513          	addi	a0,a5,565 # 100235 <FLASH_SIZE+0xe0239>
 300db46:	f81fa0ef          	jal	ra,3008ac6 <HAL_IOCMG_SetPinSchmidtMode>
    HAL_IOCMG_SetPinLevelShiftRate(GPIO5_0_AS_QDM1_INDEX, LEVEL_SHIFT_RATE_SLOW);  /* Output drive capability */
 300db4a:	4585                	li	a1,1
 300db4c:	001007b7          	lui	a5,0x100
 300db50:	23578513          	addi	a0,a5,565 # 100235 <FLASH_SIZE+0xe0239>
 300db54:	fbffa0ef          	jal	ra,3008b12 <HAL_IOCMG_SetPinLevelShiftRate>
    HAL_IOCMG_SetPinDriveRate(GPIO5_0_AS_QDM1_INDEX, DRIVER_RATE_2);  /* Output signal edge fast/slow */
 300db58:	4589                	li	a1,2
 300db5a:	001007b7          	lui	a5,0x100
 300db5e:	23578513          	addi	a0,a5,565 # 100235 <FLASH_SIZE+0xe0239>
 300db62:	ffdfa0ef          	jal	ra,3008b5e <HAL_IOCMG_SetPinDriveRate>

    HAL_IOCMG_SetPinAltFuncMode(GPIO1_7_AS_I2C1_SCL);  /* Check function selection */
 300db66:	013007b7          	lui	a5,0x1300
 300db6a:	23278513          	addi	a0,a5,562 # 1300232 <FLASH_SIZE+0x12e0236>
 300db6e:	ed3fa0ef          	jal	ra,3008a40 <HAL_IOCMG_SetPinAltFuncMode>
    HAL_IOCMG_SetPinPullMode(GPIO1_7_AS_I2C1_SCL, PULL_NONE);  /* Pull-up and pull-down */
 300db72:	4581                	li	a1,0
 300db74:	013007b7          	lui	a5,0x1300
 300db78:	23278513          	addi	a0,a5,562 # 1300232 <FLASH_SIZE+0x12e0236>
 300db7c:	efffa0ef          	jal	ra,3008a7a <HAL_IOCMG_SetPinPullMode>
    HAL_IOCMG_SetPinSchmidtMode(GPIO1_7_AS_I2C1_SCL, SCHMIDT_DISABLE);  /* Schmitt input on/off */
 300db80:	4581                	li	a1,0
 300db82:	013007b7          	lui	a5,0x1300
 300db86:	23278513          	addi	a0,a5,562 # 1300232 <FLASH_SIZE+0x12e0236>
 300db8a:	53e000ef          	jal	ra,300e0c8 <HAL_IOCMG_SetPinSchmidtMode.trans.16>
    HAL_IOCMG_SetPinLevelShiftRate(GPIO1_7_AS_I2C1_SCL, LEVEL_SHIFT_RATE_SLOW);  /* Output drive capability */
 300db8e:	4585                	li	a1,1
 300db90:	013007b7          	lui	a5,0x1300
 300db94:	23278513          	addi	a0,a5,562 # 1300232 <FLASH_SIZE+0x12e0236>
 300db98:	52c000ef          	jal	ra,300e0c4 <HAL_IOCMG_SetPinLevelShiftRate.trans.17>
    HAL_IOCMG_SetPinDriveRate(GPIO1_7_AS_I2C1_SCL, DRIVER_RATE_2);  /* Output signal edge fast/slow */
 300db9c:	4589                	li	a1,2
 300db9e:	013007b7          	lui	a5,0x1300
 300dba2:	23278513          	addi	a0,a5,562 # 1300232 <FLASH_SIZE+0x12e0236>
 300dba6:	51a000ef          	jal	ra,300e0c0 <HAL_IOCMG_SetPinDriveRate.trans.18>

    HAL_IOCMG_SetPinAltFuncMode(GPIO4_7_AS_I2C1_SDA);  /* Check function selection */
 300dbaa:	013407b7          	lui	a5,0x1340
 300dbae:	23278513          	addi	a0,a5,562 # 1340232 <FLASH_SIZE+0x1320236>
 300dbb2:	51e000ef          	jal	ra,300e0d0 <HAL_IOCMG_SetPinAltFuncMode.trans.14>
    HAL_IOCMG_SetPinPullMode(GPIO4_7_AS_I2C1_SDA, PULL_NONE);  /* Pull-up and pull-down */
 300dbb6:	4581                	li	a1,0
 300dbb8:	013407b7          	lui	a5,0x1340
 300dbbc:	23278513          	addi	a0,a5,562 # 1340232 <FLASH_SIZE+0x1320236>
 300dbc0:	50c000ef          	jal	ra,300e0cc <HAL_IOCMG_SetPinPullMode.trans.15>
    HAL_IOCMG_SetPinSchmidtMode(GPIO4_7_AS_I2C1_SDA, SCHMIDT_DISABLE);  /* Schmitt input on/off */
 300dbc4:	4581                	li	a1,0
 300dbc6:	013407b7          	lui	a5,0x1340
 300dbca:	23278513          	addi	a0,a5,562 # 1340232 <FLASH_SIZE+0x1320236>
 300dbce:	4fa000ef          	jal	ra,300e0c8 <HAL_IOCMG_SetPinSchmidtMode.trans.16>
    HAL_IOCMG_SetPinLevelShiftRate(GPIO4_7_AS_I2C1_SDA, LEVEL_SHIFT_RATE_SLOW);  /* Output drive capability */
 300dbd2:	4585                	li	a1,1
 300dbd4:	013407b7          	lui	a5,0x1340
 300dbd8:	23278513          	addi	a0,a5,562 # 1340232 <FLASH_SIZE+0x1320236>
 300dbdc:	4e8000ef          	jal	ra,300e0c4 <HAL_IOCMG_SetPinLevelShiftRate.trans.17>
    HAL_IOCMG_SetPinDriveRate(GPIO4_7_AS_I2C1_SDA, DRIVER_RATE_2);  /* Output signal edge fast/slow */
 300dbe0:	4589                	li	a1,2
 300dbe2:	013407b7          	lui	a5,0x1340
 300dbe6:	23278513          	addi	a0,a5,562 # 1340232 <FLASH_SIZE+0x1320236>
 300dbea:	4d6000ef          	jal	ra,300e0c0 <HAL_IOCMG_SetPinDriveRate.trans.18>

    HAL_IOCMG_SetPinAltFuncMode(GPIO1_5_AS_UART2_TXD);  /* Check function selection */
 300dbee:	012807b7          	lui	a5,0x1280
 300dbf2:	23378513          	addi	a0,a5,563 # 1280233 <FLASH_SIZE+0x1260237>
 300dbf6:	4da000ef          	jal	ra,300e0d0 <HAL_IOCMG_SetPinAltFuncMode.trans.14>
    HAL_IOCMG_SetPinPullMode(GPIO1_5_AS_UART2_TXD, PULL_NONE);  /* Pull-up and pull-down */
 300dbfa:	4581                	li	a1,0
 300dbfc:	012807b7          	lui	a5,0x1280
 300dc00:	23378513          	addi	a0,a5,563 # 1280233 <FLASH_SIZE+0x1260237>
 300dc04:	4c8000ef          	jal	ra,300e0cc <HAL_IOCMG_SetPinPullMode.trans.15>
    HAL_IOCMG_SetPinSchmidtMode(GPIO1_5_AS_UART2_TXD, SCHMIDT_DISABLE);  /* Schmitt input on/off */
 300dc08:	4581                	li	a1,0
 300dc0a:	012807b7          	lui	a5,0x1280
 300dc0e:	23378513          	addi	a0,a5,563 # 1280233 <FLASH_SIZE+0x1260237>
 300dc12:	4b6000ef          	jal	ra,300e0c8 <HAL_IOCMG_SetPinSchmidtMode.trans.16>
    HAL_IOCMG_SetPinLevelShiftRate(GPIO1_5_AS_UART2_TXD, LEVEL_SHIFT_RATE_SLOW);  /* Output drive capability */
 300dc16:	4585                	li	a1,1
 300dc18:	012807b7          	lui	a5,0x1280
 300dc1c:	23378513          	addi	a0,a5,563 # 1280233 <FLASH_SIZE+0x1260237>
 300dc20:	2155                	jal	ra,300e0c4 <HAL_IOCMG_SetPinLevelShiftRate.trans.17>
    HAL_IOCMG_SetPinDriveRate(GPIO1_5_AS_UART2_TXD, DRIVER_RATE_2);  /* Output signal edge fast/slow */
 300dc22:	4589                	li	a1,2
 300dc24:	012807b7          	lui	a5,0x1280
 300dc28:	23378513          	addi	a0,a5,563 # 1280233 <FLASH_SIZE+0x1260237>
 300dc2c:	2951                	jal	ra,300e0c0 <HAL_IOCMG_SetPinDriveRate.trans.18>

    HAL_IOCMG_SetPinAltFuncMode(GPIO1_6_AS_UART2_RXD);  /* Check function selection */
 300dc2e:	012c07b7          	lui	a5,0x12c0
 300dc32:	23378513          	addi	a0,a5,563 # 12c0233 <FLASH_SIZE+0x12a0237>
 300dc36:	2969                	jal	ra,300e0d0 <HAL_IOCMG_SetPinAltFuncMode.trans.14>
    HAL_IOCMG_SetPinPullMode(GPIO1_6_AS_UART2_RXD, PULL_NONE);  /* Pull-up and pull-down */
 300dc38:	4581                	li	a1,0
 300dc3a:	012c07b7          	lui	a5,0x12c0
 300dc3e:	23378513          	addi	a0,a5,563 # 12c0233 <FLASH_SIZE+0x12a0237>
 300dc42:	2169                	jal	ra,300e0cc <HAL_IOCMG_SetPinPullMode.trans.15>
    HAL_IOCMG_SetPinSchmidtMode(GPIO1_6_AS_UART2_RXD, SCHMIDT_DISABLE);  /* Schmitt input on/off */
 300dc44:	4581                	li	a1,0
 300dc46:	012c07b7          	lui	a5,0x12c0
 300dc4a:	23378513          	addi	a0,a5,563 # 12c0233 <FLASH_SIZE+0x12a0237>
 300dc4e:	29ad                	jal	ra,300e0c8 <HAL_IOCMG_SetPinSchmidtMode.trans.16>
    HAL_IOCMG_SetPinLevelShiftRate(GPIO1_6_AS_UART2_RXD, LEVEL_SHIFT_RATE_SLOW);  /* Output drive capability */
 300dc50:	4585                	li	a1,1
 300dc52:	012c07b7          	lui	a5,0x12c0
 300dc56:	23378513          	addi	a0,a5,563 # 12c0233 <FLASH_SIZE+0x12a0237>
 300dc5a:	21ad                	jal	ra,300e0c4 <HAL_IOCMG_SetPinLevelShiftRate.trans.17>
    HAL_IOCMG_SetPinDriveRate(GPIO1_6_AS_UART2_RXD, DRIVER_RATE_2);  /* Output signal edge fast/slow */
 300dc5c:	4589                	li	a1,2
 300dc5e:	012c07b7          	lui	a5,0x12c0
 300dc62:	23378513          	addi	a0,a5,563 # 12c0233 <FLASH_SIZE+0x12a0237>
 300dc66:	29a9                	jal	ra,300e0c0 <HAL_IOCMG_SetPinDriveRate.trans.18>

    HAL_IOCMG_SetPinAltFuncMode(GPIO5_2_AS_GPT2_PWM);  /* Check function selection */
 300dc68:	011407b7          	lui	a5,0x1140
 300dc6c:	23178513          	addi	a0,a5,561 # 1140231 <FLASH_SIZE+0x1120235>
 300dc70:	2185                	jal	ra,300e0d0 <HAL_IOCMG_SetPinAltFuncMode.trans.14>
    HAL_IOCMG_SetPinPullMode(GPIO5_2_AS_GPT2_PWM, PULL_NONE);  /* Pull-up and pull-down */
 300dc72:	4581                	li	a1,0
 300dc74:	011407b7          	lui	a5,0x1140
 300dc78:	23178513          	addi	a0,a5,561 # 1140231 <FLASH_SIZE+0x1120235>
 300dc7c:	2981                	jal	ra,300e0cc <HAL_IOCMG_SetPinPullMode.trans.15>
    HAL_IOCMG_SetPinSchmidtMode(GPIO5_2_AS_GPT2_PWM, SCHMIDT_DISABLE);  /* Schmitt input on/off */
 300dc7e:	4581                	li	a1,0
 300dc80:	011407b7          	lui	a5,0x1140
 300dc84:	23178513          	addi	a0,a5,561 # 1140231 <FLASH_SIZE+0x1120235>
 300dc88:	2181                	jal	ra,300e0c8 <HAL_IOCMG_SetPinSchmidtMode.trans.16>
    HAL_IOCMG_SetPinLevelShiftRate(GPIO5_2_AS_GPT2_PWM, LEVEL_SHIFT_RATE_SLOW);  /* Output drive capability */
 300dc8a:	4585                	li	a1,1
 300dc8c:	011407b7          	lui	a5,0x1140
 300dc90:	23178513          	addi	a0,a5,561 # 1140231 <FLASH_SIZE+0x1120235>
 300dc94:	2905                	jal	ra,300e0c4 <HAL_IOCMG_SetPinLevelShiftRate.trans.17>
    HAL_IOCMG_SetPinDriveRate(GPIO5_2_AS_GPT2_PWM, DRIVER_RATE_2);  /* Output signal edge fast/slow */
 300dc96:	4589                	li	a1,2
 300dc98:	011407b7          	lui	a5,0x1140
 300dc9c:	23178513          	addi	a0,a5,561 # 1140231 <FLASH_SIZE+0x1120235>
 300dca0:	2105                	jal	ra,300e0c0 <HAL_IOCMG_SetPinDriveRate.trans.18>

    HAL_IOCMG_SetPinAltFuncMode(GPIO0_5_AS_GPT1_PWM);  /* Check function selection */
 300dca2:	01a007b7          	lui	a5,0x1a00
 300dca6:	22278513          	addi	a0,a5,546 # 1a00222 <FLASH_SIZE+0x19e0226>
 300dcaa:	211d                	jal	ra,300e0d0 <HAL_IOCMG_SetPinAltFuncMode.trans.14>
    HAL_IOCMG_SetPinPullMode(GPIO0_5_AS_GPT1_PWM, PULL_NONE);  /* Pull-up and pull-down */
 300dcac:	4581                	li	a1,0
 300dcae:	01a007b7          	lui	a5,0x1a00
 300dcb2:	22278513          	addi	a0,a5,546 # 1a00222 <FLASH_SIZE+0x19e0226>
 300dcb6:	2919                	jal	ra,300e0cc <HAL_IOCMG_SetPinPullMode.trans.15>
    HAL_IOCMG_SetPinSchmidtMode(GPIO0_5_AS_GPT1_PWM, SCHMIDT_DISABLE);  /* Schmitt input on/off */
 300dcb8:	4581                	li	a1,0
 300dcba:	01a007b7          	lui	a5,0x1a00
 300dcbe:	22278513          	addi	a0,a5,546 # 1a00222 <FLASH_SIZE+0x19e0226>
 300dcc2:	2119                	jal	ra,300e0c8 <HAL_IOCMG_SetPinSchmidtMode.trans.16>
    HAL_IOCMG_SetPinLevelShiftRate(GPIO0_5_AS_GPT1_PWM, LEVEL_SHIFT_RATE_SLOW);  /* Output drive capability */
 300dcc4:	4585                	li	a1,1
 300dcc6:	01a007b7          	lui	a5,0x1a00
 300dcca:	22278513          	addi	a0,a5,546 # 1a00222 <FLASH_SIZE+0x19e0226>
 300dcce:	2edd                	jal	ra,300e0c4 <HAL_IOCMG_SetPinLevelShiftRate.trans.17>
    HAL_IOCMG_SetPinDriveRate(GPIO0_5_AS_GPT1_PWM, DRIVER_RATE_2);  /* Output signal edge fast/slow */
 300dcd0:	4589                	li	a1,2
 300dcd2:	01a007b7          	lui	a5,0x1a00
 300dcd6:	22278513          	addi	a0,a5,546 # 1a00222 <FLASH_SIZE+0x19e0226>
 300dcda:	26dd                	jal	ra,300e0c0 <HAL_IOCMG_SetPinDriveRate.trans.18>

    HAL_IOCMG_SetPinAltFuncMode(GPIO2_4_AS_GPT0_PWM);  /* Check function selection */
 300dcdc:	001c07b7          	lui	a5,0x1c0
 300dce0:	23278513          	addi	a0,a5,562 # 1c0232 <FLASH_SIZE+0x1a0236>
 300dce4:	26f5                	jal	ra,300e0d0 <HAL_IOCMG_SetPinAltFuncMode.trans.14>
    HAL_IOCMG_SetPinPullMode(GPIO2_4_AS_GPT0_PWM, PULL_NONE);  /* Pull-up and pull-down */
 300dce6:	4581                	li	a1,0
 300dce8:	001c07b7          	lui	a5,0x1c0
 300dcec:	23278513          	addi	a0,a5,562 # 1c0232 <FLASH_SIZE+0x1a0236>
 300dcf0:	2ef1                	jal	ra,300e0cc <HAL_IOCMG_SetPinPullMode.trans.15>
    HAL_IOCMG_SetPinSchmidtMode(GPIO2_4_AS_GPT0_PWM, SCHMIDT_DISABLE);  /* Schmitt input on/off */
 300dcf2:	4581                	li	a1,0
 300dcf4:	001c07b7          	lui	a5,0x1c0
 300dcf8:	23278513          	addi	a0,a5,562 # 1c0232 <FLASH_SIZE+0x1a0236>
 300dcfc:	26f1                	jal	ra,300e0c8 <HAL_IOCMG_SetPinSchmidtMode.trans.16>
    HAL_IOCMG_SetPinLevelShiftRate(GPIO2_4_AS_GPT0_PWM, LEVEL_SHIFT_RATE_SLOW);  /* Output drive capability */
 300dcfe:	4585                	li	a1,1
 300dd00:	001c07b7          	lui	a5,0x1c0
 300dd04:	23278513          	addi	a0,a5,562 # 1c0232 <FLASH_SIZE+0x1a0236>
 300dd08:	2e75                	jal	ra,300e0c4 <HAL_IOCMG_SetPinLevelShiftRate.trans.17>
    HAL_IOCMG_SetPinDriveRate(GPIO2_4_AS_GPT0_PWM, DRIVER_RATE_2);  /* Output signal edge fast/slow */
 300dd0a:	4589                	li	a1,2
 300dd0c:	001c07b7          	lui	a5,0x1c0
 300dd10:	23278513          	addi	a0,a5,562 # 1c0232 <FLASH_SIZE+0x1a0236>
 300dd14:	2675                	jal	ra,300e0c0 <HAL_IOCMG_SetPinDriveRate.trans.18>

    HAL_IOCMG_SetPinAltFuncMode(GPIO1_0_AS_GPIO1_0);  /* Check function selection */
 300dd16:	016807b7          	lui	a5,0x1680
 300dd1a:	23078513          	addi	a0,a5,560 # 1680230 <FLASH_SIZE+0x1660234>
 300dd1e:	2e4d                	jal	ra,300e0d0 <HAL_IOCMG_SetPinAltFuncMode.trans.14>
    HAL_IOCMG_SetPinPullMode(GPIO1_0_AS_GPIO1_0, PULL_NONE);  /* Pull-up and pull-down */
 300dd20:	4581                	li	a1,0
 300dd22:	016807b7          	lui	a5,0x1680
 300dd26:	23078513          	addi	a0,a5,560 # 1680230 <FLASH_SIZE+0x1660234>
 300dd2a:	264d                	jal	ra,300e0cc <HAL_IOCMG_SetPinPullMode.trans.15>
    HAL_IOCMG_SetPinSchmidtMode(GPIO1_0_AS_GPIO1_0, SCHMIDT_DISABLE);  /* Schmitt input on/off */
 300dd2c:	4581                	li	a1,0
 300dd2e:	016807b7          	lui	a5,0x1680
 300dd32:	23078513          	addi	a0,a5,560 # 1680230 <FLASH_SIZE+0x1660234>
 300dd36:	2e49                	jal	ra,300e0c8 <HAL_IOCMG_SetPinSchmidtMode.trans.16>
    HAL_IOCMG_SetPinLevelShiftRate(GPIO1_0_AS_GPIO1_0, LEVEL_SHIFT_RATE_SLOW);  /* Output drive capability */
 300dd38:	4585                	li	a1,1
 300dd3a:	016807b7          	lui	a5,0x1680
 300dd3e:	23078513          	addi	a0,a5,560 # 1680230 <FLASH_SIZE+0x1660234>
 300dd42:	2649                	jal	ra,300e0c4 <HAL_IOCMG_SetPinLevelShiftRate.trans.17>
    HAL_IOCMG_SetPinDriveRate(GPIO1_0_AS_GPIO1_0, DRIVER_RATE_2);  /* Output signal edge fast/slow */
 300dd44:	4589                	li	a1,2
 300dd46:	016807b7          	lui	a5,0x1680
 300dd4a:	23078513          	addi	a0,a5,560 # 1680230 <FLASH_SIZE+0x1660234>
 300dd4e:	2e8d                	jal	ra,300e0c0 <HAL_IOCMG_SetPinDriveRate.trans.18>

    HAL_IOCMG_SetPinAltFuncMode(GPIO1_1_AS_GPIO1_1);  /* Check function selection */
 300dd50:	016c07b7          	lui	a5,0x16c0
 300dd54:	23078513          	addi	a0,a5,560 # 16c0230 <FLASH_SIZE+0x16a0234>
 300dd58:	2ea5                	jal	ra,300e0d0 <HAL_IOCMG_SetPinAltFuncMode.trans.14>
    HAL_IOCMG_SetPinPullMode(GPIO1_1_AS_GPIO1_1, PULL_NONE);  /* Pull-up and pull-down */
 300dd5a:	4581                	li	a1,0
 300dd5c:	016c07b7          	lui	a5,0x16c0
 300dd60:	23078513          	addi	a0,a5,560 # 16c0230 <FLASH_SIZE+0x16a0234>
 300dd64:	26a5                	jal	ra,300e0cc <HAL_IOCMG_SetPinPullMode.trans.15>
    HAL_IOCMG_SetPinSchmidtMode(GPIO1_1_AS_GPIO1_1, SCHMIDT_DISABLE);  /* Schmitt input on/off */
 300dd66:	4581                	li	a1,0
 300dd68:	016c07b7          	lui	a5,0x16c0
 300dd6c:	23078513          	addi	a0,a5,560 # 16c0230 <FLASH_SIZE+0x16a0234>
 300dd70:	2ea1                	jal	ra,300e0c8 <HAL_IOCMG_SetPinSchmidtMode.trans.16>
    HAL_IOCMG_SetPinLevelShiftRate(GPIO1_1_AS_GPIO1_1, LEVEL_SHIFT_RATE_SLOW);  /* Output drive capability */
 300dd72:	4585                	li	a1,1
 300dd74:	016c07b7          	lui	a5,0x16c0
 300dd78:	23078513          	addi	a0,a5,560 # 16c0230 <FLASH_SIZE+0x16a0234>
 300dd7c:	26a1                	jal	ra,300e0c4 <HAL_IOCMG_SetPinLevelShiftRate.trans.17>
    HAL_IOCMG_SetPinDriveRate(GPIO1_1_AS_GPIO1_1, DRIVER_RATE_2);  /* Output signal edge fast/slow */
 300dd7e:	4589                	li	a1,2
 300dd80:	016c07b7          	lui	a5,0x16c0
 300dd84:	23078513          	addi	a0,a5,560 # 16c0230 <FLASH_SIZE+0x16a0234>
 300dd88:	2e25                	jal	ra,300e0c0 <HAL_IOCMG_SetPinDriveRate.trans.18>

    HAL_IOCMG_SetPinAltFuncMode(GPIO2_5_AS_GPIO2_5);  /* Check function selection */
 300dd8a:	011007b7          	lui	a5,0x1100
 300dd8e:	23078513          	addi	a0,a5,560 # 1100230 <FLASH_SIZE+0x10e0234>
 300dd92:	2e3d                	jal	ra,300e0d0 <HAL_IOCMG_SetPinAltFuncMode.trans.14>
    HAL_IOCMG_SetPinPullMode(GPIO2_5_AS_GPIO2_5, PULL_NONE);  /* Pull-up and pull-down */
 300dd94:	4581                	li	a1,0
 300dd96:	011007b7          	lui	a5,0x1100
 300dd9a:	23078513          	addi	a0,a5,560 # 1100230 <FLASH_SIZE+0x10e0234>
 300dd9e:	263d                	jal	ra,300e0cc <HAL_IOCMG_SetPinPullMode.trans.15>
    HAL_IOCMG_SetPinSchmidtMode(GPIO2_5_AS_GPIO2_5, SCHMIDT_DISABLE);  /* Schmitt input on/off */
 300dda0:	4581                	li	a1,0
 300dda2:	011007b7          	lui	a5,0x1100
 300dda6:	23078513          	addi	a0,a5,560 # 1100230 <FLASH_SIZE+0x10e0234>
 300ddaa:	2e39                	jal	ra,300e0c8 <HAL_IOCMG_SetPinSchmidtMode.trans.16>
    HAL_IOCMG_SetPinLevelShiftRate(GPIO2_5_AS_GPIO2_5, LEVEL_SHIFT_RATE_SLOW);  /* Output drive capability */
 300ddac:	4585                	li	a1,1
 300ddae:	011007b7          	lui	a5,0x1100
 300ddb2:	23078513          	addi	a0,a5,560 # 1100230 <FLASH_SIZE+0x10e0234>
 300ddb6:	2639                	jal	ra,300e0c4 <HAL_IOCMG_SetPinLevelShiftRate.trans.17>
    HAL_IOCMG_SetPinDriveRate(GPIO2_5_AS_GPIO2_5, DRIVER_RATE_2);  /* Output signal edge fast/slow */
 300ddb8:	4589                	li	a1,2
 300ddba:	011007b7          	lui	a5,0x1100
 300ddbe:	23078513          	addi	a0,a5,560 # 1100230 <FLASH_SIZE+0x10e0234>
 300ddc2:	2cfd                	jal	ra,300e0c0 <HAL_IOCMG_SetPinDriveRate.trans.18>

    HAL_IOCMG_SetPinAltFuncMode(GPIO2_6_AS_GPIO2_6);  /* Check function selection */
 300ddc4:	010c07b7          	lui	a5,0x10c0
 300ddc8:	23078513          	addi	a0,a5,560 # 10c0230 <FLASH_SIZE+0x10a0234>
 300ddcc:	2611                	jal	ra,300e0d0 <HAL_IOCMG_SetPinAltFuncMode.trans.14>
    HAL_IOCMG_SetPinPullMode(GPIO2_6_AS_GPIO2_6, PULL_NONE);  /* Pull-up and pull-down */
 300ddce:	4581                	li	a1,0
 300ddd0:	010c07b7          	lui	a5,0x10c0
 300ddd4:	23078513          	addi	a0,a5,560 # 10c0230 <FLASH_SIZE+0x10a0234>
 300ddd8:	2cd5                	jal	ra,300e0cc <HAL_IOCMG_SetPinPullMode.trans.15>
    HAL_IOCMG_SetPinSchmidtMode(GPIO2_6_AS_GPIO2_6, SCHMIDT_DISABLE);  /* Schmitt input on/off */
 300ddda:	4581                	li	a1,0
 300dddc:	010c07b7          	lui	a5,0x10c0
 300dde0:	23078513          	addi	a0,a5,560 # 10c0230 <FLASH_SIZE+0x10a0234>
 300dde4:	24d5                	jal	ra,300e0c8 <HAL_IOCMG_SetPinSchmidtMode.trans.16>
    HAL_IOCMG_SetPinLevelShiftRate(GPIO2_6_AS_GPIO2_6, LEVEL_SHIFT_RATE_SLOW);  /* Output drive capability */
 300dde6:	4585                	li	a1,1
 300dde8:	010c07b7          	lui	a5,0x10c0
 300ddec:	23078513          	addi	a0,a5,560 # 10c0230 <FLASH_SIZE+0x10a0234>
 300ddf0:	2cd1                	jal	ra,300e0c4 <HAL_IOCMG_SetPinLevelShiftRate.trans.17>
    HAL_IOCMG_SetPinDriveRate(GPIO2_6_AS_GPIO2_6, DRIVER_RATE_2);  /* Output signal edge fast/slow */
 300ddf2:	4589                	li	a1,2
 300ddf4:	010c07b7          	lui	a5,0x10c0
 300ddf8:	23078513          	addi	a0,a5,560 # 10c0230 <FLASH_SIZE+0x10a0234>
 300ddfc:	24d1                	jal	ra,300e0c0 <HAL_IOCMG_SetPinDriveRate.trans.18>

    HAL_IOCMG_SetPinAltFuncMode(GPIO2_7_AS_GPIO2_7);  /* Check function selection */
 300ddfe:	010807b7          	lui	a5,0x1080
 300de02:	23078513          	addi	a0,a5,560 # 1080230 <FLASH_SIZE+0x1060234>
 300de06:	24e9                	jal	ra,300e0d0 <HAL_IOCMG_SetPinAltFuncMode.trans.14>
    HAL_IOCMG_SetPinPullMode(GPIO2_7_AS_GPIO2_7, PULL_NONE);  /* Pull-up and pull-down */
 300de08:	4581                	li	a1,0
 300de0a:	010807b7          	lui	a5,0x1080
 300de0e:	23078513          	addi	a0,a5,560 # 1080230 <FLASH_SIZE+0x1060234>
 300de12:	2c6d                	jal	ra,300e0cc <HAL_IOCMG_SetPinPullMode.trans.15>
    HAL_IOCMG_SetPinSchmidtMode(GPIO2_7_AS_GPIO2_7, SCHMIDT_DISABLE);  /* Schmitt input on/off */
 300de14:	4581                	li	a1,0
 300de16:	010807b7          	lui	a5,0x1080
 300de1a:	23078513          	addi	a0,a5,560 # 1080230 <FLASH_SIZE+0x1060234>
 300de1e:	246d                	jal	ra,300e0c8 <HAL_IOCMG_SetPinSchmidtMode.trans.16>
    HAL_IOCMG_SetPinLevelShiftRate(GPIO2_7_AS_GPIO2_7, LEVEL_SHIFT_RATE_SLOW);  /* Output drive capability */
 300de20:	4585                	li	a1,1
 300de22:	010807b7          	lui	a5,0x1080
 300de26:	23078513          	addi	a0,a5,560 # 1080230 <FLASH_SIZE+0x1060234>
 300de2a:	2c69                	jal	ra,300e0c4 <HAL_IOCMG_SetPinLevelShiftRate.trans.17>
    HAL_IOCMG_SetPinDriveRate(GPIO2_7_AS_GPIO2_7, DRIVER_RATE_2);  /* Output signal edge fast/slow */
 300de2c:	4589                	li	a1,2
 300de2e:	010807b7          	lui	a5,0x1080
 300de32:	23078513          	addi	a0,a5,560 # 1080230 <FLASH_SIZE+0x1060234>
 300de36:	2469                	jal	ra,300e0c0 <HAL_IOCMG_SetPinDriveRate.trans.18>

    HAL_IOCMG_SetPinAltFuncMode(GPIO5_1_AS_GPIO5_1);  /* Check function selection */
 300de38:	010407b7          	lui	a5,0x1040
 300de3c:	23078513          	addi	a0,a5,560 # 1040230 <FLASH_SIZE+0x1020234>
 300de40:	2c41                	jal	ra,300e0d0 <HAL_IOCMG_SetPinAltFuncMode.trans.14>
    HAL_IOCMG_SetPinPullMode(GPIO5_1_AS_GPIO5_1, PULL_NONE);  /* Pull-up and pull-down */
 300de42:	4581                	li	a1,0
 300de44:	010407b7          	lui	a5,0x1040
 300de48:	23078513          	addi	a0,a5,560 # 1040230 <FLASH_SIZE+0x1020234>
 300de4c:	2441                	jal	ra,300e0cc <HAL_IOCMG_SetPinPullMode.trans.15>
    HAL_IOCMG_SetPinSchmidtMode(GPIO5_1_AS_GPIO5_1, SCHMIDT_DISABLE);  /* Schmitt input on/off */
 300de4e:	4581                	li	a1,0
 300de50:	010407b7          	lui	a5,0x1040
 300de54:	23078513          	addi	a0,a5,560 # 1040230 <FLASH_SIZE+0x1020234>
 300de58:	2c85                	jal	ra,300e0c8 <HAL_IOCMG_SetPinSchmidtMode.trans.16>
    HAL_IOCMG_SetPinLevelShiftRate(GPIO5_1_AS_GPIO5_1, LEVEL_SHIFT_RATE_SLOW);  /* Output drive capability */
 300de5a:	4585                	li	a1,1
 300de5c:	010407b7          	lui	a5,0x1040
 300de60:	23078513          	addi	a0,a5,560 # 1040230 <FLASH_SIZE+0x1020234>
 300de64:	2485                	jal	ra,300e0c4 <HAL_IOCMG_SetPinLevelShiftRate.trans.17>
    HAL_IOCMG_SetPinDriveRate(GPIO5_1_AS_GPIO5_1, DRIVER_RATE_2);  /* Output signal edge fast/slow */
 300de66:	4589                	li	a1,2
 300de68:	010407b7          	lui	a5,0x1040
 300de6c:	23078513          	addi	a0,a5,560 # 1040230 <FLASH_SIZE+0x1020234>
 300de70:	2c81                	jal	ra,300e0c0 <HAL_IOCMG_SetPinDriveRate.trans.18>

    HAL_IOCMG_SetPinAltFuncMode(GPIO1_4_AS_UART3_RXD);  /* Check function selection */
 300de72:	014407b7          	lui	a5,0x1440
 300de76:	23378513          	addi	a0,a5,563 # 1440233 <FLASH_SIZE+0x1420237>
 300de7a:	2c99                	jal	ra,300e0d0 <HAL_IOCMG_SetPinAltFuncMode.trans.14>
    HAL_IOCMG_SetPinPullMode(GPIO1_4_AS_UART3_RXD, PULL_NONE);  /* Pull-up and pull-down */
 300de7c:	4581                	li	a1,0
 300de7e:	014407b7          	lui	a5,0x1440
 300de82:	23378513          	addi	a0,a5,563 # 1440233 <FLASH_SIZE+0x1420237>
 300de86:	2499                	jal	ra,300e0cc <HAL_IOCMG_SetPinPullMode.trans.15>
    HAL_IOCMG_SetPinSchmidtMode(GPIO1_4_AS_UART3_RXD, SCHMIDT_DISABLE);  /* Schmitt input on/off */
 300de88:	4581                	li	a1,0
 300de8a:	014407b7          	lui	a5,0x1440
 300de8e:	23378513          	addi	a0,a5,563 # 1440233 <FLASH_SIZE+0x1420237>
 300de92:	2c1d                	jal	ra,300e0c8 <HAL_IOCMG_SetPinSchmidtMode.trans.16>
    HAL_IOCMG_SetPinLevelShiftRate(GPIO1_4_AS_UART3_RXD, LEVEL_SHIFT_RATE_SLOW);  /* Output drive capability */
 300de94:	4585                	li	a1,1
 300de96:	014407b7          	lui	a5,0x1440
 300de9a:	23378513          	addi	a0,a5,563 # 1440233 <FLASH_SIZE+0x1420237>
 300de9e:	241d                	jal	ra,300e0c4 <HAL_IOCMG_SetPinLevelShiftRate.trans.17>
    HAL_IOCMG_SetPinDriveRate(GPIO1_4_AS_UART3_RXD, DRIVER_RATE_2);  /* Output signal edge fast/slow */
 300dea0:	4589                	li	a1,2
 300dea2:	014407b7          	lui	a5,0x1440
 300dea6:	23378513          	addi	a0,a5,563 # 1440233 <FLASH_SIZE+0x1420237>
 300deaa:	2c19                	jal	ra,300e0c0 <HAL_IOCMG_SetPinDriveRate.trans.18>

    HAL_IOCMG_SetPinAltFuncMode(GPIO1_3_AS_UART3_TXD);  /* Check function selection */
 300deac:	014007b7          	lui	a5,0x1400
 300deb0:	23378513          	addi	a0,a5,563 # 1400233 <FLASH_SIZE+0x13e0237>
 300deb4:	2c31                	jal	ra,300e0d0 <HAL_IOCMG_SetPinAltFuncMode.trans.14>
    HAL_IOCMG_SetPinPullMode(GPIO1_3_AS_UART3_TXD, PULL_NONE);  /* Pull-up and pull-down */
 300deb6:	4581                	li	a1,0
 300deb8:	014007b7          	lui	a5,0x1400
 300debc:	23378513          	addi	a0,a5,563 # 1400233 <FLASH_SIZE+0x13e0237>
 300dec0:	2431                	jal	ra,300e0cc <HAL_IOCMG_SetPinPullMode.trans.15>
    HAL_IOCMG_SetPinSchmidtMode(GPIO1_3_AS_UART3_TXD, SCHMIDT_DISABLE);  /* Schmitt input on/off */
 300dec2:	4581                	li	a1,0
 300dec4:	014007b7          	lui	a5,0x1400
 300dec8:	23378513          	addi	a0,a5,563 # 1400233 <FLASH_SIZE+0x13e0237>
 300decc:	2af5                	jal	ra,300e0c8 <HAL_IOCMG_SetPinSchmidtMode.trans.16>
    HAL_IOCMG_SetPinLevelShiftRate(GPIO1_3_AS_UART3_TXD, LEVEL_SHIFT_RATE_SLOW);  /* Output drive capability */
 300dece:	4585                	li	a1,1
 300ded0:	014007b7          	lui	a5,0x1400
 300ded4:	23378513          	addi	a0,a5,563 # 1400233 <FLASH_SIZE+0x13e0237>
 300ded8:	22f5                	jal	ra,300e0c4 <HAL_IOCMG_SetPinLevelShiftRate.trans.17>
    HAL_IOCMG_SetPinDriveRate(GPIO1_3_AS_UART3_TXD, DRIVER_RATE_2);  /* Output signal edge fast/slow */
 300deda:	4589                	li	a1,2
 300dedc:	014007b7          	lui	a5,0x1400
 300dee0:	23378513          	addi	a0,a5,563 # 1400233 <FLASH_SIZE+0x13e0237>
 300dee4:	2af1                	jal	ra,300e0c0 <HAL_IOCMG_SetPinDriveRate.trans.18>

    HAL_IOCMG_SetPinAltFuncMode(GPIO4_2_AS_I2C0_SCL);  /* Check function selection */
 300dee6:	016007b7          	lui	a5,0x1600
 300deea:	23278513          	addi	a0,a5,562 # 1600232 <FLASH_SIZE+0x15e0236>
 300deee:	22cd                	jal	ra,300e0d0 <HAL_IOCMG_SetPinAltFuncMode.trans.14>
    HAL_IOCMG_SetPinPullMode(GPIO4_2_AS_I2C0_SCL, PULL_NONE);  /* Pull-up and pull-down */
 300def0:	4581                	li	a1,0
 300def2:	016007b7          	lui	a5,0x1600
 300def6:	23278513          	addi	a0,a5,562 # 1600232 <FLASH_SIZE+0x15e0236>
 300defa:	2ac9                	jal	ra,300e0cc <HAL_IOCMG_SetPinPullMode.trans.15>
    HAL_IOCMG_SetPinSchmidtMode(GPIO4_2_AS_I2C0_SCL, SCHMIDT_DISABLE);  /* Schmitt input on/off */
 300defc:	4581                	li	a1,0
 300defe:	016007b7          	lui	a5,0x1600
 300df02:	23278513          	addi	a0,a5,562 # 1600232 <FLASH_SIZE+0x15e0236>
 300df06:	22c9                	jal	ra,300e0c8 <HAL_IOCMG_SetPinSchmidtMode.trans.16>
    HAL_IOCMG_SetPinLevelShiftRate(GPIO4_2_AS_I2C0_SCL, LEVEL_SHIFT_RATE_SLOW);  /* Output drive capability */
 300df08:	4585                	li	a1,1
 300df0a:	016007b7          	lui	a5,0x1600
 300df0e:	23278513          	addi	a0,a5,562 # 1600232 <FLASH_SIZE+0x15e0236>
 300df12:	2a4d                	jal	ra,300e0c4 <HAL_IOCMG_SetPinLevelShiftRate.trans.17>
    HAL_IOCMG_SetPinDriveRate(GPIO4_2_AS_I2C0_SCL, DRIVER_RATE_2);  /* Output signal edge fast/slow */
 300df14:	4589                	li	a1,2
 300df16:	016007b7          	lui	a5,0x1600
 300df1a:	23278513          	addi	a0,a5,562 # 1600232 <FLASH_SIZE+0x15e0236>
 300df1e:	224d                	jal	ra,300e0c0 <HAL_IOCMG_SetPinDriveRate.trans.18>

    HAL_IOCMG_SetPinAltFuncMode(GPIO4_3_AS_I2C0_SDA);  /* Check function selection */
 300df20:	016407b7          	lui	a5,0x1640
 300df24:	23278513          	addi	a0,a5,562 # 1640232 <FLASH_SIZE+0x1620236>
 300df28:	2265                	jal	ra,300e0d0 <HAL_IOCMG_SetPinAltFuncMode.trans.14>
    HAL_IOCMG_SetPinPullMode(GPIO4_3_AS_I2C0_SDA, PULL_NONE);  /* Pull-up and pull-down */
 300df2a:	4581                	li	a1,0
 300df2c:	016407b7          	lui	a5,0x1640
 300df30:	23278513          	addi	a0,a5,562 # 1640232 <FLASH_SIZE+0x1620236>
 300df34:	2a61                	jal	ra,300e0cc <HAL_IOCMG_SetPinPullMode.trans.15>
    HAL_IOCMG_SetPinSchmidtMode(GPIO4_3_AS_I2C0_SDA, SCHMIDT_DISABLE);  /* Schmitt input on/off */
 300df36:	4581                	li	a1,0
 300df38:	016407b7          	lui	a5,0x1640
 300df3c:	23278513          	addi	a0,a5,562 # 1640232 <FLASH_SIZE+0x1620236>
 300df40:	2261                	jal	ra,300e0c8 <HAL_IOCMG_SetPinSchmidtMode.trans.16>
    HAL_IOCMG_SetPinLevelShiftRate(GPIO4_3_AS_I2C0_SDA, LEVEL_SHIFT_RATE_SLOW);  /* Output drive capability */
 300df42:	4585                	li	a1,1
 300df44:	016407b7          	lui	a5,0x1640
 300df48:	23278513          	addi	a0,a5,562 # 1640232 <FLASH_SIZE+0x1620236>
 300df4c:	2aa5                	jal	ra,300e0c4 <HAL_IOCMG_SetPinLevelShiftRate.trans.17>
    HAL_IOCMG_SetPinDriveRate(GPIO4_3_AS_I2C0_SDA, DRIVER_RATE_2);  /* Output signal edge fast/slow */
 300df4e:	4589                	li	a1,2
 300df50:	016407b7          	lui	a5,0x1640
 300df54:	23278513          	addi	a0,a5,562 # 1640232 <FLASH_SIZE+0x1620236>
 300df58:	22a5                	jal	ra,300e0c0 <HAL_IOCMG_SetPinDriveRate.trans.18>

    HAL_IOCMG_SetPinAltFuncMode(GPIO3_7_AS_GPT3_PWM);  /* Check function selection */
 300df5a:	011807b7          	lui	a5,0x1180
 300df5e:	23178513          	addi	a0,a5,561 # 1180231 <FLASH_SIZE+0x1160235>
 300df62:	22bd                	jal	ra,300e0d0 <HAL_IOCMG_SetPinAltFuncMode.trans.14>
    HAL_IOCMG_SetPinPullMode(GPIO3_7_AS_GPT3_PWM, PULL_NONE);  /* Pull-up and pull-down */
 300df64:	4581                	li	a1,0
 300df66:	011807b7          	lui	a5,0x1180
 300df6a:	23178513          	addi	a0,a5,561 # 1180231 <FLASH_SIZE+0x1160235>
 300df6e:	2ab9                	jal	ra,300e0cc <HAL_IOCMG_SetPinPullMode.trans.15>
    HAL_IOCMG_SetPinSchmidtMode(GPIO3_7_AS_GPT3_PWM, SCHMIDT_DISABLE);  /* Schmitt input on/off */
 300df70:	4581                	li	a1,0
 300df72:	011807b7          	lui	a5,0x1180
 300df76:	23178513          	addi	a0,a5,561 # 1180231 <FLASH_SIZE+0x1160235>
 300df7a:	22b9                	jal	ra,300e0c8 <HAL_IOCMG_SetPinSchmidtMode.trans.16>
    HAL_IOCMG_SetPinLevelShiftRate(GPIO3_7_AS_GPT3_PWM, LEVEL_SHIFT_RATE_SLOW);  /* Output drive capability */
 300df7c:	4585                	li	a1,1
 300df7e:	011807b7          	lui	a5,0x1180
 300df82:	23178513          	addi	a0,a5,561 # 1180231 <FLASH_SIZE+0x1160235>
 300df86:	2a3d                	jal	ra,300e0c4 <HAL_IOCMG_SetPinLevelShiftRate.trans.17>
    HAL_IOCMG_SetPinDriveRate(GPIO3_7_AS_GPT3_PWM, DRIVER_RATE_2);  /* Output signal edge fast/slow */
 300df88:	4589                	li	a1,2
 300df8a:	011807b7          	lui	a5,0x1180
 300df8e:	23178513          	addi	a0,a5,561 # 1180231 <FLASH_SIZE+0x1160235>
 300df92:	223d                	jal	ra,300e0c0 <HAL_IOCMG_SetPinDriveRate.trans.18>

    HAL_IOCMG_SetPinAltFuncMode(GPIO5_3_AS_ADC_AIN12);  /* Check function selection */
 300df94:	012407b7          	lui	a5,0x1240
 300df98:	23c78513          	addi	a0,a5,572 # 124023c <FLASH_SIZE+0x1220240>
 300df9c:	2a15                	jal	ra,300e0d0 <HAL_IOCMG_SetPinAltFuncMode.trans.14>
    HAL_IOCMG_SetPinPullMode(GPIO5_3_AS_ADC_AIN12, PULL_NONE);  /* Pull-up and pull-down */
 300df9e:	4581                	li	a1,0
 300dfa0:	012407b7          	lui	a5,0x1240
 300dfa4:	23c78513          	addi	a0,a5,572 # 124023c <FLASH_SIZE+0x1220240>
 300dfa8:	2215                	jal	ra,300e0cc <HAL_IOCMG_SetPinPullMode.trans.15>
    HAL_IOCMG_SetPinSchmidtMode(GPIO5_3_AS_ADC_AIN12, SCHMIDT_DISABLE);  /* Schmitt input on/off */
 300dfaa:	4581                	li	a1,0
 300dfac:	012407b7          	lui	a5,0x1240
 300dfb0:	23c78513          	addi	a0,a5,572 # 124023c <FLASH_SIZE+0x1220240>
 300dfb4:	2a11                	jal	ra,300e0c8 <HAL_IOCMG_SetPinSchmidtMode.trans.16>
    HAL_IOCMG_SetPinLevelShiftRate(GPIO5_3_AS_ADC_AIN12, LEVEL_SHIFT_RATE_SLOW);  /* Output drive capability */
 300dfb6:	4585                	li	a1,1
 300dfb8:	012407b7          	lui	a5,0x1240
 300dfbc:	23c78513          	addi	a0,a5,572 # 124023c <FLASH_SIZE+0x1220240>
 300dfc0:	2211                	jal	ra,300e0c4 <HAL_IOCMG_SetPinLevelShiftRate.trans.17>
    HAL_IOCMG_SetPinDriveRate(GPIO5_3_AS_ADC_AIN12, DRIVER_RATE_2);  /* Output signal edge fast/slow */
 300dfc2:	4589                	li	a1,2
 300dfc4:	012407b7          	lui	a5,0x1240
 300dfc8:	23c78513          	addi	a0,a5,572 # 124023c <FLASH_SIZE+0x1220240>
 300dfcc:	28d5                	jal	ra,300e0c0 <HAL_IOCMG_SetPinDriveRate.trans.18>

    HAL_IOCMG_SetPinAltFuncMode(GPIO3_6_AS_CAN_RX);  /* Check function selection */
 300dfce:	011c07b7          	lui	a5,0x11c0
 300dfd2:	23178513          	addi	a0,a5,561 # 11c0231 <FLASH_SIZE+0x11a0235>
 300dfd6:	28ed                	jal	ra,300e0d0 <HAL_IOCMG_SetPinAltFuncMode.trans.14>
    HAL_IOCMG_SetPinPullMode(GPIO3_6_AS_CAN_RX, PULL_NONE);  /* Pull-up and pull-down */
 300dfd8:	4581                	li	a1,0
 300dfda:	011c07b7          	lui	a5,0x11c0
 300dfde:	23178513          	addi	a0,a5,561 # 11c0231 <FLASH_SIZE+0x11a0235>
 300dfe2:	20ed                	jal	ra,300e0cc <HAL_IOCMG_SetPinPullMode.trans.15>
    HAL_IOCMG_SetPinSchmidtMode(GPIO3_6_AS_CAN_RX, SCHMIDT_DISABLE);  /* Schmitt input on/off */
 300dfe4:	4581                	li	a1,0
 300dfe6:	011c07b7          	lui	a5,0x11c0
 300dfea:	23178513          	addi	a0,a5,561 # 11c0231 <FLASH_SIZE+0x11a0235>
 300dfee:	28e9                	jal	ra,300e0c8 <HAL_IOCMG_SetPinSchmidtMode.trans.16>
    HAL_IOCMG_SetPinLevelShiftRate(GPIO3_6_AS_CAN_RX, LEVEL_SHIFT_RATE_SLOW);  /* Output drive capability */
 300dff0:	4585                	li	a1,1
 300dff2:	011c07b7          	lui	a5,0x11c0
 300dff6:	23178513          	addi	a0,a5,561 # 11c0231 <FLASH_SIZE+0x11a0235>
 300dffa:	20e9                	jal	ra,300e0c4 <HAL_IOCMG_SetPinLevelShiftRate.trans.17>
    HAL_IOCMG_SetPinDriveRate(GPIO3_6_AS_CAN_RX, DRIVER_RATE_2);  /* Output signal edge fast/slow */
 300dffc:	4589                	li	a1,2
 300dffe:	011c07b7          	lui	a5,0x11c0
 300e002:	23178513          	addi	a0,a5,561 # 11c0231 <FLASH_SIZE+0x11a0235>
 300e006:	286d                	jal	ra,300e0c0 <HAL_IOCMG_SetPinDriveRate.trans.18>

    HAL_IOCMG_SetPinAltFuncMode(GPIO3_5_AS_CAN_TX);  /* Check function selection */
 300e008:	012007b7          	lui	a5,0x1200
 300e00c:	23178513          	addi	a0,a5,561 # 1200231 <FLASH_SIZE+0x11e0235>
 300e010:	20c1                	jal	ra,300e0d0 <HAL_IOCMG_SetPinAltFuncMode.trans.14>
    HAL_IOCMG_SetPinPullMode(GPIO3_5_AS_CAN_TX, PULL_NONE);  /* Pull-up and pull-down */
 300e012:	4581                	li	a1,0
 300e014:	012007b7          	lui	a5,0x1200
 300e018:	23178513          	addi	a0,a5,561 # 1200231 <FLASH_SIZE+0x11e0235>
 300e01c:	2845                	jal	ra,300e0cc <HAL_IOCMG_SetPinPullMode.trans.15>
    HAL_IOCMG_SetPinSchmidtMode(GPIO3_5_AS_CAN_TX, SCHMIDT_DISABLE);  /* Schmitt input on/off */
 300e01e:	4581                	li	a1,0
 300e020:	012007b7          	lui	a5,0x1200
 300e024:	23178513          	addi	a0,a5,561 # 1200231 <FLASH_SIZE+0x11e0235>
 300e028:	2045                	jal	ra,300e0c8 <HAL_IOCMG_SetPinSchmidtMode.trans.16>
    HAL_IOCMG_SetPinLevelShiftRate(GPIO3_5_AS_CAN_TX, LEVEL_SHIFT_RATE_SLOW);  /* Output drive capability */
 300e02a:	4585                	li	a1,1
 300e02c:	012007b7          	lui	a5,0x1200
 300e030:	23178513          	addi	a0,a5,561 # 1200231 <FLASH_SIZE+0x11e0235>
 300e034:	2841                	jal	ra,300e0c4 <HAL_IOCMG_SetPinLevelShiftRate.trans.17>
    HAL_IOCMG_SetPinDriveRate(GPIO3_5_AS_CAN_TX, DRIVER_RATE_2);  /* Output signal edge fast/slow */
 300e036:	4589                	li	a1,2
 300e038:	012007b7          	lui	a5,0x1200
 300e03c:	23178513          	addi	a0,a5,561 # 1200231 <FLASH_SIZE+0x11e0235>
 300e040:	2041                	jal	ra,300e0c0 <HAL_IOCMG_SetPinDriveRate.trans.18>

    HAL_IOCMG_SetPinAltFuncMode(GPIO4_5_AS_QDM0_A);  /* Check function selection */
 300e042:	013807b7          	lui	a5,0x1380
 300e046:	23578513          	addi	a0,a5,565 # 1380235 <FLASH_SIZE+0x1360239>
 300e04a:	2059                	jal	ra,300e0d0 <HAL_IOCMG_SetPinAltFuncMode.trans.14>
    HAL_IOCMG_SetPinPullMode(GPIO4_5_AS_QDM0_A, PULL_NONE);  /* Pull-up and pull-down */
 300e04c:	4581                	li	a1,0
 300e04e:	013807b7          	lui	a5,0x1380
 300e052:	23578513          	addi	a0,a5,565 # 1380235 <FLASH_SIZE+0x1360239>
 300e056:	289d                	jal	ra,300e0cc <HAL_IOCMG_SetPinPullMode.trans.15>
    HAL_IOCMG_SetPinSchmidtMode(GPIO4_5_AS_QDM0_A, SCHMIDT_DISABLE);  /* Schmitt input on/off */
 300e058:	4581                	li	a1,0
 300e05a:	013807b7          	lui	a5,0x1380
 300e05e:	23578513          	addi	a0,a5,565 # 1380235 <FLASH_SIZE+0x1360239>
 300e062:	209d                	jal	ra,300e0c8 <HAL_IOCMG_SetPinSchmidtMode.trans.16>
    HAL_IOCMG_SetPinLevelShiftRate(GPIO4_5_AS_QDM0_A, LEVEL_SHIFT_RATE_SLOW);  /* Output drive capability */
 300e064:	4585                	li	a1,1
 300e066:	013807b7          	lui	a5,0x1380
 300e06a:	23578513          	addi	a0,a5,565 # 1380235 <FLASH_SIZE+0x1360239>
 300e06e:	2899                	jal	ra,300e0c4 <HAL_IOCMG_SetPinLevelShiftRate.trans.17>
    HAL_IOCMG_SetPinDriveRate(GPIO4_5_AS_QDM0_A, DRIVER_RATE_2);  /* Output signal edge fast/slow */
 300e070:	4589                	li	a1,2
 300e072:	013807b7          	lui	a5,0x1380
 300e076:	23578513          	addi	a0,a5,565 # 1380235 <FLASH_SIZE+0x1360239>
 300e07a:	2099                	jal	ra,300e0c0 <HAL_IOCMG_SetPinDriveRate.trans.18>

    HAL_IOCMG_SetPinAltFuncMode(GPIO4_6_AS_QDM0_B);  /* Check function selection */
 300e07c:	013c07b7          	lui	a5,0x13c0
 300e080:	22578513          	addi	a0,a5,549 # 13c0225 <FLASH_SIZE+0x13a0229>
 300e084:	20b1                	jal	ra,300e0d0 <HAL_IOCMG_SetPinAltFuncMode.trans.14>
    HAL_IOCMG_SetPinPullMode(GPIO4_6_AS_QDM0_B, PULL_NONE);  /* Pull-up and pull-down */
 300e086:	4581                	li	a1,0
 300e088:	013c07b7          	lui	a5,0x13c0
 300e08c:	22578513          	addi	a0,a5,549 # 13c0225 <FLASH_SIZE+0x13a0229>
 300e090:	2835                	jal	ra,300e0cc <HAL_IOCMG_SetPinPullMode.trans.15>
    HAL_IOCMG_SetPinSchmidtMode(GPIO4_6_AS_QDM0_B, SCHMIDT_DISABLE);  /* Schmitt input on/off */
 300e092:	4581                	li	a1,0
 300e094:	013c07b7          	lui	a5,0x13c0
 300e098:	22578513          	addi	a0,a5,549 # 13c0225 <FLASH_SIZE+0x13a0229>
 300e09c:	2035                	jal	ra,300e0c8 <HAL_IOCMG_SetPinSchmidtMode.trans.16>
    HAL_IOCMG_SetPinLevelShiftRate(GPIO4_6_AS_QDM0_B, LEVEL_SHIFT_RATE_SLOW);  /* Output drive capability */
 300e09e:	4585                	li	a1,1
 300e0a0:	013c07b7          	lui	a5,0x13c0
 300e0a4:	22578513          	addi	a0,a5,549 # 13c0225 <FLASH_SIZE+0x13a0229>
 300e0a8:	2831                	jal	ra,300e0c4 <HAL_IOCMG_SetPinLevelShiftRate.trans.17>
    HAL_IOCMG_SetPinDriveRate(GPIO4_6_AS_QDM0_B, DRIVER_RATE_2);  /* Output signal edge fast/slow */
 300e0aa:	4589                	li	a1,2
 300e0ac:	013c07b7          	lui	a5,0x13c0
 300e0b0:	22578513          	addi	a0,a5,549 # 13c0225 <FLASH_SIZE+0x13a0229>
 300e0b4:	2031                	jal	ra,300e0c0 <HAL_IOCMG_SetPinDriveRate.trans.18>

}
 300e0b6:	0001                	nop
 300e0b8:	40b2                	lw	ra,12(sp)
 300e0ba:	4422                	lw	s0,8(sp)
 300e0bc:	0141                	addi	sp,sp,16
 300e0be:	8082                	ret

0300e0c0 <HAL_IOCMG_SetPinDriveRate.trans.18>:
 300e0c0:	a9ffa06f          	j	3008b5e <HAL_IOCMG_SetPinDriveRate>

0300e0c4 <HAL_IOCMG_SetPinLevelShiftRate.trans.17>:
 300e0c4:	a4ffa06f          	j	3008b12 <HAL_IOCMG_SetPinLevelShiftRate>

0300e0c8 <HAL_IOCMG_SetPinSchmidtMode.trans.16>:
 300e0c8:	9fffa06f          	j	3008ac6 <HAL_IOCMG_SetPinSchmidtMode>

0300e0cc <HAL_IOCMG_SetPinPullMode.trans.15>:
 300e0cc:	9affa06f          	j	3008a7a <HAL_IOCMG_SetPinPullMode>

0300e0d0 <HAL_IOCMG_SetPinAltFuncMode.trans.14>:
 300e0d0:	971fa06f          	j	3008a40 <HAL_IOCMG_SetPinAltFuncMode>

0300e0d4 <SystemInit>:

void SystemInit(void)
{
 300e0d4:	1141                	addi	sp,sp,-16
 300e0d6:	c606                	sw	ra,12(sp)
 300e0d8:	c422                	sw	s0,8(sp)
 300e0da:	0800                	addi	s0,sp,16
    IOConfig();
 300e0dc:	3839                	jal	ra,300d8fa <IOConfig>
    UART0_Init();
 300e0de:	d84ff0ef          	jal	ra,300d662 <UART0_Init>
    UART2_Init();
 300e0e2:	e2aff0ef          	jal	ra,300d70c <UART2_Init>
    UART3_Init();
 300e0e6:	f1aff0ef          	jal	ra,300d800 <UART3_Init>
    APT0_Init();
 300e0ea:	acffe0ef          	jal	ra,300cbb8 <APT0_Init>
    APT1_Init();
 300e0ee:	b65fe0ef          	jal	ra,300cc52 <APT1_Init>
    ADC0_Init();
 300e0f2:	a43fe0ef          	jal	ra,300cb34 <ADC0_Init>
    CAN_Init();
 300e0f6:	bf7fe0ef          	jal	ra,300ccec <CAN_Init>
    GPT0_Init();
 300e0fa:	e23fe0ef          	jal	ra,300cf1c <GPT0_Init>
    GPT1_Init();
 300e0fe:	eb3fe0ef          	jal	ra,300cfb0 <GPT1_Init>
    GPT2_Init();
 300e102:	f45fe0ef          	jal	ra,300d046 <GPT2_Init>
    GPT3_Init();
 300e106:	fd3fe0ef          	jal	ra,300d0d8 <GPT3_Init>
    TIMER0_Init();
 300e10a:	c7eff0ef          	jal	ra,300d588 <TIMER0_Init>
    I2C0_Init();
 300e10e:	862ff0ef          	jal	ra,300d170 <I2C0_Init>
    I2C1_Init();
 300e112:	8ecff0ef          	jal	ra,300d1fe <I2C1_Init>
    QDM0_Init();
 300e116:	9acff0ef          	jal	ra,300d2c2 <QDM0_Init>
    QDM1_Init();
 300e11a:	b26ff0ef          	jal	ra,300d440 <QDM1_Init>
    GPIO_Init();
 300e11e:	ca1fe0ef          	jal	ra,300cdbe <GPIO_Init>

    /* USER CODE BEGIN system_init */
    /* USER CODE END system_init */
 300e122:	0001                	nop
 300e124:	40b2                	lw	ra,12(sp)
 300e126:	4422                	lw	s0,8(sp)
 300e128:	0141                	addi	sp,sp,16
 300e12a:	8082                	ret

0300e12c <__adddf3>:
 300e12c:	1101                	addi	sp,sp,-32
 300e12e:	ce06                	sw	ra,28(sp)
 300e130:	cc22                	sw	s0,24(sp)
 300e132:	ca26                	sw	s1,20(sp)
 300e134:	c84a                	sw	s2,16(sp)
 300e136:	c64e                	sw	s3,12(sp)
 300e138:	c452                	sw	s4,8(sp)
 300e13a:	002024f3          	frrm	s1
 300e13e:	001008b7          	lui	a7,0x100
 300e142:	18fd                	addi	a7,a7,-1 # fffff <FLASH_SIZE+0xe0003>
 300e144:	0145d993          	srli	s3,a1,0x14
 300e148:	0146d813          	srli	a6,a3,0x14
 300e14c:	00b8f7b3          	and	a5,a7,a1
 300e150:	7ff9f993          	andi	s3,s3,2047
 300e154:	00d8f8b3          	and	a7,a7,a3
 300e158:	7ff87813          	andi	a6,a6,2047
 300e15c:	01d65713          	srli	a4,a2,0x1d
 300e160:	01f5d913          	srli	s2,a1,0x1f
 300e164:	088e                	slli	a7,a7,0x3
 300e166:	00379593          	slli	a1,a5,0x3
 300e16a:	00361313          	slli	t1,a2,0x3
 300e16e:	01d55793          	srli	a5,a0,0x1d
 300e172:	41098633          	sub	a2,s3,a6
 300e176:	82fd                	srli	a3,a3,0x1f
 300e178:	8fcd                	or	a5,a5,a1
 300e17a:	050e                	slli	a0,a0,0x3
 300e17c:	01176733          	or	a4,a4,a7
 300e180:	8e32                	mv	t3,a2
 300e182:	3ad91363          	bne	s2,a3,300e528 <__adddf3+0x3fc>
 300e186:	10c05263          	blez	a2,300e28a <__adddf3+0x15e>
 300e18a:	06081f63          	bnez	a6,300e208 <__adddf3+0xdc>
 300e18e:	006766b3          	or	a3,a4,t1
 300e192:	e699                	bnez	a3,300e1a0 <__adddf3+0x74>
 300e194:	7ff00713          	li	a4,2047
 300e198:	8832                	mv	a6,a2
 300e19a:	04ee1463          	bne	t3,a4,300e1e2 <__adddf3+0xb6>
 300e19e:	a881                	j	300e1ee <__adddf3+0xc2>
 300e1a0:	167d                	addi	a2,a2,-1
 300e1a2:	e231                	bnez	a2,300e1e6 <__adddf3+0xba>
 300e1a4:	932a                	add	t1,t1,a0
 300e1a6:	97ba                	add	a5,a5,a4
 300e1a8:	00a33533          	sltu	a0,t1,a0
 300e1ac:	00a78733          	add	a4,a5,a0
 300e1b0:	4805                	li	a6,1
 300e1b2:	00871793          	slli	a5,a4,0x8
 300e1b6:	0e07d463          	bgez	a5,300e29e <__adddf3+0x172>
 300e1ba:	0805                	addi	a6,a6,1
 300e1bc:	7ff00793          	li	a5,2047
 300e1c0:	32f80f63          	beq	a6,a5,300e4fe <__adddf3+0x3d2>
 300e1c4:	ff8007b7          	lui	a5,0xff800
 300e1c8:	17fd                	addi	a5,a5,-1 # ff7fffff <RAM_END+0xfb7f7fff>
 300e1ca:	00135513          	srli	a0,t1,0x1
 300e1ce:	8ff9                	and	a5,a5,a4
 300e1d0:	00137313          	andi	t1,t1,1
 300e1d4:	00656333          	or	t1,a0,t1
 300e1d8:	01f79513          	slli	a0,a5,0x1f
 300e1dc:	00656533          	or	a0,a0,t1
 300e1e0:	8385                	srli	a5,a5,0x1
 300e1e2:	4e01                	li	t3,0
 300e1e4:	a4d1                	j	300e4a8 <__adddf3+0x37c>
 300e1e6:	7ff00693          	li	a3,2047
 300e1ea:	02de1663          	bne	t3,a3,300e216 <__adddf3+0xea>
 300e1ee:	00a7e733          	or	a4,a5,a0
 300e1f2:	6e070963          	beqz	a4,300e8e4 <__adddf3+0x7b8>
 300e1f6:	00979713          	slli	a4,a5,0x9
 300e1fa:	7ff00813          	li	a6,2047
 300e1fe:	4e01                	li	t3,0
 300e200:	2a074463          	bltz	a4,300e4a8 <__adddf3+0x37c>
 300e204:	48c1                	li	a7,16
 300e206:	aa61                	j	300e39e <__adddf3+0x272>
 300e208:	7ff00693          	li	a3,2047
 300e20c:	fed981e3          	beq	s3,a3,300e1ee <__adddf3+0xc2>
 300e210:	008006b7          	lui	a3,0x800
 300e214:	8f55                	or	a4,a4,a3
 300e216:	03800693          	li	a3,56
 300e21a:	06c6c363          	blt	a3,a2,300e280 <__adddf3+0x154>
 300e21e:	46fd                	li	a3,31
 300e220:	02c6cb63          	blt	a3,a2,300e256 <__adddf3+0x12a>
 300e224:	02000593          	li	a1,32
 300e228:	8d91                	sub	a1,a1,a2
 300e22a:	00c35833          	srl	a6,t1,a2
 300e22e:	00b716b3          	sll	a3,a4,a1
 300e232:	00b31333          	sll	t1,t1,a1
 300e236:	0106e6b3          	or	a3,a3,a6
 300e23a:	00603333          	snez	t1,t1
 300e23e:	0066e333          	or	t1,a3,t1
 300e242:	00c75633          	srl	a2,a4,a2
 300e246:	932a                	add	t1,t1,a0
 300e248:	963e                	add	a2,a2,a5
 300e24a:	00a337b3          	sltu	a5,t1,a0
 300e24e:	00f60733          	add	a4,a2,a5
 300e252:	884e                	mv	a6,s3
 300e254:	bfb9                	j	300e1b2 <__adddf3+0x86>
 300e256:	02000813          	li	a6,32
 300e25a:	00c756b3          	srl	a3,a4,a2
 300e25e:	4581                	li	a1,0
 300e260:	01060863          	beq	a2,a6,300e270 <__adddf3+0x144>
 300e264:	04000593          	li	a1,64
 300e268:	40c58633          	sub	a2,a1,a2
 300e26c:	00c715b3          	sll	a1,a4,a2
 300e270:	0065e333          	or	t1,a1,t1
 300e274:	00603333          	snez	t1,t1
 300e278:	0066e333          	or	t1,a3,t1
 300e27c:	4601                	li	a2,0
 300e27e:	b7e1                	j	300e246 <__adddf3+0x11a>
 300e280:	00676333          	or	t1,a4,t1
 300e284:	00603333          	snez	t1,t1
 300e288:	bfd5                	j	300e27c <__adddf3+0x150>
 300e28a:	ca69                	beqz	a2,300e35c <__adddf3+0x230>
 300e28c:	04099963          	bnez	s3,300e2de <__adddf3+0x1b2>
 300e290:	00a7e6b3          	or	a3,a5,a0
 300e294:	ea89                	bnez	a3,300e2a6 <__adddf3+0x17a>
 300e296:	7ff00793          	li	a5,2047
 300e29a:	02f80763          	beq	a6,a5,300e2c8 <__adddf3+0x19c>
 300e29e:	02081d63          	bnez	a6,300e2d8 <__adddf3+0x1ac>
 300e2a2:	851a                	mv	a0,t1
 300e2a4:	a991                	j	300e6f8 <__adddf3+0x5cc>
 300e2a6:	56fd                	li	a3,-1
 300e2a8:	00d61a63          	bne	a2,a3,300e2bc <__adddf3+0x190>
 300e2ac:	006506b3          	add	a3,a0,t1
 300e2b0:	97ba                	add	a5,a5,a4
 300e2b2:	0066b733          	sltu	a4,a3,t1
 300e2b6:	973e                	add	a4,a4,a5
 300e2b8:	8336                	mv	t1,a3
 300e2ba:	bde5                	j	300e1b2 <__adddf3+0x86>
 300e2bc:	7ff00693          	li	a3,2047
 300e2c0:	fff64613          	not	a2,a2
 300e2c4:	02d81663          	bne	a6,a3,300e2f0 <__adddf3+0x1c4>
 300e2c8:	00676533          	or	a0,a4,t1
 300e2cc:	62050263          	beqz	a0,300e8f0 <__adddf3+0x7c4>
 300e2d0:	00971793          	slli	a5,a4,0x9
 300e2d4:	6207d063          	bgez	a5,300e8f4 <__adddf3+0x7c8>
 300e2d8:	87ba                	mv	a5,a4
 300e2da:	851a                	mv	a0,t1
 300e2dc:	b719                	j	300e1e2 <__adddf3+0xb6>
 300e2de:	7ff00693          	li	a3,2047
 300e2e2:	fed803e3          	beq	a6,a3,300e2c8 <__adddf3+0x19c>
 300e2e6:	008006b7          	lui	a3,0x800
 300e2ea:	40c00633          	neg	a2,a2
 300e2ee:	8fd5                	or	a5,a5,a3
 300e2f0:	03800693          	li	a3,56
 300e2f4:	06c6c063          	blt	a3,a2,300e354 <__adddf3+0x228>
 300e2f8:	46fd                	li	a3,31
 300e2fa:	02c6ca63          	blt	a3,a2,300e32e <__adddf3+0x202>
 300e2fe:	02000593          	li	a1,32
 300e302:	8d91                	sub	a1,a1,a2
 300e304:	00c558b3          	srl	a7,a0,a2
 300e308:	00b796b3          	sll	a3,a5,a1
 300e30c:	00b51533          	sll	a0,a0,a1
 300e310:	0116e6b3          	or	a3,a3,a7
 300e314:	00a03533          	snez	a0,a0
 300e318:	8d55                	or	a0,a0,a3
 300e31a:	00c7d633          	srl	a2,a5,a2
 300e31e:	951a                	add	a0,a0,t1
 300e320:	00e607b3          	add	a5,a2,a4
 300e324:	00653733          	sltu	a4,a0,t1
 300e328:	973e                	add	a4,a4,a5
 300e32a:	832a                	mv	t1,a0
 300e32c:	b559                	j	300e1b2 <__adddf3+0x86>
 300e32e:	02000893          	li	a7,32
 300e332:	00c7d6b3          	srl	a3,a5,a2
 300e336:	4581                	li	a1,0
 300e338:	01160863          	beq	a2,a7,300e348 <__adddf3+0x21c>
 300e33c:	04000593          	li	a1,64
 300e340:	40c58633          	sub	a2,a1,a2
 300e344:	00c795b3          	sll	a1,a5,a2
 300e348:	8d4d                	or	a0,a0,a1
 300e34a:	00a03533          	snez	a0,a0
 300e34e:	8d55                	or	a0,a0,a3
 300e350:	4601                	li	a2,0
 300e352:	b7f1                	j	300e31e <__adddf3+0x1f2>
 300e354:	8d5d                	or	a0,a0,a5
 300e356:	00a03533          	snez	a0,a0
 300e35a:	bfdd                	j	300e350 <__adddf3+0x224>
 300e35c:	00198693          	addi	a3,s3,1
 300e360:	7ff6f593          	andi	a1,a3,2047
 300e364:	4605                	li	a2,1
 300e366:	12b64063          	blt	a2,a1,300e486 <__adddf3+0x35a>
 300e36a:	00a7e6b3          	or	a3,a5,a0
 300e36e:	04099463          	bnez	s3,300e3b6 <__adddf3+0x28a>
 300e372:	da85                	beqz	a3,300e2a2 <__adddf3+0x176>
 300e374:	006766b3          	or	a3,a4,t1
 300e378:	54068163          	beqz	a3,300e8ba <__adddf3+0x78e>
 300e37c:	932a                	add	t1,t1,a0
 300e37e:	97ba                	add	a5,a5,a4
 300e380:	00a33533          	sltu	a0,t1,a0
 300e384:	00a78733          	add	a4,a5,a0
 300e388:	00871793          	slli	a5,a4,0x8
 300e38c:	f007dbe3          	bgez	a5,300e2a2 <__adddf3+0x176>
 300e390:	ff8007b7          	lui	a5,0xff800
 300e394:	17fd                	addi	a5,a5,-1 # ff7fffff <RAM_END+0xfb7f7fff>
 300e396:	8ff9                	and	a5,a5,a4
 300e398:	851a                	mv	a0,t1
 300e39a:	4881                	li	a7,0
 300e39c:	4805                	li	a6,1
 300e39e:	00757713          	andi	a4,a0,7
 300e3a2:	12071063          	bnez	a4,300e4c2 <__adddf3+0x396>
 300e3a6:	040e0b63          	beqz	t3,300e3fc <__adddf3+0x2d0>
 300e3aa:	0018f713          	andi	a4,a7,1
 300e3ae:	c739                	beqz	a4,300e3fc <__adddf3+0x2d0>
 300e3b0:	0028e893          	ori	a7,a7,2
 300e3b4:	a0a1                	j	300e3fc <__adddf3+0x2d0>
 300e3b6:	7ff00613          	li	a2,2047
 300e3ba:	0cc99163          	bne	s3,a2,300e47c <__adddf3+0x350>
 300e3be:	5a068163          	beqz	a3,300e960 <__adddf3+0x834>
 300e3c2:	004008b7          	lui	a7,0x400
 300e3c6:	0117f8b3          	and	a7,a5,a7
 300e3ca:	0018b893          	seqz	a7,a7
 300e3ce:	0892                	slli	a7,a7,0x4
 300e3d0:	01381c63          	bne	a6,s3,300e3e8 <__adddf3+0x2bc>
 300e3d4:	00676633          	or	a2,a4,t1
 300e3d8:	c611                	beqz	a2,300e3e4 <__adddf3+0x2b8>
 300e3da:	00971613          	slli	a2,a4,0x9
 300e3de:	00064363          	bltz	a2,300e3e4 <__adddf3+0x2b8>
 300e3e2:	48c1                	li	a7,16
 300e3e4:	4e068d63          	beqz	a3,300e8de <__adddf3+0x7b2>
 300e3e8:	00676733          	or	a4,a4,t1
 300e3ec:	3c070b63          	beqz	a4,300e7c2 <__adddf3+0x696>
 300e3f0:	004007b7          	lui	a5,0x400
 300e3f4:	4501                	li	a0,0
 300e3f6:	7ff00813          	li	a6,2047
 300e3fa:	4901                	li	s2,0
 300e3fc:	00879713          	slli	a4,a5,0x8
 300e400:	00075b63          	bgez	a4,300e416 <__adddf3+0x2ea>
 300e404:	0805                	addi	a6,a6,1
 300e406:	7ff00713          	li	a4,2047
 300e40a:	52e80363          	beq	a6,a4,300e930 <__adddf3+0x804>
 300e40e:	ff800737          	lui	a4,0xff800
 300e412:	177d                	addi	a4,a4,-1 # ff7fffff <RAM_END+0xfb7f7fff>
 300e414:	8ff9                	and	a5,a5,a4
 300e416:	01d79713          	slli	a4,a5,0x1d
 300e41a:	810d                	srli	a0,a0,0x3
 300e41c:	8d59                	or	a0,a0,a4
 300e41e:	7ff00713          	li	a4,2047
 300e422:	838d                	srli	a5,a5,0x3
 300e424:	00e81963          	bne	a6,a4,300e436 <__adddf3+0x30a>
 300e428:	8d5d                	or	a0,a0,a5
 300e42a:	4781                	li	a5,0
 300e42c:	c509                	beqz	a0,300e436 <__adddf3+0x30a>
 300e42e:	000807b7          	lui	a5,0x80
 300e432:	4501                	li	a0,0
 300e434:	4901                	li	s2,0
 300e436:	00100737          	lui	a4,0x100
 300e43a:	177d                	addi	a4,a4,-1 # fffff <FLASH_SIZE+0xe0003>
 300e43c:	8ff9                	and	a5,a5,a4
 300e43e:	80100737          	lui	a4,0x80100
 300e442:	177d                	addi	a4,a4,-1 # 800fffff <RAM_END+0x7c0f7fff>
 300e444:	7ff87813          	andi	a6,a6,2047
 300e448:	0852                	slli	a6,a6,0x14
 300e44a:	8ff9                	and	a5,a5,a4
 300e44c:	0107e7b3          	or	a5,a5,a6
 300e450:	80000837          	lui	a6,0x80000
 300e454:	fff84813          	not	a6,a6
 300e458:	097e                	slli	s2,s2,0x1f
 300e45a:	0107f7b3          	and	a5,a5,a6
 300e45e:	0127e733          	or	a4,a5,s2
 300e462:	85ba                	mv	a1,a4
 300e464:	00088463          	beqz	a7,300e46c <__adddf3+0x340>
 300e468:	0018a073          	csrs	fflags,a7
 300e46c:	40f2                	lw	ra,28(sp)
 300e46e:	4462                	lw	s0,24(sp)
 300e470:	44d2                	lw	s1,20(sp)
 300e472:	4942                	lw	s2,16(sp)
 300e474:	49b2                	lw	s3,12(sp)
 300e476:	4a22                	lw	s4,8(sp)
 300e478:	6105                	addi	sp,sp,32
 300e47a:	8082                	ret
 300e47c:	4881                	li	a7,0
 300e47e:	f6c813e3          	bne	a6,a2,300e3e4 <__adddf3+0x2b8>
 300e482:	4881                	li	a7,0
 300e484:	bf81                	j	300e3d4 <__adddf3+0x2a8>
 300e486:	7ff00613          	li	a2,2047
 300e48a:	02c68163          	beq	a3,a2,300e4ac <__adddf3+0x380>
 300e48e:	932a                	add	t1,t1,a0
 300e490:	00a33533          	sltu	a0,t1,a0
 300e494:	97ba                	add	a5,a5,a4
 300e496:	97aa                	add	a5,a5,a0
 300e498:	01f79513          	slli	a0,a5,0x1f
 300e49c:	00135313          	srli	t1,t1,0x1
 300e4a0:	00656533          	or	a0,a0,t1
 300e4a4:	8385                	srli	a5,a5,0x1
 300e4a6:	8836                	mv	a6,a3
 300e4a8:	4881                	li	a7,0
 300e4aa:	bdd5                	j	300e39e <__adddf3+0x272>
 300e4ac:	c4b1                	beqz	s1,300e4f8 <__adddf3+0x3cc>
 300e4ae:	478d                	li	a5,3
 300e4b0:	02f49f63          	bne	s1,a5,300e4ee <__adddf3+0x3c2>
 300e4b4:	04090263          	beqz	s2,300e4f8 <__adddf3+0x3cc>
 300e4b8:	57fd                	li	a5,-1
 300e4ba:	557d                	li	a0,-1
 300e4bc:	7fe00813          	li	a6,2046
 300e4c0:	4895                	li	a7,5
 300e4c2:	4709                	li	a4,2
 300e4c4:	0018e893          	ori	a7,a7,1
 300e4c8:	46e48163          	beq	s1,a4,300e92a <__adddf3+0x7fe>
 300e4cc:	470d                	li	a4,3
 300e4ce:	44e48963          	beq	s1,a4,300e920 <__adddf3+0x7f4>
 300e4d2:	ec049ae3          	bnez	s1,300e3a6 <__adddf3+0x27a>
 300e4d6:	00f57713          	andi	a4,a0,15
 300e4da:	4691                	li	a3,4
 300e4dc:	ecd705e3          	beq	a4,a3,300e3a6 <__adddf3+0x27a>
 300e4e0:	00450713          	addi	a4,a0,4 # 14003004 <RAM_END+0xfffb004>
 300e4e4:	00a73533          	sltu	a0,a4,a0
 300e4e8:	97aa                	add	a5,a5,a0
 300e4ea:	853a                	mv	a0,a4
 300e4ec:	bd6d                	j	300e3a6 <__adddf3+0x27a>
 300e4ee:	4789                	li	a5,2
 300e4f0:	fcf494e3          	bne	s1,a5,300e4b8 <__adddf3+0x38c>
 300e4f4:	fc0902e3          	beqz	s2,300e4b8 <__adddf3+0x38c>
 300e4f8:	7ff00813          	li	a6,2047
 300e4fc:	a015                	j	300e520 <__adddf3+0x3f4>
 300e4fe:	c08d                	beqz	s1,300e520 <__adddf3+0x3f4>
 300e500:	478d                	li	a5,3
 300e502:	00f49a63          	bne	s1,a5,300e516 <__adddf3+0x3ea>
 300e506:	00090d63          	beqz	s2,300e520 <__adddf3+0x3f4>
 300e50a:	57fd                	li	a5,-1
 300e50c:	557d                	li	a0,-1
 300e50e:	7fe00813          	li	a6,2046
 300e512:	4e01                	li	t3,0
 300e514:	b775                	j	300e4c0 <__adddf3+0x394>
 300e516:	4789                	li	a5,2
 300e518:	fef499e3          	bne	s1,a5,300e50a <__adddf3+0x3de>
 300e51c:	fe0907e3          	beqz	s2,300e50a <__adddf3+0x3de>
 300e520:	4781                	li	a5,0
 300e522:	4501                	li	a0,0
 300e524:	4895                	li	a7,5
 300e526:	bdd9                	j	300e3fc <__adddf3+0x2d0>
 300e528:	0cc05563          	blez	a2,300e5f2 <__adddf3+0x4c6>
 300e52c:	08081163          	bnez	a6,300e5ae <__adddf3+0x482>
 300e530:	006766b3          	or	a3,a4,t1
 300e534:	c60680e3          	beqz	a3,300e194 <__adddf3+0x68>
 300e538:	167d                	addi	a2,a2,-1
 300e53a:	e605                	bnez	a2,300e562 <__adddf3+0x436>
 300e53c:	40650333          	sub	t1,a0,t1
 300e540:	8f99                	sub	a5,a5,a4
 300e542:	00653533          	sltu	a0,a0,t1
 300e546:	40a78733          	sub	a4,a5,a0
 300e54a:	4805                	li	a6,1
 300e54c:	00871793          	slli	a5,a4,0x8
 300e550:	d407d7e3          	bgez	a5,300e29e <__adddf3+0x172>
 300e554:	00800437          	lui	s0,0x800
 300e558:	147d                	addi	s0,s0,-1 # 7fffff <FLASH_SIZE+0x7e0003>
 300e55a:	8c79                	and	s0,s0,a4
 300e55c:	8a1a                	mv	s4,t1
 300e55e:	89c2                	mv	s3,a6
 300e560:	ac79                	j	300e7fe <__adddf3+0x6d2>
 300e562:	7ff00693          	li	a3,2047
 300e566:	c8de04e3          	beq	t3,a3,300e1ee <__adddf3+0xc2>
 300e56a:	03800693          	li	a3,56
 300e56e:	06c6cd63          	blt	a3,a2,300e5e8 <__adddf3+0x4bc>
 300e572:	46fd                	li	a3,31
 300e574:	04c6c563          	blt	a3,a2,300e5be <__adddf3+0x492>
 300e578:	02000593          	li	a1,32
 300e57c:	8d91                	sub	a1,a1,a2
 300e57e:	00c35833          	srl	a6,t1,a2
 300e582:	00b716b3          	sll	a3,a4,a1
 300e586:	00b31333          	sll	t1,t1,a1
 300e58a:	0106e6b3          	or	a3,a3,a6
 300e58e:	00603333          	snez	t1,t1
 300e592:	0066e333          	or	t1,a3,t1
 300e596:	00c75633          	srl	a2,a4,a2
 300e59a:	40650333          	sub	t1,a0,t1
 300e59e:	40c78633          	sub	a2,a5,a2
 300e5a2:	006537b3          	sltu	a5,a0,t1
 300e5a6:	40f60733          	sub	a4,a2,a5
 300e5aa:	884e                	mv	a6,s3
 300e5ac:	b745                	j	300e54c <__adddf3+0x420>
 300e5ae:	7ff00693          	li	a3,2047
 300e5b2:	c2d98ee3          	beq	s3,a3,300e1ee <__adddf3+0xc2>
 300e5b6:	008006b7          	lui	a3,0x800
 300e5ba:	8f55                	or	a4,a4,a3
 300e5bc:	b77d                	j	300e56a <__adddf3+0x43e>
 300e5be:	02000813          	li	a6,32
 300e5c2:	00c756b3          	srl	a3,a4,a2
 300e5c6:	4581                	li	a1,0
 300e5c8:	01060863          	beq	a2,a6,300e5d8 <__adddf3+0x4ac>
 300e5cc:	04000593          	li	a1,64
 300e5d0:	40c58633          	sub	a2,a1,a2
 300e5d4:	00c715b3          	sll	a1,a4,a2
 300e5d8:	0065e333          	or	t1,a1,t1
 300e5dc:	00603333          	snez	t1,t1
 300e5e0:	0066e333          	or	t1,a3,t1
 300e5e4:	4601                	li	a2,0
 300e5e6:	bf55                	j	300e59a <__adddf3+0x46e>
 300e5e8:	00676333          	or	t1,a4,t1
 300e5ec:	00603333          	snez	t1,t1
 300e5f0:	bfd5                	j	300e5e4 <__adddf3+0x4b8>
 300e5f2:	ce69                	beqz	a2,300e6cc <__adddf3+0x5a0>
 300e5f4:	04099963          	bnez	s3,300e646 <__adddf3+0x51a>
 300e5f8:	00a7e5b3          	or	a1,a5,a0
 300e5fc:	e589                	bnez	a1,300e606 <__adddf3+0x4da>
 300e5fe:	7ff00793          	li	a5,2047
 300e602:	8936                	mv	s2,a3
 300e604:	b959                	j	300e29a <__adddf3+0x16e>
 300e606:	55fd                	li	a1,-1
 300e608:	00b61d63          	bne	a2,a1,300e622 <__adddf3+0x4f6>
 300e60c:	40a305b3          	sub	a1,t1,a0
 300e610:	40f707b3          	sub	a5,a4,a5
 300e614:	00b33733          	sltu	a4,t1,a1
 300e618:	40e78733          	sub	a4,a5,a4
 300e61c:	832e                	mv	t1,a1
 300e61e:	8936                	mv	s2,a3
 300e620:	b735                	j	300e54c <__adddf3+0x420>
 300e622:	7ff00593          	li	a1,2047
 300e626:	fff64613          	not	a2,a2
 300e62a:	02b81763          	bne	a6,a1,300e658 <__adddf3+0x52c>
 300e62e:	00676533          	or	a0,a4,t1
 300e632:	2c050563          	beqz	a0,300e8fc <__adddf3+0x7d0>
 300e636:	00971793          	slli	a5,a4,0x9
 300e63a:	2c07d463          	bgez	a5,300e902 <__adddf3+0x7d6>
 300e63e:	87ba                	mv	a5,a4
 300e640:	851a                	mv	a0,t1
 300e642:	8936                	mv	s2,a3
 300e644:	be79                	j	300e1e2 <__adddf3+0xb6>
 300e646:	7ff00593          	li	a1,2047
 300e64a:	feb802e3          	beq	a6,a1,300e62e <__adddf3+0x502>
 300e64e:	008005b7          	lui	a1,0x800
 300e652:	40c00633          	neg	a2,a2
 300e656:	8fcd                	or	a5,a5,a1
 300e658:	03800593          	li	a1,56
 300e65c:	06c5c463          	blt	a1,a2,300e6c4 <__adddf3+0x598>
 300e660:	45fd                	li	a1,31
 300e662:	02c5cd63          	blt	a1,a2,300e69c <__adddf3+0x570>
 300e666:	02000893          	li	a7,32
 300e66a:	40c888b3          	sub	a7,a7,a2
 300e66e:	00c55e33          	srl	t3,a0,a2
 300e672:	011795b3          	sll	a1,a5,a7
 300e676:	01151533          	sll	a0,a0,a7
 300e67a:	01c5e5b3          	or	a1,a1,t3
 300e67e:	00a03533          	snez	a0,a0
 300e682:	8d4d                	or	a0,a0,a1
 300e684:	00c7d633          	srl	a2,a5,a2
 300e688:	40a30533          	sub	a0,t1,a0
 300e68c:	40c707b3          	sub	a5,a4,a2
 300e690:	00a33733          	sltu	a4,t1,a0
 300e694:	40e78733          	sub	a4,a5,a4
 300e698:	832a                	mv	t1,a0
 300e69a:	b751                	j	300e61e <__adddf3+0x4f2>
 300e69c:	02000e13          	li	t3,32
 300e6a0:	00c7d5b3          	srl	a1,a5,a2
 300e6a4:	4881                	li	a7,0
 300e6a6:	01c60863          	beq	a2,t3,300e6b6 <__adddf3+0x58a>
 300e6aa:	04000893          	li	a7,64
 300e6ae:	40c88633          	sub	a2,a7,a2
 300e6b2:	00c798b3          	sll	a7,a5,a2
 300e6b6:	00a8e533          	or	a0,a7,a0
 300e6ba:	00a03533          	snez	a0,a0
 300e6be:	8d4d                	or	a0,a0,a1
 300e6c0:	4601                	li	a2,0
 300e6c2:	b7d9                	j	300e688 <__adddf3+0x55c>
 300e6c4:	8d5d                	or	a0,a0,a5
 300e6c6:	00a03533          	snez	a0,a0
 300e6ca:	bfdd                	j	300e6c0 <__adddf3+0x594>
 300e6cc:	00198613          	addi	a2,s3,1
 300e6d0:	7ff67613          	andi	a2,a2,2047
 300e6d4:	4585                	li	a1,1
 300e6d6:	10c5c063          	blt	a1,a2,300e7d6 <__adddf3+0x6aa>
 300e6da:	00a7e5b3          	or	a1,a5,a0
 300e6de:	00676633          	or	a2,a4,t1
 300e6e2:	0a099563          	bnez	s3,300e78c <__adddf3+0x660>
 300e6e6:	e1ad                	bnez	a1,300e748 <__adddf3+0x61c>
 300e6e8:	1c061763          	bnez	a2,300e8b6 <__adddf3+0x78a>
 300e6ec:	ffe48913          	addi	s2,s1,-2
 300e6f0:	00193913          	seqz	s2,s2
 300e6f4:	4701                	li	a4,0
 300e6f6:	4501                	li	a0,0
 300e6f8:	00e567b3          	or	a5,a0,a4
 300e6fc:	20078f63          	beqz	a5,300e91a <__adddf3+0x7ee>
 300e700:	01f55793          	srli	a5,a0,0x1f
 300e704:	00171e13          	slli	t3,a4,0x1
 300e708:	9e3e                	add	t3,t3,a5
 300e70a:	00151793          	slli	a5,a0,0x1
 300e70e:	0077f693          	andi	a3,a5,7
 300e712:	4881                	li	a7,0
 300e714:	c28d                	beqz	a3,300e736 <__adddf3+0x60a>
 300e716:	4689                	li	a3,2
 300e718:	1ad48f63          	beq	s1,a3,300e8d6 <__adddf3+0x7aa>
 300e71c:	468d                	li	a3,3
 300e71e:	1ad48363          	beq	s1,a3,300e8c4 <__adddf3+0x798>
 300e722:	4885                	li	a7,1
 300e724:	e889                	bnez	s1,300e736 <__adddf3+0x60a>
 300e726:	00f7f693          	andi	a3,a5,15
 300e72a:	4611                	li	a2,4
 300e72c:	4885                	li	a7,1
 300e72e:	ffc7b793          	sltiu	a5,a5,-4
 300e732:	18c69e63          	bne	a3,a2,300e8ce <__adddf3+0x7a2>
 300e736:	018e5e13          	srli	t3,t3,0x18
 300e73a:	001e4e13          	xori	t3,t3,1
 300e73e:	001e7e13          	andi	t3,t3,1
 300e742:	87ba                	mv	a5,a4
 300e744:	4801                	li	a6,0
 300e746:	b9a1                	j	300e39e <__adddf3+0x272>
 300e748:	16060963          	beqz	a2,300e8ba <__adddf3+0x78e>
 300e74c:	406505b3          	sub	a1,a0,t1
 300e750:	40e78633          	sub	a2,a5,a4
 300e754:	00b53833          	sltu	a6,a0,a1
 300e758:	41060633          	sub	a2,a2,a6
 300e75c:	00861413          	slli	s0,a2,0x8
 300e760:	00045c63          	bgez	s0,300e778 <__adddf3+0x64c>
 300e764:	40a30533          	sub	a0,t1,a0
 300e768:	40f707b3          	sub	a5,a4,a5
 300e76c:	00a33733          	sltu	a4,t1,a0
 300e770:	40e78733          	sub	a4,a5,a4
 300e774:	8936                	mv	s2,a3
 300e776:	b749                	j	300e6f8 <__adddf3+0x5cc>
 300e778:	00c5e533          	or	a0,a1,a2
 300e77c:	14051163          	bnez	a0,300e8be <__adddf3+0x792>
 300e780:	ffe48913          	addi	s2,s1,-2
 300e784:	00193913          	seqz	s2,s2
 300e788:	4701                	li	a4,0
 300e78a:	b7bd                	j	300e6f8 <__adddf3+0x5cc>
 300e78c:	7ff00e93          	li	t4,2047
 300e790:	03d99c63          	bne	s3,t4,300e7c8 <__adddf3+0x69c>
 300e794:	1c058263          	beqz	a1,300e958 <__adddf3+0x82c>
 300e798:	004008b7          	lui	a7,0x400
 300e79c:	0117f8b3          	and	a7,a5,a7
 300e7a0:	0018b893          	seqz	a7,a7
 300e7a4:	0892                	slli	a7,a7,0x4
 300e7a6:	03381663          	bne	a6,s3,300e7d2 <__adddf3+0x6a6>
 300e7aa:	c611                	beqz	a2,300e7b6 <__adddf3+0x68a>
 300e7ac:	00971413          	slli	s0,a4,0x9
 300e7b0:	00044363          	bltz	s0,300e7b6 <__adddf3+0x68a>
 300e7b4:	48c1                	li	a7,16
 300e7b6:	ed91                	bnez	a1,300e7d2 <__adddf3+0x6a6>
 300e7b8:	14060963          	beqz	a2,300e90a <__adddf3+0x7de>
 300e7bc:	87ba                	mv	a5,a4
 300e7be:	851a                	mv	a0,t1
 300e7c0:	8936                	mv	s2,a3
 300e7c2:	7ff00813          	li	a6,2047
 300e7c6:	bee1                	j	300e39e <__adddf3+0x272>
 300e7c8:	4881                	li	a7,0
 300e7ca:	ffd816e3          	bne	a6,t4,300e7b6 <__adddf3+0x68a>
 300e7ce:	4881                	li	a7,0
 300e7d0:	bfe9                	j	300e7aa <__adddf3+0x67e>
 300e7d2:	da65                	beqz	a2,300e7c2 <__adddf3+0x696>
 300e7d4:	b931                	j	300e3f0 <__adddf3+0x2c4>
 300e7d6:	40650a33          	sub	s4,a0,t1
 300e7da:	01453633          	sltu	a2,a0,s4
 300e7de:	40e78433          	sub	s0,a5,a4
 300e7e2:	8c11                	sub	s0,s0,a2
 300e7e4:	00841613          	slli	a2,s0,0x8
 300e7e8:	06065a63          	bgez	a2,300e85c <__adddf3+0x730>
 300e7ec:	40a30a33          	sub	s4,t1,a0
 300e7f0:	40f707b3          	sub	a5,a4,a5
 300e7f4:	01433733          	sltu	a4,t1,s4
 300e7f8:	40e78433          	sub	s0,a5,a4
 300e7fc:	8936                	mv	s2,a3
 300e7fe:	c03d                	beqz	s0,300e864 <__adddf3+0x738>
 300e800:	8522                	mv	a0,s0
 300e802:	39f010ef          	jal	ra,30103a0 <__clzsi2>
 300e806:	ff850813          	addi	a6,a0,-8
 300e80a:	47fd                	li	a5,31
 300e80c:	0707c263          	blt	a5,a6,300e870 <__adddf3+0x744>
 300e810:	02000713          	li	a4,32
 300e814:	41070733          	sub	a4,a4,a6
 300e818:	01041433          	sll	s0,s0,a6
 300e81c:	00ea5733          	srl	a4,s4,a4
 300e820:	008767b3          	or	a5,a4,s0
 300e824:	010a1333          	sll	t1,s4,a6
 300e828:	07384e63          	blt	a6,s3,300e8a4 <__adddf3+0x778>
 300e82c:	41380833          	sub	a6,a6,s3
 300e830:	00180713          	addi	a4,a6,1 # 80000001 <RAM_END+0x7bff8001>
 300e834:	46fd                	li	a3,31
 300e836:	04e6c363          	blt	a3,a4,300e87c <__adddf3+0x750>
 300e83a:	02000693          	li	a3,32
 300e83e:	8e99                	sub	a3,a3,a4
 300e840:	00e35633          	srl	a2,t1,a4
 300e844:	00d79533          	sll	a0,a5,a3
 300e848:	00d31333          	sll	t1,t1,a3
 300e84c:	8d51                	or	a0,a0,a2
 300e84e:	00603333          	snez	t1,t1
 300e852:	00656533          	or	a0,a0,t1
 300e856:	00e7d733          	srl	a4,a5,a4
 300e85a:	bd79                	j	300e6f8 <__adddf3+0x5cc>
 300e85c:	008a6533          	or	a0,s4,s0
 300e860:	fd59                	bnez	a0,300e7fe <__adddf3+0x6d2>
 300e862:	bf39                	j	300e780 <__adddf3+0x654>
 300e864:	8552                	mv	a0,s4
 300e866:	33b010ef          	jal	ra,30103a0 <__clzsi2>
 300e86a:	02050513          	addi	a0,a0,32
 300e86e:	bf61                	j	300e806 <__adddf3+0x6da>
 300e870:	fd850413          	addi	s0,a0,-40
 300e874:	008a17b3          	sll	a5,s4,s0
 300e878:	4301                	li	t1,0
 300e87a:	b77d                	j	300e828 <__adddf3+0x6fc>
 300e87c:	1805                	addi	a6,a6,-31
 300e87e:	02000693          	li	a3,32
 300e882:	0107d833          	srl	a6,a5,a6
 300e886:	4601                	li	a2,0
 300e888:	00d70763          	beq	a4,a3,300e896 <__adddf3+0x76a>
 300e88c:	04000613          	li	a2,64
 300e890:	8e19                	sub	a2,a2,a4
 300e892:	00c79633          	sll	a2,a5,a2
 300e896:	00c36533          	or	a0,t1,a2
 300e89a:	00a03533          	snez	a0,a0
 300e89e:	00a86533          	or	a0,a6,a0
 300e8a2:	b5dd                	j	300e788 <__adddf3+0x65c>
 300e8a4:	ff800737          	lui	a4,0xff800
 300e8a8:	fff70513          	addi	a0,a4,-1 # ff7fffff <RAM_END+0xfb7f7fff>
 300e8ac:	41098833          	sub	a6,s3,a6
 300e8b0:	00a7f733          	and	a4,a5,a0
 300e8b4:	b2ed                	j	300e29e <__adddf3+0x172>
 300e8b6:	851a                	mv	a0,t1
 300e8b8:	bd75                	j	300e774 <__adddf3+0x648>
 300e8ba:	873e                	mv	a4,a5
 300e8bc:	bd35                	j	300e6f8 <__adddf3+0x5cc>
 300e8be:	8732                	mv	a4,a2
 300e8c0:	852e                	mv	a0,a1
 300e8c2:	bd1d                	j	300e6f8 <__adddf3+0x5cc>
 300e8c4:	4885                	li	a7,1
 300e8c6:	e60918e3          	bnez	s2,300e736 <__adddf3+0x60a>
 300e8ca:	ff87b793          	sltiu	a5,a5,-8
 300e8ce:	0017c793          	xori	a5,a5,1
 300e8d2:	9e3e                	add	t3,t3,a5
 300e8d4:	b58d                	j	300e736 <__adddf3+0x60a>
 300e8d6:	4885                	li	a7,1
 300e8d8:	e4090fe3          	beqz	s2,300e736 <__adddf3+0x60a>
 300e8dc:	b7fd                	j	300e8ca <__adddf3+0x79e>
 300e8de:	87ba                	mv	a5,a4
 300e8e0:	851a                	mv	a0,t1
 300e8e2:	b5c5                	j	300e7c2 <__adddf3+0x696>
 300e8e4:	4781                	li	a5,0
 300e8e6:	4501                	li	a0,0
 300e8e8:	7ff00813          	li	a6,2047
 300e8ec:	4881                	li	a7,0
 300e8ee:	b639                	j	300e3fc <__adddf3+0x2d0>
 300e8f0:	4781                	li	a5,0
 300e8f2:	bfed                	j	300e8ec <__adddf3+0x7c0>
 300e8f4:	87ba                	mv	a5,a4
 300e8f6:	851a                	mv	a0,t1
 300e8f8:	4e01                	li	t3,0
 300e8fa:	b229                	j	300e204 <__adddf3+0xd8>
 300e8fc:	4781                	li	a5,0
 300e8fe:	8936                	mv	s2,a3
 300e900:	b7f5                	j	300e8ec <__adddf3+0x7c0>
 300e902:	87ba                	mv	a5,a4
 300e904:	851a                	mv	a0,t1
 300e906:	8936                	mv	s2,a3
 300e908:	bfc5                	j	300e8f8 <__adddf3+0x7cc>
 300e90a:	4501                	li	a0,0
 300e90c:	004007b7          	lui	a5,0x400
 300e910:	7ff00813          	li	a6,2047
 300e914:	4901                	li	s2,0
 300e916:	48c1                	li	a7,16
 300e918:	b4d5                	j	300e3fc <__adddf3+0x2d0>
 300e91a:	4501                	li	a0,0
 300e91c:	4801                	li	a6,0
 300e91e:	b7f9                	j	300e8ec <__adddf3+0x7c0>
 300e920:	a80913e3          	bnez	s2,300e3a6 <__adddf3+0x27a>
 300e924:	00850713          	addi	a4,a0,8
 300e928:	be75                	j	300e4e4 <__adddf3+0x3b8>
 300e92a:	a6090ee3          	beqz	s2,300e3a6 <__adddf3+0x27a>
 300e92e:	bfdd                	j	300e924 <__adddf3+0x7f8>
 300e930:	4501                	li	a0,0
 300e932:	cc99                	beqz	s1,300e950 <__adddf3+0x824>
 300e934:	478d                	li	a5,3
 300e936:	00f49863          	bne	s1,a5,300e946 <__adddf3+0x81a>
 300e93a:	00090b63          	beqz	s2,300e950 <__adddf3+0x824>
 300e93e:	557d                	li	a0,-1
 300e940:	7fe00813          	li	a6,2046
 300e944:	a031                	j	300e950 <__adddf3+0x824>
 300e946:	4789                	li	a5,2
 300e948:	fef49be3          	bne	s1,a5,300e93e <__adddf3+0x812>
 300e94c:	fe0909e3          	beqz	s2,300e93e <__adddf3+0x812>
 300e950:	0058e893          	ori	a7,a7,5
 300e954:	87aa                	mv	a5,a0
 300e956:	b4c1                	j	300e416 <__adddf3+0x2ea>
 300e958:	4881                	li	a7,0
 300e95a:	e5381fe3          	bne	a6,s3,300e7b8 <__adddf3+0x68c>
 300e95e:	bd85                	j	300e7ce <__adddf3+0x6a2>
 300e960:	b33801e3          	beq	a6,s3,300e482 <__adddf3+0x356>
 300e964:	87ba                	mv	a5,a4
 300e966:	851a                	mv	a0,t1
 300e968:	7ff00813          	li	a6,2047
 300e96c:	be35                	j	300e4a8 <__adddf3+0x37c>

0300e96e <__divdf3>:
 300e96e:	7179                	addi	sp,sp,-48
 300e970:	d422                	sw	s0,40(sp)
 300e972:	ca56                	sw	s5,20(sp)
 300e974:	c266                	sw	s9,4(sp)
 300e976:	d606                	sw	ra,44(sp)
 300e978:	d226                	sw	s1,36(sp)
 300e97a:	d04a                	sw	s2,32(sp)
 300e97c:	ce4e                	sw	s3,28(sp)
 300e97e:	cc52                	sw	s4,24(sp)
 300e980:	c85a                	sw	s6,16(sp)
 300e982:	c65e                	sw	s7,12(sp)
 300e984:	c462                	sw	s8,8(sp)
 300e986:	842a                	mv	s0,a0
 300e988:	8cb2                	mv	s9,a2
 300e98a:	8ab6                	mv	s5,a3
 300e98c:	002029f3          	frrm	s3
 300e990:	00100bb7          	lui	s7,0x100
 300e994:	84aa                	mv	s1,a0
 300e996:	0145d513          	srli	a0,a1,0x14
 300e99a:	1bfd                	addi	s7,s7,-1 # fffff <FLASH_SIZE+0xe0003>
 300e99c:	7ff57513          	andi	a0,a0,2047
 300e9a0:	00bbfbb3          	and	s7,s7,a1
 300e9a4:	01f5da13          	srli	s4,a1,0x1f
 300e9a8:	c50d                	beqz	a0,300e9d2 <__divdf3+0x64>
 300e9aa:	7ff00793          	li	a5,2047
 300e9ae:	06f50c63          	beq	a0,a5,300ea26 <__divdf3+0xb8>
 300e9b2:	008007b7          	lui	a5,0x800
 300e9b6:	0b8e                	slli	s7,s7,0x3
 300e9b8:	00fbebb3          	or	s7,s7,a5
 300e9bc:	01d45793          	srli	a5,s0,0x1d
 300e9c0:	0177ebb3          	or	s7,a5,s7
 300e9c4:	00341493          	slli	s1,s0,0x3
 300e9c8:	c0150b13          	addi	s6,a0,-1023
 300e9cc:	4c01                	li	s8,0
 300e9ce:	4901                	li	s2,0
 300e9d0:	a0b5                	j	300ea3c <__divdf3+0xce>
 300e9d2:	008be7b3          	or	a5,s7,s0
 300e9d6:	c7e1                	beqz	a5,300ea9e <__divdf3+0x130>
 300e9d8:	020b8b63          	beqz	s7,300ea0e <__divdf3+0xa0>
 300e9dc:	855e                	mv	a0,s7
 300e9de:	1c3010ef          	jal	ra,30103a0 <__clzsi2>
 300e9e2:	ff550693          	addi	a3,a0,-11
 300e9e6:	47f1                	li	a5,28
 300e9e8:	02d7c963          	blt	a5,a3,300ea1a <__divdf3+0xac>
 300e9ec:	4775                	li	a4,29
 300e9ee:	ff850493          	addi	s1,a0,-8
 300e9f2:	8f15                	sub	a4,a4,a3
 300e9f4:	009b9bb3          	sll	s7,s7,s1
 300e9f8:	00e45733          	srl	a4,s0,a4
 300e9fc:	01776bb3          	or	s7,a4,s7
 300ea00:	009414b3          	sll	s1,s0,s1
 300ea04:	c0d00b13          	li	s6,-1011
 300ea08:	40ab0b33          	sub	s6,s6,a0
 300ea0c:	b7c1                	j	300e9cc <__divdf3+0x5e>
 300ea0e:	8522                	mv	a0,s0
 300ea10:	191010ef          	jal	ra,30103a0 <__clzsi2>
 300ea14:	02050513          	addi	a0,a0,32
 300ea18:	b7e9                	j	300e9e2 <__divdf3+0x74>
 300ea1a:	fd850b93          	addi	s7,a0,-40
 300ea1e:	01741bb3          	sll	s7,s0,s7
 300ea22:	4481                	li	s1,0
 300ea24:	b7c5                	j	300ea04 <__divdf3+0x96>
 300ea26:	008be433          	or	s0,s7,s0
 300ea2a:	cc3d                	beqz	s0,300eaa8 <__divdf3+0x13a>
 300ea2c:	00cb9793          	slli	a5,s7,0xc
 300ea30:	7ff00b13          	li	s6,2047
 300ea34:	4c0d                	li	s8,3
 300ea36:	4941                	li	s2,16
 300ea38:	f807cbe3          	bltz	a5,300e9ce <__divdf3+0x60>
 300ea3c:	014ad513          	srli	a0,s5,0x14
 300ea40:	00100437          	lui	s0,0x100
 300ea44:	147d                	addi	s0,s0,-1 # fffff <FLASH_SIZE+0xe0003>
 300ea46:	7ff57513          	andi	a0,a0,2047
 300ea4a:	01547433          	and	s0,s0,s5
 300ea4e:	87e6                	mv	a5,s9
 300ea50:	01fada93          	srli	s5,s5,0x1f
 300ea54:	c125                	beqz	a0,300eab4 <__divdf3+0x146>
 300ea56:	7ff00713          	li	a4,2047
 300ea5a:	0ae50563          	beq	a0,a4,300eb04 <__divdf3+0x196>
 300ea5e:	008007b7          	lui	a5,0x800
 300ea62:	040e                	slli	s0,s0,0x3
 300ea64:	8c5d                	or	s0,s0,a5
 300ea66:	01dcd793          	srli	a5,s9,0x1d
 300ea6a:	8c5d                	or	s0,s0,a5
 300ea6c:	c0150513          	addi	a0,a0,-1023
 300ea70:	003c9793          	slli	a5,s9,0x3
 300ea74:	4701                	li	a4,0
 300ea76:	002c1693          	slli	a3,s8,0x2
 300ea7a:	8ed9                	or	a3,a3,a4
 300ea7c:	16fd                	addi	a3,a3,-1 # 7fffff <FLASH_SIZE+0x7e0003>
 300ea7e:	4639                	li	a2,14
 300ea80:	015a4833          	xor	a6,s4,s5
 300ea84:	40ab0533          	sub	a0,s6,a0
 300ea88:	0ad66763          	bltu	a2,a3,300eb36 <__divdf3+0x1c8>
 300ea8c:	00002617          	auipc	a2,0x2
 300ea90:	67c60613          	addi	a2,a2,1660 # 3011108 <g_crgIpMatch+0xbf8>
 300ea94:	068a                	slli	a3,a3,0x2
 300ea96:	96b2                	add	a3,a3,a2
 300ea98:	4294                	lw	a3,0(a3)
 300ea9a:	96b2                	add	a3,a3,a2
 300ea9c:	8682                	jr	a3
 300ea9e:	4b81                	li	s7,0
 300eaa0:	4481                	li	s1,0
 300eaa2:	4b01                	li	s6,0
 300eaa4:	4c05                	li	s8,1
 300eaa6:	b725                	j	300e9ce <__divdf3+0x60>
 300eaa8:	4b81                	li	s7,0
 300eaaa:	4481                	li	s1,0
 300eaac:	7ff00b13          	li	s6,2047
 300eab0:	4c09                	li	s8,2
 300eab2:	bf31                	j	300e9ce <__divdf3+0x60>
 300eab4:	019467b3          	or	a5,s0,s9
 300eab8:	c3b5                	beqz	a5,300eb1c <__divdf3+0x1ae>
 300eaba:	c80d                	beqz	s0,300eaec <__divdf3+0x17e>
 300eabc:	8522                	mv	a0,s0
 300eabe:	0e3010ef          	jal	ra,30103a0 <__clzsi2>
 300eac2:	ff550693          	addi	a3,a0,-11
 300eac6:	47f1                	li	a5,28
 300eac8:	02d7c863          	blt	a5,a3,300eaf8 <__divdf3+0x18a>
 300eacc:	4775                	li	a4,29
 300eace:	ff850793          	addi	a5,a0,-8
 300ead2:	8f15                	sub	a4,a4,a3
 300ead4:	00f41433          	sll	s0,s0,a5
 300ead8:	00ecd733          	srl	a4,s9,a4
 300eadc:	8c59                	or	s0,s0,a4
 300eade:	00fc97b3          	sll	a5,s9,a5
 300eae2:	c0d00713          	li	a4,-1011
 300eae6:	40a70533          	sub	a0,a4,a0
 300eaea:	b769                	j	300ea74 <__divdf3+0x106>
 300eaec:	8566                	mv	a0,s9
 300eaee:	0b3010ef          	jal	ra,30103a0 <__clzsi2>
 300eaf2:	02050513          	addi	a0,a0,32
 300eaf6:	b7f1                	j	300eac2 <__divdf3+0x154>
 300eaf8:	fd850413          	addi	s0,a0,-40
 300eafc:	008c9433          	sll	s0,s9,s0
 300eb00:	4781                	li	a5,0
 300eb02:	b7c5                	j	300eae2 <__divdf3+0x174>
 300eb04:	01946633          	or	a2,s0,s9
 300eb08:	ce19                	beqz	a2,300eb26 <__divdf3+0x1b8>
 300eb0a:	00c41713          	slli	a4,s0,0xc
 300eb0e:	7ff00513          	li	a0,2047
 300eb12:	02074063          	bltz	a4,300eb32 <__divdf3+0x1c4>
 300eb16:	470d                	li	a4,3
 300eb18:	4941                	li	s2,16
 300eb1a:	bfb1                	j	300ea76 <__divdf3+0x108>
 300eb1c:	4401                	li	s0,0
 300eb1e:	4781                	li	a5,0
 300eb20:	4501                	li	a0,0
 300eb22:	4705                	li	a4,1
 300eb24:	bf89                	j	300ea76 <__divdf3+0x108>
 300eb26:	4401                	li	s0,0
 300eb28:	4781                	li	a5,0
 300eb2a:	7ff00513          	li	a0,2047
 300eb2e:	4709                	li	a4,2
 300eb30:	b799                	j	300ea76 <__divdf3+0x108>
 300eb32:	470d                	li	a4,3
 300eb34:	b789                	j	300ea76 <__divdf3+0x108>
 300eb36:	01746663          	bltu	s0,s7,300eb42 <__divdf3+0x1d4>
 300eb3a:	268b9463          	bne	s7,s0,300eda2 <__divdf3+0x434>
 300eb3e:	26f4e263          	bltu	s1,a5,300eda2 <__divdf3+0x434>
 300eb42:	01fb9693          	slli	a3,s7,0x1f
 300eb46:	0014d713          	srli	a4,s1,0x1
 300eb4a:	01f49593          	slli	a1,s1,0x1f
 300eb4e:	001bdb93          	srli	s7,s7,0x1
 300eb52:	00e6e4b3          	or	s1,a3,a4
 300eb56:	0187d693          	srli	a3,a5,0x18
 300eb5a:	0422                	slli	s0,s0,0x8
 300eb5c:	8ec1                	or	a3,a3,s0
 300eb5e:	0106de93          	srli	t4,a3,0x10
 300eb62:	03dbd333          	divu	t1,s7,t4
 300eb66:	01069e13          	slli	t3,a3,0x10
 300eb6a:	010e5e13          	srli	t3,t3,0x10
 300eb6e:	00879613          	slli	a2,a5,0x8
 300eb72:	0104d793          	srli	a5,s1,0x10
 300eb76:	03dbfbb3          	remu	s7,s7,t4
 300eb7a:	889a                	mv	a7,t1
 300eb7c:	026e0733          	mul	a4,t3,t1
 300eb80:	0bc2                	slli	s7,s7,0x10
 300eb82:	0177e7b3          	or	a5,a5,s7
 300eb86:	00e7fc63          	bgeu	a5,a4,300eb9e <__divdf3+0x230>
 300eb8a:	97b6                	add	a5,a5,a3
 300eb8c:	fff30893          	addi	a7,t1,-1
 300eb90:	00d7e763          	bltu	a5,a3,300eb9e <__divdf3+0x230>
 300eb94:	00e7f563          	bgeu	a5,a4,300eb9e <__divdf3+0x230>
 300eb98:	ffe30893          	addi	a7,t1,-2
 300eb9c:	97b6                	add	a5,a5,a3
 300eb9e:	8f99                	sub	a5,a5,a4
 300eba0:	03d7df33          	divu	t5,a5,t4
 300eba4:	01049713          	slli	a4,s1,0x10
 300eba8:	8341                	srli	a4,a4,0x10
 300ebaa:	03d7f7b3          	remu	a5,a5,t4
 300ebae:	84fa                	mv	s1,t5
 300ebb0:	03ee0333          	mul	t1,t3,t5
 300ebb4:	07c2                	slli	a5,a5,0x10
 300ebb6:	8f5d                	or	a4,a4,a5
 300ebb8:	00677c63          	bgeu	a4,t1,300ebd0 <__divdf3+0x262>
 300ebbc:	9736                	add	a4,a4,a3
 300ebbe:	ffff0493          	addi	s1,t5,-1
 300ebc2:	00d76763          	bltu	a4,a3,300ebd0 <__divdf3+0x262>
 300ebc6:	00677563          	bgeu	a4,t1,300ebd0 <__divdf3+0x262>
 300ebca:	ffef0493          	addi	s1,t5,-2
 300ebce:	9736                	add	a4,a4,a3
 300ebd0:	08c2                	slli	a7,a7,0x10
 300ebd2:	0098e4b3          	or	s1,a7,s1
 300ebd6:	68c1                	lui	a7,0x10
 300ebd8:	fff88f13          	addi	t5,a7,-1 # ffff <RAM_SIZE+0xafff>
 300ebdc:	0104d293          	srli	t0,s1,0x10
 300ebe0:	01065f93          	srli	t6,a2,0x10
 300ebe4:	40670733          	sub	a4,a4,t1
 300ebe8:	01e4f333          	and	t1,s1,t5
 300ebec:	01e67f33          	and	t5,a2,t5
 300ebf0:	03e307b3          	mul	a5,t1,t5
 300ebf4:	03e28433          	mul	s0,t0,t5
 300ebf8:	026f8333          	mul	t1,t6,t1
 300ebfc:	008303b3          	add	t2,t1,s0
 300ec00:	0107d313          	srli	t1,a5,0x10
 300ec04:	931e                	add	t1,t1,t2
 300ec06:	03f282b3          	mul	t0,t0,t6
 300ec0a:	00837363          	bgeu	t1,s0,300ec10 <__divdf3+0x2a2>
 300ec0e:	92c6                	add	t0,t0,a7
 300ec10:	63c1                	lui	t2,0x10
 300ec12:	01035893          	srli	a7,t1,0x10
 300ec16:	13fd                	addi	t2,t2,-1 # ffff <RAM_SIZE+0xafff>
 300ec18:	92c6                	add	t0,t0,a7
 300ec1a:	007378b3          	and	a7,t1,t2
 300ec1e:	08c2                	slli	a7,a7,0x10
 300ec20:	0077f7b3          	and	a5,a5,t2
 300ec24:	98be                	add	a7,a7,a5
 300ec26:	00576763          	bltu	a4,t0,300ec34 <__divdf3+0x2c6>
 300ec2a:	8426                	mv	s0,s1
 300ec2c:	02571e63          	bne	a4,t0,300ec68 <__divdf3+0x2fa>
 300ec30:	0315fc63          	bgeu	a1,a7,300ec68 <__divdf3+0x2fa>
 300ec34:	95b2                	add	a1,a1,a2
 300ec36:	00c5b7b3          	sltu	a5,a1,a2
 300ec3a:	97b6                	add	a5,a5,a3
 300ec3c:	973e                	add	a4,a4,a5
 300ec3e:	fff48413          	addi	s0,s1,-1
 300ec42:	00e6e663          	bltu	a3,a4,300ec4e <__divdf3+0x2e0>
 300ec46:	02e69163          	bne	a3,a4,300ec68 <__divdf3+0x2fa>
 300ec4a:	00c5ef63          	bltu	a1,a2,300ec68 <__divdf3+0x2fa>
 300ec4e:	00576663          	bltu	a4,t0,300ec5a <__divdf3+0x2ec>
 300ec52:	00e29b63          	bne	t0,a4,300ec68 <__divdf3+0x2fa>
 300ec56:	0115f963          	bgeu	a1,a7,300ec68 <__divdf3+0x2fa>
 300ec5a:	95b2                	add	a1,a1,a2
 300ec5c:	00c5b7b3          	sltu	a5,a1,a2
 300ec60:	97b6                	add	a5,a5,a3
 300ec62:	ffe48413          	addi	s0,s1,-2
 300ec66:	973e                	add	a4,a4,a5
 300ec68:	411588b3          	sub	a7,a1,a7
 300ec6c:	40570733          	sub	a4,a4,t0
 300ec70:	0115b5b3          	sltu	a1,a1,a7
 300ec74:	8f0d                	sub	a4,a4,a1
 300ec76:	57fd                	li	a5,-1
 300ec78:	0ee68863          	beq	a3,a4,300ed68 <__divdf3+0x3fa>
 300ec7c:	03d752b3          	divu	t0,a4,t4
 300ec80:	0108d793          	srli	a5,a7,0x10
 300ec84:	03d77733          	remu	a4,a4,t4
 300ec88:	8596                	mv	a1,t0
 300ec8a:	025e0333          	mul	t1,t3,t0
 300ec8e:	0742                	slli	a4,a4,0x10
 300ec90:	8f5d                	or	a4,a4,a5
 300ec92:	00677c63          	bgeu	a4,t1,300ecaa <__divdf3+0x33c>
 300ec96:	9736                	add	a4,a4,a3
 300ec98:	fff28593          	addi	a1,t0,-1
 300ec9c:	00d76763          	bltu	a4,a3,300ecaa <__divdf3+0x33c>
 300eca0:	00677563          	bgeu	a4,t1,300ecaa <__divdf3+0x33c>
 300eca4:	ffe28593          	addi	a1,t0,-2
 300eca8:	9736                	add	a4,a4,a3
 300ecaa:	40670733          	sub	a4,a4,t1
 300ecae:	03d75333          	divu	t1,a4,t4
 300ecb2:	01089793          	slli	a5,a7,0x10
 300ecb6:	83c1                	srli	a5,a5,0x10
 300ecb8:	03d77733          	remu	a4,a4,t4
 300ecbc:	026e0e33          	mul	t3,t3,t1
 300ecc0:	0742                	slli	a4,a4,0x10
 300ecc2:	8f5d                	or	a4,a4,a5
 300ecc4:	879a                	mv	a5,t1
 300ecc6:	01c77c63          	bgeu	a4,t3,300ecde <__divdf3+0x370>
 300ecca:	9736                	add	a4,a4,a3
 300eccc:	fff30793          	addi	a5,t1,-1
 300ecd0:	00d76763          	bltu	a4,a3,300ecde <__divdf3+0x370>
 300ecd4:	01c77563          	bgeu	a4,t3,300ecde <__divdf3+0x370>
 300ecd8:	ffe30793          	addi	a5,t1,-2
 300ecdc:	9736                	add	a4,a4,a3
 300ecde:	05c2                	slli	a1,a1,0x10
 300ece0:	41c70733          	sub	a4,a4,t3
 300ece4:	00f5ee33          	or	t3,a1,a5
 300ece8:	010e1793          	slli	a5,t3,0x10
 300ecec:	83c1                	srli	a5,a5,0x10
 300ecee:	010e5893          	srli	a7,t3,0x10
 300ecf2:	02ff0eb3          	mul	t4,t5,a5
 300ecf6:	031f8333          	mul	t1,t6,a7
 300ecfa:	03e88f33          	mul	t5,a7,t5
 300ecfe:	02ff8fb3          	mul	t6,t6,a5
 300ed02:	010ed793          	srli	a5,t4,0x10
 300ed06:	9ffa                	add	t6,t6,t5
 300ed08:	97fe                	add	a5,a5,t6
 300ed0a:	01e7f463          	bgeu	a5,t5,300ed12 <__divdf3+0x3a4>
 300ed0e:	65c1                	lui	a1,0x10
 300ed10:	932e                	add	t1,t1,a1
 300ed12:	0107d893          	srli	a7,a5,0x10
 300ed16:	989a                	add	a7,a7,t1
 300ed18:	6341                	lui	t1,0x10
 300ed1a:	137d                	addi	t1,t1,-1 # ffff <RAM_SIZE+0xafff>
 300ed1c:	0067f5b3          	and	a1,a5,t1
 300ed20:	05c2                	slli	a1,a1,0x10
 300ed22:	006efeb3          	and	t4,t4,t1
 300ed26:	95f6                	add	a1,a1,t4
 300ed28:	01176663          	bltu	a4,a7,300ed34 <__divdf3+0x3c6>
 300ed2c:	87f2                	mv	a5,t3
 300ed2e:	03171b63          	bne	a4,a7,300ed64 <__divdf3+0x3f6>
 300ed32:	c99d                	beqz	a1,300ed68 <__divdf3+0x3fa>
 300ed34:	9736                	add	a4,a4,a3
 300ed36:	fffe0793          	addi	a5,t3,-1
 300ed3a:	02d76163          	bltu	a4,a3,300ed5c <__divdf3+0x3ee>
 300ed3e:	01176663          	bltu	a4,a7,300ed4a <__divdf3+0x3dc>
 300ed42:	03171163          	bne	a4,a7,300ed64 <__divdf3+0x3f6>
 300ed46:	00b67d63          	bgeu	a2,a1,300ed60 <__divdf3+0x3f2>
 300ed4a:	00161313          	slli	t1,a2,0x1
 300ed4e:	00c33633          	sltu	a2,t1,a2
 300ed52:	96b2                	add	a3,a3,a2
 300ed54:	ffee0793          	addi	a5,t3,-2
 300ed58:	9736                	add	a4,a4,a3
 300ed5a:	861a                	mv	a2,t1
 300ed5c:	01171463          	bne	a4,a7,300ed64 <__divdf3+0x3f6>
 300ed60:	00c58463          	beq	a1,a2,300ed68 <__divdf3+0x3fa>
 300ed64:	0017e793          	ori	a5,a5,1
 300ed68:	3ff50613          	addi	a2,a0,1023
 300ed6c:	12c05763          	blez	a2,300ee9a <__divdf3+0x52c>
 300ed70:	0077f713          	andi	a4,a5,7
 300ed74:	c771                	beqz	a4,300ee40 <__divdf3+0x4d2>
 300ed76:	4709                	li	a4,2
 300ed78:	00196913          	ori	s2,s2,1
 300ed7c:	0ce98063          	beq	s3,a4,300ee3c <__divdf3+0x4ce>
 300ed80:	470d                	li	a4,3
 300ed82:	0ae98863          	beq	s3,a4,300ee32 <__divdf3+0x4c4>
 300ed86:	0a099d63          	bnez	s3,300ee40 <__divdf3+0x4d2>
 300ed8a:	00f7f713          	andi	a4,a5,15
 300ed8e:	4691                	li	a3,4
 300ed90:	0ad70863          	beq	a4,a3,300ee40 <__divdf3+0x4d2>
 300ed94:	00478713          	addi	a4,a5,4 # 800004 <FLASH_SIZE+0x7e0008>
 300ed98:	00f737b3          	sltu	a5,a4,a5
 300ed9c:	943e                	add	s0,s0,a5
 300ed9e:	87ba                	mv	a5,a4
 300eda0:	a045                	j	300ee40 <__divdf3+0x4d2>
 300eda2:	157d                	addi	a0,a0,-1
 300eda4:	4581                	li	a1,0
 300eda6:	bb45                	j	300eb56 <__divdf3+0x1e8>
 300eda8:	8852                	mv	a6,s4
 300edaa:	845e                	mv	s0,s7
 300edac:	87a6                	mv	a5,s1
 300edae:	8762                	mv	a4,s8
 300edb0:	4689                	li	a3,2
 300edb2:	00d70f63          	beq	a4,a3,300edd0 <__divdf3+0x462>
 300edb6:	468d                	li	a3,3
 300edb8:	22d70b63          	beq	a4,a3,300efee <__divdf3+0x680>
 300edbc:	4685                	li	a3,1
 300edbe:	fad715e3          	bne	a4,a3,300ed68 <__divdf3+0x3fa>
 300edc2:	4401                	li	s0,0
 300edc4:	4781                	li	a5,0
 300edc6:	ac09                	j	300efd8 <__divdf3+0x66a>
 300edc8:	8856                	mv	a6,s5
 300edca:	b7dd                	j	300edb0 <__divdf3+0x442>
 300edcc:	00896913          	ori	s2,s2,8
 300edd0:	4401                	li	s0,0
 300edd2:	4781                	li	a5,0
 300edd4:	7ff00613          	li	a2,2047
 300edd8:	00100737          	lui	a4,0x100
 300eddc:	177d                	addi	a4,a4,-1 # fffff <FLASH_SIZE+0xe0003>
 300edde:	8c79                	and	s0,s0,a4
 300ede0:	80100737          	lui	a4,0x80100
 300ede4:	177d                	addi	a4,a4,-1 # 800fffff <RAM_END+0x7c0f7fff>
 300ede6:	7ff67693          	andi	a3,a2,2047
 300edea:	8c79                	and	s0,s0,a4
 300edec:	06d2                	slli	a3,a3,0x14
 300edee:	80000737          	lui	a4,0x80000
 300edf2:	fff74713          	not	a4,a4
 300edf6:	8c55                	or	s0,s0,a3
 300edf8:	087e                	slli	a6,a6,0x1f
 300edfa:	8c79                	and	s0,s0,a4
 300edfc:	01046733          	or	a4,s0,a6
 300ee00:	853e                	mv	a0,a5
 300ee02:	85ba                	mv	a1,a4
 300ee04:	00090463          	beqz	s2,300ee0c <__divdf3+0x49e>
 300ee08:	00192073          	csrs	fflags,s2
 300ee0c:	50b2                	lw	ra,44(sp)
 300ee0e:	5422                	lw	s0,40(sp)
 300ee10:	5492                	lw	s1,36(sp)
 300ee12:	5902                	lw	s2,32(sp)
 300ee14:	49f2                	lw	s3,28(sp)
 300ee16:	4a62                	lw	s4,24(sp)
 300ee18:	4ad2                	lw	s5,20(sp)
 300ee1a:	4b42                	lw	s6,16(sp)
 300ee1c:	4bb2                	lw	s7,12(sp)
 300ee1e:	4c22                	lw	s8,8(sp)
 300ee20:	4c92                	lw	s9,4(sp)
 300ee22:	6145                	addi	sp,sp,48
 300ee24:	8082                	ret
 300ee26:	00080437          	lui	s0,0x80
 300ee2a:	4781                	li	a5,0
 300ee2c:	4801                	li	a6,0
 300ee2e:	470d                	li	a4,3
 300ee30:	b741                	j	300edb0 <__divdf3+0x442>
 300ee32:	00081763          	bnez	a6,300ee40 <__divdf3+0x4d2>
 300ee36:	00878713          	addi	a4,a5,8
 300ee3a:	bfb9                	j	300ed98 <__divdf3+0x42a>
 300ee3c:	fe081de3          	bnez	a6,300ee36 <__divdf3+0x4c8>
 300ee40:	00741713          	slli	a4,s0,0x7
 300ee44:	00075863          	bgez	a4,300ee54 <__divdf3+0x4e6>
 300ee48:	ff000737          	lui	a4,0xff000
 300ee4c:	177d                	addi	a4,a4,-1 # feffffff <RAM_END+0xfaff7fff>
 300ee4e:	8c79                	and	s0,s0,a4
 300ee50:	40050613          	addi	a2,a0,1024
 300ee54:	7fe00713          	li	a4,2046
 300ee58:	00c74963          	blt	a4,a2,300ee6a <__divdf3+0x4fc>
 300ee5c:	0037d713          	srli	a4,a5,0x3
 300ee60:	01d41793          	slli	a5,s0,0x1d
 300ee64:	8fd9                	or	a5,a5,a4
 300ee66:	800d                	srli	s0,s0,0x3
 300ee68:	bf85                	j	300edd8 <__divdf3+0x46a>
 300ee6a:	4789                	li	a5,2
 300ee6c:	02f98463          	beq	s3,a5,300ee94 <__divdf3+0x526>
 300ee70:	478d                	li	a5,3
 300ee72:	00f98b63          	beq	s3,a5,300ee88 <__divdf3+0x51a>
 300ee76:	00098b63          	beqz	s3,300ee8c <__divdf3+0x51e>
 300ee7a:	57fd                	li	a5,-1
 300ee7c:	7fe00613          	li	a2,2046
 300ee80:	00596913          	ori	s2,s2,5
 300ee84:	843e                	mv	s0,a5
 300ee86:	bf89                	j	300edd8 <__divdf3+0x46a>
 300ee88:	fe0819e3          	bnez	a6,300ee7a <__divdf3+0x50c>
 300ee8c:	4781                	li	a5,0
 300ee8e:	7ff00613          	li	a2,2047
 300ee92:	b7fd                	j	300ee80 <__divdf3+0x512>
 300ee94:	fe081ce3          	bnez	a6,300ee8c <__divdf3+0x51e>
 300ee98:	b7cd                	j	300ee7a <__divdf3+0x50c>
 300ee9a:	4585                	li	a1,1
 300ee9c:	ea29                	bnez	a2,300eeee <__divdf3+0x580>
 300ee9e:	0077f693          	andi	a3,a5,7
 300eea2:	8722                	mv	a4,s0
 300eea4:	c2a1                	beqz	a3,300eee4 <__divdf3+0x576>
 300eea6:	4709                	li	a4,2
 300eea8:	00196913          	ori	s2,s2,1
 300eeac:	02e98963          	beq	s3,a4,300eede <__divdf3+0x570>
 300eeb0:	470d                	li	a4,3
 300eeb2:	02e98063          	beq	s3,a4,300eed2 <__divdf3+0x564>
 300eeb6:	8722                	mv	a4,s0
 300eeb8:	02099663          	bnez	s3,300eee4 <__divdf3+0x576>
 300eebc:	00f7f693          	andi	a3,a5,15
 300eec0:	4591                	li	a1,4
 300eec2:	02b68163          	beq	a3,a1,300eee4 <__divdf3+0x576>
 300eec6:	ffc7b713          	sltiu	a4,a5,-4
 300eeca:	00174713          	xori	a4,a4,1
 300eece:	9722                	add	a4,a4,s0
 300eed0:	a811                	j	300eee4 <__divdf3+0x576>
 300eed2:	8722                	mv	a4,s0
 300eed4:	00081863          	bnez	a6,300eee4 <__divdf3+0x576>
 300eed8:	ff87b713          	sltiu	a4,a5,-8
 300eedc:	b7fd                	j	300eeca <__divdf3+0x55c>
 300eede:	8722                	mv	a4,s0
 300eee0:	fe081ce3          	bnez	a6,300eed8 <__divdf3+0x56a>
 300eee4:	8361                	srli	a4,a4,0x18
 300eee6:	00174713          	xori	a4,a4,1
 300eeea:	00177593          	andi	a1,a4,1
 300eeee:	4705                	li	a4,1
 300eef0:	8f11                	sub	a4,a4,a2
 300eef2:	03800693          	li	a3,56
 300eef6:	0ce6c063          	blt	a3,a4,300efb6 <__divdf3+0x648>
 300eefa:	46fd                	li	a3,31
 300eefc:	04e6c963          	blt	a3,a4,300ef4e <__divdf3+0x5e0>
 300ef00:	41e50513          	addi	a0,a0,1054
 300ef04:	00a416b3          	sll	a3,s0,a0
 300ef08:	00e7d633          	srl	a2,a5,a4
 300ef0c:	00a797b3          	sll	a5,a5,a0
 300ef10:	8ed1                	or	a3,a3,a2
 300ef12:	00f037b3          	snez	a5,a5
 300ef16:	8fd5                	or	a5,a5,a3
 300ef18:	00e45433          	srl	s0,s0,a4
 300ef1c:	0077f713          	andi	a4,a5,7
 300ef20:	c32d                	beqz	a4,300ef82 <__divdf3+0x614>
 300ef22:	4709                	li	a4,2
 300ef24:	00196913          	ori	s2,s2,1
 300ef28:	04e98b63          	beq	s3,a4,300ef7e <__divdf3+0x610>
 300ef2c:	470d                	li	a4,3
 300ef2e:	04e98363          	beq	s3,a4,300ef74 <__divdf3+0x606>
 300ef32:	04099863          	bnez	s3,300ef82 <__divdf3+0x614>
 300ef36:	00f7f713          	andi	a4,a5,15
 300ef3a:	4691                	li	a3,4
 300ef3c:	04d70363          	beq	a4,a3,300ef82 <__divdf3+0x614>
 300ef40:	00478713          	addi	a4,a5,4
 300ef44:	00f737b3          	sltu	a5,a4,a5
 300ef48:	943e                	add	s0,s0,a5
 300ef4a:	87ba                	mv	a5,a4
 300ef4c:	a81d                	j	300ef82 <__divdf3+0x614>
 300ef4e:	5685                	li	a3,-31
 300ef50:	8e91                	sub	a3,a3,a2
 300ef52:	02000893          	li	a7,32
 300ef56:	00d456b3          	srl	a3,s0,a3
 300ef5a:	4601                	li	a2,0
 300ef5c:	01170663          	beq	a4,a7,300ef68 <__divdf3+0x5fa>
 300ef60:	43e50513          	addi	a0,a0,1086
 300ef64:	00a41633          	sll	a2,s0,a0
 300ef68:	8fd1                	or	a5,a5,a2
 300ef6a:	00f037b3          	snez	a5,a5
 300ef6e:	8fd5                	or	a5,a5,a3
 300ef70:	4401                	li	s0,0
 300ef72:	b76d                	j	300ef1c <__divdf3+0x5ae>
 300ef74:	00081763          	bnez	a6,300ef82 <__divdf3+0x614>
 300ef78:	00878713          	addi	a4,a5,8
 300ef7c:	b7e1                	j	300ef44 <__divdf3+0x5d6>
 300ef7e:	fe081de3          	bnez	a6,300ef78 <__divdf3+0x60a>
 300ef82:	00841713          	slli	a4,s0,0x8
 300ef86:	02075063          	bgez	a4,300efa6 <__divdf3+0x638>
 300ef8a:	00196913          	ori	s2,s2,1
 300ef8e:	4401                	li	s0,0
 300ef90:	4781                	li	a5,0
 300ef92:	4605                	li	a2,1
 300ef94:	e40582e3          	beqz	a1,300edd8 <__divdf3+0x46a>
 300ef98:	00197713          	andi	a4,s2,1
 300ef9c:	e2070ee3          	beqz	a4,300edd8 <__divdf3+0x46a>
 300efa0:	00296913          	ori	s2,s2,2
 300efa4:	bd15                	j	300edd8 <__divdf3+0x46a>
 300efa6:	0037d713          	srli	a4,a5,0x3
 300efaa:	01d41793          	slli	a5,s0,0x1d
 300efae:	8fd9                	or	a5,a5,a4
 300efb0:	800d                	srli	s0,s0,0x3
 300efb2:	4601                	li	a2,0
 300efb4:	b7c5                	j	300ef94 <__divdf3+0x626>
 300efb6:	8fc1                	or	a5,a5,s0
 300efb8:	cf89                	beqz	a5,300efd2 <__divdf3+0x664>
 300efba:	4789                	li	a5,2
 300efbc:	00196913          	ori	s2,s2,1
 300efc0:	02f98363          	beq	s3,a5,300efe6 <__divdf3+0x678>
 300efc4:	478d                	li	a5,3
 300efc6:	00f98b63          	beq	s3,a5,300efdc <__divdf3+0x66e>
 300efca:	4795                	li	a5,5
 300efcc:	00099b63          	bnez	s3,300efe2 <__divdf3+0x674>
 300efd0:	838d                	srli	a5,a5,0x3
 300efd2:	00296913          	ori	s2,s2,2
 300efd6:	4401                	li	s0,0
 300efd8:	4601                	li	a2,0
 300efda:	bbfd                	j	300edd8 <__divdf3+0x46a>
 300efdc:	47a5                	li	a5,9
 300efde:	fe0809e3          	beqz	a6,300efd0 <__divdf3+0x662>
 300efe2:	4785                	li	a5,1
 300efe4:	b7f5                	j	300efd0 <__divdf3+0x662>
 300efe6:	47a5                	li	a5,9
 300efe8:	fe0814e3          	bnez	a6,300efd0 <__divdf3+0x662>
 300efec:	bfdd                	j	300efe2 <__divdf3+0x674>
 300efee:	00080437          	lui	s0,0x80
 300eff2:	4781                	li	a5,0
 300eff4:	7ff00613          	li	a2,2047
 300eff8:	4801                	li	a6,0
 300effa:	bbf9                	j	300edd8 <__divdf3+0x46a>
 300effc:	00080437          	lui	s0,0x80
 300f000:	4781                	li	a5,0
 300f002:	7ff00613          	li	a2,2047
 300f006:	4801                	li	a6,0
 300f008:	4941                	li	s2,16
 300f00a:	b3f9                	j	300edd8 <__divdf3+0x46a>

0300f00c <__gedf2>:
 300f00c:	002027f3          	frrm	a5
 300f010:	001007b7          	lui	a5,0x100
 300f014:	0145d713          	srli	a4,a1,0x14
 300f018:	17fd                	addi	a5,a5,-1 # fffff <FLASH_SIZE+0xe0003>
 300f01a:	0146d813          	srli	a6,a3,0x14
 300f01e:	7ff77713          	andi	a4,a4,2047
 300f022:	7ff00e93          	li	t4,2047
 300f026:	00b7f8b3          	and	a7,a5,a1
 300f02a:	832a                	mv	t1,a0
 300f02c:	8ff5                	and	a5,a5,a3
 300f02e:	81fd                	srli	a1,a1,0x1f
 300f030:	8e32                	mv	t3,a2
 300f032:	7ff87813          	andi	a6,a6,2047
 300f036:	82fd                	srli	a3,a3,0x1f
 300f038:	01d71a63          	bne	a4,t4,300f04c <__gedf2+0x40>
 300f03c:	00a8eeb3          	or	t4,a7,a0
 300f040:	060e8a63          	beqz	t4,300f0b4 <__gedf2+0xa8>
 300f044:	00186073          	csrsi	fflags,16
 300f048:	5579                	li	a0,-2
 300f04a:	8082                	ret
 300f04c:	01d81a63          	bne	a6,t4,300f060 <__gedf2+0x54>
 300f050:	8e5d                	or	a2,a2,a5
 300f052:	fa6d                	bnez	a2,300f044 <__gedf2+0x38>
 300f054:	e305                	bnez	a4,300f074 <__gedf2+0x68>
 300f056:	00a8e533          	or	a0,a7,a0
 300f05a:	00153513          	seqz	a0,a0
 300f05e:	a811                	j	300f072 <__gedf2+0x66>
 300f060:	ef21                	bnez	a4,300f0b8 <__gedf2+0xac>
 300f062:	00a8e533          	or	a0,a7,a0
 300f066:	00153513          	seqz	a0,a0
 300f06a:	00081463          	bnez	a6,300f072 <__gedf2+0x66>
 300f06e:	8e5d                	or	a2,a2,a5
 300f070:	c221                	beqz	a2,300f0b0 <__gedf2+0xa4>
 300f072:	e901                	bnez	a0,300f082 <__gedf2+0x76>
 300f074:	00d59463          	bne	a1,a3,300f07c <__gedf2+0x70>
 300f078:	00e85863          	bge	a6,a4,300f088 <__gedf2+0x7c>
 300f07c:	4505                	li	a0,1
 300f07e:	e199                	bnez	a1,300f084 <__gedf2+0x78>
 300f080:	8082                	ret
 300f082:	fefd                	bnez	a3,300f080 <__gedf2+0x74>
 300f084:	557d                	li	a0,-1
 300f086:	8082                	ret
 300f088:	01075663          	bge	a4,a6,300f094 <__gedf2+0x88>
 300f08c:	557d                	li	a0,-1
 300f08e:	d9ed                	beqz	a1,300f080 <__gedf2+0x74>
 300f090:	4505                	li	a0,1
 300f092:	8082                	ret
 300f094:	ff17e4e3          	bltu	a5,a7,300f07c <__gedf2+0x70>
 300f098:	00f89863          	bne	a7,a5,300f0a8 <__gedf2+0x9c>
 300f09c:	fe6e60e3          	bltu	t3,t1,300f07c <__gedf2+0x70>
 300f0a0:	4501                	li	a0,0
 300f0a2:	fdc37fe3          	bgeu	t1,t3,300f080 <__gedf2+0x74>
 300f0a6:	b7dd                	j	300f08c <__gedf2+0x80>
 300f0a8:	fef8e2e3          	bltu	a7,a5,300f08c <__gedf2+0x80>
 300f0ac:	4501                	li	a0,0
 300f0ae:	8082                	ret
 300f0b0:	fd75                	bnez	a0,300f0ac <__gedf2+0xa0>
 300f0b2:	b7e9                	j	300f07c <__gedf2+0x70>
 300f0b4:	f8e80ee3          	beq	a6,a4,300f050 <__gedf2+0x44>
 300f0b8:	4501                	li	a0,0
 300f0ba:	fa080ae3          	beqz	a6,300f06e <__gedf2+0x62>
 300f0be:	bf5d                	j	300f074 <__gedf2+0x68>

0300f0c0 <__ledf2>:
 300f0c0:	002027f3          	frrm	a5
 300f0c4:	001007b7          	lui	a5,0x100
 300f0c8:	0145d713          	srli	a4,a1,0x14
 300f0cc:	17fd                	addi	a5,a5,-1 # fffff <FLASH_SIZE+0xe0003>
 300f0ce:	0146d813          	srli	a6,a3,0x14
 300f0d2:	7ff77713          	andi	a4,a4,2047
 300f0d6:	7ff00e93          	li	t4,2047
 300f0da:	00b7f8b3          	and	a7,a5,a1
 300f0de:	832a                	mv	t1,a0
 300f0e0:	8ff5                	and	a5,a5,a3
 300f0e2:	81fd                	srli	a1,a1,0x1f
 300f0e4:	8e32                	mv	t3,a2
 300f0e6:	7ff87813          	andi	a6,a6,2047
 300f0ea:	82fd                	srli	a3,a3,0x1f
 300f0ec:	01d71a63          	bne	a4,t4,300f100 <__ledf2+0x40>
 300f0f0:	00a8eeb3          	or	t4,a7,a0
 300f0f4:	060e8a63          	beqz	t4,300f168 <__ledf2+0xa8>
 300f0f8:	00186073          	csrsi	fflags,16
 300f0fc:	4509                	li	a0,2
 300f0fe:	8082                	ret
 300f100:	01d81a63          	bne	a6,t4,300f114 <__ledf2+0x54>
 300f104:	8e5d                	or	a2,a2,a5
 300f106:	fa6d                	bnez	a2,300f0f8 <__ledf2+0x38>
 300f108:	e305                	bnez	a4,300f128 <__ledf2+0x68>
 300f10a:	00a8e533          	or	a0,a7,a0
 300f10e:	00153513          	seqz	a0,a0
 300f112:	a811                	j	300f126 <__ledf2+0x66>
 300f114:	ef21                	bnez	a4,300f16c <__ledf2+0xac>
 300f116:	00a8e533          	or	a0,a7,a0
 300f11a:	00153513          	seqz	a0,a0
 300f11e:	00081463          	bnez	a6,300f126 <__ledf2+0x66>
 300f122:	8e5d                	or	a2,a2,a5
 300f124:	c221                	beqz	a2,300f164 <__ledf2+0xa4>
 300f126:	e901                	bnez	a0,300f136 <__ledf2+0x76>
 300f128:	00d59463          	bne	a1,a3,300f130 <__ledf2+0x70>
 300f12c:	00e85863          	bge	a6,a4,300f13c <__ledf2+0x7c>
 300f130:	4505                	li	a0,1
 300f132:	e199                	bnez	a1,300f138 <__ledf2+0x78>
 300f134:	8082                	ret
 300f136:	fefd                	bnez	a3,300f134 <__ledf2+0x74>
 300f138:	557d                	li	a0,-1
 300f13a:	8082                	ret
 300f13c:	01075663          	bge	a4,a6,300f148 <__ledf2+0x88>
 300f140:	557d                	li	a0,-1
 300f142:	d9ed                	beqz	a1,300f134 <__ledf2+0x74>
 300f144:	4505                	li	a0,1
 300f146:	8082                	ret
 300f148:	ff17e4e3          	bltu	a5,a7,300f130 <__ledf2+0x70>
 300f14c:	00f89863          	bne	a7,a5,300f15c <__ledf2+0x9c>
 300f150:	fe6e60e3          	bltu	t3,t1,300f130 <__ledf2+0x70>
 300f154:	4501                	li	a0,0
 300f156:	fdc37fe3          	bgeu	t1,t3,300f134 <__ledf2+0x74>
 300f15a:	b7dd                	j	300f140 <__ledf2+0x80>
 300f15c:	fef8e2e3          	bltu	a7,a5,300f140 <__ledf2+0x80>
 300f160:	4501                	li	a0,0
 300f162:	8082                	ret
 300f164:	fd75                	bnez	a0,300f160 <__ledf2+0xa0>
 300f166:	b7e9                	j	300f130 <__ledf2+0x70>
 300f168:	f8e80ee3          	beq	a6,a4,300f104 <__ledf2+0x44>
 300f16c:	4501                	li	a0,0
 300f16e:	fa080ae3          	beqz	a6,300f122 <__ledf2+0x62>
 300f172:	bf5d                	j	300f128 <__ledf2+0x68>

0300f174 <__muldf3>:
 300f174:	7179                	addi	sp,sp,-48
 300f176:	d422                	sw	s0,40(sp)
 300f178:	ca56                	sw	s5,20(sp)
 300f17a:	c266                	sw	s9,4(sp)
 300f17c:	d606                	sw	ra,44(sp)
 300f17e:	d226                	sw	s1,36(sp)
 300f180:	d04a                	sw	s2,32(sp)
 300f182:	ce4e                	sw	s3,28(sp)
 300f184:	cc52                	sw	s4,24(sp)
 300f186:	c85a                	sw	s6,16(sp)
 300f188:	c65e                	sw	s7,12(sp)
 300f18a:	c462                	sw	s8,8(sp)
 300f18c:	842a                	mv	s0,a0
 300f18e:	8cb2                	mv	s9,a2
 300f190:	8ab6                	mv	s5,a3
 300f192:	002029f3          	frrm	s3
 300f196:	001004b7          	lui	s1,0x100
 300f19a:	0145db93          	srli	s7,a1,0x14
 300f19e:	14fd                	addi	s1,s1,-1 # fffff <FLASH_SIZE+0xe0003>
 300f1a0:	7ffbfb93          	andi	s7,s7,2047
 300f1a4:	8ced                	and	s1,s1,a1
 300f1a6:	01f5db13          	srli	s6,a1,0x1f
 300f1aa:	020b8463          	beqz	s7,300f1d2 <__muldf3+0x5e>
 300f1ae:	7ff00793          	li	a5,2047
 300f1b2:	06fb8763          	beq	s7,a5,300f220 <__muldf3+0xac>
 300f1b6:	008007b7          	lui	a5,0x800
 300f1ba:	048e                	slli	s1,s1,0x3
 300f1bc:	8cdd                	or	s1,s1,a5
 300f1be:	01d55793          	srli	a5,a0,0x1d
 300f1c2:	8cdd                	or	s1,s1,a5
 300f1c4:	00351a13          	slli	s4,a0,0x3
 300f1c8:	c01b8b93          	addi	s7,s7,-1023
 300f1cc:	4c01                	li	s8,0
 300f1ce:	4901                	li	s2,0
 300f1d0:	a0a5                	j	300f238 <__muldf3+0xc4>
 300f1d2:	00a4e7b3          	or	a5,s1,a0
 300f1d6:	c3f9                	beqz	a5,300f29c <__muldf3+0x128>
 300f1d8:	c88d                	beqz	s1,300f20a <__muldf3+0x96>
 300f1da:	8526                	mv	a0,s1
 300f1dc:	1c4010ef          	jal	ra,30103a0 <__clzsi2>
 300f1e0:	ff550713          	addi	a4,a0,-11
 300f1e4:	47f1                	li	a5,28
 300f1e6:	02e7c763          	blt	a5,a4,300f214 <__muldf3+0xa0>
 300f1ea:	47f5                	li	a5,29
 300f1ec:	ff850a13          	addi	s4,a0,-8
 300f1f0:	8f99                	sub	a5,a5,a4
 300f1f2:	014494b3          	sll	s1,s1,s4
 300f1f6:	00f457b3          	srl	a5,s0,a5
 300f1fa:	8cdd                	or	s1,s1,a5
 300f1fc:	01441a33          	sll	s4,s0,s4
 300f200:	c0d00b93          	li	s7,-1011
 300f204:	40ab8bb3          	sub	s7,s7,a0
 300f208:	b7d1                	j	300f1cc <__muldf3+0x58>
 300f20a:	196010ef          	jal	ra,30103a0 <__clzsi2>
 300f20e:	02050513          	addi	a0,a0,32
 300f212:	b7f9                	j	300f1e0 <__muldf3+0x6c>
 300f214:	fd850493          	addi	s1,a0,-40
 300f218:	009414b3          	sll	s1,s0,s1
 300f21c:	4a01                	li	s4,0
 300f21e:	b7cd                	j	300f200 <__muldf3+0x8c>
 300f220:	00a4e433          	or	s0,s1,a0
 300f224:	c049                	beqz	s0,300f2a6 <__muldf3+0x132>
 300f226:	00c49793          	slli	a5,s1,0xc
 300f22a:	8a2a                	mv	s4,a0
 300f22c:	7ff00b93          	li	s7,2047
 300f230:	4c0d                	li	s8,3
 300f232:	4941                	li	s2,16
 300f234:	f807cde3          	bltz	a5,300f1ce <__muldf3+0x5a>
 300f238:	014ad513          	srli	a0,s5,0x14
 300f23c:	00100437          	lui	s0,0x100
 300f240:	147d                	addi	s0,s0,-1 # fffff <FLASH_SIZE+0xe0003>
 300f242:	7ff57513          	andi	a0,a0,2047
 300f246:	01547433          	and	s0,s0,s5
 300f24a:	87e6                	mv	a5,s9
 300f24c:	01fada93          	srli	s5,s5,0x1f
 300f250:	c12d                	beqz	a0,300f2b2 <__muldf3+0x13e>
 300f252:	7ff00713          	li	a4,2047
 300f256:	0ae50663          	beq	a0,a4,300f302 <__muldf3+0x18e>
 300f25a:	008007b7          	lui	a5,0x800
 300f25e:	040e                	slli	s0,s0,0x3
 300f260:	8c5d                	or	s0,s0,a5
 300f262:	01dcd793          	srli	a5,s9,0x1d
 300f266:	8c5d                	or	s0,s0,a5
 300f268:	c0150513          	addi	a0,a0,-1023
 300f26c:	003c9793          	slli	a5,s9,0x3
 300f270:	4701                	li	a4,0
 300f272:	002c1693          	slli	a3,s8,0x2
 300f276:	8ed9                	or	a3,a3,a4
 300f278:	955e                	add	a0,a0,s7
 300f27a:	16fd                	addi	a3,a3,-1
 300f27c:	4639                	li	a2,14
 300f27e:	015b4833          	xor	a6,s6,s5
 300f282:	00150893          	addi	a7,a0,1
 300f286:	10d66563          	bltu	a2,a3,300f390 <__muldf3+0x21c>
 300f28a:	00002617          	auipc	a2,0x2
 300f28e:	eba60613          	addi	a2,a2,-326 # 3011144 <g_crgIpMatch+0xc34>
 300f292:	068a                	slli	a3,a3,0x2
 300f294:	96b2                	add	a3,a3,a2
 300f296:	4294                	lw	a3,0(a3)
 300f298:	96b2                	add	a3,a3,a2
 300f29a:	8682                	jr	a3
 300f29c:	4481                	li	s1,0
 300f29e:	4a01                	li	s4,0
 300f2a0:	4b81                	li	s7,0
 300f2a2:	4c05                	li	s8,1
 300f2a4:	b72d                	j	300f1ce <__muldf3+0x5a>
 300f2a6:	4481                	li	s1,0
 300f2a8:	4a01                	li	s4,0
 300f2aa:	7ff00b93          	li	s7,2047
 300f2ae:	4c09                	li	s8,2
 300f2b0:	bf39                	j	300f1ce <__muldf3+0x5a>
 300f2b2:	019467b3          	or	a5,s0,s9
 300f2b6:	c3b5                	beqz	a5,300f31a <__muldf3+0x1a6>
 300f2b8:	c80d                	beqz	s0,300f2ea <__muldf3+0x176>
 300f2ba:	8522                	mv	a0,s0
 300f2bc:	0e4010ef          	jal	ra,30103a0 <__clzsi2>
 300f2c0:	ff550693          	addi	a3,a0,-11
 300f2c4:	47f1                	li	a5,28
 300f2c6:	02d7c863          	blt	a5,a3,300f2f6 <__muldf3+0x182>
 300f2ca:	4775                	li	a4,29
 300f2cc:	ff850793          	addi	a5,a0,-8
 300f2d0:	8f15                	sub	a4,a4,a3
 300f2d2:	00f41433          	sll	s0,s0,a5
 300f2d6:	00ecd733          	srl	a4,s9,a4
 300f2da:	8c59                	or	s0,s0,a4
 300f2dc:	00fc97b3          	sll	a5,s9,a5
 300f2e0:	c0d00713          	li	a4,-1011
 300f2e4:	40a70533          	sub	a0,a4,a0
 300f2e8:	b761                	j	300f270 <__muldf3+0xfc>
 300f2ea:	8566                	mv	a0,s9
 300f2ec:	0b4010ef          	jal	ra,30103a0 <__clzsi2>
 300f2f0:	02050513          	addi	a0,a0,32
 300f2f4:	b7f1                	j	300f2c0 <__muldf3+0x14c>
 300f2f6:	fd850413          	addi	s0,a0,-40
 300f2fa:	008c9433          	sll	s0,s9,s0
 300f2fe:	4781                	li	a5,0
 300f300:	b7c5                	j	300f2e0 <__muldf3+0x16c>
 300f302:	01946633          	or	a2,s0,s9
 300f306:	ce19                	beqz	a2,300f324 <__muldf3+0x1b0>
 300f308:	00c41713          	slli	a4,s0,0xc
 300f30c:	7ff00513          	li	a0,2047
 300f310:	02074063          	bltz	a4,300f330 <__muldf3+0x1bc>
 300f314:	470d                	li	a4,3
 300f316:	4941                	li	s2,16
 300f318:	bfa9                	j	300f272 <__muldf3+0xfe>
 300f31a:	4401                	li	s0,0
 300f31c:	4781                	li	a5,0
 300f31e:	4501                	li	a0,0
 300f320:	4705                	li	a4,1
 300f322:	bf81                	j	300f272 <__muldf3+0xfe>
 300f324:	4401                	li	s0,0
 300f326:	4781                	li	a5,0
 300f328:	7ff00513          	li	a0,2047
 300f32c:	4709                	li	a4,2
 300f32e:	b791                	j	300f272 <__muldf3+0xfe>
 300f330:	470d                	li	a4,3
 300f332:	b781                	j	300f272 <__muldf3+0xfe>
 300f334:	00080437          	lui	s0,0x80
 300f338:	4781                	li	a5,0
 300f33a:	7ff00613          	li	a2,2047
 300f33e:	4801                	li	a6,0
 300f340:	4941                	li	s2,16
 300f342:	00100737          	lui	a4,0x100
 300f346:	177d                	addi	a4,a4,-1 # fffff <FLASH_SIZE+0xe0003>
 300f348:	8c79                	and	s0,s0,a4
 300f34a:	80100737          	lui	a4,0x80100
 300f34e:	177d                	addi	a4,a4,-1 # 800fffff <RAM_END+0x7c0f7fff>
 300f350:	7ff67693          	andi	a3,a2,2047
 300f354:	8c79                	and	s0,s0,a4
 300f356:	06d2                	slli	a3,a3,0x14
 300f358:	80000737          	lui	a4,0x80000
 300f35c:	fff74713          	not	a4,a4
 300f360:	8c55                	or	s0,s0,a3
 300f362:	087e                	slli	a6,a6,0x1f
 300f364:	8c79                	and	s0,s0,a4
 300f366:	01046733          	or	a4,s0,a6
 300f36a:	853e                	mv	a0,a5
 300f36c:	85ba                	mv	a1,a4
 300f36e:	00090463          	beqz	s2,300f376 <__muldf3+0x202>
 300f372:	00192073          	csrs	fflags,s2
 300f376:	50b2                	lw	ra,44(sp)
 300f378:	5422                	lw	s0,40(sp)
 300f37a:	5492                	lw	s1,36(sp)
 300f37c:	5902                	lw	s2,32(sp)
 300f37e:	49f2                	lw	s3,28(sp)
 300f380:	4a62                	lw	s4,24(sp)
 300f382:	4ad2                	lw	s5,20(sp)
 300f384:	4b42                	lw	s6,16(sp)
 300f386:	4bb2                	lw	s7,12(sp)
 300f388:	4c22                	lw	s8,8(sp)
 300f38a:	4c92                	lw	s9,4(sp)
 300f38c:	6145                	addi	sp,sp,48
 300f38e:	8082                	ret
 300f390:	6f41                	lui	t5,0x10
 300f392:	ffff0e93          	addi	t4,t5,-1 # ffff <RAM_SIZE+0xafff>
 300f396:	010a5713          	srli	a4,s4,0x10
 300f39a:	0107d593          	srli	a1,a5,0x10
 300f39e:	01da7a33          	and	s4,s4,t4
 300f3a2:	01d7f7b3          	and	a5,a5,t4
 300f3a6:	03458633          	mul	a2,a1,s4
 300f3aa:	034786b3          	mul	a3,a5,s4
 300f3ae:	02f70fb3          	mul	t6,a4,a5
 300f3b2:	01f60333          	add	t1,a2,t6
 300f3b6:	0106d613          	srli	a2,a3,0x10
 300f3ba:	961a                	add	a2,a2,t1
 300f3bc:	02b70e33          	mul	t3,a4,a1
 300f3c0:	01f67363          	bgeu	a2,t6,300f3c6 <__muldf3+0x252>
 300f3c4:	9e7a                	add	t3,t3,t5
 300f3c6:	01065293          	srli	t0,a2,0x10
 300f3ca:	01d67633          	and	a2,a2,t4
 300f3ce:	01d6f6b3          	and	a3,a3,t4
 300f3d2:	01045f13          	srli	t5,s0,0x10
 300f3d6:	01d47eb3          	and	t4,s0,t4
 300f3da:	0642                	slli	a2,a2,0x10
 300f3dc:	9636                	add	a2,a2,a3
 300f3de:	03d70fb3          	mul	t6,a4,t4
 300f3e2:	03da06b3          	mul	a3,s4,t4
 300f3e6:	034f0a33          	mul	s4,t5,s4
 300f3ea:	01fa0333          	add	t1,s4,t6
 300f3ee:	0106da13          	srli	s4,a3,0x10
 300f3f2:	9a1a                	add	s4,s4,t1
 300f3f4:	03e70733          	mul	a4,a4,t5
 300f3f8:	01fa7463          	bgeu	s4,t6,300f400 <__muldf3+0x28c>
 300f3fc:	6341                	lui	t1,0x10
 300f3fe:	971a                	add	a4,a4,t1
 300f400:	010a5313          	srli	t1,s4,0x10
 300f404:	933a                	add	t1,t1,a4
 300f406:	6741                	lui	a4,0x10
 300f408:	fff70f93          	addi	t6,a4,-1 # ffff <RAM_SIZE+0xafff>
 300f40c:	01fa7a33          	and	s4,s4,t6
 300f410:	01f6f6b3          	and	a3,a3,t6
 300f414:	0104d413          	srli	s0,s1,0x10
 300f418:	0a42                	slli	s4,s4,0x10
 300f41a:	01f4f4b3          	and	s1,s1,t6
 300f41e:	9a36                	add	s4,s4,a3
 300f420:	02978fb3          	mul	t6,a5,s1
 300f424:	92d2                	add	t0,t0,s4
 300f426:	029586b3          	mul	a3,a1,s1
 300f42a:	02f407b3          	mul	a5,s0,a5
 300f42e:	028583b3          	mul	t2,a1,s0
 300f432:	00f685b3          	add	a1,a3,a5
 300f436:	010fd693          	srli	a3,t6,0x10
 300f43a:	96ae                	add	a3,a3,a1
 300f43c:	00f6f363          	bgeu	a3,a5,300f442 <__muldf3+0x2ce>
 300f440:	93ba                	add	t2,t2,a4
 300f442:	6741                	lui	a4,0x10
 300f444:	fff70793          	addi	a5,a4,-1 # ffff <RAM_SIZE+0xafff>
 300f448:	00ffffb3          	and	t6,t6,a5
 300f44c:	0106d593          	srli	a1,a3,0x10
 300f450:	8efd                	and	a3,a3,a5
 300f452:	03d487b3          	mul	a5,s1,t4
 300f456:	06c2                	slli	a3,a3,0x10
 300f458:	96fe                	add	a3,a3,t6
 300f45a:	959e                	add	a1,a1,t2
 300f45c:	03d40eb3          	mul	t4,s0,t4
 300f460:	029f04b3          	mul	s1,t5,s1
 300f464:	028f0fb3          	mul	t6,t5,s0
 300f468:	94f6                	add	s1,s1,t4
 300f46a:	0107d413          	srli	s0,a5,0x10
 300f46e:	94a2                	add	s1,s1,s0
 300f470:	01d4f363          	bgeu	s1,t4,300f476 <__muldf3+0x302>
 300f474:	9fba                	add	t6,t6,a4
 300f476:	6ec1                	lui	t4,0x10
 300f478:	1efd                	addi	t4,t4,-1 # ffff <RAM_SIZE+0xafff>
 300f47a:	01d4f733          	and	a4,s1,t4
 300f47e:	01d7f7b3          	and	a5,a5,t4
 300f482:	0742                	slli	a4,a4,0x10
 300f484:	9e16                	add	t3,t3,t0
 300f486:	973e                	add	a4,a4,a5
 300f488:	014e3a33          	sltu	s4,t3,s4
 300f48c:	971a                	add	a4,a4,t1
 300f48e:	01470433          	add	s0,a4,s4
 300f492:	9e36                	add	t3,t3,a3
 300f494:	00de36b3          	sltu	a3,t3,a3
 300f498:	00b40eb3          	add	t4,s0,a1
 300f49c:	00de8f33          	add	t5,t4,a3
 300f4a0:	00673733          	sltu	a4,a4,t1
 300f4a4:	01443433          	sltu	s0,s0,s4
 300f4a8:	8c59                	or	s0,s0,a4
 300f4aa:	00df36b3          	sltu	a3,t5,a3
 300f4ae:	80c1                	srli	s1,s1,0x10
 300f4b0:	00beb5b3          	sltu	a1,t4,a1
 300f4b4:	9426                	add	s0,s0,s1
 300f4b6:	8ecd                	or	a3,a3,a1
 300f4b8:	9436                	add	s0,s0,a3
 300f4ba:	947e                	add	s0,s0,t6
 300f4bc:	017f5793          	srli	a5,t5,0x17
 300f4c0:	0426                	slli	s0,s0,0x9
 300f4c2:	8c5d                	or	s0,s0,a5
 300f4c4:	009e1793          	slli	a5,t3,0x9
 300f4c8:	8fd1                	or	a5,a5,a2
 300f4ca:	00f037b3          	snez	a5,a5
 300f4ce:	017e5e13          	srli	t3,t3,0x17
 300f4d2:	01c7e7b3          	or	a5,a5,t3
 300f4d6:	0f26                	slli	t5,t5,0x9
 300f4d8:	00741713          	slli	a4,s0,0x7
 300f4dc:	01e7e7b3          	or	a5,a5,t5
 300f4e0:	06075e63          	bgez	a4,300f55c <__muldf3+0x3e8>
 300f4e4:	0017d713          	srli	a4,a5,0x1
 300f4e8:	8b85                	andi	a5,a5,1
 300f4ea:	8fd9                	or	a5,a5,a4
 300f4ec:	01f41713          	slli	a4,s0,0x1f
 300f4f0:	8fd9                	or	a5,a5,a4
 300f4f2:	8005                	srli	s0,s0,0x1
 300f4f4:	3ff88613          	addi	a2,a7,1023
 300f4f8:	0cc05863          	blez	a2,300f5c8 <__muldf3+0x454>
 300f4fc:	0077f713          	andi	a4,a5,7
 300f500:	c73d                	beqz	a4,300f56e <__muldf3+0x3fa>
 300f502:	4709                	li	a4,2
 300f504:	00196913          	ori	s2,s2,1
 300f508:	06e98163          	beq	s3,a4,300f56a <__muldf3+0x3f6>
 300f50c:	470d                	li	a4,3
 300f50e:	04e98963          	beq	s3,a4,300f560 <__muldf3+0x3ec>
 300f512:	04099e63          	bnez	s3,300f56e <__muldf3+0x3fa>
 300f516:	00f7f713          	andi	a4,a5,15
 300f51a:	4691                	li	a3,4
 300f51c:	04d70963          	beq	a4,a3,300f56e <__muldf3+0x3fa>
 300f520:	00478713          	addi	a4,a5,4 # 800004 <FLASH_SIZE+0x7e0008>
 300f524:	00f737b3          	sltu	a5,a4,a5
 300f528:	943e                	add	s0,s0,a5
 300f52a:	87ba                	mv	a5,a4
 300f52c:	a089                	j	300f56e <__muldf3+0x3fa>
 300f52e:	885a                	mv	a6,s6
 300f530:	8426                	mv	s0,s1
 300f532:	87d2                	mv	a5,s4
 300f534:	8762                	mv	a4,s8
 300f536:	4689                	li	a3,2
 300f538:	00d70d63          	beq	a4,a3,300f552 <__muldf3+0x3de>
 300f53c:	468d                	li	a3,3
 300f53e:	1cd70f63          	beq	a4,a3,300f71c <__muldf3+0x5a8>
 300f542:	4685                	li	a3,1
 300f544:	fad718e3          	bne	a4,a3,300f4f4 <__muldf3+0x380>
 300f548:	4401                	li	s0,0
 300f54a:	4781                	li	a5,0
 300f54c:	aa6d                	j	300f706 <__muldf3+0x592>
 300f54e:	8856                	mv	a6,s5
 300f550:	b7dd                	j	300f536 <__muldf3+0x3c2>
 300f552:	4401                	li	s0,0
 300f554:	4781                	li	a5,0
 300f556:	7ff00613          	li	a2,2047
 300f55a:	b3e5                	j	300f342 <__muldf3+0x1ce>
 300f55c:	88aa                	mv	a7,a0
 300f55e:	bf59                	j	300f4f4 <__muldf3+0x380>
 300f560:	00081763          	bnez	a6,300f56e <__muldf3+0x3fa>
 300f564:	00878713          	addi	a4,a5,8
 300f568:	bf75                	j	300f524 <__muldf3+0x3b0>
 300f56a:	fe081de3          	bnez	a6,300f564 <__muldf3+0x3f0>
 300f56e:	00741713          	slli	a4,s0,0x7
 300f572:	00075863          	bgez	a4,300f582 <__muldf3+0x40e>
 300f576:	ff000737          	lui	a4,0xff000
 300f57a:	177d                	addi	a4,a4,-1 # feffffff <RAM_END+0xfaff7fff>
 300f57c:	8c79                	and	s0,s0,a4
 300f57e:	40088613          	addi	a2,a7,1024
 300f582:	7fe00713          	li	a4,2046
 300f586:	00c74963          	blt	a4,a2,300f598 <__muldf3+0x424>
 300f58a:	0037d713          	srli	a4,a5,0x3
 300f58e:	01d41793          	slli	a5,s0,0x1d
 300f592:	8fd9                	or	a5,a5,a4
 300f594:	800d                	srli	s0,s0,0x3
 300f596:	b375                	j	300f342 <__muldf3+0x1ce>
 300f598:	4789                	li	a5,2
 300f59a:	02f98463          	beq	s3,a5,300f5c2 <__muldf3+0x44e>
 300f59e:	478d                	li	a5,3
 300f5a0:	00f98b63          	beq	s3,a5,300f5b6 <__muldf3+0x442>
 300f5a4:	00098b63          	beqz	s3,300f5ba <__muldf3+0x446>
 300f5a8:	57fd                	li	a5,-1
 300f5aa:	7fe00613          	li	a2,2046
 300f5ae:	00596913          	ori	s2,s2,5
 300f5b2:	843e                	mv	s0,a5
 300f5b4:	b379                	j	300f342 <__muldf3+0x1ce>
 300f5b6:	fe0819e3          	bnez	a6,300f5a8 <__muldf3+0x434>
 300f5ba:	4781                	li	a5,0
 300f5bc:	7ff00613          	li	a2,2047
 300f5c0:	b7fd                	j	300f5ae <__muldf3+0x43a>
 300f5c2:	fe081ce3          	bnez	a6,300f5ba <__muldf3+0x446>
 300f5c6:	b7cd                	j	300f5a8 <__muldf3+0x434>
 300f5c8:	4585                	li	a1,1
 300f5ca:	ea29                	bnez	a2,300f61c <__muldf3+0x4a8>
 300f5cc:	0077f693          	andi	a3,a5,7
 300f5d0:	8722                	mv	a4,s0
 300f5d2:	c2a1                	beqz	a3,300f612 <__muldf3+0x49e>
 300f5d4:	4709                	li	a4,2
 300f5d6:	00196913          	ori	s2,s2,1
 300f5da:	02e98963          	beq	s3,a4,300f60c <__muldf3+0x498>
 300f5de:	470d                	li	a4,3
 300f5e0:	02e98063          	beq	s3,a4,300f600 <__muldf3+0x48c>
 300f5e4:	8722                	mv	a4,s0
 300f5e6:	02099663          	bnez	s3,300f612 <__muldf3+0x49e>
 300f5ea:	00f7f693          	andi	a3,a5,15
 300f5ee:	4591                	li	a1,4
 300f5f0:	02b68163          	beq	a3,a1,300f612 <__muldf3+0x49e>
 300f5f4:	ffc7b713          	sltiu	a4,a5,-4
 300f5f8:	00174713          	xori	a4,a4,1
 300f5fc:	9722                	add	a4,a4,s0
 300f5fe:	a811                	j	300f612 <__muldf3+0x49e>
 300f600:	8722                	mv	a4,s0
 300f602:	00081863          	bnez	a6,300f612 <__muldf3+0x49e>
 300f606:	ff87b713          	sltiu	a4,a5,-8
 300f60a:	b7fd                	j	300f5f8 <__muldf3+0x484>
 300f60c:	8722                	mv	a4,s0
 300f60e:	fe081ce3          	bnez	a6,300f606 <__muldf3+0x492>
 300f612:	01875593          	srli	a1,a4,0x18
 300f616:	0015c593          	xori	a1,a1,1
 300f61a:	8985                	andi	a1,a1,1
 300f61c:	4705                	li	a4,1
 300f61e:	8f11                	sub	a4,a4,a2
 300f620:	03800693          	li	a3,56
 300f624:	0ce6c063          	blt	a3,a4,300f6e4 <__muldf3+0x570>
 300f628:	46fd                	li	a3,31
 300f62a:	04e6c963          	blt	a3,a4,300f67c <__muldf3+0x508>
 300f62e:	41e88893          	addi	a7,a7,1054
 300f632:	011416b3          	sll	a3,s0,a7
 300f636:	00e7d633          	srl	a2,a5,a4
 300f63a:	011797b3          	sll	a5,a5,a7
 300f63e:	8ed1                	or	a3,a3,a2
 300f640:	00f037b3          	snez	a5,a5
 300f644:	8fd5                	or	a5,a5,a3
 300f646:	00e45433          	srl	s0,s0,a4
 300f64a:	0077f713          	andi	a4,a5,7
 300f64e:	c32d                	beqz	a4,300f6b0 <__muldf3+0x53c>
 300f650:	4709                	li	a4,2
 300f652:	00196913          	ori	s2,s2,1
 300f656:	04e98b63          	beq	s3,a4,300f6ac <__muldf3+0x538>
 300f65a:	470d                	li	a4,3
 300f65c:	04e98363          	beq	s3,a4,300f6a2 <__muldf3+0x52e>
 300f660:	04099863          	bnez	s3,300f6b0 <__muldf3+0x53c>
 300f664:	00f7f713          	andi	a4,a5,15
 300f668:	4691                	li	a3,4
 300f66a:	04d70363          	beq	a4,a3,300f6b0 <__muldf3+0x53c>
 300f66e:	00478713          	addi	a4,a5,4
 300f672:	00f737b3          	sltu	a5,a4,a5
 300f676:	943e                	add	s0,s0,a5
 300f678:	87ba                	mv	a5,a4
 300f67a:	a81d                	j	300f6b0 <__muldf3+0x53c>
 300f67c:	5685                	li	a3,-31
 300f67e:	8e91                	sub	a3,a3,a2
 300f680:	02000513          	li	a0,32
 300f684:	00d456b3          	srl	a3,s0,a3
 300f688:	4601                	li	a2,0
 300f68a:	00a70663          	beq	a4,a0,300f696 <__muldf3+0x522>
 300f68e:	43e88893          	addi	a7,a7,1086
 300f692:	01141633          	sll	a2,s0,a7
 300f696:	8fd1                	or	a5,a5,a2
 300f698:	00f037b3          	snez	a5,a5
 300f69c:	8fd5                	or	a5,a5,a3
 300f69e:	4401                	li	s0,0
 300f6a0:	b76d                	j	300f64a <__muldf3+0x4d6>
 300f6a2:	00081763          	bnez	a6,300f6b0 <__muldf3+0x53c>
 300f6a6:	00878713          	addi	a4,a5,8
 300f6aa:	b7e1                	j	300f672 <__muldf3+0x4fe>
 300f6ac:	fe081de3          	bnez	a6,300f6a6 <__muldf3+0x532>
 300f6b0:	00841713          	slli	a4,s0,0x8
 300f6b4:	02075063          	bgez	a4,300f6d4 <__muldf3+0x560>
 300f6b8:	00196913          	ori	s2,s2,1
 300f6bc:	4401                	li	s0,0
 300f6be:	4781                	li	a5,0
 300f6c0:	4605                	li	a2,1
 300f6c2:	c80580e3          	beqz	a1,300f342 <__muldf3+0x1ce>
 300f6c6:	00197713          	andi	a4,s2,1
 300f6ca:	c6070ce3          	beqz	a4,300f342 <__muldf3+0x1ce>
 300f6ce:	00296913          	ori	s2,s2,2
 300f6d2:	b985                	j	300f342 <__muldf3+0x1ce>
 300f6d4:	0037d713          	srli	a4,a5,0x3
 300f6d8:	01d41793          	slli	a5,s0,0x1d
 300f6dc:	8fd9                	or	a5,a5,a4
 300f6de:	800d                	srli	s0,s0,0x3
 300f6e0:	4601                	li	a2,0
 300f6e2:	b7c5                	j	300f6c2 <__muldf3+0x54e>
 300f6e4:	8fc1                	or	a5,a5,s0
 300f6e6:	cf89                	beqz	a5,300f700 <__muldf3+0x58c>
 300f6e8:	4789                	li	a5,2
 300f6ea:	00196913          	ori	s2,s2,1
 300f6ee:	02f98363          	beq	s3,a5,300f714 <__muldf3+0x5a0>
 300f6f2:	478d                	li	a5,3
 300f6f4:	00f98b63          	beq	s3,a5,300f70a <__muldf3+0x596>
 300f6f8:	4795                	li	a5,5
 300f6fa:	00099b63          	bnez	s3,300f710 <__muldf3+0x59c>
 300f6fe:	838d                	srli	a5,a5,0x3
 300f700:	00296913          	ori	s2,s2,2
 300f704:	4401                	li	s0,0
 300f706:	4601                	li	a2,0
 300f708:	b92d                	j	300f342 <__muldf3+0x1ce>
 300f70a:	47a5                	li	a5,9
 300f70c:	fe0809e3          	beqz	a6,300f6fe <__muldf3+0x58a>
 300f710:	4785                	li	a5,1
 300f712:	b7f5                	j	300f6fe <__muldf3+0x58a>
 300f714:	47a5                	li	a5,9
 300f716:	fe0814e3          	bnez	a6,300f6fe <__muldf3+0x58a>
 300f71a:	bfdd                	j	300f710 <__muldf3+0x59c>
 300f71c:	00080437          	lui	s0,0x80
 300f720:	4781                	li	a5,0
 300f722:	7ff00613          	li	a2,2047
 300f726:	4801                	li	a6,0
 300f728:	b929                	j	300f342 <__muldf3+0x1ce>

0300f72a <__subdf3>:
 300f72a:	1101                	addi	sp,sp,-32
 300f72c:	ce06                	sw	ra,28(sp)
 300f72e:	cc22                	sw	s0,24(sp)
 300f730:	ca26                	sw	s1,20(sp)
 300f732:	c84a                	sw	s2,16(sp)
 300f734:	c64e                	sw	s3,12(sp)
 300f736:	c452                	sw	s4,8(sp)
 300f738:	00202973          	frrm	s2
 300f73c:	001008b7          	lui	a7,0x100
 300f740:	18fd                	addi	a7,a7,-1 # fffff <FLASH_SIZE+0xe0003>
 300f742:	00b8f7b3          	and	a5,a7,a1
 300f746:	0145d993          	srli	s3,a1,0x14
 300f74a:	01f5d493          	srli	s1,a1,0x1f
 300f74e:	00379593          	slli	a1,a5,0x3
 300f752:	01d55793          	srli	a5,a0,0x1d
 300f756:	00d8f8b3          	and	a7,a7,a3
 300f75a:	8fcd                	or	a5,a5,a1
 300f75c:	0146d593          	srli	a1,a3,0x14
 300f760:	01d65713          	srli	a4,a2,0x1d
 300f764:	088e                	slli	a7,a7,0x3
 300f766:	00361813          	slli	a6,a2,0x3
 300f76a:	7ff5f593          	andi	a1,a1,2047
 300f76e:	7ff00613          	li	a2,2047
 300f772:	7ff9f993          	andi	s3,s3,2047
 300f776:	050e                	slli	a0,a0,0x3
 300f778:	82fd                	srli	a3,a3,0x1f
 300f77a:	01176733          	or	a4,a4,a7
 300f77e:	00c59563          	bne	a1,a2,300f788 <__subdf3+0x5e>
 300f782:	01076633          	or	a2,a4,a6
 300f786:	e219                	bnez	a2,300f78c <__subdf3+0x62>
 300f788:	0016c693          	xori	a3,a3,1
 300f78c:	40b988b3          	sub	a7,s3,a1
 300f790:	3a969163          	bne	a3,s1,300fb32 <__subdf3+0x408>
 300f794:	11105363          	blez	a7,300f89a <__subdf3+0x170>
 300f798:	edbd                	bnez	a1,300f816 <__subdf3+0xec>
 300f79a:	010766b3          	or	a3,a4,a6
 300f79e:	e699                	bnez	a3,300f7ac <__subdf3+0x82>
 300f7a0:	7ff00713          	li	a4,2047
 300f7a4:	85c6                	mv	a1,a7
 300f7a6:	04e89563          	bne	a7,a4,300f7f0 <__subdf3+0xc6>
 300f7aa:	a889                	j	300f7fc <__subdf3+0xd2>
 300f7ac:	fff88693          	addi	a3,a7,-1
 300f7b0:	e2b1                	bnez	a3,300f7f4 <__subdf3+0xca>
 300f7b2:	982a                	add	a6,a6,a0
 300f7b4:	97ba                	add	a5,a5,a4
 300f7b6:	00a83533          	sltu	a0,a6,a0
 300f7ba:	00a78733          	add	a4,a5,a0
 300f7be:	4585                	li	a1,1
 300f7c0:	00871793          	slli	a5,a4,0x8
 300f7c4:	0e07d663          	bgez	a5,300f8b0 <__subdf3+0x186>
 300f7c8:	0585                	addi	a1,a1,1 # 10001 <RAM_SIZE+0xb001>
 300f7ca:	7ff00793          	li	a5,2047
 300f7ce:	32f58e63          	beq	a1,a5,300fb0a <__subdf3+0x3e0>
 300f7d2:	ff8007b7          	lui	a5,0xff800
 300f7d6:	17fd                	addi	a5,a5,-1 # ff7fffff <RAM_END+0xfb7f7fff>
 300f7d8:	00185513          	srli	a0,a6,0x1
 300f7dc:	8ff9                	and	a5,a5,a4
 300f7de:	00187813          	andi	a6,a6,1
 300f7e2:	01056833          	or	a6,a0,a6
 300f7e6:	01f79513          	slli	a0,a5,0x1f
 300f7ea:	01056533          	or	a0,a0,a6
 300f7ee:	8385                	srli	a5,a5,0x1
 300f7f0:	4881                	li	a7,0
 300f7f2:	a4d1                	j	300fab6 <__subdf3+0x38c>
 300f7f4:	7ff00613          	li	a2,2047
 300f7f8:	02c89763          	bne	a7,a2,300f826 <__subdf3+0xfc>
 300f7fc:	00a7e733          	or	a4,a5,a0
 300f800:	6e070c63          	beqz	a4,300fef8 <__subdf3+0x7ce>
 300f804:	00979713          	slli	a4,a5,0x9
 300f808:	7ff00593          	li	a1,2047
 300f80c:	4881                	li	a7,0
 300f80e:	2a074463          	bltz	a4,300fab6 <__subdf3+0x38c>
 300f812:	4341                	li	t1,16
 300f814:	aa71                	j	300f9b0 <__subdf3+0x286>
 300f816:	7ff00693          	li	a3,2047
 300f81a:	fed981e3          	beq	s3,a3,300f7fc <__subdf3+0xd2>
 300f81e:	008006b7          	lui	a3,0x800
 300f822:	8f55                	or	a4,a4,a3
 300f824:	86c6                	mv	a3,a7
 300f826:	03800613          	li	a2,56
 300f82a:	06d64363          	blt	a2,a3,300f890 <__subdf3+0x166>
 300f82e:	467d                	li	a2,31
 300f830:	02d64b63          	blt	a2,a3,300f866 <__subdf3+0x13c>
 300f834:	02000593          	li	a1,32
 300f838:	8d95                	sub	a1,a1,a3
 300f83a:	00d858b3          	srl	a7,a6,a3
 300f83e:	00b71633          	sll	a2,a4,a1
 300f842:	00b81833          	sll	a6,a6,a1
 300f846:	01166633          	or	a2,a2,a7
 300f84a:	01003833          	snez	a6,a6
 300f84e:	01066833          	or	a6,a2,a6
 300f852:	00d756b3          	srl	a3,a4,a3
 300f856:	982a                	add	a6,a6,a0
 300f858:	96be                	add	a3,a3,a5
 300f85a:	00a837b3          	sltu	a5,a6,a0
 300f85e:	00f68733          	add	a4,a3,a5
 300f862:	85ce                	mv	a1,s3
 300f864:	bfb1                	j	300f7c0 <__subdf3+0x96>
 300f866:	02000893          	li	a7,32
 300f86a:	00d75633          	srl	a2,a4,a3
 300f86e:	4581                	li	a1,0
 300f870:	01168863          	beq	a3,a7,300f880 <__subdf3+0x156>
 300f874:	04000593          	li	a1,64
 300f878:	40d586b3          	sub	a3,a1,a3
 300f87c:	00d715b3          	sll	a1,a4,a3
 300f880:	0105e833          	or	a6,a1,a6
 300f884:	01003833          	snez	a6,a6
 300f888:	01066833          	or	a6,a2,a6
 300f88c:	4681                	li	a3,0
 300f88e:	b7e1                	j	300f856 <__subdf3+0x12c>
 300f890:	01076833          	or	a6,a4,a6
 300f894:	01003833          	snez	a6,a6
 300f898:	bfd5                	j	300f88c <__subdf3+0x162>
 300f89a:	0c088a63          	beqz	a7,300f96e <__subdf3+0x244>
 300f89e:	04099863          	bnez	s3,300f8ee <__subdf3+0x1c4>
 300f8a2:	00a7e6b3          	or	a3,a5,a0
 300f8a6:	ea81                	bnez	a3,300f8b6 <__subdf3+0x18c>
 300f8a8:	7ff00793          	li	a5,2047
 300f8ac:	02f58663          	beq	a1,a5,300f8d8 <__subdf3+0x1ae>
 300f8b0:	ed85                	bnez	a1,300f8e8 <__subdf3+0x1be>
 300f8b2:	8542                	mv	a0,a6
 300f8b4:	a991                	j	300fd08 <__subdf3+0x5de>
 300f8b6:	56fd                	li	a3,-1
 300f8b8:	00d89a63          	bne	a7,a3,300f8cc <__subdf3+0x1a2>
 300f8bc:	010506b3          	add	a3,a0,a6
 300f8c0:	97ba                	add	a5,a5,a4
 300f8c2:	0106b733          	sltu	a4,a3,a6
 300f8c6:	973e                	add	a4,a4,a5
 300f8c8:	8836                	mv	a6,a3
 300f8ca:	bddd                	j	300f7c0 <__subdf3+0x96>
 300f8cc:	7ff00693          	li	a3,2047
 300f8d0:	fff8c893          	not	a7,a7
 300f8d4:	02d59663          	bne	a1,a3,300f900 <__subdf3+0x1d6>
 300f8d8:	01076533          	or	a0,a4,a6
 300f8dc:	62050463          	beqz	a0,300ff04 <__subdf3+0x7da>
 300f8e0:	00971793          	slli	a5,a4,0x9
 300f8e4:	6007d363          	bgez	a5,300feea <__subdf3+0x7c0>
 300f8e8:	87ba                	mv	a5,a4
 300f8ea:	8542                	mv	a0,a6
 300f8ec:	b711                	j	300f7f0 <__subdf3+0xc6>
 300f8ee:	7ff00693          	li	a3,2047
 300f8f2:	fed583e3          	beq	a1,a3,300f8d8 <__subdf3+0x1ae>
 300f8f6:	008006b7          	lui	a3,0x800
 300f8fa:	411008b3          	neg	a7,a7
 300f8fe:	8fd5                	or	a5,a5,a3
 300f900:	03800693          	li	a3,56
 300f904:	0716c163          	blt	a3,a7,300f966 <__subdf3+0x23c>
 300f908:	46fd                	li	a3,31
 300f90a:	0316cb63          	blt	a3,a7,300f940 <__subdf3+0x216>
 300f90e:	02000613          	li	a2,32
 300f912:	41160633          	sub	a2,a2,a7
 300f916:	01155333          	srl	t1,a0,a7
 300f91a:	00c796b3          	sll	a3,a5,a2
 300f91e:	00c51533          	sll	a0,a0,a2
 300f922:	0066e6b3          	or	a3,a3,t1
 300f926:	00a03533          	snez	a0,a0
 300f92a:	8d55                	or	a0,a0,a3
 300f92c:	0117d8b3          	srl	a7,a5,a7
 300f930:	9542                	add	a0,a0,a6
 300f932:	00e887b3          	add	a5,a7,a4
 300f936:	01053733          	sltu	a4,a0,a6
 300f93a:	973e                	add	a4,a4,a5
 300f93c:	882a                	mv	a6,a0
 300f93e:	b549                	j	300f7c0 <__subdf3+0x96>
 300f940:	02000313          	li	t1,32
 300f944:	0117d6b3          	srl	a3,a5,a7
 300f948:	4601                	li	a2,0
 300f94a:	00688863          	beq	a7,t1,300f95a <__subdf3+0x230>
 300f94e:	04000613          	li	a2,64
 300f952:	411608b3          	sub	a7,a2,a7
 300f956:	01179633          	sll	a2,a5,a7
 300f95a:	8d51                	or	a0,a0,a2
 300f95c:	00a03533          	snez	a0,a0
 300f960:	8d55                	or	a0,a0,a3
 300f962:	4881                	li	a7,0
 300f964:	b7f1                	j	300f930 <__subdf3+0x206>
 300f966:	8d5d                	or	a0,a0,a5
 300f968:	00a03533          	snez	a0,a0
 300f96c:	bfdd                	j	300f962 <__subdf3+0x238>
 300f96e:	00198693          	addi	a3,s3,1
 300f972:	7ff6f313          	andi	t1,a3,2047
 300f976:	4605                	li	a2,1
 300f978:	10664e63          	blt	a2,t1,300fa94 <__subdf3+0x36a>
 300f97c:	00a7e6b3          	or	a3,a5,a0
 300f980:	04099463          	bnez	s3,300f9c8 <__subdf3+0x29e>
 300f984:	d69d                	beqz	a3,300f8b2 <__subdf3+0x188>
 300f986:	010766b3          	or	a3,a4,a6
 300f98a:	52068e63          	beqz	a3,300fec6 <__subdf3+0x79c>
 300f98e:	982a                	add	a6,a6,a0
 300f990:	97ba                	add	a5,a5,a4
 300f992:	00a83533          	sltu	a0,a6,a0
 300f996:	00a78733          	add	a4,a5,a0
 300f99a:	00871793          	slli	a5,a4,0x8
 300f99e:	f007dae3          	bgez	a5,300f8b2 <__subdf3+0x188>
 300f9a2:	ff8007b7          	lui	a5,0xff800
 300f9a6:	17fd                	addi	a5,a5,-1 # ff7fffff <RAM_END+0xfb7f7fff>
 300f9a8:	8ff9                	and	a5,a5,a4
 300f9aa:	8542                	mv	a0,a6
 300f9ac:	4301                	li	t1,0
 300f9ae:	4585                	li	a1,1
 300f9b0:	00757713          	andi	a4,a0,7
 300f9b4:	10071e63          	bnez	a4,300fad0 <__subdf3+0x3a6>
 300f9b8:	04088b63          	beqz	a7,300fa0e <__subdf3+0x2e4>
 300f9bc:	00137713          	andi	a4,t1,1
 300f9c0:	c739                	beqz	a4,300fa0e <__subdf3+0x2e4>
 300f9c2:	00236313          	ori	t1,t1,2
 300f9c6:	a0a1                	j	300fa0e <__subdf3+0x2e4>
 300f9c8:	7ff00613          	li	a2,2047
 300f9cc:	0ac99f63          	bne	s3,a2,300fa8a <__subdf3+0x360>
 300f9d0:	58068d63          	beqz	a3,300ff6a <__subdf3+0x840>
 300f9d4:	00400337          	lui	t1,0x400
 300f9d8:	0067f333          	and	t1,a5,t1
 300f9dc:	00133313          	seqz	t1,t1
 300f9e0:	0312                	slli	t1,t1,0x4
 300f9e2:	01359c63          	bne	a1,s3,300f9fa <__subdf3+0x2d0>
 300f9e6:	01076633          	or	a2,a4,a6
 300f9ea:	c611                	beqz	a2,300f9f6 <__subdf3+0x2cc>
 300f9ec:	00971613          	slli	a2,a4,0x9
 300f9f0:	00064363          	bltz	a2,300f9f6 <__subdf3+0x2cc>
 300f9f4:	4341                	li	t1,16
 300f9f6:	4e068e63          	beqz	a3,300fef2 <__subdf3+0x7c8>
 300f9fa:	01076733          	or	a4,a4,a6
 300f9fe:	3c070c63          	beqz	a4,300fdd6 <__subdf3+0x6ac>
 300fa02:	004007b7          	lui	a5,0x400
 300fa06:	4501                	li	a0,0
 300fa08:	7ff00593          	li	a1,2047
 300fa0c:	4481                	li	s1,0
 300fa0e:	00879713          	slli	a4,a5,0x8
 300fa12:	00075b63          	bgez	a4,300fa28 <__subdf3+0x2fe>
 300fa16:	0585                	addi	a1,a1,1
 300fa18:	7ff00713          	li	a4,2047
 300fa1c:	52e58063          	beq	a1,a4,300ff3c <__subdf3+0x812>
 300fa20:	ff800737          	lui	a4,0xff800
 300fa24:	177d                	addi	a4,a4,-1 # ff7fffff <RAM_END+0xfb7f7fff>
 300fa26:	8ff9                	and	a5,a5,a4
 300fa28:	01d79713          	slli	a4,a5,0x1d
 300fa2c:	810d                	srli	a0,a0,0x3
 300fa2e:	8d59                	or	a0,a0,a4
 300fa30:	7ff00713          	li	a4,2047
 300fa34:	838d                	srli	a5,a5,0x3
 300fa36:	00e59963          	bne	a1,a4,300fa48 <__subdf3+0x31e>
 300fa3a:	8d5d                	or	a0,a0,a5
 300fa3c:	4781                	li	a5,0
 300fa3e:	c509                	beqz	a0,300fa48 <__subdf3+0x31e>
 300fa40:	000807b7          	lui	a5,0x80
 300fa44:	4501                	li	a0,0
 300fa46:	4481                	li	s1,0
 300fa48:	00100737          	lui	a4,0x100
 300fa4c:	177d                	addi	a4,a4,-1 # fffff <FLASH_SIZE+0xe0003>
 300fa4e:	8ff9                	and	a5,a5,a4
 300fa50:	80100737          	lui	a4,0x80100
 300fa54:	177d                	addi	a4,a4,-1 # 800fffff <RAM_END+0x7c0f7fff>
 300fa56:	7ff5f593          	andi	a1,a1,2047
 300fa5a:	05d2                	slli	a1,a1,0x14
 300fa5c:	8ff9                	and	a5,a5,a4
 300fa5e:	80000737          	lui	a4,0x80000
 300fa62:	8fcd                	or	a5,a5,a1
 300fa64:	fff74713          	not	a4,a4
 300fa68:	04fe                	slli	s1,s1,0x1f
 300fa6a:	8ff9                	and	a5,a5,a4
 300fa6c:	0097e733          	or	a4,a5,s1
 300fa70:	85ba                	mv	a1,a4
 300fa72:	00030463          	beqz	t1,300fa7a <__subdf3+0x350>
 300fa76:	00132073          	csrs	fflags,t1
 300fa7a:	40f2                	lw	ra,28(sp)
 300fa7c:	4462                	lw	s0,24(sp)
 300fa7e:	44d2                	lw	s1,20(sp)
 300fa80:	4942                	lw	s2,16(sp)
 300fa82:	49b2                	lw	s3,12(sp)
 300fa84:	4a22                	lw	s4,8(sp)
 300fa86:	6105                	addi	sp,sp,32
 300fa88:	8082                	ret
 300fa8a:	4301                	li	t1,0
 300fa8c:	f6c595e3          	bne	a1,a2,300f9f6 <__subdf3+0x2cc>
 300fa90:	4301                	li	t1,0
 300fa92:	bf91                	j	300f9e6 <__subdf3+0x2bc>
 300fa94:	7ff00613          	li	a2,2047
 300fa98:	02c68163          	beq	a3,a2,300faba <__subdf3+0x390>
 300fa9c:	982a                	add	a6,a6,a0
 300fa9e:	00a83533          	sltu	a0,a6,a0
 300faa2:	97ba                	add	a5,a5,a4
 300faa4:	97aa                	add	a5,a5,a0
 300faa6:	01f79513          	slli	a0,a5,0x1f
 300faaa:	00185813          	srli	a6,a6,0x1
 300faae:	01056533          	or	a0,a0,a6
 300fab2:	8385                	srli	a5,a5,0x1
 300fab4:	85b6                	mv	a1,a3
 300fab6:	4301                	li	t1,0
 300fab8:	bde5                	j	300f9b0 <__subdf3+0x286>
 300faba:	04090563          	beqz	s2,300fb04 <__subdf3+0x3da>
 300fabe:	478d                	li	a5,3
 300fac0:	02f91e63          	bne	s2,a5,300fafc <__subdf3+0x3d2>
 300fac4:	c0a1                	beqz	s1,300fb04 <__subdf3+0x3da>
 300fac6:	57fd                	li	a5,-1
 300fac8:	557d                	li	a0,-1
 300faca:	7fe00593          	li	a1,2046
 300face:	4315                	li	t1,5
 300fad0:	4709                	li	a4,2
 300fad2:	00136313          	ori	t1,t1,1
 300fad6:	46e90063          	beq	s2,a4,300ff36 <__subdf3+0x80c>
 300fada:	470d                	li	a4,3
 300fadc:	44e90863          	beq	s2,a4,300ff2c <__subdf3+0x802>
 300fae0:	ec091ce3          	bnez	s2,300f9b8 <__subdf3+0x28e>
 300fae4:	00f57713          	andi	a4,a0,15
 300fae8:	4691                	li	a3,4
 300faea:	ecd707e3          	beq	a4,a3,300f9b8 <__subdf3+0x28e>
 300faee:	00450713          	addi	a4,a0,4
 300faf2:	00a73533          	sltu	a0,a4,a0
 300faf6:	97aa                	add	a5,a5,a0
 300faf8:	853a                	mv	a0,a4
 300fafa:	bd7d                	j	300f9b8 <__subdf3+0x28e>
 300fafc:	4789                	li	a5,2
 300fafe:	fcf914e3          	bne	s2,a5,300fac6 <__subdf3+0x39c>
 300fb02:	d0f1                	beqz	s1,300fac6 <__subdf3+0x39c>
 300fb04:	7ff00593          	li	a1,2047
 300fb08:	a00d                	j	300fb2a <__subdf3+0x400>
 300fb0a:	02090063          	beqz	s2,300fb2a <__subdf3+0x400>
 300fb0e:	478d                	li	a5,3
 300fb10:	00f91963          	bne	s2,a5,300fb22 <__subdf3+0x3f8>
 300fb14:	c899                	beqz	s1,300fb2a <__subdf3+0x400>
 300fb16:	57fd                	li	a5,-1
 300fb18:	557d                	li	a0,-1
 300fb1a:	7fe00593          	li	a1,2046
 300fb1e:	4881                	li	a7,0
 300fb20:	b77d                	j	300face <__subdf3+0x3a4>
 300fb22:	4789                	li	a5,2
 300fb24:	fef919e3          	bne	s2,a5,300fb16 <__subdf3+0x3ec>
 300fb28:	d4fd                	beqz	s1,300fb16 <__subdf3+0x3ec>
 300fb2a:	4781                	li	a5,0
 300fb2c:	4501                	li	a0,0
 300fb2e:	4315                	li	t1,5
 300fb30:	bdf9                	j	300fa0e <__subdf3+0x2e4>
 300fb32:	0d105663          	blez	a7,300fbfe <__subdf3+0x4d4>
 300fb36:	e1c9                	bnez	a1,300fbb8 <__subdf3+0x48e>
 300fb38:	010766b3          	or	a3,a4,a6
 300fb3c:	c60682e3          	beqz	a3,300f7a0 <__subdf3+0x76>
 300fb40:	fff88693          	addi	a3,a7,-1
 300fb44:	e685                	bnez	a3,300fb6c <__subdf3+0x442>
 300fb46:	41050833          	sub	a6,a0,a6
 300fb4a:	8f99                	sub	a5,a5,a4
 300fb4c:	01053533          	sltu	a0,a0,a6
 300fb50:	40a78733          	sub	a4,a5,a0
 300fb54:	4585                	li	a1,1
 300fb56:	00871793          	slli	a5,a4,0x8
 300fb5a:	d407dbe3          	bgez	a5,300f8b0 <__subdf3+0x186>
 300fb5e:	00800437          	lui	s0,0x800
 300fb62:	147d                	addi	s0,s0,-1 # 7fffff <FLASH_SIZE+0x7e0003>
 300fb64:	8c79                	and	s0,s0,a4
 300fb66:	8a42                	mv	s4,a6
 300fb68:	89ae                	mv	s3,a1
 300fb6a:	a465                	j	300fe12 <__subdf3+0x6e8>
 300fb6c:	7ff00613          	li	a2,2047
 300fb70:	c8c886e3          	beq	a7,a2,300f7fc <__subdf3+0xd2>
 300fb74:	03800613          	li	a2,56
 300fb78:	06d64e63          	blt	a2,a3,300fbf4 <__subdf3+0x4ca>
 300fb7c:	467d                	li	a2,31
 300fb7e:	04d64663          	blt	a2,a3,300fbca <__subdf3+0x4a0>
 300fb82:	02000593          	li	a1,32
 300fb86:	8d95                	sub	a1,a1,a3
 300fb88:	00d858b3          	srl	a7,a6,a3
 300fb8c:	00b71633          	sll	a2,a4,a1
 300fb90:	00b81833          	sll	a6,a6,a1
 300fb94:	01166633          	or	a2,a2,a7
 300fb98:	01003833          	snez	a6,a6
 300fb9c:	01066833          	or	a6,a2,a6
 300fba0:	00d756b3          	srl	a3,a4,a3
 300fba4:	41050833          	sub	a6,a0,a6
 300fba8:	40d786b3          	sub	a3,a5,a3
 300fbac:	010537b3          	sltu	a5,a0,a6
 300fbb0:	40f68733          	sub	a4,a3,a5
 300fbb4:	85ce                	mv	a1,s3
 300fbb6:	b745                	j	300fb56 <__subdf3+0x42c>
 300fbb8:	7ff00693          	li	a3,2047
 300fbbc:	c4d980e3          	beq	s3,a3,300f7fc <__subdf3+0xd2>
 300fbc0:	008006b7          	lui	a3,0x800
 300fbc4:	8f55                	or	a4,a4,a3
 300fbc6:	86c6                	mv	a3,a7
 300fbc8:	b775                	j	300fb74 <__subdf3+0x44a>
 300fbca:	02000893          	li	a7,32
 300fbce:	00d75633          	srl	a2,a4,a3
 300fbd2:	4581                	li	a1,0
 300fbd4:	01168863          	beq	a3,a7,300fbe4 <__subdf3+0x4ba>
 300fbd8:	04000593          	li	a1,64
 300fbdc:	40d586b3          	sub	a3,a1,a3
 300fbe0:	00d715b3          	sll	a1,a4,a3
 300fbe4:	0105e833          	or	a6,a1,a6
 300fbe8:	01003833          	snez	a6,a6
 300fbec:	01066833          	or	a6,a2,a6
 300fbf0:	4681                	li	a3,0
 300fbf2:	bf4d                	j	300fba4 <__subdf3+0x47a>
 300fbf4:	01076833          	or	a6,a4,a6
 300fbf8:	01003833          	snez	a6,a6
 300fbfc:	bfd5                	j	300fbf0 <__subdf3+0x4c6>
 300fbfe:	0c088e63          	beqz	a7,300fcda <__subdf3+0x5b0>
 300fc02:	04099963          	bnez	s3,300fc54 <__subdf3+0x52a>
 300fc06:	00a7e633          	or	a2,a5,a0
 300fc0a:	e609                	bnez	a2,300fc14 <__subdf3+0x4ea>
 300fc0c:	7ff00793          	li	a5,2047
 300fc10:	84b6                	mv	s1,a3
 300fc12:	b969                	j	300f8ac <__subdf3+0x182>
 300fc14:	567d                	li	a2,-1
 300fc16:	00c89d63          	bne	a7,a2,300fc30 <__subdf3+0x506>
 300fc1a:	40a808b3          	sub	a7,a6,a0
 300fc1e:	40f707b3          	sub	a5,a4,a5
 300fc22:	01183733          	sltu	a4,a6,a7
 300fc26:	40e78733          	sub	a4,a5,a4
 300fc2a:	8846                	mv	a6,a7
 300fc2c:	84b6                	mv	s1,a3
 300fc2e:	b725                	j	300fb56 <__subdf3+0x42c>
 300fc30:	7ff00613          	li	a2,2047
 300fc34:	fff8c893          	not	a7,a7
 300fc38:	02c59763          	bne	a1,a2,300fc66 <__subdf3+0x53c>
 300fc3c:	01076533          	or	a0,a4,a6
 300fc40:	2c050463          	beqz	a0,300ff08 <__subdf3+0x7de>
 300fc44:	00971793          	slli	a5,a4,0x9
 300fc48:	2c07d363          	bgez	a5,300ff0e <__subdf3+0x7e4>
 300fc4c:	87ba                	mv	a5,a4
 300fc4e:	8542                	mv	a0,a6
 300fc50:	84b6                	mv	s1,a3
 300fc52:	be79                	j	300f7f0 <__subdf3+0xc6>
 300fc54:	7ff00613          	li	a2,2047
 300fc58:	fec582e3          	beq	a1,a2,300fc3c <__subdf3+0x512>
 300fc5c:	00800637          	lui	a2,0x800
 300fc60:	411008b3          	neg	a7,a7
 300fc64:	8fd1                	or	a5,a5,a2
 300fc66:	03800613          	li	a2,56
 300fc6a:	07164463          	blt	a2,a7,300fcd2 <__subdf3+0x5a8>
 300fc6e:	467d                	li	a2,31
 300fc70:	03164d63          	blt	a2,a7,300fcaa <__subdf3+0x580>
 300fc74:	02000313          	li	t1,32
 300fc78:	41130333          	sub	t1,t1,a7
 300fc7c:	01155e33          	srl	t3,a0,a7
 300fc80:	00679633          	sll	a2,a5,t1
 300fc84:	00651533          	sll	a0,a0,t1
 300fc88:	01c66633          	or	a2,a2,t3
 300fc8c:	00a03533          	snez	a0,a0
 300fc90:	8d51                	or	a0,a0,a2
 300fc92:	0117d8b3          	srl	a7,a5,a7
 300fc96:	40a80533          	sub	a0,a6,a0
 300fc9a:	411707b3          	sub	a5,a4,a7
 300fc9e:	00a83733          	sltu	a4,a6,a0
 300fca2:	40e78733          	sub	a4,a5,a4
 300fca6:	882a                	mv	a6,a0
 300fca8:	b751                	j	300fc2c <__subdf3+0x502>
 300fcaa:	02000e13          	li	t3,32
 300fcae:	0117d633          	srl	a2,a5,a7
 300fcb2:	4301                	li	t1,0
 300fcb4:	01c88863          	beq	a7,t3,300fcc4 <__subdf3+0x59a>
 300fcb8:	04000313          	li	t1,64
 300fcbc:	411308b3          	sub	a7,t1,a7
 300fcc0:	01179333          	sll	t1,a5,a7
 300fcc4:	00a36533          	or	a0,t1,a0
 300fcc8:	00a03533          	snez	a0,a0
 300fccc:	8d51                	or	a0,a0,a2
 300fcce:	4881                	li	a7,0
 300fcd0:	b7d9                	j	300fc96 <__subdf3+0x56c>
 300fcd2:	8d5d                	or	a0,a0,a5
 300fcd4:	00a03533          	snez	a0,a0
 300fcd8:	bfdd                	j	300fcce <__subdf3+0x5a4>
 300fcda:	00198613          	addi	a2,s3,1
 300fcde:	7ff67613          	andi	a2,a2,2047
 300fce2:	4305                	li	t1,1
 300fce4:	10c34363          	blt	t1,a2,300fdea <__subdf3+0x6c0>
 300fce8:	00a7ee33          	or	t3,a5,a0
 300fcec:	01076633          	or	a2,a4,a6
 300fcf0:	0a099763          	bnez	s3,300fd9e <__subdf3+0x674>
 300fcf4:	060e1363          	bnez	t3,300fd5a <__subdf3+0x630>
 300fcf8:	1c061563          	bnez	a2,300fec2 <__subdf3+0x798>
 300fcfc:	ffe90493          	addi	s1,s2,-2
 300fd00:	0014b493          	seqz	s1,s1
 300fd04:	4701                	li	a4,0
 300fd06:	4501                	li	a0,0
 300fd08:	00e567b3          	or	a5,a0,a4
 300fd0c:	20078d63          	beqz	a5,300ff26 <__subdf3+0x7fc>
 300fd10:	01f55793          	srli	a5,a0,0x1f
 300fd14:	00171893          	slli	a7,a4,0x1
 300fd18:	98be                	add	a7,a7,a5
 300fd1a:	00151793          	slli	a5,a0,0x1
 300fd1e:	0077f693          	andi	a3,a5,7
 300fd22:	4301                	li	t1,0
 300fd24:	c295                	beqz	a3,300fd48 <__subdf3+0x61e>
 300fd26:	4689                	li	a3,2
 300fd28:	1ad90d63          	beq	s2,a3,300fee2 <__subdf3+0x7b8>
 300fd2c:	468d                	li	a3,3
 300fd2e:	1ad90163          	beq	s2,a3,300fed0 <__subdf3+0x7a6>
 300fd32:	4305                	li	t1,1
 300fd34:	00091a63          	bnez	s2,300fd48 <__subdf3+0x61e>
 300fd38:	00f7f693          	andi	a3,a5,15
 300fd3c:	4611                	li	a2,4
 300fd3e:	4305                	li	t1,1
 300fd40:	ffc7b793          	sltiu	a5,a5,-4
 300fd44:	18c69b63          	bne	a3,a2,300feda <__subdf3+0x7b0>
 300fd48:	0188d893          	srli	a7,a7,0x18
 300fd4c:	0018c893          	xori	a7,a7,1
 300fd50:	0018f893          	andi	a7,a7,1
 300fd54:	87ba                	mv	a5,a4
 300fd56:	4581                	li	a1,0
 300fd58:	b9a1                	j	300f9b0 <__subdf3+0x286>
 300fd5a:	16060663          	beqz	a2,300fec6 <__subdf3+0x79c>
 300fd5e:	410505b3          	sub	a1,a0,a6
 300fd62:	40e78633          	sub	a2,a5,a4
 300fd66:	00b538b3          	sltu	a7,a0,a1
 300fd6a:	41160633          	sub	a2,a2,a7
 300fd6e:	00861413          	slli	s0,a2,0x8
 300fd72:	00045c63          	bgez	s0,300fd8a <__subdf3+0x660>
 300fd76:	40a80533          	sub	a0,a6,a0
 300fd7a:	40f707b3          	sub	a5,a4,a5
 300fd7e:	00a83733          	sltu	a4,a6,a0
 300fd82:	40e78733          	sub	a4,a5,a4
 300fd86:	84b6                	mv	s1,a3
 300fd88:	b741                	j	300fd08 <__subdf3+0x5de>
 300fd8a:	00c5e533          	or	a0,a1,a2
 300fd8e:	12051e63          	bnez	a0,300feca <__subdf3+0x7a0>
 300fd92:	ffe90493          	addi	s1,s2,-2
 300fd96:	0014b493          	seqz	s1,s1
 300fd9a:	4701                	li	a4,0
 300fd9c:	b7b5                	j	300fd08 <__subdf3+0x5de>
 300fd9e:	7ff00e93          	li	t4,2047
 300fda2:	03d99d63          	bne	s3,t4,300fddc <__subdf3+0x6b2>
 300fda6:	1a0e0e63          	beqz	t3,300ff62 <__subdf3+0x838>
 300fdaa:	00400337          	lui	t1,0x400
 300fdae:	0067f333          	and	t1,a5,t1
 300fdb2:	00133313          	seqz	t1,t1
 300fdb6:	0312                	slli	t1,t1,0x4
 300fdb8:	03359763          	bne	a1,s3,300fde6 <__subdf3+0x6bc>
 300fdbc:	c611                	beqz	a2,300fdc8 <__subdf3+0x69e>
 300fdbe:	00971593          	slli	a1,a4,0x9
 300fdc2:	0005c363          	bltz	a1,300fdc8 <__subdf3+0x69e>
 300fdc6:	4341                	li	t1,16
 300fdc8:	000e1f63          	bnez	t3,300fde6 <__subdf3+0x6bc>
 300fdcc:	14060563          	beqz	a2,300ff16 <__subdf3+0x7ec>
 300fdd0:	87ba                	mv	a5,a4
 300fdd2:	8542                	mv	a0,a6
 300fdd4:	84b6                	mv	s1,a3
 300fdd6:	7ff00593          	li	a1,2047
 300fdda:	bed9                	j	300f9b0 <__subdf3+0x286>
 300fddc:	4301                	li	t1,0
 300fdde:	ffd595e3          	bne	a1,t4,300fdc8 <__subdf3+0x69e>
 300fde2:	4301                	li	t1,0
 300fde4:	bfe1                	j	300fdbc <__subdf3+0x692>
 300fde6:	da65                	beqz	a2,300fdd6 <__subdf3+0x6ac>
 300fde8:	b929                	j	300fa02 <__subdf3+0x2d8>
 300fdea:	41050a33          	sub	s4,a0,a6
 300fdee:	01453633          	sltu	a2,a0,s4
 300fdf2:	40e78433          	sub	s0,a5,a4
 300fdf6:	8c11                	sub	s0,s0,a2
 300fdf8:	00841613          	slli	a2,s0,0x8
 300fdfc:	06065863          	bgez	a2,300fe6c <__subdf3+0x742>
 300fe00:	40a80a33          	sub	s4,a6,a0
 300fe04:	40f707b3          	sub	a5,a4,a5
 300fe08:	01483733          	sltu	a4,a6,s4
 300fe0c:	40e78433          	sub	s0,a5,a4
 300fe10:	84b6                	mv	s1,a3
 300fe12:	c02d                	beqz	s0,300fe74 <__subdf3+0x74a>
 300fe14:	8522                	mv	a0,s0
 300fe16:	2369                	jal	ra,30103a0 <__clzsi2>
 300fe18:	ff850593          	addi	a1,a0,-8
 300fe1c:	47fd                	li	a5,31
 300fe1e:	06b7c063          	blt	a5,a1,300fe7e <__subdf3+0x754>
 300fe22:	02000713          	li	a4,32
 300fe26:	8f0d                	sub	a4,a4,a1
 300fe28:	00b41433          	sll	s0,s0,a1
 300fe2c:	00ea5733          	srl	a4,s4,a4
 300fe30:	008767b3          	or	a5,a4,s0
 300fe34:	00ba1833          	sll	a6,s4,a1
 300fe38:	0735cc63          	blt	a1,s3,300feb0 <__subdf3+0x786>
 300fe3c:	413585b3          	sub	a1,a1,s3
 300fe40:	00158713          	addi	a4,a1,1
 300fe44:	46fd                	li	a3,31
 300fe46:	04e6c263          	blt	a3,a4,300fe8a <__subdf3+0x760>
 300fe4a:	02000693          	li	a3,32
 300fe4e:	8e99                	sub	a3,a3,a4
 300fe50:	00e85633          	srl	a2,a6,a4
 300fe54:	00d79533          	sll	a0,a5,a3
 300fe58:	00d81833          	sll	a6,a6,a3
 300fe5c:	8d51                	or	a0,a0,a2
 300fe5e:	01003833          	snez	a6,a6
 300fe62:	01056533          	or	a0,a0,a6
 300fe66:	00e7d733          	srl	a4,a5,a4
 300fe6a:	bd79                	j	300fd08 <__subdf3+0x5de>
 300fe6c:	008a6533          	or	a0,s4,s0
 300fe70:	f14d                	bnez	a0,300fe12 <__subdf3+0x6e8>
 300fe72:	b705                	j	300fd92 <__subdf3+0x668>
 300fe74:	8552                	mv	a0,s4
 300fe76:	232d                	jal	ra,30103a0 <__clzsi2>
 300fe78:	02050513          	addi	a0,a0,32
 300fe7c:	bf71                	j	300fe18 <__subdf3+0x6ee>
 300fe7e:	fd850413          	addi	s0,a0,-40
 300fe82:	008a17b3          	sll	a5,s4,s0
 300fe86:	4801                	li	a6,0
 300fe88:	bf45                	j	300fe38 <__subdf3+0x70e>
 300fe8a:	1585                	addi	a1,a1,-31
 300fe8c:	02000693          	li	a3,32
 300fe90:	00b7d5b3          	srl	a1,a5,a1
 300fe94:	4601                	li	a2,0
 300fe96:	00d70763          	beq	a4,a3,300fea4 <__subdf3+0x77a>
 300fe9a:	04000613          	li	a2,64
 300fe9e:	8e19                	sub	a2,a2,a4
 300fea0:	00c79633          	sll	a2,a5,a2
 300fea4:	00c86533          	or	a0,a6,a2
 300fea8:	00a03533          	snez	a0,a0
 300feac:	8d4d                	or	a0,a0,a1
 300feae:	b5f5                	j	300fd9a <__subdf3+0x670>
 300feb0:	ff800737          	lui	a4,0xff800
 300feb4:	fff70513          	addi	a0,a4,-1 # ff7fffff <RAM_END+0xfb7f7fff>
 300feb8:	40b985b3          	sub	a1,s3,a1
 300febc:	00a7f733          	and	a4,a5,a0
 300fec0:	bac5                	j	300f8b0 <__subdf3+0x186>
 300fec2:	8542                	mv	a0,a6
 300fec4:	b5c9                	j	300fd86 <__subdf3+0x65c>
 300fec6:	873e                	mv	a4,a5
 300fec8:	b581                	j	300fd08 <__subdf3+0x5de>
 300feca:	8732                	mv	a4,a2
 300fecc:	852e                	mv	a0,a1
 300fece:	bd2d                	j	300fd08 <__subdf3+0x5de>
 300fed0:	4305                	li	t1,1
 300fed2:	e6049be3          	bnez	s1,300fd48 <__subdf3+0x61e>
 300fed6:	ff87b793          	sltiu	a5,a5,-8
 300feda:	0017c793          	xori	a5,a5,1
 300fede:	98be                	add	a7,a7,a5
 300fee0:	b5a5                	j	300fd48 <__subdf3+0x61e>
 300fee2:	4305                	li	t1,1
 300fee4:	e60482e3          	beqz	s1,300fd48 <__subdf3+0x61e>
 300fee8:	b7fd                	j	300fed6 <__subdf3+0x7ac>
 300feea:	87ba                	mv	a5,a4
 300feec:	8542                	mv	a0,a6
 300feee:	4881                	li	a7,0
 300fef0:	b20d                	j	300f812 <__subdf3+0xe8>
 300fef2:	87ba                	mv	a5,a4
 300fef4:	8542                	mv	a0,a6
 300fef6:	b5c5                	j	300fdd6 <__subdf3+0x6ac>
 300fef8:	4781                	li	a5,0
 300fefa:	4501                	li	a0,0
 300fefc:	7ff00593          	li	a1,2047
 300ff00:	4301                	li	t1,0
 300ff02:	b631                	j	300fa0e <__subdf3+0x2e4>
 300ff04:	4781                	li	a5,0
 300ff06:	bfed                	j	300ff00 <__subdf3+0x7d6>
 300ff08:	4781                	li	a5,0
 300ff0a:	84b6                	mv	s1,a3
 300ff0c:	bfd5                	j	300ff00 <__subdf3+0x7d6>
 300ff0e:	87ba                	mv	a5,a4
 300ff10:	8542                	mv	a0,a6
 300ff12:	84b6                	mv	s1,a3
 300ff14:	bfe9                	j	300feee <__subdf3+0x7c4>
 300ff16:	4501                	li	a0,0
 300ff18:	004007b7          	lui	a5,0x400
 300ff1c:	7ff00593          	li	a1,2047
 300ff20:	4481                	li	s1,0
 300ff22:	4341                	li	t1,16
 300ff24:	b4ed                	j	300fa0e <__subdf3+0x2e4>
 300ff26:	4501                	li	a0,0
 300ff28:	4581                	li	a1,0
 300ff2a:	bfd9                	j	300ff00 <__subdf3+0x7d6>
 300ff2c:	a80496e3          	bnez	s1,300f9b8 <__subdf3+0x28e>
 300ff30:	00850713          	addi	a4,a0,8
 300ff34:	be7d                	j	300faf2 <__subdf3+0x3c8>
 300ff36:	a80481e3          	beqz	s1,300f9b8 <__subdf3+0x28e>
 300ff3a:	bfdd                	j	300ff30 <__subdf3+0x806>
 300ff3c:	4501                	li	a0,0
 300ff3e:	00090e63          	beqz	s2,300ff5a <__subdf3+0x830>
 300ff42:	478d                	li	a5,3
 300ff44:	00f91763          	bne	s2,a5,300ff52 <__subdf3+0x828>
 300ff48:	c889                	beqz	s1,300ff5a <__subdf3+0x830>
 300ff4a:	557d                	li	a0,-1
 300ff4c:	7fe00593          	li	a1,2046
 300ff50:	a029                	j	300ff5a <__subdf3+0x830>
 300ff52:	4789                	li	a5,2
 300ff54:	fef91be3          	bne	s2,a5,300ff4a <__subdf3+0x820>
 300ff58:	d8ed                	beqz	s1,300ff4a <__subdf3+0x820>
 300ff5a:	00536313          	ori	t1,t1,5
 300ff5e:	87aa                	mv	a5,a0
 300ff60:	b4e1                	j	300fa28 <__subdf3+0x2fe>
 300ff62:	4301                	li	t1,0
 300ff64:	e73594e3          	bne	a1,s3,300fdcc <__subdf3+0x6a2>
 300ff68:	bdad                	j	300fde2 <__subdf3+0x6b8>
 300ff6a:	b33583e3          	beq	a1,s3,300fa90 <__subdf3+0x366>
 300ff6e:	87ba                	mv	a5,a4
 300ff70:	8542                	mv	a0,a6
 300ff72:	7ff00593          	li	a1,2047
 300ff76:	b681                	j	300fab6 <__subdf3+0x38c>

0300ff78 <__fixdfsi>:
 300ff78:	002027f3          	frrm	a5
 300ff7c:	001007b7          	lui	a5,0x100
 300ff80:	0145d693          	srli	a3,a1,0x14
 300ff84:	fff78613          	addi	a2,a5,-1 # fffff <FLASH_SIZE+0xe0003>
 300ff88:	7ff6f693          	andi	a3,a3,2047
 300ff8c:	3fe00713          	li	a4,1022
 300ff90:	8e6d                	and	a2,a2,a1
 300ff92:	81fd                	srli	a1,a1,0x1f
 300ff94:	00d74863          	blt	a4,a3,300ffa4 <__fixdfsi+0x2c>
 300ff98:	eec9                	bnez	a3,3010032 <__fixdfsi+0xba>
 300ff9a:	00a667b3          	or	a5,a2,a0
 300ff9e:	ebd1                	bnez	a5,3010032 <__fixdfsi+0xba>
 300ffa0:	853e                	mv	a0,a5
 300ffa2:	8082                	ret
 300ffa4:	41d00713          	li	a4,1053
 300ffa8:	02d75863          	bge	a4,a3,300ffd8 <__fixdfsi+0x60>
 300ffac:	80000737          	lui	a4,0x80000
 300ffb0:	fff74713          	not	a4,a4
 300ffb4:	00e587b3          	add	a5,a1,a4
 300ffb8:	cdbd                	beqz	a1,3010036 <__fixdfsi+0xbe>
 300ffba:	41e00593          	li	a1,1054
 300ffbe:	4741                	li	a4,16
 300ffc0:	04b69363          	bne	a3,a1,3010006 <__fixdfsi+0x8e>
 300ffc4:	062e                	slli	a2,a2,0xb
 300ffc6:	01555693          	srli	a3,a0,0x15
 300ffca:	8e55                	or	a2,a2,a3
 300ffcc:	ee0d                	bnez	a2,3010006 <__fixdfsi+0x8e>
 300ffce:	00b51713          	slli	a4,a0,0xb
 300ffd2:	d779                	beqz	a4,300ffa0 <__fixdfsi+0x28>
 300ffd4:	4705                	li	a4,1
 300ffd6:	a805                	j	3010006 <__fixdfsi+0x8e>
 300ffd8:	43300813          	li	a6,1075
 300ffdc:	40d80833          	sub	a6,a6,a3
 300ffe0:	477d                	li	a4,31
 300ffe2:	8fd1                	or	a5,a5,a2
 300ffe4:	03074463          	blt	a4,a6,301000c <__fixdfsi+0x94>
 300ffe8:	bed68613          	addi	a2,a3,-1043 # 7ffbed <FLASH_SIZE+0x7dfbf1>
 300ffec:	00c516b3          	sll	a3,a0,a2
 300fff0:	00c797b3          	sll	a5,a5,a2
 300fff4:	01055533          	srl	a0,a0,a6
 300fff8:	00d03733          	snez	a4,a3
 300fffc:	8fc9                	or	a5,a5,a0
 300fffe:	c199                	beqz	a1,3010004 <__fixdfsi+0x8c>
 3010000:	40f007b3          	neg	a5,a5
 3010004:	df51                	beqz	a4,300ffa0 <__fixdfsi+0x28>
 3010006:	00172073          	csrs	fflags,a4
 301000a:	bf59                	j	300ffa0 <__fixdfsi+0x28>
 301000c:	02000613          	li	a2,32
 3010010:	4701                	li	a4,0
 3010012:	00c80663          	beq	a6,a2,301001e <__fixdfsi+0xa6>
 3010016:	c0d68713          	addi	a4,a3,-1011
 301001a:	00e79733          	sll	a4,a5,a4
 301001e:	8f49                	or	a4,a4,a0
 3010020:	41300513          	li	a0,1043
 3010024:	40d506b3          	sub	a3,a0,a3
 3010028:	00e03733          	snez	a4,a4
 301002c:	00d7d7b3          	srl	a5,a5,a3
 3010030:	b7f9                	j	300fffe <__fixdfsi+0x86>
 3010032:	4781                	li	a5,0
 3010034:	b745                	j	300ffd4 <__fixdfsi+0x5c>
 3010036:	4741                	li	a4,16
 3010038:	b7f9                	j	3010006 <__fixdfsi+0x8e>

0301003a <__floatunsidf>:
 301003a:	1141                	addi	sp,sp,-16
 301003c:	c606                	sw	ra,12(sp)
 301003e:	c422                	sw	s0,8(sp)
 3010040:	cd21                	beqz	a0,3010098 <__floatunsidf+0x5e>
 3010042:	842a                	mv	s0,a0
 3010044:	2eb1                	jal	ra,30103a0 <__clzsi2>
 3010046:	41e00713          	li	a4,1054
 301004a:	47a9                	li	a5,10
 301004c:	8f09                	sub	a4,a4,a0
 301004e:	04a7c063          	blt	a5,a0,301008e <__floatunsidf+0x54>
 3010052:	47ad                	li	a5,11
 3010054:	8f89                	sub	a5,a5,a0
 3010056:	0555                	addi	a0,a0,21
 3010058:	00f457b3          	srl	a5,s0,a5
 301005c:	00a41433          	sll	s0,s0,a0
 3010060:	00100537          	lui	a0,0x100
 3010064:	157d                	addi	a0,a0,-1 # fffff <FLASH_SIZE+0xe0003>
 3010066:	801006b7          	lui	a3,0x80100
 301006a:	8fe9                	and	a5,a5,a0
 301006c:	7ff77713          	andi	a4,a4,2047
 3010070:	16fd                	addi	a3,a3,-1 # 800fffff <RAM_END+0x7c0f7fff>
 3010072:	0752                	slli	a4,a4,0x14
 3010074:	8ff5                	and	a5,a5,a3
 3010076:	8fd9                	or	a5,a5,a4
 3010078:	8522                	mv	a0,s0
 301007a:	40b2                	lw	ra,12(sp)
 301007c:	4422                	lw	s0,8(sp)
 301007e:	80000737          	lui	a4,0x80000
 3010082:	fff74713          	not	a4,a4
 3010086:	8f7d                	and	a4,a4,a5
 3010088:	85ba                	mv	a1,a4
 301008a:	0141                	addi	sp,sp,16
 301008c:	8082                	ret
 301008e:	1555                	addi	a0,a0,-11
 3010090:	00a417b3          	sll	a5,s0,a0
 3010094:	4401                	li	s0,0
 3010096:	b7e9                	j	3010060 <__floatunsidf+0x26>
 3010098:	4781                	li	a5,0
 301009a:	4401                	li	s0,0
 301009c:	4701                	li	a4,0
 301009e:	b7c9                	j	3010060 <__floatunsidf+0x26>

030100a0 <__extendsfdf2>:
 30100a0:	1141                	addi	sp,sp,-16
 30100a2:	c606                	sw	ra,12(sp)
 30100a4:	c422                	sw	s0,8(sp)
 30100a6:	c226                	sw	s1,4(sp)
 30100a8:	e00506d3          	fmv.x.w	a3,fa0
 30100ac:	002027f3          	frrm	a5
 30100b0:	0176d513          	srli	a0,a3,0x17
 30100b4:	0ff57513          	andi	a0,a0,255
 30100b8:	00800437          	lui	s0,0x800
 30100bc:	00150793          	addi	a5,a0,1
 30100c0:	147d                	addi	s0,s0,-1 # 7fffff <FLASH_SIZE+0x7e0003>
 30100c2:	0ff7f793          	andi	a5,a5,255
 30100c6:	4705                	li	a4,1
 30100c8:	8c75                	and	s0,s0,a3
 30100ca:	01f6d493          	srli	s1,a3,0x1f
 30100ce:	00f75963          	bge	a4,a5,30100e0 <__extendsfdf2+0x40>
 30100d2:	00345793          	srli	a5,s0,0x3
 30100d6:	38050513          	addi	a0,a0,896
 30100da:	0476                	slli	s0,s0,0x1d
 30100dc:	4701                	li	a4,0
 30100de:	a891                	j	3010132 <__extendsfdf2+0x92>
 30100e0:	e915                	bnez	a0,3010114 <__extendsfdf2+0x74>
 30100e2:	c459                	beqz	s0,3010170 <__extendsfdf2+0xd0>
 30100e4:	8522                	mv	a0,s0
 30100e6:	2c6d                	jal	ra,30103a0 <__clzsi2>
 30100e8:	47a9                	li	a5,10
 30100ea:	00a7cf63          	blt	a5,a0,3010108 <__extendsfdf2+0x68>
 30100ee:	47ad                	li	a5,11
 30100f0:	8f89                	sub	a5,a5,a0
 30100f2:	01550713          	addi	a4,a0,21
 30100f6:	00f457b3          	srl	a5,s0,a5
 30100fa:	00e41433          	sll	s0,s0,a4
 30100fe:	38900713          	li	a4,905
 3010102:	40a70533          	sub	a0,a4,a0
 3010106:	bfd9                	j	30100dc <__extendsfdf2+0x3c>
 3010108:	ff550793          	addi	a5,a0,-11
 301010c:	00f417b3          	sll	a5,s0,a5
 3010110:	4401                	li	s0,0
 3010112:	b7f5                	j	30100fe <__extendsfdf2+0x5e>
 3010114:	c02d                	beqz	s0,3010176 <__extendsfdf2+0xd6>
 3010116:	00400737          	lui	a4,0x400
 301011a:	8f61                	and	a4,a4,s0
 301011c:	00345793          	srli	a5,s0,0x3
 3010120:	00173713          	seqz	a4,a4
 3010124:	000806b7          	lui	a3,0x80
 3010128:	0712                	slli	a4,a4,0x4
 301012a:	0476                	slli	s0,s0,0x1d
 301012c:	8fd5                	or	a5,a5,a3
 301012e:	7ff00513          	li	a0,2047
 3010132:	00100637          	lui	a2,0x100
 3010136:	167d                	addi	a2,a2,-1 # fffff <FLASH_SIZE+0xe0003>
 3010138:	8ff1                	and	a5,a5,a2
 301013a:	80100637          	lui	a2,0x80100
 301013e:	167d                	addi	a2,a2,-1 # 800fffff <RAM_END+0x7c0f7fff>
 3010140:	7ff57513          	andi	a0,a0,2047
 3010144:	0552                	slli	a0,a0,0x14
 3010146:	8ff1                	and	a5,a5,a2
 3010148:	80000637          	lui	a2,0x80000
 301014c:	8fc9                	or	a5,a5,a0
 301014e:	fff64613          	not	a2,a2
 3010152:	01f49693          	slli	a3,s1,0x1f
 3010156:	8ff1                	and	a5,a5,a2
 3010158:	00d7e633          	or	a2,a5,a3
 301015c:	8522                	mv	a0,s0
 301015e:	85b2                	mv	a1,a2
 3010160:	c319                	beqz	a4,3010166 <__extendsfdf2+0xc6>
 3010162:	00172073          	csrs	fflags,a4
 3010166:	40b2                	lw	ra,12(sp)
 3010168:	4422                	lw	s0,8(sp)
 301016a:	4492                	lw	s1,4(sp)
 301016c:	0141                	addi	sp,sp,16
 301016e:	8082                	ret
 3010170:	4781                	li	a5,0
 3010172:	4501                	li	a0,0
 3010174:	b7a5                	j	30100dc <__extendsfdf2+0x3c>
 3010176:	4781                	li	a5,0
 3010178:	7ff00513          	li	a0,2047
 301017c:	b785                	j	30100dc <__extendsfdf2+0x3c>

0301017e <__truncdfsf2>:
 301017e:	00202873          	frrm	a6
 3010182:	001006b7          	lui	a3,0x100
 3010186:	16fd                	addi	a3,a3,-1 # fffff <FLASH_SIZE+0xe0003>
 3010188:	8eed                	and	a3,a3,a1
 301018a:	0145d893          	srli	a7,a1,0x14
 301018e:	00369793          	slli	a5,a3,0x3
 3010192:	7ff8f893          	andi	a7,a7,2047
 3010196:	01d55693          	srli	a3,a0,0x1d
 301019a:	8edd                	or	a3,a3,a5
 301019c:	00188793          	addi	a5,a7,1
 30101a0:	7ff7f793          	andi	a5,a5,2047
 30101a4:	4705                	li	a4,1
 30101a6:	81fd                	srli	a1,a1,0x1f
 30101a8:	00351613          	slli	a2,a0,0x3
 30101ac:	16f75b63          	bge	a4,a5,3010322 <__truncdfsf2+0x1a4>
 30101b0:	c8088713          	addi	a4,a7,-896
 30101b4:	0fe00793          	li	a5,254
 30101b8:	0ae7d063          	bge	a5,a4,3010258 <__truncdfsf2+0xda>
 30101bc:	04080063          	beqz	a6,30101fc <__truncdfsf2+0x7e>
 30101c0:	478d                	li	a5,3
 30101c2:	02f81963          	bne	a6,a5,30101f4 <__truncdfsf2+0x76>
 30101c6:	c99d                	beqz	a1,30101fc <__truncdfsf2+0x7e>
 30101c8:	57fd                	li	a5,-1
 30101ca:	0fe00713          	li	a4,254
 30101ce:	4681                	li	a3,0
 30101d0:	4615                	li	a2,5
 30101d2:	4509                	li	a0,2
 30101d4:	00166613          	ori	a2,a2,1
 30101d8:	1aa80063          	beq	a6,a0,3010378 <__truncdfsf2+0x1fa>
 30101dc:	450d                	li	a0,3
 30101de:	18a80a63          	beq	a6,a0,3010372 <__truncdfsf2+0x1f4>
 30101e2:	12081763          	bnez	a6,3010310 <__truncdfsf2+0x192>
 30101e6:	00f7f513          	andi	a0,a5,15
 30101ea:	4891                	li	a7,4
 30101ec:	13150263          	beq	a0,a7,3010310 <__truncdfsf2+0x192>
 30101f0:	0791                	addi	a5,a5,4
 30101f2:	aa39                	j	3010310 <__truncdfsf2+0x192>
 30101f4:	4789                	li	a5,2
 30101f6:	fcf819e3          	bne	a6,a5,30101c8 <__truncdfsf2+0x4a>
 30101fa:	d5f9                	beqz	a1,30101c8 <__truncdfsf2+0x4a>
 30101fc:	4781                	li	a5,0
 30101fe:	0ff00713          	li	a4,255
 3010202:	4615                	li	a2,5
 3010204:	00579693          	slli	a3,a5,0x5
 3010208:	0006db63          	bgez	a3,301021e <__truncdfsf2+0xa0>
 301020c:	0705                	addi	a4,a4,1 # 400001 <FLASH_SIZE+0x3e0005>
 301020e:	0ff00693          	li	a3,255
 3010212:	16d70563          	beq	a4,a3,301037c <__truncdfsf2+0x1fe>
 3010216:	fc0006b7          	lui	a3,0xfc000
 301021a:	16fd                	addi	a3,a3,-1 # fbffffff <RAM_END+0xf7ff7fff>
 301021c:	8ff5                	and	a5,a5,a3
 301021e:	0ff00693          	li	a3,255
 3010222:	838d                	srli	a5,a5,0x3
 3010224:	00d71663          	bne	a4,a3,3010230 <__truncdfsf2+0xb2>
 3010228:	c781                	beqz	a5,3010230 <__truncdfsf2+0xb2>
 301022a:	004007b7          	lui	a5,0x400
 301022e:	4581                	li	a1,0
 3010230:	008006b7          	lui	a3,0x800
 3010234:	16fd                	addi	a3,a3,-1 # 7fffff <FLASH_SIZE+0x7e0003>
 3010236:	8ff5                	and	a5,a5,a3
 3010238:	808006b7          	lui	a3,0x80800
 301023c:	0ff77713          	andi	a4,a4,255
 3010240:	16fd                	addi	a3,a3,-1 # 807fffff <RAM_END+0x7c7f7fff>
 3010242:	075e                	slli	a4,a4,0x17
 3010244:	8ff5                	and	a5,a5,a3
 3010246:	05fe                	slli	a1,a1,0x1f
 3010248:	8fd9                	or	a5,a5,a4
 301024a:	8fcd                	or	a5,a5,a1
 301024c:	c219                	beqz	a2,3010252 <__truncdfsf2+0xd4>
 301024e:	00162073          	csrs	fflags,a2
 3010252:	f0078553          	fmv.w.x	fa0,a5
 3010256:	8082                	ret
 3010258:	08e04e63          	bgtz	a4,30102f4 <__truncdfsf2+0x176>
 301025c:	57a5                	li	a5,-23
 301025e:	0ef74d63          	blt	a4,a5,3010358 <__truncdfsf2+0x1da>
 3010262:	008007b7          	lui	a5,0x800
 3010266:	4379                	li	t1,30
 3010268:	8edd                	or	a3,a3,a5
 301026a:	40e30333          	sub	t1,t1,a4
 301026e:	47fd                	li	a5,31
 3010270:	0467ce63          	blt	a5,t1,30102cc <__truncdfsf2+0x14e>
 3010274:	c8288893          	addi	a7,a7,-894
 3010278:	011617b3          	sll	a5,a2,a7
 301027c:	00f037b3          	snez	a5,a5
 3010280:	011696b3          	sll	a3,a3,a7
 3010284:	00665333          	srl	t1,a2,t1
 3010288:	8edd                	or	a3,a3,a5
 301028a:	00d367b3          	or	a5,t1,a3
 301028e:	4701                	li	a4,0
 3010290:	cff9                	beqz	a5,301036e <__truncdfsf2+0x1f0>
 3010292:	00179713          	slli	a4,a5,0x1
 3010296:	00777693          	andi	a3,a4,7
 301029a:	4601                	li	a2,0
 301029c:	c28d                	beqz	a3,30102be <__truncdfsf2+0x140>
 301029e:	4689                	li	a3,2
 30102a0:	0cd80263          	beq	a6,a3,3010364 <__truncdfsf2+0x1e6>
 30102a4:	468d                	li	a3,3
 30102a6:	0ad80b63          	beq	a6,a3,301035c <__truncdfsf2+0x1de>
 30102aa:	4605                	li	a2,1
 30102ac:	00081963          	bnez	a6,30102be <__truncdfsf2+0x140>
 30102b0:	00f77693          	andi	a3,a4,15
 30102b4:	4511                	li	a0,4
 30102b6:	4605                	li	a2,1
 30102b8:	00a68363          	beq	a3,a0,30102be <__truncdfsf2+0x140>
 30102bc:	0711                	addi	a4,a4,4
 30102be:	01b75693          	srli	a3,a4,0x1b
 30102c2:	0016c693          	xori	a3,a3,1
 30102c6:	8a85                	andi	a3,a3,1
 30102c8:	4701                	li	a4,0
 30102ca:	a83d                	j	3010308 <__truncdfsf2+0x18a>
 30102cc:	57f9                	li	a5,-2
 30102ce:	40e78733          	sub	a4,a5,a4
 30102d2:	02000793          	li	a5,32
 30102d6:	00e6d733          	srl	a4,a3,a4
 30102da:	4501                	li	a0,0
 30102dc:	00f30663          	beq	t1,a5,30102e8 <__truncdfsf2+0x16a>
 30102e0:	ca288893          	addi	a7,a7,-862
 30102e4:	01169533          	sll	a0,a3,a7
 30102e8:	00c567b3          	or	a5,a0,a2
 30102ec:	00f037b3          	snez	a5,a5
 30102f0:	8fd9                	or	a5,a5,a4
 30102f2:	bf71                	j	301028e <__truncdfsf2+0x110>
 30102f4:	051a                	slli	a0,a0,0x6
 30102f6:	00a037b3          	snez	a5,a0
 30102fa:	068e                	slli	a3,a3,0x3
 30102fc:	8275                	srli	a2,a2,0x1d
 30102fe:	8edd                	or	a3,a3,a5
 3010300:	00c6e7b3          	or	a5,a3,a2
 3010304:	4681                	li	a3,0
 3010306:	4601                	li	a2,0
 3010308:	0077f513          	andi	a0,a5,7
 301030c:	ec0513e3          	bnez	a0,30101d2 <__truncdfsf2+0x54>
 3010310:	ee068ae3          	beqz	a3,3010204 <__truncdfsf2+0x86>
 3010314:	00167693          	andi	a3,a2,1
 3010318:	ee0686e3          	beqz	a3,3010204 <__truncdfsf2+0x86>
 301031c:	00266613          	ori	a2,a2,2
 3010320:	b5d5                	j	3010204 <__truncdfsf2+0x86>
 3010322:	00c6e7b3          	or	a5,a3,a2
 3010326:	00089563          	bnez	a7,3010330 <__truncdfsf2+0x1b2>
 301032a:	00f037b3          	snez	a5,a5
 301032e:	b785                	j	301028e <__truncdfsf2+0x110>
 3010330:	cf8d                	beqz	a5,301036a <__truncdfsf2+0x1ec>
 3010332:	7ff00793          	li	a5,2047
 3010336:	4601                	li	a2,0
 3010338:	00f89863          	bne	a7,a5,3010348 <__truncdfsf2+0x1ca>
 301033c:	00400637          	lui	a2,0x400
 3010340:	8e75                	and	a2,a2,a3
 3010342:	00163613          	seqz	a2,a2
 3010346:	0612                	slli	a2,a2,0x4
 3010348:	068e                	slli	a3,a3,0x3
 301034a:	020007b7          	lui	a5,0x2000
 301034e:	8fd5                	or	a5,a5,a3
 3010350:	0ff00713          	li	a4,255
 3010354:	4681                	li	a3,0
 3010356:	bf4d                	j	3010308 <__truncdfsf2+0x18a>
 3010358:	4785                	li	a5,1
 301035a:	bf25                	j	3010292 <__truncdfsf2+0x114>
 301035c:	4605                	li	a2,1
 301035e:	f1a5                	bnez	a1,30102be <__truncdfsf2+0x140>
 3010360:	0721                	addi	a4,a4,8
 3010362:	bfb1                	j	30102be <__truncdfsf2+0x140>
 3010364:	4605                	li	a2,1
 3010366:	dda1                	beqz	a1,30102be <__truncdfsf2+0x140>
 3010368:	bfe5                	j	3010360 <__truncdfsf2+0x1e2>
 301036a:	0ff00713          	li	a4,255
 301036e:	4601                	li	a2,0
 3010370:	bd51                	j	3010204 <__truncdfsf2+0x86>
 3010372:	fdd9                	bnez	a1,3010310 <__truncdfsf2+0x192>
 3010374:	07a1                	addi	a5,a5,8 # 2000008 <RAM_CODE_START+0x8>
 3010376:	bf69                	j	3010310 <__truncdfsf2+0x192>
 3010378:	ddc1                	beqz	a1,3010310 <__truncdfsf2+0x192>
 301037a:	bfed                	j	3010374 <__truncdfsf2+0x1f6>
 301037c:	4781                	li	a5,0
 301037e:	00080e63          	beqz	a6,301039a <__truncdfsf2+0x21c>
 3010382:	468d                	li	a3,3
 3010384:	00d81763          	bne	a6,a3,3010392 <__truncdfsf2+0x214>
 3010388:	c989                	beqz	a1,301039a <__truncdfsf2+0x21c>
 301038a:	57fd                	li	a5,-1
 301038c:	0fe00713          	li	a4,254
 3010390:	a029                	j	301039a <__truncdfsf2+0x21c>
 3010392:	4689                	li	a3,2
 3010394:	fed81be3          	bne	a6,a3,301038a <__truncdfsf2+0x20c>
 3010398:	d9ed                	beqz	a1,301038a <__truncdfsf2+0x20c>
 301039a:	00566613          	ori	a2,a2,5
 301039e:	b541                	j	301021e <__truncdfsf2+0xa0>

030103a0 <__clzsi2>:
 30103a0:	67c1                	lui	a5,0x10
 30103a2:	02f57663          	bgeu	a0,a5,30103ce <__clzsi2+0x2e>
 30103a6:	0ff00793          	li	a5,255
 30103aa:	00a7b7b3          	sltu	a5,a5,a0
 30103ae:	078e                	slli	a5,a5,0x3
 30103b0:	02000713          	li	a4,32
 30103b4:	8f1d                	sub	a4,a4,a5
 30103b6:	00f557b3          	srl	a5,a0,a5
 30103ba:	00001517          	auipc	a0,0x1
 30103be:	eea52503          	lw	a0,-278(a0) # 30112a4 <_GLOBAL_OFFSET_TABLE_+0x4>
 30103c2:	97aa                	add	a5,a5,a0
 30103c4:	0007c503          	lbu	a0,0(a5) # 10000 <RAM_SIZE+0xb000>
 30103c8:	40a70533          	sub	a0,a4,a0
 30103cc:	8082                	ret
 30103ce:	01000737          	lui	a4,0x1000
 30103d2:	47c1                	li	a5,16
 30103d4:	fce56ee3          	bltu	a0,a4,30103b0 <__clzsi2+0x10>
 30103d8:	47e1                	li	a5,24
 30103da:	bfd9                	j	30103b0 <__clzsi2+0x10>

030103dc <fabsf>:
 30103dc:	e00507d3          	fmv.x.w	a5,fa0
 30103e0:	80000737          	lui	a4,0x80000
 30103e4:	fff74713          	not	a4,a4
 30103e8:	8ff9                	and	a5,a5,a4
 30103ea:	f0078553          	fmv.w.x	fa0,a5
 30103ee:	8082                	ret

030103f0 <round>:
 30103f0:	7179                	addi	sp,sp,-48
 30103f2:	ce4e                	sw	s3,28(sp)
 30103f4:	0145d993          	srli	s3,a1,0x14
 30103f8:	d422                	sw	s0,40(sp)
 30103fa:	d226                	sw	s1,36(sp)
 30103fc:	d606                	sw	ra,44(sp)
 30103fe:	d04a                	sw	s2,32(sp)
 3010400:	cc52                	sw	s4,24(sp)
 3010402:	ca56                	sw	s5,20(sp)
 3010404:	c85a                	sw	s6,16(sp)
 3010406:	7ff9f993          	andi	s3,s3,2047
 301040a:	43200793          	li	a5,1074
 301040e:	84aa                	mv	s1,a0
 3010410:	842e                	mv	s0,a1
 3010412:	0537c163          	blt	a5,s3,3010454 <round+0x64>
 3010416:	8b2e                	mv	s6,a1
 3010418:	892e                	mv	s2,a1
 301041a:	0005d663          	bgez	a1,3010426 <round+0x36>
 301041e:	80000937          	lui	s2,0x80000
 3010422:	00b94933          	xor	s2,s2,a1
 3010426:	03011a37          	lui	s4,0x3011
 301042a:	284a2683          	lw	a3,644(s4) # 3011284 <__clz_tab+0x104>
 301042e:	280a2603          	lw	a2,640(s4)
 3010432:	8526                	mv	a0,s1
 3010434:	85ca                	mv	a1,s2
 3010436:	20d9                	jal	ra,30104fc <__adddf3.trans.31>
 3010438:	3fd00693          	li	a3,1021
 301043c:	0336c863          	blt	a3,s3,301046c <round+0x7c>
 3010440:	c42a                	sw	a0,8(sp)
 3010442:	c62e                	sw	a1,12(sp)
 3010444:	8526                	mv	a0,s1
 3010446:	85a2                	mv	a1,s0
 3010448:	4601                	li	a2,0
 301044a:	4681                	li	a3,0
 301044c:	d29fe0ef          	jal	ra,300f174 <__muldf3>
 3010450:	84aa                	mv	s1,a0
 3010452:	842e                	mv	s0,a1
 3010454:	85a2                	mv	a1,s0
 3010456:	50b2                	lw	ra,44(sp)
 3010458:	5422                	lw	s0,40(sp)
 301045a:	8526                	mv	a0,s1
 301045c:	5902                	lw	s2,32(sp)
 301045e:	5492                	lw	s1,36(sp)
 3010460:	49f2                	lw	s3,28(sp)
 3010462:	4a62                	lw	s4,24(sp)
 3010464:	4ad2                	lw	s5,20(sp)
 3010466:	4b42                	lw	s6,16(sp)
 3010468:	6145                	addi	sp,sp,48
 301046a:	8082                	ret
 301046c:	280a2603          	lw	a2,640(s4)
 3010470:	284a2683          	lw	a3,644(s4)
 3010474:	2051                	jal	ra,30104f8 <__subdf3.trans.41>
 3010476:	8626                	mv	a2,s1
 3010478:	86ca                	mv	a3,s2
 301047a:	28bd                	jal	ra,30104f8 <__subdf3.trans.41>
 301047c:	862a                	mv	a2,a0
 301047e:	86ae                	mv	a3,a1
 3010480:	8a2a                	mv	s4,a0
 3010482:	8aae                	mv	s5,a1
 3010484:	8526                	mv	a0,s1
 3010486:	85ca                	mv	a1,s2
 3010488:	2895                	jal	ra,30104fc <__adddf3.trans.31>
 301048a:	030117b7          	lui	a5,0x3011
 301048e:	2887a603          	lw	a2,648(a5) # 3011288 <__clz_tab+0x108>
 3010492:	28c7a683          	lw	a3,652(a5)
 3010496:	89aa                	mv	s3,a0
 3010498:	892e                	mv	s2,a1
 301049a:	84aa                	mv	s1,a0
 301049c:	842e                	mv	s0,a1
 301049e:	8552                	mv	a0,s4
 30104a0:	85d6                	mv	a1,s5
 30104a2:	b6bfe0ef          	jal	ra,300f00c <__gedf2>
 30104a6:	02a05363          	blez	a0,30104cc <round+0xdc>
 30104aa:	030117b7          	lui	a5,0x3011
 30104ae:	2907a603          	lw	a2,656(a5) # 3011290 <__clz_tab+0x110>
 30104b2:	2947a683          	lw	a3,660(a5)
 30104b6:	854e                	mv	a0,s3
 30104b8:	85ca                	mv	a1,s2
 30104ba:	283d                	jal	ra,30104f8 <__subdf3.trans.41>
 30104bc:	84aa                	mv	s1,a0
 30104be:	842e                	mv	s0,a1
 30104c0:	f80b5ae3          	bgez	s6,3010454 <round+0x64>
 30104c4:	800007b7          	lui	a5,0x80000
 30104c8:	8c3d                	xor	s0,s0,a5
 30104ca:	b769                	j	3010454 <round+0x64>
 30104cc:	030117b7          	lui	a5,0x3011
 30104d0:	2987a603          	lw	a2,664(a5) # 3011298 <__clz_tab+0x118>
 30104d4:	29c7a683          	lw	a3,668(a5)
 30104d8:	8552                	mv	a0,s4
 30104da:	85d6                	mv	a1,s5
 30104dc:	be5fe0ef          	jal	ra,300f0c0 <__ledf2>
 30104e0:	fea040e3          	bgtz	a0,30104c0 <round+0xd0>
 30104e4:	030117b7          	lui	a5,0x3011
 30104e8:	2907a603          	lw	a2,656(a5) # 3011290 <__clz_tab+0x110>
 30104ec:	2947a683          	lw	a3,660(a5)
 30104f0:	854e                	mv	a0,s3
 30104f2:	85ca                	mv	a1,s2
 30104f4:	2021                	jal	ra,30104fc <__adddf3.trans.31>
 30104f6:	b7d9                	j	30104bc <round+0xcc>

030104f8 <__subdf3.trans.41>:
 30104f8:	a32ff06f          	j	300f72a <__subdf3>

030104fc <__adddf3.trans.31>:
 30104fc:	c31fd06f          	j	300e12c <__adddf3>

03010500 <abs>:
 3010500:	41f55793          	srai	a5,a0,0x1f
 3010504:	8d3d                	xor	a0,a0,a5
 3010506:	8d1d                	sub	a0,a0,a5
 3010508:	8082                	ret
	...

0301050c <__rodata_start>:
 301050c:	9680                	pop	{ra,s0-s6},384
 301050e:	4b18                	lw	a4,16(a4)

03010510 <g_crgIpMatch>:
 3010510:	0000 1400 0000 0000 0140 0000 1000 1400     ........@.......
 3010520:	0000 0000 0144 0000 2000 1400 0000 0000     ....D.... ......
 3010530:	0148 0000 3000 1400 0000 0000 014c 0000     H....0......L...
 3010540:	0000 1430 0000 0000 0240 0000 1000 1430     ..0.....@.....0.
 3010550:	0000 0000 0244 0000 2000 1430 0000 0000     ....D.... 0.....
 3010560:	0248 0000 3000 1430 0000 0000 024c 0000     H....00.....L...
 3010570:	0000 1438 0000 0000 0040 0000 0000 1420     ..8.....@..... .
 3010580:	0000 0000 0180 0000 1000 1420 0000 0000     .......... .....
 3010590:	0184 0000 0000 1410 0000 0000 01c0 0000     ................
 30105a0:	1000 1410 0000 0000 01c4 0000 0000 1460     ..............`.
 30105b0:	0002 0000 02c0 0000 0000 1470 0001 0000     ..........p.....
 30105c0:	0440 0000 1000 1470 0001 0000 0444 0000     @.....p.....D...
 30105d0:	2000 1470 0001 0000 0448 0000 3000 1470     . p.....H....0p.
 30105e0:	0001 0000 044c 0000 0000 1440 0001 0000     ....L.....@.....
 30105f0:	0200 0000 0000 14b0 0001 0000 0280 0000     ................
 3010600:	1000 14b0 0001 0000 0284 0000 2000 14b0     ............. ..
 3010610:	0001 0000 0288 0000 0000 1c00 0001 0000     ................
 3010620:	0300 0000 0000 1450 0001 0000 0480 0000     ......P.........
 3010630:	1000 1450 0001 0000 0484 0000 2000 1450     ..P.......... P.
 3010640:	0001 0000 0488 0000 3000 1450 0001 0000     .........0P.....
 3010650:	048c 0000 4000 1450 0001 0000 0490 0000     .....@P.........
 3010660:	5000 1450 0001 0000 0494 0000 1000 1440     .PP...........@.
 3010670:	0005 0000 03c0 0000 0000 14c0 0001 0000     ................
 3010680:	04c0 0000 1000 14c0 0001 0000 04c4 0000     ................
 3010690:	0000 147d 0001 0000 0b00 0000 0000 1480     ..}.............
 30106a0:	0001 0000 0380 0000 0000 14a0 0001 0000     ................
 30106b0:	0400 0000 1000 14a0 0001 0000 0404 0000     ................
 30106c0:	2000 14a0 0001 0000 0408 0000 3000 14a0     . ...........0..
 30106d0:	0001 0000 040c 0000 0000 1001 0001 0000     ................
 30106e0:	0340 0000 0000 1810 0006 0000 0a60 0000     @...........`...
 30106f0:	0000 1830 0006 0000 0a70 0000 0000 1840     ..0.....p.....@.
 3010700:	0006 0000 0a80 0000 0000 1820 0006 0000     .......... .....
 3010710:	0a90 0000 1000 1820 0006 0000 0a90 0004     ...... .........
 3010720:	0000 1800 0003 0000 0a00 0000 0000 1471     ..............q.
 3010730:	0004 0000 0500 0000 2e2e 642f 6972 6576     ........../drive
 3010740:	7372 612f 6364 692f 636e 612f 6364 695f     rs/adc/inc/adc_i
 3010750:	2e70 0068 2e2e 642f 6972 6576 7372 612f     p.h.../drivers/a
 3010760:	6364 732f 6372 612f 6364 632e 0000 0000     dc/src/adc.c....
 3010770:	2e2e 642f 6972 6576 7372 612f 7470 692f     ../drivers/apt/i
 3010780:	636e 612f 7470 695f 2e70 0068 2e2e 642f     nc/apt_ip.h.../d
 3010790:	6972 6576 7372 612f 7470 732f 6372 612f     rivers/apt/src/a
 30107a0:	7470 632e 0000 0000 28de 0300 29f6 0300     pt.c.....(...)..
 30107b0:	2b0e 0300 2c26 0300 0000 42c8 2e2e 642f     .+..&,.....B../d
 30107c0:	6972 6576 7372 622f 7361 2f65 7273 2f63     rivers/base/src/
 30107d0:	6e69 6574 7272 7075 2e74 0063 31d4 0300     interrupt.c..1..
 30107e0:	3226 0300 3278 0300 32ca 0300 331c 0300     &2..x2...2...3..
 30107f0:	336e 0300 33c0 0300 3412 0300 34bc 0300     n3...3...4...4..
 3010800:	350e 0300 3560 0300 35b2 0300 3604 0300     .5..`5...5...6..
 3010810:	3656 0300 36a8 0300 36fa 0300 4142 4455     V6...6...6..BAUD
 3010820:	5220 5441 3a45 2520 0d64 000a 7257 7469      RATE: %d...Writ
 3010830:	4465 7461 2161 0a0d 0000 0000 2e2e 642f     eData!......../d
 3010840:	6972 6576 7372 632f 6772 692f 636e 632f     rivers/crg/inc/c
 3010850:	6772 695f 2e70 0068 2e2e 642f 6972 6576     rg_ip.h.../drive
 3010860:	7372 632f 6772 732f 6372 632f 6772 632e     rs/crg/src/crg.c
	...
 3010878:	0001 0000 0002 0000 0003 0000 0004 0000     ................
 3010888:	0005 0000 0006 0000 0007 0000 4f74 0300     ............tO..
 3010898:	4f84 0300 4f8e 0300 4fa2 0300 4f84 0300     .O...O...O...O..
 30108a8:	4fbe 0300 4f84 0300 6796 0300 6800 0300     .O...O...g...h..
 30108b8:	6800 0300 6800 0300 6800 0300 6800 0300     .h...h...h...h..
 30108c8:	6800 0300 6800 0300 6800 0300 6800 0300     .h...h...h...h..
 30108d8:	6800 0300 66d6 0300 672c 0300 6800 0300     .h...f..,g...h..
 30108e8:	67c0 0300 6800 0300 6800 0300 6800 0300     .g...h...h...h..
 30108f8:	6800 0300 6800 0300 6800 0300 6800 0300     .h...h...h...h..
 3010908:	6800 0300 6800 0300 6796 0300 6800 0300     .h...h...g...h..
 3010918:	6800 0300 6700 0300 6800 0300 6756 0300     .h...g...h..Vg..
 3010928:	6800 0300 6800 0300 6796 0300 2e2e 642f     .h...h...g..../d
 3010938:	6972 6576 7372 672f 6970 2f6f 6e69 2f63     rivers/gpio/inc/
 3010948:	7067 6f69 695f 2e70 0068 0000 2e2e 642f     gpio_ip.h...../d
 3010958:	6972 6576 7372 672f 6970 2f6f 7273 2f63     rivers/gpio/src/
 3010968:	7067 6f69 632e 0000 2e2e 642f 6972 6576     gpio.c..../drive
 3010978:	7372 672f 7470 732f 6372 672f 7470 632e     rs/gpt/src/gpt.c
 3010988:	0000 0000 2e2e 642f 6972 6576 7372 692f     ....../drivers/i
 3010998:	6332 732f 6372 692f 6332 632e 0000 0000     2c/src/i2c.c....
 30109a8:	2e2e 642f 6972 6576 7372 692f 636f 676d     ../drivers/iocmg
 30109b8:	692f 636e 692f 636f 676d 695f 2e70 0068     /inc/iocmg_ip.h.
 30109c8:	2e2e 642f 6972 6576 7372 692f 636f 676d     ../drivers/iocmg
 30109d8:	732f 6372 692f 636f 676d 632e 0000 0000     /src/iocmg.c....
 30109e8:	2e2e 642f 6972 6576 7372 712f 6d64 692f     ../drivers/qdm/i
 30109f8:	636e 712f 6d64 695f 2e70 0068 2e2e 642f     nc/qdm_ip.h.../d
 3010a08:	6972 6576 7372 712f 6d64 732f 6372 712f     rivers/qdm/src/q
 3010a18:	6d64 632e 0000 0000 9a58 0300 9a64 0300     dm.c....X...d...
 3010a28:	9a70 0300 9a7c 0300 9a8a 0300 9a98 0300     p...|...........
 3010a38:	9aa4 0300 9ab0 0300 9abe 0300 9aca 0300     ................
 3010a48:	2e2e 642f 6972 6576 7372 742f 6d69 7265     ../drivers/timer
 3010a58:	692f 636e 742f 6d69 7265 695f 2e70 0068     /inc/timer_ip.h.
 3010a68:	2e2e 642f 6972 6576 7372 742f 6d69 7265     ../drivers/timer
 3010a78:	732f 6372 742f 6d69 7265 632e 0000 0000     /src/timer.c....
 3010a88:	a4e6 0300 a4fc 0300 a512 0300 a528 0300     ............(...
 3010a98:	a53e 0300 2e2e 642f 6972 6576 7372 752f     >...../drivers/u
 3010aa8:	7261 2f74 7273 2f63 6175 7472 632e 0000     art/src/uart.c..
 3010ab8:	b15a 0300 b166 0300 b172 0300 b17e 0300     Z...f...r...~...
 3010ac8:	b18a 0300 b196 0300 b1a2 0300 b1ae 0300     ................
 3010ad8:	b1ba 0300 7257 7469 2065 6143 6c6c 6162     ....Write Callba
 3010ae8:	6b63 0a0d 0000 0000 6552 6461 4320 6c61     ck......Read Cal
 3010af8:	626c 6361 216b 0a0d 0000 0000 4554 5453     lback!......TEST
 3010b08:	4320 4e41 0000 0000 694c 7466 0a0d 0000      CAN....Lift....
 3010b18:	614c 0d79 000a 0000 3d3d 4d3d 746f 726f     Lay.....===Motor
 3010b28:	4520 636e 646f 2065 7245 6f72 2072 203d      Encode Error = 
 3010b38:	6425 202c 6f6d 6f74 2072 6973 6564 253a     %d, motor side:%
 3010b48:	2c64 6320 6c61 7563 616c 6574 7020 7265     d, calculate per
 3010b58:	6f69 2064 6425 736d 3d3d 0d3d 000a 0000     iod %dms===.....
 3010b68:	0000 0000 c000 4050 d197 5a7e 21fb 4009     ......P@..~Z.!.@
 3010b78:	0000 0000 0000 4059 0000 0000 0000 4024     ......Y@......$@
 3010b88:	0000 0000 4000 408f 6341 7574 6c61 6665     .....@.@Actualef
 3010b98:	5374 6570 6465 253a 322e 6d66 2f6d 2c73     tSpeed:%.2fmm/s,
 3010ba8:	6341 7574 6c61 6952 6867 5374 6570 6465     ActualRightSpeed
 3010bb8:	253a 322e 6d66 2f6d 2c73 5f41 6f4d 6576     :%.2fmm/s,A_Move
 3010bc8:	585f 253d 322e 6d66 2f6d 2c73 5f41 6f4d     _X=%.2fmm/s,A_Mo
 3010bd8:	6576 5a5f 253d 322e 6d66 6172 2f64 0d73     ve_Z=%.2fmrad/s.
 3010be8:	000a 0000 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d     ....------------
 3010bf8:	2d2d 2d2d 732d 6e65 5f64 6f63 6e75 3d74     -----send_count=
 3010c08:	7525 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d     %u--------------
 3010c18:	2d2d 0d2d 000a 0000 7830 7825 0020 0000     ---.....0x%x ...
 3010c28:	2020 0a0d 0000 0000 6144 6174 7320 6e65       ......Data sen
 3010c38:	2064 7265 6f72 2c72 6320 646f 2065 203d     d error, code = 
 3010c48:	6425 0a0d 0000 0000 6f6d 6564 436c 6c61     %d......modelCal
 3010c58:	654c 7466 7053 6565 3a64 2e25 6632 6d6d     LeftSpeed:%.2fmm
 3010c68:	732f 202c 6f6d 6564 436c 6c61 6952 6867     /s, modelCalRigh
 3010c78:	5374 6570 6465 253a 322e 6d66 2f6d 0d73     tSpeed:%.2fmm/s.
 3010c88:	000a 0000 0a0d 5f67 6954 656d 4372 756f     ......g_TimerCou
 3010c98:	746e 253d 2c64 5f67 6552 7663 6f43 6e75     nt=%d,g_RecvCoun
 3010ca8:	3d74 6425 4d2c 766f 5f65 3d58 2e25 6632     t=%d,Move_X=%.2f
 3010cb8:	6d6d 732f 4d2c 766f 5f65 3d59 2e25 6632     mm/s,Move_Y=%.2f
 3010cc8:	6d6d 732f 4d2c 766f 5f65 3d5a 2e25 6632     mm/s,Move_Z=%.2f
 3010cd8:	726d 6461 732f 0a0d 0000 0000 0a0d 5f67     mrad/s........g_
 3010ce8:	6954 656d 4372 756f 746e 253d 2c64 5f67     TimerCount=%d,g_
 3010cf8:	6552 7663 6f43 6e75 3d74 6425 0000 0000     RecvCount=%d....
 3010d08:	0a0d 694c 656e 7261 7320 6570 6465 7320     ..Linear speed s
 3010d18:	7465 6520 7272 726f 203a 3d58 2e25 6632     et error: X=%.2f
 3010d28:	6d6d 732f 5920 253d 322e 6d66 2f6d 2c73     mm/s Y=%.2fmm/s,
 3010d38:	6d20 7375 2074 656c 7373 2520 322e 6d66      must less %.2fm
 3010d48:	2f6d 0d73 000a 0000 0a0d 6e41 7567 616c     m/s.......Angula
 3010d58:	2072 7073 6565 2064 6573 2074 7265 6f72     r speed set erro
 3010d68:	3a72 5a20 253d 322e 6d66 6172 2f64 2c73     r: Z=%.2fmrad/s,
 3010d78:	6d20 7375 2074 656c 7373 2520 312e 6d66      must less %.1fm
 3010d88:	6172 2f64 0d73 000a 6552 6563 6569 6576     rad/s...Receieve
 3010d98:	2164 0a0d 0000 0000 6552 6563 7669 2065     d!......Receive 
 3010da8:	656d 7373 6761 3a65 2520 2078 0a0d 0000     message: %x ....
 3010db8:	4c43 534f 2145 0a0d 0000 0000 504f 4e45     CLOSE!......OPEN
 3010dc8:	0d21 000a 5055 0d21 000a 0000 4f44 4e57     !...UP!.....DOWN
 3010dd8:	0d21 000a 7542 7474 6e6f 2031 7645 656e     !...Button1 Evne
 3010de8:	2c74 6720 4b5f 2050 202b 6625 0a0d 0000     t, g_KP + %f....
 3010df8:	5f67 504b 253d 2066 5f67 494b 253d 2066     g_KP=%f g_KI=%f 
 3010e08:	5f67 444b 253d 0d66 000a 0000 7542 7474     g_KD=%f.....Butt
 3010e18:	6e6f 2032 7645 656e 2c74 6720 4b5f 2049     on2 Evnet, g_KI 
 3010e28:	202b 6625 0a0d 0000 0000 4000 0000 0000     + %f.......@....
 3010e38:	0000 0000 0000 406e 0000 0000 4000 408f     ......n@.....@.@
 3010e48:	999a 9999 9999 3fb9 0000 42c8 0000 0000     .......?...B....
 3010e58:	0000 0000 0000 405e 0000 0000 0000 4000     ......^@.......@
 3010e68:	5000 47c3 0000 0000 0000 0000 6a00 40f8     .P.G.........j.@
 3010e78:	3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d     ================
 3010e88:	3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d     ================
 3010e98:	3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d     ================
 3010ea8:	3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 0a0d     ==============..
 3010eb8:	0000 0000 2020 2020 2020 2020 2020 2020     ....            
 3010ec8:	2020 2020 80e2 20a2 7545 656c 4372 7261         ... EulerCar
 3010ed8:	4320 6e6f 7274 6c6f 656c 2072 2e31 2030      Controller 1.0 
 3010ee8:	80e2 20a2 2020 2020 2020 2020 2020 2020     ...             
 3010ef8:	2020 2020 2020 0a0d 0000 0000 2020 2020           ......    
 3010f08:	2020 2020 2020 2020 2020 2020 2020 2020                     
 3010f18:	2020 2020 2020 2020 2020 2020 2020 2020                     
 3010f28:	2020 2020 2020 2020 2020 2020 2020 2020                     
 3010f38:	2020 2020 2020 2020 2020 0a0d 0000 0000               ......
 3010f48:	2020 9ee2 20a4 7953 7473 6d65 4920 666e       ... System Inf
 3010f58:	726f 616d 6974 6e6f 203a 2020 2020 2020     ormation:       
 3010f68:	2020 2020 2020 2020 2020 2020 2020 2020                     
 3010f78:	2020 2020 2020 2020 2020 2020 2020 0d20                    .
 3010f88:	000a 0000 2020 2020 2020 80e2 20a2 6f4d     ....      ... Mo
 3010f98:	6f74 2072 7954 6570 253a 0d73 000a 0000     tor Type:%s.....
 3010fa8:	2020 2020 2020 80e2 20a2 6f4d 6f74 2072           ... Motor 
 3010fb8:	6e45 6f63 6564 4c20 6e69 2065 754e 626d     Encode Line Numb
 3010fc8:	7265 253a 3530 0d64 000a 0000 2020 2020     er:%05d.....    
 3010fd8:	2020 80e2 20a2 6f4d 6f74 2072 614d 2078       ... Motor Max 
 3010fe8:	7053 6565 3a64 2e25 3230 6d66 2f6d 0d73     Speed:%.02fmm/s.
 3010ff8:	000a 0000 2020 2020 2020 80e2 20a2 7545     ....      ... Eu
 3011008:	656c 4372 7261 4420 7461 2061 6553 646e     lerCar Data Send
 3011018:	5020 7265 6f69 3a64 6425 736d 252c 4864      Period:%dms,%dH
 3011028:	0d5a 000a 2020 9ee2 20a4 4950 2044 6e49     Z...  ... PID In
 3011038:	6f66 6d72 7461 6f69 3a6e 2020 2020 2020     formation:      
 3011048:	2020 2020 2020 2020 2020 2020 2020 2020                     
 3011058:	2020 2020 2020 2020 2020 2020 2020 2020                     
 3011068:	2020 0d20 000a 0000 2020 2020 2020 80e2        .....      ..
 3011078:	20a2 504b 253a 302e 6632 2020 2020 80e2     . KP:%.02f    ..
 3011088:	20a2 494b 253a 302e 6632 2020 2020 80e2     . KI:%.02f    ..
 3011098:	20a2 444b 253a 302e 6632 0a0d 0000 0000     . KD:%.02f......
 30110a8:	2020 2020 2020 80e2 20a2 4950 2044 6f43           ... PID Co
 30110b8:	746e 6f72 206c 6550 6972 646f 253a 6d64     ntrol Period:%dm
 30110c8:	0d73 000a 7545 656c 4372 7261 4d20 5543     s...EulerCar MCU
 30110d8:	6920 696e 2074 7573 6363 7365 2173 2121      init success!!!
 30110e8:	0a0d 0000 4954 454d 2052 7473 7261 0d74     ....TIMER start.
 30110f8:	000a 0000 0000 0000 0000 0000 0000 4059     ..............Y@
 3011108:	dcc4 ffff dcba ffff dcc0 ffff dcba ffff     ................
 3011118:	def4 ffff dcba ffff dcc0 ffff dcc8 ffff     ................
 3011128:	dcc8 ffff def4 ffff dcc0 ffff dca0 ffff     ................
 3011138:	dca0 ffff dca0 ffff dd1e ffff e3f2 ffff     ................
 3011148:	e3f2 ffff e40a ffff e3ec ffff e3ec ffff     ................
 3011158:	e1f0 ffff e40a ffff e3ec ffff e1f0 ffff     ................
 3011168:	e3ec ffff e40a ffff e3ea ffff e3ea ffff     ................
 3011178:	e3ea ffff e5d8 ffff                         ........

03011180 <__clz_tab>:
 3011180:	0100 0202 0303 0303 0404 0404 0404 0404     ................
 3011190:	0505 0505 0505 0505 0505 0505 0505 0505     ................
 30111a0:	0606 0606 0606 0606 0606 0606 0606 0606     ................
 30111b0:	0606 0606 0606 0606 0606 0606 0606 0606     ................
 30111c0:	0707 0707 0707 0707 0707 0707 0707 0707     ................
 30111d0:	0707 0707 0707 0707 0707 0707 0707 0707     ................
 30111e0:	0707 0707 0707 0707 0707 0707 0707 0707     ................
 30111f0:	0707 0707 0707 0707 0707 0707 0707 0707     ................
 3011200:	0808 0808 0808 0808 0808 0808 0808 0808     ................
 3011210:	0808 0808 0808 0808 0808 0808 0808 0808     ................
 3011220:	0808 0808 0808 0808 0808 0808 0808 0808     ................
 3011230:	0808 0808 0808 0808 0808 0808 0808 0808     ................
 3011240:	0808 0808 0808 0808 0808 0808 0808 0808     ................
 3011250:	0808 0808 0808 0808 0808 0808 0808 0808     ................
 3011260:	0808 0808 0808 0808 0808 0808 0808 0808     ................
 3011270:	0808 0808 0808 0808 0808 0808 0808 0808     ................
 3011280:	0000 0000 0000 4330 0000 0000 0000 3fe0     ......0C.......?
 3011290:	0000 0000 0000 3ff0 0000 0000 0000 bfe0     .......?........

030112a0 <_GLOBAL_OFFSET_TABLE_>:
 30112a0:	0000 0000 1180 0301 ffff ffff 0000 0000     ................
