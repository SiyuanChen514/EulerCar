
D:\car\custom_controller\eulercar_controller\application\out\bin\target.elf:     file format elf32-littleriscv


Disassembly of section .text.entry:

03000004 <_start>:

    .section      .text.entry
    .global _start
    .option norvc
_start:
    j handle_reset
 3000004:	5440006f          	j	3000548 <handle_reset>

03000008 <TrapHandler>:
.endm

/* The interrupt vector table must be aligned with 4 bytes */
.align 2
TrapHandler:
    j     TrapVector        /* trap and INT 0 */
 3000008:	4880006f          	j	3000490 <TrapVector>
    j     TrapVector        /* INT 1 */
 300000c:	4840006f          	j	3000490 <TrapVector>
    j     TrapVector        /* INT 2 */
 3000010:	4800006f          	j	3000490 <TrapVector>
    j     TrapVector        /* INT 3 */
 3000014:	47c0006f          	j	3000490 <TrapVector>
    j     TrapVector        /* INT 4 */
 3000018:	4780006f          	j	3000490 <TrapVector>
    j     TrapVector        /* INT 5 */
 300001c:	4740006f          	j	3000490 <TrapVector>
    j     TrapVector        /* INT 6 */
 3000020:	4700006f          	j	3000490 <TrapVector>
    j     TrapVector        /* INT 7 */
 3000024:	46c0006f          	j	3000490 <TrapVector>
    j     TrapVector        /* INT 8 */
 3000028:	4680006f          	j	3000490 <TrapVector>
    j     TrapVector        /* INT 9 */
 300002c:	4640006f          	j	3000490 <TrapVector>
    j     TrapVector        /* INT 10 */
 3000030:	4600006f          	j	3000490 <TrapVector>
    j     TrapVector        /* INT 11 */
 3000034:	45c0006f          	j	3000490 <TrapVector>
    j     TrapVector        /* INT 12 */
 3000038:	4580006f          	j	3000490 <TrapVector>
    j     TrapVector        /* INT 13 */
 300003c:	4540006f          	j	3000490 <TrapVector>
    j     TrapVector        /* INT 14 */
 3000040:	4500006f          	j	3000490 <TrapVector>
    j     TrapVector        /* INT 15 */
 3000044:	44c0006f          	j	3000490 <TrapVector>
    j     TrapVector        /* INT 16 */
 3000048:	4480006f          	j	3000490 <TrapVector>
    j     TrapVector        /* INT 17 */
 300004c:	4440006f          	j	3000490 <TrapVector>
    j     TrapVector        /* INT 18 */
 3000050:	4400006f          	j	3000490 <TrapVector>
    j     TrapVector        /* INT 19 */
 3000054:	43c0006f          	j	3000490 <TrapVector>
    j     TrapVector        /* INT 20 */
 3000058:	4380006f          	j	3000490 <TrapVector>
    j     TrapVector        /* INT 21 */
 300005c:	4340006f          	j	3000490 <TrapVector>
    j     TrapVector        /* INT 22 */
 3000060:	4300006f          	j	3000490 <TrapVector>
    j     TrapVector        /* INT 23 */
 3000064:	42c0006f          	j	3000490 <TrapVector>
    j     TrapVector        /* INT 24 */
 3000068:	4280006f          	j	3000490 <TrapVector>
    j     TrapVector        /* INT 25 */
 300006c:	4240006f          	j	3000490 <TrapVector>

    j     IntHandler        /* INT 26 */
 3000070:	2640006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 27 */
 3000074:	2600006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 28 */
 3000078:	25c0006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 29 */
 300007c:	2580006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 30 */
 3000080:	2540006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 31 */
 3000084:	2500006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 32 */
 3000088:	24c0006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 33 */
 300008c:	2480006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 34 */
 3000090:	2440006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 35 */
 3000094:	2400006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 36 */
 3000098:	23c0006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 37 */
 300009c:	2380006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 38 */
 30000a0:	2340006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 39 */
 30000a4:	2300006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 40 */
 30000a8:	22c0006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 41 */
 30000ac:	2280006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 42 */
 30000b0:	2240006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 43 */
 30000b4:	2200006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 44 */
 30000b8:	21c0006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 45 */
 30000bc:	2180006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 46 */
 30000c0:	2140006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 47 */
 30000c4:	2100006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 48 */
 30000c8:	20c0006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 49 */
 30000cc:	2080006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 50 */
 30000d0:	2040006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 51 */
 30000d4:	2000006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 52 */
 30000d8:	1fc0006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 53 */
 30000dc:	1f80006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 54 */
 30000e0:	1f40006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 55 */
 30000e4:	1f00006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 56 */
 30000e8:	1ec0006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 57 */
 30000ec:	1e80006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 58 */
 30000f0:	1e40006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 59 */
 30000f4:	1e00006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 60 */
 30000f8:	1dc0006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 61 */
 30000fc:	1d80006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 62 */
 3000100:	1d40006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 63 */
 3000104:	1d00006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 64 */
 3000108:	1cc0006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 65 */
 300010c:	1c80006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 66 */
 3000110:	1c40006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 67 */
 3000114:	1c00006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 68 */
 3000118:	1bc0006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 69 */
 300011c:	1b80006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 70 */
 3000120:	1b40006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 71 */
 3000124:	1b00006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 72 */
 3000128:	1ac0006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 73 */
 300012c:	1a80006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 74 */
 3000130:	1a40006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 75 */
 3000134:	1a00006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 76 */
 3000138:	19c0006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 77 */
 300013c:	1980006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 78 */
 3000140:	1940006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 79 */
 3000144:	1900006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 80 */
 3000148:	18c0006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 81 */
 300014c:	1880006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 82 */
 3000150:	1840006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 83 */
 3000154:	1800006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 84 */
 3000158:	17c0006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 85 */
 300015c:	1780006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 86 */
 3000160:	1740006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 87 */
 3000164:	1700006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 88 */
 3000168:	16c0006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 89 */
 300016c:	1680006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 90 */
 3000170:	1640006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 91 */
 3000174:	1600006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 92 */
 3000178:	15c0006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 93 */
 300017c:	1580006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 94 */
 3000180:	1540006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 95 */
 3000184:	1500006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 96 */
 3000188:	14c0006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 97 */
 300018c:	1480006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 98 */
 3000190:	1440006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 99 */
 3000194:	1400006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 100 */
 3000198:	13c0006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 101 */
 300019c:	1380006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 102 */
 30001a0:	1340006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 103 */
 30001a4:	1300006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 104 */
 30001a8:	12c0006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 105 */
 30001ac:	1280006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 106 */
 30001b0:	1240006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 107 */
 30001b4:	1200006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 108 */
 30001b8:	11c0006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 109 */
 30001bc:	1180006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 110 */
 30001c0:	1140006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 111 */
 30001c4:	1100006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 112 */
 30001c8:	10c0006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 113 */
 30001cc:	1080006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 114 */
 30001d0:	1040006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 115 */
 30001d4:	1000006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 116 */
 30001d8:	0fc0006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 117 */
 30001dc:	0f80006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 118 */
 30001e0:	0f40006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 119 */
 30001e4:	0f00006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 120 */
 30001e8:	0ec0006f          	j	30002d4 <IntHandler>
    j     IntHandler        /* INT 121 */
 30001ec:	0e80006f          	j	30002d4 <IntHandler>

030001f0 <NmiEntry>:

.align 2
NmiEntry:
    SAVE_SYSERR_REGS
 30001f0:	f9010113          	addi	sp,sp,-112
 30001f4:	04812023          	sw	s0,64(sp)
 30001f8:	04912223          	sw	s1,68(sp)
 30001fc:	05212423          	sw	s2,72(sp)
 3000200:	05312623          	sw	s3,76(sp)
 3000204:	05412823          	sw	s4,80(sp)
 3000208:	05512a23          	sw	s5,84(sp)
 300020c:	05612c23          	sw	s6,88(sp)
 3000210:	05712e23          	sw	s7,92(sp)
 3000214:	07812023          	sw	s8,96(sp)
 3000218:	07912223          	sw	s9,100(sp)
 300021c:	07a12423          	sw	s10,104(sp)
 3000220:	07b12623          	sw	s11,108(sp)
 3000224:	11010593          	addi	a1,sp,272
 3000228:	06b12823          	sw	a1,112(sp)
 300022c:	06312a23          	sw	gp,116(sp)
 3000230:	06412c23          	sw	tp,120(sp)
 3000234:	34102573          	csrr	a0,mepc
 3000238:	300025f3          	csrr	a1,mstatus
 300023c:	34302673          	csrr	a2,mtval
 3000240:	342026f3          	csrr	a3,mcause
 3000244:	06a12e23          	sw	a0,124(sp)
 3000248:	08b12023          	sw	a1,128(sp)
 300024c:	08c12223          	sw	a2,132(sp)
 3000250:	08d12423          	sw	a3,136(sp)
 3000254:	00010513          	mv	a0,sp
    call SysErrNmiEntry
 3000258:	72d020ef          	jal	ra,3003184 <SysErrNmiEntry>

0300025c <deadLoop1>:
deadLoop1:
    tail deadLoop1
 300025c:	a001                	j	300025c <deadLoop1>
    nop
 300025e:	00000013          	nop

03000262 <TrapEntry>:

.align 2
TrapEntry:
    SAVE_SYSERR_REGS
 3000262:	f9010113          	addi	sp,sp,-112
 3000266:	04812023          	sw	s0,64(sp)
 300026a:	04912223          	sw	s1,68(sp)
 300026e:	05212423          	sw	s2,72(sp)
 3000272:	05312623          	sw	s3,76(sp)
 3000276:	05412823          	sw	s4,80(sp)
 300027a:	05512a23          	sw	s5,84(sp)
 300027e:	05612c23          	sw	s6,88(sp)
 3000282:	05712e23          	sw	s7,92(sp)
 3000286:	07812023          	sw	s8,96(sp)
 300028a:	07912223          	sw	s9,100(sp)
 300028e:	07a12423          	sw	s10,104(sp)
 3000292:	07b12623          	sw	s11,108(sp)
 3000296:	11010593          	addi	a1,sp,272
 300029a:	06b12823          	sw	a1,112(sp)
 300029e:	06312a23          	sw	gp,116(sp)
 30002a2:	06412c23          	sw	tp,120(sp)
 30002a6:	34102573          	csrr	a0,mepc
 30002aa:	300025f3          	csrr	a1,mstatus
 30002ae:	34302673          	csrr	a2,mtval
 30002b2:	342026f3          	csrr	a3,mcause
 30002b6:	06a12e23          	sw	a0,124(sp)
 30002ba:	08b12023          	sw	a1,128(sp)
 30002be:	08c12223          	sw	a2,132(sp)
 30002c2:	08d12423          	sw	a3,136(sp)
 30002c6:	00010513          	mv	a0,sp
    /* Exception run with interrupts masked */
    csrc mstatus, MSTATUS_MIE
 30002ca:	30047073          	csrci	mstatus,8
    call SysErrExcEntry
 30002ce:	699020ef          	jal	ra,3003166 <SysErrExcEntry>

030002d2 <deadLoop2>:
deadLoop2:
    tail deadLoop2
 30002d2:	a001                	j	30002d2 <deadLoop2>

030002d4 <IntHandler>:

.align 2
IntHandler:
    addi  sp, sp, -(TOTAL_INT_SIZE_ON_STACK)
 30002d4:	f6010113          	addi	sp,sp,-160

    SREG  a0, 3 * REGBYTES(sp)
 30002d8:	00a12623          	sw	a0,12(sp)
    SREG  a1, 4 * REGBYTES(sp)
 30002dc:	00b12823          	sw	a1,16(sp)

#if defined(USER_MODE_ENABLE) && (USER_MODE_ENABLE == 1)
    la    a0, g_RiscvPrivMode
 30002e0:	87618513          	addi	a0,gp,-1930 # 4000180 <g_RiscvPrivMode>
    lw    a1, (a0)
 30002e4:	00052583          	lw	a1,0(a0)
    addi  a1, a1, 1
 30002e8:	00158593          	addi	a1,a1,1
    sw    a1, (a0)
 30002ec:	00b52023          	sw	a1,0(a0)
#endif

#if defined(HARD_NESTED_IRQ_SUPPORT) && (HARD_NESTED_IRQ_SUPPORT == 1)
    csrr  a0, mcause
#else
    csrr  a0, cipri
 30002f0:	7ed02573          	csrr	a0,0x7ed
    csrr  a1, prithd
 30002f4:	bfe025f3          	csrr	a1,0xbfe
    csrw  prithd, a0                /* read prithd */
 30002f8:	bfe51073          	csrw	0xbfe,a0
    SREG  a1, 6 * REGBYTES(sp)      /* save prithd */
 30002fc:	00b12c23          	sw	a1,24(sp)
    csrr  a1, mstatus               /* read mstatus */
 3000300:	300025f3          	csrr	a1,mstatus
    SREG  a1, 7 * REGBYTES(sp)      /* save mstatus */
 3000304:	00b12e23          	sw	a1,28(sp)
    csrr  a1, mepc                  /* read mepc */
 3000308:	341025f3          	csrr	a1,mepc
    SREG  a1, 8 * REGBYTES(sp)      /* save mepc */
 300030c:	02b12023          	sw	a1,32(sp)

    csrr  a0, mcause
 3000310:	34202573          	csrr	a0,mcause

    li  a1, (3<<11)
 3000314:	000025b7          	lui	a1,0x2
 3000318:	80058593          	addi	a1,a1,-2048 # 1800 <__bss_size__+0x76c>
    csrs  mstatus, a1
 300031c:	3005a073          	csrs	mstatus,a1
    la    a1, custom_nested_irq_main_handler_entry
 3000320:	00000597          	auipc	a1,0x0
 3000324:	01058593          	addi	a1,a1,16 # 3000330 <custom_nested_irq_main_handler_entry>
    csrw  mepc, a1
 3000328:	34159073          	csrw	mepc,a1
    mret
 300032c:	30200073          	mret

03000330 <custom_nested_irq_main_handler_entry>:
#endif

.align 2
custom_nested_irq_main_handler_entry:
    SREG  t0, 0 * REGBYTES(sp)
 3000330:	00512023          	sw	t0,0(sp)
    SREG  t1, 1 * REGBYTES(sp)
 3000334:	00612223          	sw	t1,4(sp)
    SREG  t2, 2 * REGBYTES(sp)
 3000338:	00712423          	sw	t2,8(sp)
    SREG  a2, 5 * REGBYTES(sp)
 300033c:	00c12a23          	sw	a2,20(sp)
    SREG  ra, 9 * REGBYTES(sp)
 3000340:	02112223          	sw	ra,36(sp)
    SREG  a3, 10 * REGBYTES(sp)
 3000344:	02d12423          	sw	a3,40(sp)
    SREG  a4, 11 * REGBYTES(sp)
 3000348:	02e12623          	sw	a4,44(sp)
    SREG  a5, 12 * REGBYTES(sp)
 300034c:	02f12823          	sw	a5,48(sp)
    SREG  a6, 13 * REGBYTES(sp)
 3000350:	03012a23          	sw	a6,52(sp)
    SREG  a7, 14 * REGBYTES(sp)
 3000354:	03112c23          	sw	a7,56(sp)
    SREG  t3, 15 * REGBYTES(sp)
 3000358:	03c12e23          	sw	t3,60(sp)
    SREG  t4, 16 * REGBYTES(sp)
 300035c:	05d12023          	sw	t4,64(sp)
    SREG  t5, 17 * REGBYTES(sp)
 3000360:	05e12223          	sw	t5,68(sp)
    SREG  t6, 18 * REGBYTES(sp)
 3000364:	05f12423          	sw	t6,72(sp)

#ifdef FLOAT_SUPPORT
    FSREG  f0, 19 * REGBYTES(sp)
 3000368:	04012627          	fsw	ft0,76(sp)
    FSREG  f1, 20 * REGBYTES(sp)
 300036c:	04112827          	fsw	ft1,80(sp)
    FSREG  f2, 21 * REGBYTES(sp)
 3000370:	04212a27          	fsw	ft2,84(sp)
    FSREG  f3, 22 * REGBYTES(sp)
 3000374:	04312c27          	fsw	ft3,88(sp)
    FSREG  f4, 23 * REGBYTES(sp)
 3000378:	04412e27          	fsw	ft4,92(sp)
    FSREG  f5, 24 * REGBYTES(sp)
 300037c:	06512027          	fsw	ft5,96(sp)
    FSREG  f6, 25 * REGBYTES(sp)
 3000380:	06612227          	fsw	ft6,100(sp)
    FSREG  f7, 26 * REGBYTES(sp)
 3000384:	06712427          	fsw	ft7,104(sp)
    FSREG  f10, 27 * REGBYTES(sp)
 3000388:	06a12627          	fsw	fa0,108(sp)
    FSREG  f11, 28 * REGBYTES(sp)
 300038c:	06b12827          	fsw	fa1,112(sp)
    FSREG  f12, 29 * REGBYTES(sp)
 3000390:	06c12a27          	fsw	fa2,116(sp)
    FSREG  f13, 30 * REGBYTES(sp)
 3000394:	06d12c27          	fsw	fa3,120(sp)
    FSREG  f14, 31 * REGBYTES(sp)
 3000398:	06e12e27          	fsw	fa4,124(sp)
    FSREG  f15, 32 * REGBYTES(sp)
 300039c:	08f12027          	fsw	fa5,128(sp)
    FSREG  f16, 33 * REGBYTES(sp)
 30003a0:	09012227          	fsw	fa6,132(sp)
    FSREG  f17, 34 * REGBYTES(sp)
 30003a4:	09112427          	fsw	fa7,136(sp)
    FSREG  f28, 35 * REGBYTES(sp)
 30003a8:	09c12627          	fsw	ft8,140(sp)
    FSREG  f29, 36 * REGBYTES(sp)
 30003ac:	09d12827          	fsw	ft9,144(sp)
    FSREG  f30, 37 * REGBYTES(sp)
 30003b0:	09e12a27          	fsw	ft10,148(sp)
    FSREG  f31, 38 * REGBYTES(sp)
 30003b4:	09f12c27          	fsw	ft11,152(sp)
#endif

    andi  a0, a0, MCAUSE_MASK_INT_NUM
 30003b8:	0ff57513          	andi	a0,a0,255
    call  InterruptEntry
 30003bc:	317020ef          	jal	ra,3002ed2 <InterruptEntry>

    LREG  t1, 1 * REGBYTES(sp)
 30003c0:	00412303          	lw	t1,4(sp)
    LREG  t2, 2 * REGBYTES(sp)
 30003c4:	00812383          	lw	t2,8(sp)
    LREG  a2, 5 * REGBYTES(sp)
 30003c8:	01412603          	lw	a2,20(sp)
    LREG  ra, 9 * REGBYTES(sp)
 30003cc:	02412083          	lw	ra,36(sp)
    LREG  a3, 10 * REGBYTES(sp)
 30003d0:	02812683          	lw	a3,40(sp)
    LREG  a4, 11 * REGBYTES(sp)
 30003d4:	02c12703          	lw	a4,44(sp)
    LREG  a5, 12 * REGBYTES(sp)
 30003d8:	03012783          	lw	a5,48(sp)
    LREG  a6, 13 * REGBYTES(sp)
 30003dc:	03412803          	lw	a6,52(sp)
    LREG  a7, 14 * REGBYTES(sp)
 30003e0:	03812883          	lw	a7,56(sp)
    LREG  t3, 15 * REGBYTES(sp)
 30003e4:	03c12e03          	lw	t3,60(sp)
    LREG  t4, 16 * REGBYTES(sp)
 30003e8:	04012e83          	lw	t4,64(sp)
    LREG  t5, 17 * REGBYTES(sp)
 30003ec:	04412f03          	lw	t5,68(sp)
    LREG  t6, 18 * REGBYTES(sp)
 30003f0:	04812f83          	lw	t6,72(sp)

#ifdef FLOAT_SUPPORT
    FLREG  f0, 19 * REGBYTES(sp)
 30003f4:	04c12007          	flw	ft0,76(sp)
    FLREG  f1, 20 * REGBYTES(sp)
 30003f8:	05012087          	flw	ft1,80(sp)
    FLREG  f2, 21 * REGBYTES(sp)
 30003fc:	05412107          	flw	ft2,84(sp)
    FLREG  f3, 22 * REGBYTES(sp)
 3000400:	05812187          	flw	ft3,88(sp)
    FLREG  f4, 23 * REGBYTES(sp)
 3000404:	05c12207          	flw	ft4,92(sp)
    FLREG  f5, 24 * REGBYTES(sp)
 3000408:	06012287          	flw	ft5,96(sp)
    FLREG  f6, 25 * REGBYTES(sp)
 300040c:	06412307          	flw	ft6,100(sp)
    FLREG  f7, 26 * REGBYTES(sp)
 3000410:	06812387          	flw	ft7,104(sp)
    FLREG  f10, 27 * REGBYTES(sp)
 3000414:	06c12507          	flw	fa0,108(sp)
    FLREG  f11, 28 * REGBYTES(sp)
 3000418:	07012587          	flw	fa1,112(sp)
    FLREG  f12, 29 * REGBYTES(sp)
 300041c:	07412607          	flw	fa2,116(sp)
    FLREG  f13, 30 * REGBYTES(sp)
 3000420:	07812687          	flw	fa3,120(sp)
    FLREG  f14, 31 * REGBYTES(sp)
 3000424:	07c12707          	flw	fa4,124(sp)
    FLREG  f15, 32 * REGBYTES(sp)
 3000428:	08012787          	flw	fa5,128(sp)
    FLREG  f16, 33 * REGBYTES(sp)
 300042c:	08412807          	flw	fa6,132(sp)
    FLREG  f17, 34 * REGBYTES(sp)
 3000430:	08812887          	flw	fa7,136(sp)
    FLREG  f28, 35 * REGBYTES(sp)
 3000434:	08c12e07          	flw	ft8,140(sp)
    FLREG  f29, 36 * REGBYTES(sp)
 3000438:	09012e87          	flw	ft9,144(sp)
    FLREG  f30, 37 * REGBYTES(sp)
 300043c:	09412f07          	flw	ft10,148(sp)
    FLREG  f31, 38 * REGBYTES(sp)
 3000440:	09812f87          	flw	ft11,152(sp)

03000444 <quit_int>:
     */

#if defined(HARD_NESTED_IRQ_SUPPORT) && (HARD_NESTED_IRQ_SUPPORT == 1)
    LREG  t0, 0 * REGBYTES(sp)
#else
    LREG  a0, 7 * REGBYTES(sp)  /* load mstatus */
 3000444:	01c12503          	lw	a0,28(sp)
    csrr  t0, mstatus
 3000448:	300022f3          	csrr	t0,mstatus
    LREG  a1, 8 * REGBYTES(sp)  /* load mepc */
 300044c:	02012583          	lw	a1,32(sp)
    andi  t0, t0, MSTATUS_MIE
 3000450:	0082f293          	andi	t0,t0,8
    bnei  t0, 0, restore_mstatus
 3000454:	0002923b          	bnei	t0,0,300045c <restore_mstatus>
    andi  a0, a0, ~(MSTATUS_MIE | MSTATUS_MPIE)
 3000458:	f7757513          	andi	a0,a0,-137

0300045c <restore_mstatus>:
restore_mstatus:
    csrw  mstatus, a0
 300045c:	30051073          	csrw	mstatus,a0

    LREG  t0, 0 * REGBYTES(sp)
 3000460:	00012283          	lw	t0,0(sp)
    csrw  mepc, a1
 3000464:	34159073          	csrw	mepc,a1
    LREG  a0, 6 * REGBYTES(sp)  /* load prithd */
 3000468:	01812503          	lw	a0,24(sp)
    csrw  prithd, a0
 300046c:	bfe51073          	csrw	0xbfe,a0
#endif

#if defined(USER_MODE_ENABLE) && (USER_MODE_ENABLE == 1)
    la    a0, g_RiscvPrivMode
 3000470:	87618513          	addi	a0,gp,-1930 # 4000180 <g_RiscvPrivMode>
    lw    a1, (a0)
 3000474:	00052583          	lw	a1,0(a0)
    addi  a1, a1, -1
 3000478:	fff58593          	addi	a1,a1,-1
    sw    a1, (a0)
 300047c:	00b52023          	sw	a1,0(a0)
#endif

    LREG  a1, 4 * REGBYTES(sp)   /* 2 consecutive csrw instructions will have a bubble */
 3000480:	01012583          	lw	a1,16(sp)

    LREG  a0, 3 * REGBYTES(sp)
 3000484:	00c12503          	lw	a0,12(sp)

    addi  sp, sp, TOTAL_INT_SIZE_ON_STACK
 3000488:	0a010113          	addi	sp,sp,160

    mret
 300048c:	30200073          	mret

03000490 <TrapVector>:

.align 2
TrapVector:
    push_reg
 3000490:	f6010113          	addi	sp,sp,-160
 3000494:	fff11f8b          	stmia	{ra,t0-t6,a0-a7},(sp)
 3000498:	f6010113          	addi	sp,sp,-160
    csrr  a0, mcause
 300049c:	34202573          	csrr	a0,mcause
    li    t1, MCAUSE_ECALL_FROM_MMODE
 30004a0:	00b00313          	li	t1,11
#if defined(USER_MODE_ENABLE) && (USER_MODE_ENABLE == 1)
    beq   a0, t1, switch_to_umode
 30004a4:	02650c63          	beq	a0,t1,30004dc <switch_to_umode>
#else
    beq   a0, t1, switch_to_mmode
#endif
    li    t1, MCAUSE_ECALL_FROM_UMODE
 30004a8:	00800313          	li	t1,8
    beq   a0, t1, switch_to_mmode
 30004ac:	04650c63          	beq	a0,t1,3000504 <switch_to_mmode>

    li    a1, MCAUSE_MASK_INT_BIT
 30004b0:	800005b7          	lui	a1,0x80000
    li    a2, MCAUSE_MASK_INT_NUM
 30004b4:	0ff00613          	li	a2,255
    and   a1, a0, a1
 30004b8:	00b575b3          	and	a1,a0,a1
    and   a0, a0, a2
 30004bc:	00c57533          	and	a0,a0,a2

    li    a2, 0xc
 30004c0:	00c00613          	li	a2,12
    beq   a0, a2, NmiEntry
 30004c4:	d2c506e3          	beq	a0,a2,30001f0 <NmiEntry>
    beqz  a1, TrapEntry
 30004c8:	d8058de3          	beqz	a1,3000262 <TrapEntry>
    pop_reg
 30004cc:	0a010113          	addi	sp,sp,160
 30004d0:	fff10f8b          	ldmia	{ra,t0-t6,a0-a7},(sp)
 30004d4:	0a010113          	addi	sp,sp,160
    mret
 30004d8:	30200073          	mret

030004dc <switch_to_umode>:

#if defined(USER_MODE_ENABLE) && (USER_MODE_ENABLE == 1)
.align 2
switch_to_umode:
    li    t2,  MSTATUS_MPP_MACHINE
 30004dc:	000023b7          	lui	t2,0x2
 30004e0:	80038393          	addi	t2,t2,-2048 # 1800 <__bss_size__+0x76c>
    csrc  mstatus, t2
 30004e4:	3003b073          	csrc	mstatus,t2
    csrr  t0,  mepc
 30004e8:	341022f3          	csrr	t0,mepc
    addi  t0,  t0,  4
 30004ec:	00428293          	addi	t0,t0,4
    csrw  mepc, t0
 30004f0:	34129073          	csrw	mepc,t0
    pop_reg
 30004f4:	0a010113          	addi	sp,sp,160
 30004f8:	fff10f8b          	ldmia	{ra,t0-t6,a0-a7},(sp)
 30004fc:	0a010113          	addi	sp,sp,160
    mret
 3000500:	30200073          	mret

03000504 <switch_to_mmode>:
#endif

.align 2
switch_to_mmode:
    li    t2,  MSTATUS_MPP_MACHINE
 3000504:	000023b7          	lui	t2,0x2
 3000508:	80038393          	addi	t2,t2,-2048 # 1800 <__bss_size__+0x76c>
    csrs  mstatus, t2
 300050c:	3003a073          	csrs	mstatus,t2
    csrr  t0,  mepc
 3000510:	341022f3          	csrr	t0,mepc
    addi  t0,  t0,  4
 3000514:	00428293          	addi	t0,t0,4
    csrw  mepc, t0
 3000518:	34129073          	csrw	mepc,t0
    pop_reg
 300051c:	0a010113          	addi	sp,sp,160
 3000520:	fff10f8b          	ldmia	{ra,t0-t6,a0-a7},(sp)
 3000524:	0a010113          	addi	sp,sp,160
    mret
 3000528:	30200073          	mret

0300052c <mem_cpy>:

.align 2
mem_cpy:
    bge t0, t2, cpy_done
 300052c:	0072dc63          	bge	t0,t2,3000544 <cpy_done>
    lw  t3, (t1)
 3000530:	00032e03          	lw	t3,0(t1)
    sw  t3, (t0)
 3000534:	01c2a023          	sw	t3,0(t0)
    addi t0, t0, 4
 3000538:	00428293          	addi	t0,t0,4
    addi t1, t1, 4
 300053c:	00430313          	addi	t1,t1,4
    j mem_cpy
 3000540:	fedff06f          	j	300052c <mem_cpy>

03000544 <cpy_done>:
cpy_done:
    ret
 3000544:	00008067          	ret

03000548 <handle_reset>:

.align 2
handle_reset:
    csrwi mstatus, 0
 3000548:	30005073          	csrwi	mstatus,0
    csrwi mie,  0
 300054c:	30405073          	csrwi	mie,0
    csrci mstatus, 0x08
 3000550:	30047073          	csrci	mstatus,8
    la    t0,  TrapHandler
 3000554:	00000297          	auipc	t0,0x0
 3000558:	ab428293          	addi	t0,t0,-1356 # 3000008 <TrapHandler>
    addi  t0,  t0, 1
 300055c:	00128293          	addi	t0,t0,1
    csrw  mtvec, t0
 3000560:	30529073          	csrw	mtvec,t0
    csrwi 0x7EF, 0x1               /* lock mtvec */
 3000564:	7ef0d073          	csrwi	0x7ef,1

03000568 <flash_init>:
    csrwi 0x7C8, 0x1              /* enable hardware nest interrupt support */
#endif

flash_init:
/* eflash prefetch enable */
    li  t0, EFC_BASE_ADDR
 3000568:	147102b7          	lui	t0,0x14710
    lw  t1, 0x120(t0)
 300056c:	1202a303          	lw	t1,288(t0) # 14710120 <RAM_END+0x10708120>
    ori t1, t1, 1
 3000570:	00136313          	ori	t1,t1,1
    sw  t1, 0x120(t0)
 3000574:	1262a023          	sw	t1,288(t0)

/* eflash cache enable */
    lw  t1, 0x124(t0)
 3000578:	1242a303          	lw	t1,292(t0)
    ori t1, t1, 1
 300057c:	00136313          	ori	t1,t1,1
    sw  t1, 0x124(t0)
 3000580:	1262a223          	sw	t1,292(t0)

/* enable flash cmd */
    li t0, EFC_MAGIC_NUMBER
 3000584:	fedcc2b7          	lui	t0,0xfedcc
 3000588:	a9828293          	addi	t0,t0,-1384 # fedcba98 <RAM_END+0xfadc3a98>
    li t1, EFC_MAGIC_LOCK_RW
 300058c:	14710337          	lui	t1,0x14710
 3000590:	20030313          	addi	t1,t1,512 # 14710200 <RAM_END+0x10708200>
    sw t0, (t1)
 3000594:	00532023          	sw	t0,0(t1)

/* initialize global pointer */
    .option push
    .option norelax
    la gp, __global_pointer$
 3000598:	01000197          	auipc	gp,0x1000
 300059c:	37218193          	addi	gp,gp,882 # 400090a <__global_pointer$>
    .option pop

/* initialize stack pointer */
    la sp, __stack_top
 30005a0:	01007117          	auipc	sp,0x1007
 30005a4:	66010113          	addi	sp,sp,1632 # 4007c00 <__INTERRUPT_STACK_BEGIN__>

/* timer0 interrupt enable */
    li t0, TIMER0_CONTROL
 30005a8:	143002b7          	lui	t0,0x14300
 30005ac:	00828293          	addi	t0,t0,8 # 14300008 <RAM_END+0x102f8008>
    lw t1, (t0)
 30005b0:	0002a303          	lw	t1,0(t0)
    andi t1, t1, TIMER0_INTENABLE
 30005b4:	02037313          	andi	t1,t1,32
    sw t1, (t0)
 30005b8:	0062a023          	sw	t1,0(t0)

/* uart0 deinit */
    li t0, 0x14000000
 30005bc:	140002b7          	lui	t0,0x14000
    li t1, 0
 30005c0:	00000313          	li	t1,0
    sw t1, IBRD_OFFSET(t0)
 30005c4:	0262a223          	sw	t1,36(t0) # 14000024 <RAM_END+0xfff8024>
    sw t1, FBRD_OFFSET(t0)
 30005c8:	0262a423          	sw	t1,40(t0)
    sw t1, LCR_H_OFFSET(t0)
 30005cc:	0262a623          	sw	t1,44(t0)
    sw t1, CR_OFFSET(t0)
 30005d0:	0262a823          	sw	t1,48(t0)
    sw t1, DMACR_OFFSET(t0)
 30005d4:	0462a423          	sw	t1,72(t0)

030005d8 <clear_sram>:

/* perform the rest of initialization in C */
clear_sram:
    /* clear sysram parity error */
    li  t0, SYSRAM_ERROR
 30005d8:	101082b7          	lui	t0,0x10108
 30005dc:	30028293          	addi	t0,t0,768 # 10108300 <RAM_END+0xc100300>
    lw  t1, (t0)
 30005e0:	0002a303          	lw	t1,0(t0)
    ori t1, t1, 1
 30005e4:	00136313          	ori	t1,t1,1
    sw  t1, (t0)
 30005e8:	0062a023          	sw	t1,0(t0)

    la t0, SRAM_START
 30005ec:	01000297          	auipc	t0,0x1000
 30005f0:	a1428293          	addi	t0,t0,-1516 # 4000000 <g_tsensorGain>
    la t1, SRAM_END
 30005f4:	01008317          	auipc	t1,0x1008
 30005f8:	a0c30313          	addi	t1,t1,-1524 # 4008000 <RAM_END>
    li t2, 0
 30005fc:	00000393          	li	t2,0

03000600 <clear_sram_loop>:

clear_sram_loop:
    sw      t2, (t0)            /* clear all sram */
 3000600:	0072a023          	sw	t2,0(t0)
    addi    t0, t0, 4           /* increment clear index pointer */
 3000604:	00428293          	addi	t0,t0,4
    blt     t0, t1, clear_sram_loop /* are we at the end yet, if not , contiue till the end */
 3000608:	fe62cce3          	blt	t0,t1,3000600 <clear_sram_loop>

0300060c <start_coderom_code_copy>:

start_coderom_code_copy:
    la t0, __sram_code_start_addr    /* SRAM addr */
 300060c:	ff000297          	auipc	t0,0xff000
 3000610:	9f428293          	addi	t0,t0,-1548 # 2000000 <RAM_CODE_START>
    la t1, __sram_code_load_addr     /* ROM addr  */
 3000614:	00000317          	auipc	t1,0x0
 3000618:	13430313          	addi	t1,t1,308 # 3000748 <Chip_InitFail>
    la t2, __sram_code_end_addr
 300061c:	ff000397          	auipc	t2,0xff000
 3000620:	9e438393          	addi	t2,t2,-1564 # 2000000 <RAM_CODE_START>
    jal mem_cpy
 3000624:	f09ff0ef          	jal	ra,300052c <mem_cpy>

03000628 <start_reserved_data_copy>:

start_reserved_data_copy:
    la t0, __reserved_code_start_addr  /* SRAM addr */
 3000628:	01000297          	auipc	t0,0x1000
 300062c:	9d828293          	addi	t0,t0,-1576 # 4000000 <g_tsensorGain>
    la t1, __reserved_code_load_addr   /* ROM addr  */
 3000630:	00000317          	auipc	t1,0x0
 3000634:	11830313          	addi	t1,t1,280 # 3000748 <Chip_InitFail>
    la t2, __reserved_code_end_addr
 3000638:	01000397          	auipc	t2,0x1000
 300063c:	9c838393          	addi	t2,t2,-1592 # 4000000 <g_tsensorGain>
    jal mem_cpy
 3000640:	eedff0ef          	jal	ra,300052c <mem_cpy>

03000644 <start_coderom_data_copy>:

start_coderom_data_copy:
    la t0, __data_start              /* SRAM addr */
 3000644:	01000297          	auipc	t0,0x1000
 3000648:	9bc28293          	addi	t0,t0,-1604 # 4000000 <g_tsensorGain>
    la t1, __data_load               /* ROM addr  */
 300064c:	00012317          	auipc	t1,0x12
 3000650:	08430313          	addi	t1,t1,132 # 30126d0 <__data_load>
    la t2, __data_end
 3000654:	87618393          	addi	t2,gp,-1930 # 4000180 <g_RiscvPrivMode>
    jal mem_cpy
 3000658:	ed5ff0ef          	jal	ra,300052c <mem_cpy>

0300065c <pmp_init>:

pmp_init:
    li t0, 0xB00
 300065c:	000012b7          	lui	t0,0x1
 3000660:	b0028293          	addi	t0,t0,-1280 # b00 <cipri+0x313>
    csrw pmpaddr0, t0
 3000664:	3b029073          	csrw	pmpaddr0,t0
    li t0, 0x400400   /* 0x2C00~0x1000FFF, BOOTROM, enable R+X */
 3000668:	004002b7          	lui	t0,0x400
 300066c:	40028293          	addi	t0,t0,1024 # 400400 <FLASH_SIZE+0x3e0404>
    csrw pmpaddr1, t0
 3000670:	3b129073          	csrw	pmpaddr1,t0
    li t0, 0x800000   /* 0x1001000~0x1FFFFFF, Reserved: diable R+X+W */
 3000674:	008002b7          	lui	t0,0x800
    csrw pmpaddr2, t0
 3000678:	3b229073          	csrw	pmpaddr2,t0
    li t0, 0x802000   /* 0x2000000~0x2007FFF, SYSRAM_ITCM */
 300067c:	008022b7          	lui	t0,0x802
    csrw pmpaddr3, t0
 3000680:	3b329073          	csrw	pmpaddr3,t0
    li t0, 0xC00000   /* 0x2008000 ~ 0x2FFFFFF, Reserved: disable R+X+W */
 3000684:	00c002b7          	lui	t0,0xc00
    csrw pmpaddr4, t0
 3000688:	3b429073          	csrw	pmpaddr4,t0
    li t0, 0x1000000  /* 0x3000000 ~ 0x03FFFFFF: EFLASH: enable R+X */
 300068c:	010002b7          	lui	t0,0x1000
    csrw pmpaddr5, t0
 3000690:	3b529073          	csrw	pmpaddr5,t0
    li t0, 0x1002000  /* 0x4000000 ~ 0x04007FFF: SYSTEM_DTCM enable R+W */
 3000694:	010022b7          	lui	t0,0x1002
    csrw pmpaddr6, t0
 3000698:	3b629073          	csrw	pmpaddr6,t0
    li t0,0x7000400   /* 0x4008000 ~ 0x01C000FFF: REGISTER R+W  */
 300069c:	070002b7          	lui	t0,0x7000
 30006a0:	40028293          	addi	t0,t0,1024 # 7000400 <RAM_END+0x2ff8400>
    csrw pmpaddr7, t0
 30006a4:	3b729073          	csrw	pmpaddr7,t0

    li t0,0xf3333333  /* register TOR-R-W */
 30006a8:	f33332b7          	lui	t0,0xf3333
 30006ac:	33328293          	addi	t0,t0,819 # f3333333 <RAM_END+0xef32b333>
    csrw 0x7d8,t0
 30006b0:	7d829073          	csrw	0x7d8,t0
#if defined(USER_MODE_ENABLE) && (USER_MODE_ENABLE == 1)
    li t0,0x0d080d8b  /* 0x0d:TOR-R-X; 0x0b:TOR-R-W; 0x08:TOR; 0x0c:TOR-x; 0x09:TOR-R */
 30006b4:	0d0812b7          	lui	t0,0xd081
 30006b8:	d8b28293          	addi	t0,t0,-629 # d080d8b <RAM_END+0x9078d8b>
    csrw pmpcfg0,t0
 30006bc:	3a029073          	csrw	pmpcfg0,t0
    li t0,0x0b0b0d08
 30006c0:	0b0b12b7          	lui	t0,0xb0b1
 30006c4:	d0828293          	addi	t0,t0,-760 # b0b0d08 <RAM_END+0x70a8d08>
    csrw pmpcfg1,t0
 30006c8:	3a129073          	csrw	pmpcfg1,t0
    li t0,0x8b8b8d88
    csrw pmpcfg1,t0
#endif

/* disable Icache */
    csrwi  0x7C0, 0x0 /* disable ICACHE */
 30006cc:	7c005073          	csrwi	0x7c0,0
    fence
 30006d0:	0ff0000f          	fence

/* disable Dcache */
    csrwi  0x7C1, 0x0 /* disable DCACHE */
 30006d4:	7c105073          	csrwi	0x7c1,0
    fence
 30006d8:	0ff0000f          	fence

/* support float and mie */
    li t0,0x2008
 30006dc:	000022b7          	lui	t0,0x2
 30006e0:	00828293          	addi	t0,t0,8 # 2008 <__bss_size__+0xf74>
    csrs mstatus,t0
 30006e4:	3002a073          	csrs	mstatus,t0
    li t0,0x20
 30006e8:	02000293          	li	t0,32
    csrs misa,t0
 30006ec:	3012a073          	csrs	misa,t0

/* Interrupt set default priority = 1*/
    li t0, 0x11111111
 30006f0:	111112b7          	lui	t0,0x11111
 30006f4:	11128293          	addi	t0,t0,273 # 11111111 <RAM_END+0xd109111>
    csrw locipri0, t0
 30006f8:	bc029073          	csrw	0xbc0,t0
    csrw locipri1, t0
 30006fc:	bc129073          	csrw	0xbc1,t0
    csrw locipri2, t0
 3000700:	bc229073          	csrw	0xbc2,t0
    csrw locipri3, t0
 3000704:	bc329073          	csrw	0xbc3,t0
    csrw locipri4, t0
 3000708:	bc429073          	csrw	0xbc4,t0
    csrw locipri5, t0
 300070c:	bc529073          	csrw	0xbc5,t0
    csrw locipri6, t0
 3000710:	bc629073          	csrw	0xbc6,t0
    csrw locipri7, t0
 3000714:	bc729073          	csrw	0xbc7,t0
    csrw locipri8, t0
 3000718:	bc829073          	csrw	0xbc8,t0
    csrw locipri9, t0
 300071c:	bc929073          	csrw	0xbc9,t0
    csrw locipri10, t0
 3000720:	bca29073          	csrw	0xbca,t0
    csrw locipri11, t0
 3000724:	bcb29073          	csrw	0xbcb,t0
    csrw locipri12, t0
 3000728:	bcc29073          	csrw	0xbcc,t0
    csrw locipri13, t0
 300072c:	bcd29073          	csrw	0xbcd,t0
    csrw locipri14, t0
 3000730:	bce29073          	csrw	0xbce,t0
    csrw locipri15, t0
 3000734:	bcf29073          	csrw	0xbcf,t0

    ecall
 3000738:	00000073          	ecall
    jal Chip_Init
 300073c:	014000ef          	jal	ra,3000750 <Chip_Init>

/* jump to C func. */
    jal main
 3000740:	1ab0c0ef          	jal	ra,300d0ea <main>

03000744 <dead_loop>:

dead_loop:
    j dead_loop
 3000744:	0000006f          	j	3000744 <dead_loop>

Disassembly of section .text:

03000748 <Chip_InitFail>:
 * @brief Chip Init Fail Process, deadloop if Chip Init fail
 * @param None
 * @retval None
 */
static inline void Chip_InitFail(void)
{
 3000748:	1141                	addi	sp,sp,-16
 300074a:	c622                	sw	s0,12(sp)
 300074c:	0800                	addi	s0,sp,16
    while (1) {
 300074e:	a001                	j	300074e <Chip_InitFail+0x6>

03000750 <Chip_Init>:
 * @brief Chip Init
 * @param None
 * @retval None
 */
void Chip_Init(void)
{
 3000750:	1101                	addi	sp,sp,-32
 3000752:	ce06                	sw	ra,28(sp)
 3000754:	cc22                	sw	s0,24(sp)
 3000756:	1000                	addi	s0,sp,32
    CRG_CoreClkSelect coreClkSelect;
    /* Config CRG */
    if (CRG_Config(&coreClkSelect) != BASE_STATUS_OK) {
 3000758:	fec40793          	addi	a5,s0,-20
 300075c:	853e                	mv	a0,a5
 300075e:	2d40d0ef          	jal	ra,300da32 <CRG_Config>
 3000762:	87aa                	mv	a5,a0
 3000764:	c391                	beqz	a5,3000768 <Chip_Init+0x18>
        Chip_InitFail();
 3000766:	37cd                	jal	ra,3000748 <Chip_InitFail>
    }

    /* Config FLASH Clock */
    FLASH_ClockConfig(coreClkSelect);
 3000768:	fec42783          	lw	a5,-20(s0)
 300076c:	853e                	mv	a0,a5
 300076e:	796000ef          	jal	ra,3000f04 <FLASH_ClockConfig>
    SYSTICK_Init();
 3000772:	057000ef          	jal	ra,3000fc8 <SYSTICK_Init>
    /* Set CoreClock Select after FLASH Config Done */
    CRG_SetCoreClockSelect(coreClkSelect);
 3000776:	fec42783          	lw	a5,-20(s0)
 300077a:	853e                	mv	a0,a5
 300077c:	25b1                	jal	ra,3000dc8 <CRG_SetCoreClockSelect>

    IRQ_Init();
 300077e:	798020ef          	jal	ra,3002f16 <IRQ_Init>
    ANAVREF_Init();
 3000782:	23e5                	jal	ra,3000d6a <ANAVREF_Init>
    ANATRIM_Entry();
 3000784:	2b51                	jal	ra,3000d18 <ANATRIM_Entry>
    /* User Add Code Here */
 3000786:	0001                	nop
 3000788:	40f2                	lw	ra,28(sp)
 300078a:	4462                	lw	s0,24(sp)
 300078c:	6105                	addi	sp,sp,32
 300078e:	8082                	ret

03000790 <CalculateGain>:
 * @brief Calculate the conversion gain of the tsensor.
 * @param data, original data.
 * @retval None
 */
static void CalculateGain(unsigned int data)
{
 3000790:	1101                	addi	sp,sp,-32
 3000792:	ce22                	sw	s0,28(sp)
 3000794:	1000                	addi	s0,sp,32
 3000796:	fea42623          	sw	a0,-20(s0)
    g_tsensorGain = ((float)(data) / 10000000.0f);
 300079a:	fec42783          	lw	a5,-20(s0)
 300079e:	d017f753          	fcvt.s.wu	fa4,a5
 30007a2:	030127b7          	lui	a5,0x3012
 30007a6:	8947a787          	flw	fa5,-1900(a5) # 3011894 <__rodata_start>
 30007aa:	18f777d3          	fdiv.s	fa5,fa4,fa5
 30007ae:	040007b7          	lui	a5,0x4000
 30007b2:	00f7a027          	fsw	fa5,0(a5) # 4000000 <g_tsensorGain>
}
 30007b6:	0001                	nop
 30007b8:	4472                	lw	s0,28(sp)
 30007ba:	6105                	addi	sp,sp,32
 30007bc:	8082                	ret

030007be <CHIP_GetInfo>:
 * @brief Obtains the chip ID.
 * @param None
 * @retval None
 */
static bool CHIP_GetInfo(void)
{
 30007be:	7179                	addi	sp,sp,-48
 30007c0:	d606                	sw	ra,44(sp)
 30007c2:	d422                	sw	s0,40(sp)
 30007c4:	1800                	addi	s0,sp,48
    FOTP_INFO_RGN0_NUMBER_4 emptyData;
    FOTP_INFO_RGN0_NUMBER_2 idData;
    FOTP_InfoGet(FOTP_INFO_RNG0, 4U, (void *)&emptyData.comData);   /* 4 is the number of fotp_empty_flag in otp */
 30007c6:	fe040793          	addi	a5,s0,-32
 30007ca:	863e                	mv	a2,a5
 30007cc:	4591                	li	a1,4
 30007ce:	4501                	li	a0,0
 30007d0:	2391                	jal	ra,3000d14 <FOTP_InfoGet.trans.38>
    FOTP_InfoGet(FOTP_INFO_RNG0, 2U, (void *)&idData.comData);      /* 2 is the number of idData in otp */
 30007d2:	fd040793          	addi	a5,s0,-48
 30007d6:	863e                	mv	a2,a5
 30007d8:	4589                	li	a1,2
 30007da:	4501                	li	a0,0
 30007dc:	2b25                	jal	ra,3000d14 <FOTP_InfoGet.trans.38>
    if (emptyData.REG.fotp_empty_flag != 0x5AA59669 || idData.REG.chip_id == 0xFFFFFFFF) {
 30007de:	fe042703          	lw	a4,-32(s0)
 30007e2:	5aa597b7          	lui	a5,0x5aa59
 30007e6:	66978793          	addi	a5,a5,1641 # 5aa59669 <RAM_END+0x56a51669>
 30007ea:	00f71763          	bne	a4,a5,30007f8 <CHIP_GetInfo+0x3a>
 30007ee:	fd042703          	lw	a4,-48(s0)
 30007f2:	57fd                	li	a5,-1
 30007f4:	00f71463          	bne	a4,a5,30007fc <CHIP_GetInfo+0x3e>
        return false;
 30007f8:	4781                	li	a5,0
 30007fa:	a011                	j	30007fe <CHIP_GetInfo+0x40>
    }
    return true;
 30007fc:	4785                	li	a5,1
}
 30007fe:	853e                	mv	a0,a5
 3000800:	50b2                	lw	ra,44(sp)
 3000802:	5422                	lw	s0,40(sp)
 3000804:	6145                	addi	sp,sp,48
 3000806:	8082                	ret

03000808 <CHIP_AnalogTrim>:
 * @brief Analog module trim.
 * @param None
 * @retval None
 */
static void CHIP_AnalogTrim(void)
{
 3000808:	711d                	addi	sp,sp,-96
 300080a:	ce86                	sw	ra,92(sp)
 300080c:	cca2                	sw	s0,88(sp)
 300080e:	1080                	addi	s0,sp,96
    FOTP_INFO_RGN0_NUMBER_20 trimData20;
    FOTP_InfoGet(FOTP_INFO_RNG0, 20U, (void *)&trimData20.comData); /* 20 is the number of trim data in otp */
 3000810:	fdc40793          	addi	a5,s0,-36
 3000814:	863e                	mv	a2,a5
 3000816:	45d1                	li	a1,20
 3000818:	4501                	li	a0,0
 300081a:	29ed                	jal	ra,3000d14 <FOTP_InfoGet.trans.38>
    /* VREF */
    VREF->VREF_TRIM0.BIT.da_iref_trim = trimData20.REG.data0.da_iref_trim;
 300081c:	18100737          	lui	a4,0x18100
 3000820:	fdc42783          	lw	a5,-36(s0)
 3000824:	83c1                	srli	a5,a5,0x10
 3000826:	9bfd                	andi	a5,a5,-1
 3000828:	0ff7f693          	andi	a3,a5,255
 300082c:	433c                	lw	a5,64(a4)
 300082e:	0ff6f693          	andi	a3,a3,255
 3000832:	f007f793          	andi	a5,a5,-256
 3000836:	8fd5                	or	a5,a5,a3
 3000838:	c33c                	sw	a5,64(a4)
    VREF->VREF_TRIM0.BIT.da_ref_vref_trim = trimData20.REG.data0.da_ref_vref_trim;
 300083a:	18100737          	lui	a4,0x18100
 300083e:	fdc42783          	lw	a5,-36(s0)
 3000842:	83a1                	srli	a5,a5,0x8
 3000844:	9bfd                	andi	a5,a5,-1
 3000846:	0ff7f693          	andi	a3,a5,255
 300084a:	433c                	lw	a5,64(a4)
 300084c:	0ff6f693          	andi	a3,a3,255
 3000850:	06a2                	slli	a3,a3,0x8
 3000852:	7641                	lui	a2,0xffff0
 3000854:	0ff60613          	addi	a2,a2,255 # ffff00ff <RAM_END+0xfbfe80ff>
 3000858:	8ff1                	and	a5,a5,a2
 300085a:	8fd5                	or	a5,a5,a3
 300085c:	c33c                	sw	a5,64(a4)
    VREF->VREF_TRIM0.BIT.da_ref_vbg_trim = trimData20.REG.data0.da_ref_vbg_trim;
 300085e:	18100737          	lui	a4,0x18100
 3000862:	fdc42783          	lw	a5,-36(s0)
 3000866:	0ff7f693          	andi	a3,a5,255
 300086a:	433c                	lw	a5,64(a4)
 300086c:	0ff6f693          	andi	a3,a3,255
 3000870:	06c2                	slli	a3,a3,0x10
 3000872:	ff010637          	lui	a2,0xff010
 3000876:	167d                	addi	a2,a2,-1 # ff00ffff <RAM_END+0xfb007fff>
 3000878:	8ff1                	and	a5,a5,a2
 300087a:	8fd5                	or	a5,a5,a3
 300087c:	c33c                	sw	a5,64(a4)
    unsigned int value = trimData20.REG.data1.da_ref_temp_trim3;
 300087e:	fe042783          	lw	a5,-32(s0)
 3000882:	83c1                	srli	a5,a5,0x10
 3000884:	9bfd                	andi	a5,a5,-1
 3000886:	9f81                	uxtb	a5
 3000888:	fef42623          	sw	a5,-20(s0)
    value |= (trimData20.REG.data1.da_ref_temp_trim2 << 8U);    /* Shift left by 8 bits */
 300088c:	fe042783          	lw	a5,-32(s0)
 3000890:	83a1                	srli	a5,a5,0x8
 3000892:	9bfd                	andi	a5,a5,-1
 3000894:	9f81                	uxtb	a5
 3000896:	07a2                	slli	a5,a5,0x8
 3000898:	873e                	mv	a4,a5
 300089a:	fec42783          	lw	a5,-20(s0)
 300089e:	8fd9                	or	a5,a5,a4
 30008a0:	fef42623          	sw	a5,-20(s0)
    value |= (trimData20.REG.data1.da_ref_temp_trim1 << 16U);   /* Shift left by 16 bits */
 30008a4:	fe042783          	lw	a5,-32(s0)
 30008a8:	9f81                	uxtb	a5
 30008aa:	07c2                	slli	a5,a5,0x10
 30008ac:	873e                	mv	a4,a5
 30008ae:	fec42783          	lw	a5,-20(s0)
 30008b2:	8fd9                	or	a5,a5,a4
 30008b4:	fef42623          	sw	a5,-20(s0)
    value |= (trimData20.REG.data0.da_ref_temp_trim0 << 24U);   /* Shift left by 24 bits */
 30008b8:	fdc42783          	lw	a5,-36(s0)
 30008bc:	83e1                	srli	a5,a5,0x18
 30008be:	9f81                	uxtb	a5
 30008c0:	07e2                	slli	a5,a5,0x18
 30008c2:	873e                	mv	a4,a5
 30008c4:	fec42783          	lw	a5,-20(s0)
 30008c8:	8fd9                	or	a5,a5,a4
 30008ca:	fef42623          	sw	a5,-20(s0)
    VREF->VREF_TRIM1.reg = value;
 30008ce:	181007b7          	lui	a5,0x18100
 30008d2:	fec42703          	lw	a4,-20(s0)
 30008d6:	c3f8                	sw	a4,68(a5)

    FOTP_INFO_RGN0_NUMBER_21 trimData21;
    FOTP_InfoGet(FOTP_INFO_RNG0, 21U, (void *)&trimData21.comData); /* 21 is the number of trim data in otp */
 30008d8:	fcc40793          	addi	a5,s0,-52
 30008dc:	863e                	mv	a2,a5
 30008de:	45d5                	li	a1,21
 30008e0:	4501                	li	a0,0
 30008e2:	290d                	jal	ra,3000d14 <FOTP_InfoGet.trans.38>
    /* ADC */
    ADC0->ADC_OEGE_TRIM.BIT.cfg_gain_cali_trim = trimData21.REG.data1.saradc_gain;
 30008e4:	18000737          	lui	a4,0x18000
 30008e8:	fd042783          	lw	a5,-48(s0)
 30008ec:	86be                	mv	a3,a5
 30008ee:	6789                	lui	a5,0x2
 30008f0:	17fd                	addi	a5,a5,-1 # 1fff <__bss_size__+0xf6b>
 30008f2:	8ff5                	and	a5,a5,a3
 30008f4:	01079613          	slli	a2,a5,0x10
 30008f8:	8241                	srli	a2,a2,0x10
 30008fa:	6785                	lui	a5,0x1
 30008fc:	973e                	add	a4,a4,a5
 30008fe:	80472783          	lw	a5,-2044(a4) # 17fff804 <RAM_END+0x13ff7804>
 3000902:	6689                	lui	a3,0x2
 3000904:	16fd                	addi	a3,a3,-1 # 1fff <__bss_size__+0xf6b>
 3000906:	8ef1                	and	a3,a3,a2
 3000908:	06c2                	slli	a3,a3,0x10
 300090a:	e0010637          	lui	a2,0xe0010
 300090e:	167d                	addi	a2,a2,-1 # e000ffff <RAM_END+0xdc007fff>
 3000910:	8ff1                	and	a5,a5,a2
 3000912:	8fd5                	or	a5,a5,a3
 3000914:	80f72223          	sw	a5,-2044(a4)
    ADC0->ADC_OEGE_TRIM.BIT.cfg_ofst_cali_trim = trimData21.REG.data1.saradc_offset;
 3000918:	18000737          	lui	a4,0x18000
 300091c:	fd042783          	lw	a5,-48(s0)
 3000920:	83c1                	srli	a5,a5,0x10
 3000922:	86be                	mv	a3,a5
 3000924:	6785                	lui	a5,0x1
 3000926:	17fd                	addi	a5,a5,-1 # fff <prithd+0x401>
 3000928:	8ff5                	and	a5,a5,a3
 300092a:	01079613          	slli	a2,a5,0x10
 300092e:	8241                	srli	a2,a2,0x10
 3000930:	6785                	lui	a5,0x1
 3000932:	973e                	add	a4,a4,a5
 3000934:	80472783          	lw	a5,-2044(a4) # 17fff804 <RAM_END+0x13ff7804>
 3000938:	6685                	lui	a3,0x1
 300093a:	16fd                	addi	a3,a3,-1 # fff <prithd+0x401>
 300093c:	8ef1                	and	a3,a3,a2
 300093e:	767d                	lui	a2,0xfffff
 3000940:	8ff1                	and	a5,a5,a2
 3000942:	8fd5                	or	a5,a5,a3
 3000944:	80f72223          	sw	a5,-2044(a4)
   
    /* TSENSOR */
    TSENSOR->TSENSOR_TRIM.reg = trimData20.REG.data1.da_ref_vptat_trim;
 3000948:	fe042783          	lw	a5,-32(s0)
 300094c:	83e1                	srli	a5,a5,0x18
 300094e:	0ff7f713          	andi	a4,a5,255
 3000952:	185007b7          	lui	a5,0x18500
 3000956:	cb98                	sw	a4,16(a5)
    ADC0->ADC_TSENSOR_TRIM.BIT.cfg_tsensor_ofst_trim = trimData21.REG.data2.ts_offset;
 3000958:	18000737          	lui	a4,0x18000
 300095c:	fd442783          	lw	a5,-44(s0)
 3000960:	86be                	mv	a3,a5
 3000962:	6785                	lui	a5,0x1
 3000964:	17fd                	addi	a5,a5,-1 # fff <prithd+0x401>
 3000966:	8ff5                	and	a5,a5,a3
 3000968:	01079613          	slli	a2,a5,0x10
 300096c:	8241                	srli	a2,a2,0x10
 300096e:	6785                	lui	a5,0x1
 3000970:	973e                	add	a4,a4,a5
 3000972:	80072783          	lw	a5,-2048(a4) # 17fff800 <RAM_END+0x13ff7800>
 3000976:	6685                	lui	a3,0x1
 3000978:	16fd                	addi	a3,a3,-1 # fff <prithd+0x401>
 300097a:	8ef1                	and	a3,a3,a2
 300097c:	767d                	lui	a2,0xfffff
 300097e:	8ff1                	and	a5,a5,a2
 3000980:	8fd5                	or	a5,a5,a3
 3000982:	80f72023          	sw	a5,-2048(a4)
    CalculateGain(trimData21.REG.data3.ts_gain);
 3000986:	fd842783          	lw	a5,-40(s0)
 300098a:	83a5                	srli	a5,a5,0x9
 300098c:	853e                	mv	a0,a5
 300098e:	3509                	jal	ra,3000790 <CalculateGain>

    /* PGA */
    PGA0->PGA_TRIM.BIT.da_pga_vos_trim = trimData21.REG.data0.da_pga0_vos_trim;
 3000990:	18200737          	lui	a4,0x18200
 3000994:	fcc42783          	lw	a5,-52(s0)
 3000998:	1ff7f793          	andi	a5,a5,511
 300099c:	01079693          	slli	a3,a5,0x10
 30009a0:	82c1                	srli	a3,a3,0x10
 30009a2:	531c                	lw	a5,32(a4)
 30009a4:	1ff6f693          	andi	a3,a3,511
 30009a8:	e007f793          	andi	a5,a5,-512
 30009ac:	8fd5                	or	a5,a5,a3
 30009ae:	d31c                	sw	a5,32(a4)
    PGA1->PGA_TRIM.BIT.da_pga_vos_trim = trimData21.REG.data0.da_pga1_vos_trim;
 30009b0:	18201737          	lui	a4,0x18201
 30009b4:	fcc42783          	lw	a5,-52(s0)
 30009b8:	83c1                	srli	a5,a5,0x10
 30009ba:	1ff7f793          	andi	a5,a5,511
 30009be:	01079693          	slli	a3,a5,0x10
 30009c2:	82c1                	srli	a3,a3,0x10
 30009c4:	531c                	lw	a5,32(a4)
 30009c6:	1ff6f693          	andi	a3,a3,511
 30009ca:	e007f793          	andi	a5,a5,-512
 30009ce:	8fd5                	or	a5,a5,a3
 30009d0:	d31c                	sw	a5,32(a4)

    FOTP_INFO_RGN0_NUMBER_22 trimData22;
    FOTP_InfoGet(FOTP_INFO_RNG0, 22U, (void *)&trimData22.comData); /* 22 is the number of trim data in otp */
 30009d2:	fbc40793          	addi	a5,s0,-68
 30009d6:	863e                	mv	a2,a5
 30009d8:	45d9                	li	a1,22
 30009da:	4501                	li	a0,0
 30009dc:	257d                	jal	ra,300108a <FOTP_InfoGet>
    ADC0->ADC_PGA0_OEGE_TRIM0.BIT.cfg_pga0_gain_trim2 = trimData22.REG.data0.pga0_gain2;
 30009de:	18000737          	lui	a4,0x18000
 30009e2:	fbc42783          	lw	a5,-68(s0)
 30009e6:	86be                	mv	a3,a5
 30009e8:	6789                	lui	a5,0x2
 30009ea:	17fd                	addi	a5,a5,-1 # 1fff <__bss_size__+0xf6b>
 30009ec:	8ff5                	and	a5,a5,a3
 30009ee:	01079613          	slli	a2,a5,0x10
 30009f2:	8241                	srli	a2,a2,0x10
 30009f4:	6785                	lui	a5,0x1
 30009f6:	973e                	add	a4,a4,a5
 30009f8:	81072783          	lw	a5,-2032(a4) # 17fff810 <RAM_END+0x13ff7810>
 30009fc:	6689                	lui	a3,0x2
 30009fe:	16fd                	addi	a3,a3,-1 # 1fff <__bss_size__+0xf6b>
 3000a00:	8ef1                	and	a3,a3,a2
 3000a02:	06c2                	slli	a3,a3,0x10
 3000a04:	e0010637          	lui	a2,0xe0010
 3000a08:	167d                	addi	a2,a2,-1 # e000ffff <RAM_END+0xdc007fff>
 3000a0a:	8ff1                	and	a5,a5,a2
 3000a0c:	8fd5                	or	a5,a5,a3
 3000a0e:	80f72823          	sw	a5,-2032(a4)
    ADC0->ADC_PGA0_OEGE_TRIM0.BIT.cfg_pga0_ofst_trim2 = trimData22.REG.data0.pga0_offset2;
 3000a12:	18000737          	lui	a4,0x18000
 3000a16:	fbc42783          	lw	a5,-68(s0)
 3000a1a:	83c1                	srli	a5,a5,0x10
 3000a1c:	86be                	mv	a3,a5
 3000a1e:	6785                	lui	a5,0x1
 3000a20:	17fd                	addi	a5,a5,-1 # fff <prithd+0x401>
 3000a22:	8ff5                	and	a5,a5,a3
 3000a24:	01079613          	slli	a2,a5,0x10
 3000a28:	8241                	srli	a2,a2,0x10
 3000a2a:	6785                	lui	a5,0x1
 3000a2c:	973e                	add	a4,a4,a5
 3000a2e:	81072783          	lw	a5,-2032(a4) # 17fff810 <RAM_END+0x13ff7810>
 3000a32:	6685                	lui	a3,0x1
 3000a34:	16fd                	addi	a3,a3,-1 # fff <prithd+0x401>
 3000a36:	8ef1                	and	a3,a3,a2
 3000a38:	767d                	lui	a2,0xfffff
 3000a3a:	8ff1                	and	a5,a5,a2
 3000a3c:	8fd5                	or	a5,a5,a3
 3000a3e:	80f72823          	sw	a5,-2032(a4)
    ADC0->ADC_PGA0_OEGE_TRIM1.BIT.cfg_pga0_gain_trim4 = trimData22.REG.data1.pga0_gain4;
 3000a42:	18000737          	lui	a4,0x18000
 3000a46:	fc042783          	lw	a5,-64(s0)
 3000a4a:	86be                	mv	a3,a5
 3000a4c:	6789                	lui	a5,0x2
 3000a4e:	17fd                	addi	a5,a5,-1 # 1fff <__bss_size__+0xf6b>
 3000a50:	8ff5                	and	a5,a5,a3
 3000a52:	01079613          	slli	a2,a5,0x10
 3000a56:	8241                	srli	a2,a2,0x10
 3000a58:	6785                	lui	a5,0x1
 3000a5a:	973e                	add	a4,a4,a5
 3000a5c:	81472783          	lw	a5,-2028(a4) # 17fff814 <RAM_END+0x13ff7814>
 3000a60:	6689                	lui	a3,0x2
 3000a62:	16fd                	addi	a3,a3,-1 # 1fff <__bss_size__+0xf6b>
 3000a64:	8ef1                	and	a3,a3,a2
 3000a66:	06c2                	slli	a3,a3,0x10
 3000a68:	e0010637          	lui	a2,0xe0010
 3000a6c:	167d                	addi	a2,a2,-1 # e000ffff <RAM_END+0xdc007fff>
 3000a6e:	8ff1                	and	a5,a5,a2
 3000a70:	8fd5                	or	a5,a5,a3
 3000a72:	80f72a23          	sw	a5,-2028(a4)
    ADC0->ADC_PGA0_OEGE_TRIM1.BIT.cfg_pga0_ofst_trim4 = trimData22.REG.data1.pga0_offset4;
 3000a76:	18000737          	lui	a4,0x18000
 3000a7a:	fc042783          	lw	a5,-64(s0)
 3000a7e:	83c1                	srli	a5,a5,0x10
 3000a80:	86be                	mv	a3,a5
 3000a82:	6785                	lui	a5,0x1
 3000a84:	17fd                	addi	a5,a5,-1 # fff <prithd+0x401>
 3000a86:	8ff5                	and	a5,a5,a3
 3000a88:	01079613          	slli	a2,a5,0x10
 3000a8c:	8241                	srli	a2,a2,0x10
 3000a8e:	6785                	lui	a5,0x1
 3000a90:	973e                	add	a4,a4,a5
 3000a92:	81472783          	lw	a5,-2028(a4) # 17fff814 <RAM_END+0x13ff7814>
 3000a96:	6685                	lui	a3,0x1
 3000a98:	16fd                	addi	a3,a3,-1 # fff <prithd+0x401>
 3000a9a:	8ef1                	and	a3,a3,a2
 3000a9c:	767d                	lui	a2,0xfffff
 3000a9e:	8ff1                	and	a5,a5,a2
 3000aa0:	8fd5                	or	a5,a5,a3
 3000aa2:	80f72a23          	sw	a5,-2028(a4)
    ADC0->ADC_PGA0_OEGE_TRIM2.BIT.cfg_pga0_gain_trim8 = trimData22.REG.data2.pga0_gain8;
 3000aa6:	18000737          	lui	a4,0x18000
 3000aaa:	fc442783          	lw	a5,-60(s0)
 3000aae:	86be                	mv	a3,a5
 3000ab0:	6789                	lui	a5,0x2
 3000ab2:	17fd                	addi	a5,a5,-1 # 1fff <__bss_size__+0xf6b>
 3000ab4:	8ff5                	and	a5,a5,a3
 3000ab6:	01079613          	slli	a2,a5,0x10
 3000aba:	8241                	srli	a2,a2,0x10
 3000abc:	6785                	lui	a5,0x1
 3000abe:	973e                	add	a4,a4,a5
 3000ac0:	81872783          	lw	a5,-2024(a4) # 17fff818 <RAM_END+0x13ff7818>
 3000ac4:	6689                	lui	a3,0x2
 3000ac6:	16fd                	addi	a3,a3,-1 # 1fff <__bss_size__+0xf6b>
 3000ac8:	8ef1                	and	a3,a3,a2
 3000aca:	06c2                	slli	a3,a3,0x10
 3000acc:	e0010637          	lui	a2,0xe0010
 3000ad0:	167d                	addi	a2,a2,-1 # e000ffff <RAM_END+0xdc007fff>
 3000ad2:	8ff1                	and	a5,a5,a2
 3000ad4:	8fd5                	or	a5,a5,a3
 3000ad6:	80f72c23          	sw	a5,-2024(a4)
    ADC0->ADC_PGA0_OEGE_TRIM2.BIT.cfg_pga0_ofst_trim8 = trimData22.REG.data2.pga0_offset8;
 3000ada:	18000737          	lui	a4,0x18000
 3000ade:	fc442783          	lw	a5,-60(s0)
 3000ae2:	83c1                	srli	a5,a5,0x10
 3000ae4:	86be                	mv	a3,a5
 3000ae6:	6785                	lui	a5,0x1
 3000ae8:	17fd                	addi	a5,a5,-1 # fff <prithd+0x401>
 3000aea:	8ff5                	and	a5,a5,a3
 3000aec:	01079613          	slli	a2,a5,0x10
 3000af0:	8241                	srli	a2,a2,0x10
 3000af2:	6785                	lui	a5,0x1
 3000af4:	973e                	add	a4,a4,a5
 3000af6:	81872783          	lw	a5,-2024(a4) # 17fff818 <RAM_END+0x13ff7818>
 3000afa:	6685                	lui	a3,0x1
 3000afc:	16fd                	addi	a3,a3,-1 # fff <prithd+0x401>
 3000afe:	8ef1                	and	a3,a3,a2
 3000b00:	767d                	lui	a2,0xfffff
 3000b02:	8ff1                	and	a5,a5,a2
 3000b04:	8fd5                	or	a5,a5,a3
 3000b06:	80f72c23          	sw	a5,-2024(a4)
    ADC0->ADC_PGA0_OEGE_TRIM3.BIT.cfg_pga0_gain_trim16 = trimData22.REG.data3.pga0_gain16;
 3000b0a:	18000737          	lui	a4,0x18000
 3000b0e:	fc842783          	lw	a5,-56(s0)
 3000b12:	86be                	mv	a3,a5
 3000b14:	6789                	lui	a5,0x2
 3000b16:	17fd                	addi	a5,a5,-1 # 1fff <__bss_size__+0xf6b>
 3000b18:	8ff5                	and	a5,a5,a3
 3000b1a:	01079613          	slli	a2,a5,0x10
 3000b1e:	8241                	srli	a2,a2,0x10
 3000b20:	6785                	lui	a5,0x1
 3000b22:	973e                	add	a4,a4,a5
 3000b24:	81c72783          	lw	a5,-2020(a4) # 17fff81c <RAM_END+0x13ff781c>
 3000b28:	6689                	lui	a3,0x2
 3000b2a:	16fd                	addi	a3,a3,-1 # 1fff <__bss_size__+0xf6b>
 3000b2c:	8ef1                	and	a3,a3,a2
 3000b2e:	06c2                	slli	a3,a3,0x10
 3000b30:	e0010637          	lui	a2,0xe0010
 3000b34:	167d                	addi	a2,a2,-1 # e000ffff <RAM_END+0xdc007fff>
 3000b36:	8ff1                	and	a5,a5,a2
 3000b38:	8fd5                	or	a5,a5,a3
 3000b3a:	80f72e23          	sw	a5,-2020(a4)
    ADC0->ADC_PGA0_OEGE_TRIM3.BIT.cfg_pga0_ofst_trim16 = trimData22.REG.data3.pga0_offset16;
 3000b3e:	18000737          	lui	a4,0x18000
 3000b42:	fc842783          	lw	a5,-56(s0)
 3000b46:	83c1                	srli	a5,a5,0x10
 3000b48:	86be                	mv	a3,a5
 3000b4a:	6785                	lui	a5,0x1
 3000b4c:	17fd                	addi	a5,a5,-1 # fff <prithd+0x401>
 3000b4e:	8ff5                	and	a5,a5,a3
 3000b50:	01079613          	slli	a2,a5,0x10
 3000b54:	8241                	srli	a2,a2,0x10
 3000b56:	6785                	lui	a5,0x1
 3000b58:	973e                	add	a4,a4,a5
 3000b5a:	81c72783          	lw	a5,-2020(a4) # 17fff81c <RAM_END+0x13ff781c>
 3000b5e:	6685                	lui	a3,0x1
 3000b60:	16fd                	addi	a3,a3,-1 # fff <prithd+0x401>
 3000b62:	8ef1                	and	a3,a3,a2
 3000b64:	767d                	lui	a2,0xfffff
 3000b66:	8ff1                	and	a5,a5,a2
 3000b68:	8fd5                	or	a5,a5,a3
 3000b6a:	80f72e23          	sw	a5,-2020(a4)

    FOTP_INFO_RGN0_NUMBER_23 trimData23;
    FOTP_InfoGet(FOTP_INFO_RNG0, 23U, (void *)&trimData23.comData); /* 23 is the number of trim data in otp */
 3000b6e:	fac40793          	addi	a5,s0,-84
 3000b72:	863e                	mv	a2,a5
 3000b74:	45dd                	li	a1,23
 3000b76:	4501                	li	a0,0
 3000b78:	2b09                	jal	ra,300108a <FOTP_InfoGet>
    ADC0->ADC_PGA1_OEGE_TRIM0.BIT.cfg_pga1_gain_trim2 = trimData23.REG.data0.pga1_gain2;
 3000b7a:	18000737          	lui	a4,0x18000
 3000b7e:	fac42783          	lw	a5,-84(s0)
 3000b82:	86be                	mv	a3,a5
 3000b84:	6789                	lui	a5,0x2
 3000b86:	17fd                	addi	a5,a5,-1 # 1fff <__bss_size__+0xf6b>
 3000b88:	8ff5                	and	a5,a5,a3
 3000b8a:	01079613          	slli	a2,a5,0x10
 3000b8e:	8241                	srli	a2,a2,0x10
 3000b90:	6785                	lui	a5,0x1
 3000b92:	973e                	add	a4,a4,a5
 3000b94:	82072783          	lw	a5,-2016(a4) # 17fff820 <RAM_END+0x13ff7820>
 3000b98:	6689                	lui	a3,0x2
 3000b9a:	16fd                	addi	a3,a3,-1 # 1fff <__bss_size__+0xf6b>
 3000b9c:	8ef1                	and	a3,a3,a2
 3000b9e:	06c2                	slli	a3,a3,0x10
 3000ba0:	e0010637          	lui	a2,0xe0010
 3000ba4:	167d                	addi	a2,a2,-1 # e000ffff <RAM_END+0xdc007fff>
 3000ba6:	8ff1                	and	a5,a5,a2
 3000ba8:	8fd5                	or	a5,a5,a3
 3000baa:	82f72023          	sw	a5,-2016(a4)
    ADC0->ADC_PGA1_OEGE_TRIM0.BIT.cfg_pga1_ofst_trim2 = trimData23.REG.data0.pga1_offset2;
 3000bae:	18000737          	lui	a4,0x18000
 3000bb2:	fac42783          	lw	a5,-84(s0)
 3000bb6:	83c1                	srli	a5,a5,0x10
 3000bb8:	86be                	mv	a3,a5
 3000bba:	6785                	lui	a5,0x1
 3000bbc:	17fd                	addi	a5,a5,-1 # fff <prithd+0x401>
 3000bbe:	8ff5                	and	a5,a5,a3
 3000bc0:	01079613          	slli	a2,a5,0x10
 3000bc4:	8241                	srli	a2,a2,0x10
 3000bc6:	6785                	lui	a5,0x1
 3000bc8:	973e                	add	a4,a4,a5
 3000bca:	82072783          	lw	a5,-2016(a4) # 17fff820 <RAM_END+0x13ff7820>
 3000bce:	6685                	lui	a3,0x1
 3000bd0:	16fd                	addi	a3,a3,-1 # fff <prithd+0x401>
 3000bd2:	8ef1                	and	a3,a3,a2
 3000bd4:	767d                	lui	a2,0xfffff
 3000bd6:	8ff1                	and	a5,a5,a2
 3000bd8:	8fd5                	or	a5,a5,a3
 3000bda:	82f72023          	sw	a5,-2016(a4)
    ADC0->ADC_PGA1_OEGE_TRIM1.BIT.cfg_pga1_gain_trim4 = trimData23.REG.data1.pga1_gain4;
 3000bde:	18000737          	lui	a4,0x18000
 3000be2:	fb042783          	lw	a5,-80(s0)
 3000be6:	86be                	mv	a3,a5
 3000be8:	6789                	lui	a5,0x2
 3000bea:	17fd                	addi	a5,a5,-1 # 1fff <__bss_size__+0xf6b>
 3000bec:	8ff5                	and	a5,a5,a3
 3000bee:	01079613          	slli	a2,a5,0x10
 3000bf2:	8241                	srli	a2,a2,0x10
 3000bf4:	6785                	lui	a5,0x1
 3000bf6:	973e                	add	a4,a4,a5
 3000bf8:	82472783          	lw	a5,-2012(a4) # 17fff824 <RAM_END+0x13ff7824>
 3000bfc:	6689                	lui	a3,0x2
 3000bfe:	16fd                	addi	a3,a3,-1 # 1fff <__bss_size__+0xf6b>
 3000c00:	8ef1                	and	a3,a3,a2
 3000c02:	06c2                	slli	a3,a3,0x10
 3000c04:	e0010637          	lui	a2,0xe0010
 3000c08:	167d                	addi	a2,a2,-1 # e000ffff <RAM_END+0xdc007fff>
 3000c0a:	8ff1                	and	a5,a5,a2
 3000c0c:	8fd5                	or	a5,a5,a3
 3000c0e:	82f72223          	sw	a5,-2012(a4)
    ADC0->ADC_PGA1_OEGE_TRIM1.BIT.cfg_pga1_ofst_trim4 = trimData23.REG.data1.pga1_offset4;
 3000c12:	18000737          	lui	a4,0x18000
 3000c16:	fb042783          	lw	a5,-80(s0)
 3000c1a:	83c1                	srli	a5,a5,0x10
 3000c1c:	86be                	mv	a3,a5
 3000c1e:	6785                	lui	a5,0x1
 3000c20:	17fd                	addi	a5,a5,-1 # fff <prithd+0x401>
 3000c22:	8ff5                	and	a5,a5,a3
 3000c24:	01079613          	slli	a2,a5,0x10
 3000c28:	8241                	srli	a2,a2,0x10
 3000c2a:	6785                	lui	a5,0x1
 3000c2c:	973e                	add	a4,a4,a5
 3000c2e:	82472783          	lw	a5,-2012(a4) # 17fff824 <RAM_END+0x13ff7824>
 3000c32:	6685                	lui	a3,0x1
 3000c34:	16fd                	addi	a3,a3,-1 # fff <prithd+0x401>
 3000c36:	8ef1                	and	a3,a3,a2
 3000c38:	767d                	lui	a2,0xfffff
 3000c3a:	8ff1                	and	a5,a5,a2
 3000c3c:	8fd5                	or	a5,a5,a3
 3000c3e:	82f72223          	sw	a5,-2012(a4)
    ADC0->ADC_PGA1_OEGE_TRIM2.BIT.cfg_pga1_gain_trim8 = trimData23.REG.data2.pga1_gain8;
 3000c42:	18000737          	lui	a4,0x18000
 3000c46:	fb442783          	lw	a5,-76(s0)
 3000c4a:	86be                	mv	a3,a5
 3000c4c:	6789                	lui	a5,0x2
 3000c4e:	17fd                	addi	a5,a5,-1 # 1fff <__bss_size__+0xf6b>
 3000c50:	8ff5                	and	a5,a5,a3
 3000c52:	01079613          	slli	a2,a5,0x10
 3000c56:	8241                	srli	a2,a2,0x10
 3000c58:	6785                	lui	a5,0x1
 3000c5a:	973e                	add	a4,a4,a5
 3000c5c:	82872783          	lw	a5,-2008(a4) # 17fff828 <RAM_END+0x13ff7828>
 3000c60:	6689                	lui	a3,0x2
 3000c62:	16fd                	addi	a3,a3,-1 # 1fff <__bss_size__+0xf6b>
 3000c64:	8ef1                	and	a3,a3,a2
 3000c66:	06c2                	slli	a3,a3,0x10
 3000c68:	e0010637          	lui	a2,0xe0010
 3000c6c:	167d                	addi	a2,a2,-1 # e000ffff <RAM_END+0xdc007fff>
 3000c6e:	8ff1                	and	a5,a5,a2
 3000c70:	8fd5                	or	a5,a5,a3
 3000c72:	82f72423          	sw	a5,-2008(a4)
    ADC0->ADC_PGA1_OEGE_TRIM2.BIT.cfg_pga1_ofst_trim8 = trimData23.REG.data2.pga1_offset8;
 3000c76:	18000737          	lui	a4,0x18000
 3000c7a:	fb442783          	lw	a5,-76(s0)
 3000c7e:	83c1                	srli	a5,a5,0x10
 3000c80:	86be                	mv	a3,a5
 3000c82:	6785                	lui	a5,0x1
 3000c84:	17fd                	addi	a5,a5,-1 # fff <prithd+0x401>
 3000c86:	8ff5                	and	a5,a5,a3
 3000c88:	01079613          	slli	a2,a5,0x10
 3000c8c:	8241                	srli	a2,a2,0x10
 3000c8e:	6785                	lui	a5,0x1
 3000c90:	973e                	add	a4,a4,a5
 3000c92:	82872783          	lw	a5,-2008(a4) # 17fff828 <RAM_END+0x13ff7828>
 3000c96:	6685                	lui	a3,0x1
 3000c98:	16fd                	addi	a3,a3,-1 # fff <prithd+0x401>
 3000c9a:	8ef1                	and	a3,a3,a2
 3000c9c:	767d                	lui	a2,0xfffff
 3000c9e:	8ff1                	and	a5,a5,a2
 3000ca0:	8fd5                	or	a5,a5,a3
 3000ca2:	82f72423          	sw	a5,-2008(a4)
    ADC0->ADC_PGA1_OEGE_TRIM3.BIT.cfg_pga1_gain_trim16 = trimData23.REG.data3.pga1_gain16;
 3000ca6:	18000737          	lui	a4,0x18000
 3000caa:	fb842783          	lw	a5,-72(s0)
 3000cae:	86be                	mv	a3,a5
 3000cb0:	6789                	lui	a5,0x2
 3000cb2:	17fd                	addi	a5,a5,-1 # 1fff <__bss_size__+0xf6b>
 3000cb4:	8ff5                	and	a5,a5,a3
 3000cb6:	01079613          	slli	a2,a5,0x10
 3000cba:	8241                	srli	a2,a2,0x10
 3000cbc:	6785                	lui	a5,0x1
 3000cbe:	973e                	add	a4,a4,a5
 3000cc0:	82c72783          	lw	a5,-2004(a4) # 17fff82c <RAM_END+0x13ff782c>
 3000cc4:	6689                	lui	a3,0x2
 3000cc6:	16fd                	addi	a3,a3,-1 # 1fff <__bss_size__+0xf6b>
 3000cc8:	8ef1                	and	a3,a3,a2
 3000cca:	06c2                	slli	a3,a3,0x10
 3000ccc:	e0010637          	lui	a2,0xe0010
 3000cd0:	167d                	addi	a2,a2,-1 # e000ffff <RAM_END+0xdc007fff>
 3000cd2:	8ff1                	and	a5,a5,a2
 3000cd4:	8fd5                	or	a5,a5,a3
 3000cd6:	82f72623          	sw	a5,-2004(a4)
    ADC0->ADC_PGA1_OEGE_TRIM3.BIT.cfg_pga1_ofst_trim16 = trimData23.REG.data3.pga1_offset16;
 3000cda:	18000737          	lui	a4,0x18000
 3000cde:	fb842783          	lw	a5,-72(s0)
 3000ce2:	83c1                	srli	a5,a5,0x10
 3000ce4:	86be                	mv	a3,a5
 3000ce6:	6785                	lui	a5,0x1
 3000ce8:	17fd                	addi	a5,a5,-1 # fff <prithd+0x401>
 3000cea:	8ff5                	and	a5,a5,a3
 3000cec:	01079613          	slli	a2,a5,0x10
 3000cf0:	8241                	srli	a2,a2,0x10
 3000cf2:	6785                	lui	a5,0x1
 3000cf4:	973e                	add	a4,a4,a5
 3000cf6:	82c72783          	lw	a5,-2004(a4) # 17fff82c <RAM_END+0x13ff782c>
 3000cfa:	6685                	lui	a3,0x1
 3000cfc:	16fd                	addi	a3,a3,-1 # fff <prithd+0x401>
 3000cfe:	8ef1                	and	a3,a3,a2
 3000d00:	767d                	lui	a2,0xfffff
 3000d02:	8ff1                	and	a5,a5,a2
 3000d04:	8fd5                	or	a5,a5,a3
 3000d06:	82f72623          	sw	a5,-2004(a4)
}
 3000d0a:	0001                	nop
 3000d0c:	40f6                	lw	ra,92(sp)
 3000d0e:	4466                	lw	s0,88(sp)
 3000d10:	6125                	addi	sp,sp,96
 3000d12:	8082                	ret

03000d14 <FOTP_InfoGet.trans.38>:
 3000d14:	3760006f          	j	300108a <FOTP_InfoGet>

03000d18 <ANATRIM_Entry>:
 * @brief Parameter calibration entry of the analog module.
 * @param None
 * @retval None
 */
void ANATRIM_Entry(void)
{
 3000d18:	1141                	addi	sp,sp,-16
 3000d1a:	c606                	sw	ra,12(sp)
 3000d1c:	c422                	sw	s0,8(sp)
 3000d1e:	0800                	addi	s0,sp,16
    if (CHIP_GetInfo() == false) { /* If the chip information is incorrect, calibration is not performed */
 3000d20:	3c79                	jal	ra,30007be <CHIP_GetInfo>
 3000d22:	87aa                	mv	a5,a0
 3000d24:	0017c793          	xori	a5,a5,1
 3000d28:	9f81                	uxtb	a5
 3000d2a:	eb9d                	bnez	a5,3000d60 <ANATRIM_Entry+0x48>
        return;
    }
    HAL_CRG_IpEnableSet((void *)ADC0, IP_CLK_ENABLE); /* Enable the clock for calibration */
 3000d2c:	4585                	li	a1,1
 3000d2e:	18000537          	lui	a0,0x18000
 3000d32:	2849                	jal	ra,3000dc4 <HAL_CRG_IpEnableSet.trans.19>
    HAL_CRG_IpEnableSet((void *)PGA0, IP_CLK_ENABLE);
 3000d34:	4585                	li	a1,1
 3000d36:	18200537          	lui	a0,0x18200
 3000d3a:	2069                	jal	ra,3000dc4 <HAL_CRG_IpEnableSet.trans.19>
    HAL_CRG_IpEnableSet((void *)PGA1, IP_CLK_ENABLE);
 3000d3c:	4585                	li	a1,1
 3000d3e:	18201537          	lui	a0,0x18201
 3000d42:	2049                	jal	ra,3000dc4 <HAL_CRG_IpEnableSet.trans.19>
    CHIP_AnalogTrim();
 3000d44:	34d1                	jal	ra,3000808 <CHIP_AnalogTrim>
    HAL_CRG_IpEnableSet((void *)ADC0, IP_CLK_DISABLE); /* The clock is disabled after calibration */
 3000d46:	4581                	li	a1,0
 3000d48:	18000537          	lui	a0,0x18000
 3000d4c:	28a5                	jal	ra,3000dc4 <HAL_CRG_IpEnableSet.trans.19>
    HAL_CRG_IpEnableSet((void *)PGA0, IP_CLK_DISABLE);
 3000d4e:	4581                	li	a1,0
 3000d50:	18200537          	lui	a0,0x18200
 3000d54:	2885                	jal	ra,3000dc4 <HAL_CRG_IpEnableSet.trans.19>
    HAL_CRG_IpEnableSet((void *)PGA1, IP_CLK_DISABLE);
 3000d56:	4581                	li	a1,0
 3000d58:	18201537          	lui	a0,0x18201
 3000d5c:	20a5                	jal	ra,3000dc4 <HAL_CRG_IpEnableSet.trans.19>
 3000d5e:	a011                	j	3000d62 <ANATRIM_Entry+0x4a>
        return;
 3000d60:	0001                	nop
 3000d62:	40b2                	lw	ra,12(sp)
 3000d64:	4422                	lw	s0,8(sp)
 3000d66:	0141                	addi	sp,sp,16
 3000d68:	8082                	ret

03000d6a <ANAVREF_Init>:
 * @brief Set Crg Core clock select
 * @param None
 * @retval None
 */
void ANAVREF_Init(void)
{
 3000d6a:	1141                	addi	sp,sp,-16
 3000d6c:	c606                	sw	ra,12(sp)
 3000d6e:	c422                	sw	s0,8(sp)
 3000d70:	0800                	addi	s0,sp,16
    HAL_CRG_IpEnableSet(VREF_BASE, IP_CLK_ENABLE);
 3000d72:	4585                	li	a1,1
 3000d74:	18100537          	lui	a0,0x18100
 3000d78:	20b1                	jal	ra,3000dc4 <HAL_CRG_IpEnableSet.trans.19>
    VREF->VREF_CTRL1.BIT.da_ref_temp_trim_enh = 0x1;
 3000d7a:	18100737          	lui	a4,0x18100
 3000d7e:	531c                	lw	a5,32(a4)
 3000d80:	66c1                	lui	a3,0x10
 3000d82:	8fd5                	or	a5,a5,a3
 3000d84:	d31c                	sw	a5,32(a4)
    VREF->VREF_CTRL0.BIT.da_ref_enh = BASE_CFG_ENABLE;
 3000d86:	18100737          	lui	a4,0x18100
 3000d8a:	431c                	lw	a5,0(a4)
 3000d8c:	0017e793          	ori	a5,a5,1
 3000d90:	c31c                	sw	a5,0(a4)
    BASE_FUNC_DELAY_US(200); /* delay 200us */
 3000d92:	000f47b7          	lui	a5,0xf4
 3000d96:	24078593          	addi	a1,a5,576 # f4240 <FLASH_SIZE+0xd4244>
 3000d9a:	0c800513          	li	a0,200
 3000d9e:	20b5                	jal	ra,3000e0a <BASE_FUNC_Delay.trans.26>
    VREF->VREF_CTRL1.BIT.da_ref_chop_enh = BASE_CFG_ENABLE;
 3000da0:	18100737          	lui	a4,0x18100
 3000da4:	531c                	lw	a5,32(a4)
 3000da6:	0017e793          	ori	a5,a5,1
 3000daa:	d31c                	sw	a5,32(a4)
    BASE_FUNC_DELAY_US(40); /* delay 40us */
 3000dac:	000f47b7          	lui	a5,0xf4
 3000db0:	24078593          	addi	a1,a5,576 # f4240 <FLASH_SIZE+0xd4244>
 3000db4:	02800513          	li	a0,40
 3000db8:	2889                	jal	ra,3000e0a <BASE_FUNC_Delay.trans.26>
 3000dba:	0001                	nop
 3000dbc:	40b2                	lw	ra,12(sp)
 3000dbe:	4422                	lw	s0,8(sp)
 3000dc0:	0141                	addi	sp,sp,16
 3000dc2:	8082                	ret

03000dc4 <HAL_CRG_IpEnableSet.trans.19>:
 3000dc4:	2420406f          	j	3005006 <HAL_CRG_IpEnableSet>

03000dc8 <CRG_SetCoreClockSelect>:
 * @brief Set Crg Core clock select
 * @param coreClkSelect Input core clock select value
 * @retval None
 */
void CRG_SetCoreClockSelect(CRG_CoreClkSelect coreClkSelect)
{
 3000dc8:	715d                	addi	sp,sp,-80
 3000dca:	c686                	sw	ra,76(sp)
 3000dcc:	c4a2                	sw	s0,72(sp)
 3000dce:	0880                	addi	s0,sp,80
 3000dd0:	faa42e23          	sw	a0,-68(s0)
    CRG_Handle crg;
    crg.baseAddress = CRG;
 3000dd4:	100007b7          	lui	a5,0x10000
 3000dd8:	fcf42423          	sw	a5,-56(s0)
    crg.coreClkSelect = coreClkSelect;
 3000ddc:	fbc42783          	lw	a5,-68(s0)
 3000de0:	fef42023          	sw	a5,-32(s0)
    if (crg.coreClkSelect == CRG_CORE_CLK_SELECT_TCXO) { /* If an external crystal oscillator is selected. */
 3000de4:	fe042703          	lw	a4,-32(s0)
 3000de8:	4785                	li	a5,1
 3000dea:	00f71663          	bne	a4,a5,3000df6 <CRG_SetCoreClockSelect+0x2e>
        BASE_FUNC_DELAY_MS(10);  /* 10: delay 10ms, wait clokc stable. */
 3000dee:	3e800593          	li	a1,1000
 3000df2:	4529                	li	a0,10
 3000df4:	2819                	jal	ra,3000e0a <BASE_FUNC_Delay.trans.26>
    }
    HAL_CRG_SetCoreClockSelect(&crg);
 3000df6:	fc840793          	addi	a5,s0,-56
 3000dfa:	853e                	mv	a0,a5
 3000dfc:	6fb030ef          	jal	ra,3004cf6 <HAL_CRG_SetCoreClockSelect>
 3000e00:	0001                	nop
 3000e02:	40b6                	lw	ra,76(sp)
 3000e04:	4426                	lw	s0,72(sp)
 3000e06:	6161                	addi	sp,sp,80
 3000e08:	8082                	ret

03000e0a <BASE_FUNC_Delay.trans.26>:
 3000e0a:	0560206f          	j	3002e60 <BASE_FUNC_Delay>

03000e0e <SetFlashDiv>:
 * @param frequence frequnce
 * @param div Output Divison
 * @retval None
 */
static void SetFlashDiv(unsigned int frequency, unsigned int *nreadDiv)
{
 3000e0e:	7179                	addi	sp,sp,-48
 3000e10:	d622                	sw	s0,44(sp)
 3000e12:	1800                	addi	s0,sp,48
 3000e14:	fca42e23          	sw	a0,-36(s0)
 3000e18:	fcb42c23          	sw	a1,-40(s0)
    unsigned int div;
    unsigned int freq = frequency;
 3000e1c:	fdc42783          	lw	a5,-36(s0)
 3000e20:	fef42423          	sw	a5,-24(s0)
    /* Get frequency divider of flash. */
    if (freq < FLASH_BASE_FREQ) {
 3000e24:	fe842703          	lw	a4,-24(s0)
 3000e28:	023c37b7          	lui	a5,0x23c3
 3000e2c:	45f78793          	addi	a5,a5,1119 # 23c345f <RAM_CODE_START+0x3c345f>
 3000e30:	00e7e863          	bltu	a5,a4,3000e40 <SetFlashDiv+0x32>
        freq = FLASH_BASE_FREQ;
 3000e34:	023c37b7          	lui	a5,0x23c3
 3000e38:	46078793          	addi	a5,a5,1120 # 23c3460 <RAM_CODE_START+0x3c3460>
 3000e3c:	fef42423          	sw	a5,-24(s0)
    }
    /* Get the flash frequency division based on the frequency. */
    if ((freq % FLASH_BASE_FREQ) == 0) {
 3000e40:	fe842703          	lw	a4,-24(s0)
 3000e44:	023c37b7          	lui	a5,0x23c3
 3000e48:	46078793          	addi	a5,a5,1120 # 23c3460 <RAM_CODE_START+0x3c3460>
 3000e4c:	02f777b3          	remu	a5,a4,a5
 3000e50:	ef81                	bnez	a5,3000e68 <SetFlashDiv+0x5a>
        div = freq / FLASH_BASE_FREQ;
 3000e52:	fe842703          	lw	a4,-24(s0)
 3000e56:	023c37b7          	lui	a5,0x23c3
 3000e5a:	46078793          	addi	a5,a5,1120 # 23c3460 <RAM_CODE_START+0x3c3460>
 3000e5e:	02f757b3          	divu	a5,a4,a5
 3000e62:	fef42623          	sw	a5,-20(s0)
 3000e66:	a821                	j	3000e7e <SetFlashDiv+0x70>
    } else {
        div = (freq / FLASH_BASE_FREQ) + 1;
 3000e68:	fe842703          	lw	a4,-24(s0)
 3000e6c:	023c37b7          	lui	a5,0x23c3
 3000e70:	46078793          	addi	a5,a5,1120 # 23c3460 <RAM_CODE_START+0x3c3460>
 3000e74:	02f757b3          	divu	a5,a4,a5
 3000e78:	0785                	addi	a5,a5,1
 3000e7a:	fef42623          	sw	a5,-20(s0)
    }
    /* Ensure the flash frequency division is valid. */
    if (div > FLASH_MAX_DIV) {
 3000e7e:	fec42703          	lw	a4,-20(s0)
 3000e82:	4791                	li	a5,4
 3000e84:	00e7f563          	bgeu	a5,a4,3000e8e <SetFlashDiv+0x80>
        div = FLASH_MAX_DIV;
 3000e88:	4791                	li	a5,4
 3000e8a:	fef42623          	sw	a5,-20(s0)
    }
    *nreadDiv = div;
 3000e8e:	fd842783          	lw	a5,-40(s0)
 3000e92:	fec42703          	lw	a4,-20(s0)
 3000e96:	c398                	sw	a4,0(a5)
}
 3000e98:	0001                	nop
 3000e9a:	5432                	lw	s0,44(sp)
 3000e9c:	6145                	addi	sp,sp,48
 3000e9e:	8082                	ret

03000ea0 <GetFlashFreq>:
 * @brief Get the Rounding up value
 * @param coreClkSelect Core Clock select
 * @retval Frequency of Flash
 */
static unsigned int GetFlashFreq(CRG_CoreClkSelect coreClkSelect)
{
 3000ea0:	7179                	addi	sp,sp,-48
 3000ea2:	d606                	sw	ra,44(sp)
 3000ea4:	d422                	sw	s0,40(sp)
 3000ea6:	1800                	addi	s0,sp,48
 3000ea8:	fca42e23          	sw	a0,-36(s0)
    unsigned int hclk;
    /* Get frequency of flash. */
    switch (coreClkSelect) {
 3000eac:	fdc42783          	lw	a5,-36(s0)
 3000eb0:	4705                	li	a4,1
 3000eb2:	02e78063          	beq	a5,a4,3000ed2 <GetFlashFreq+0x32>
 3000eb6:	4705                	li	a4,1
 3000eb8:	00e7e663          	bltu	a5,a4,3000ec4 <GetFlashFreq+0x24>
 3000ebc:	4709                	li	a4,2
 3000ebe:	02e78163          	beq	a5,a4,3000ee0 <GetFlashFreq+0x40>
 3000ec2:	a025                	j	3000eea <GetFlashFreq+0x4a>
        case CRG_CORE_CLK_SELECT_HOSC:
            hclk = HOSC_FREQ;
 3000ec4:	017d87b7          	lui	a5,0x17d8
 3000ec8:	84078793          	addi	a5,a5,-1984 # 17d7840 <FLASH_SIZE+0x17b7844>
 3000ecc:	fef42623          	sw	a5,-20(s0)
            break;
 3000ed0:	a01d                	j	3000ef6 <GetFlashFreq+0x56>
        case CRG_CORE_CLK_SELECT_TCXO:
            hclk = XTRAIL_FREQ;
 3000ed2:	01c9c7b7          	lui	a5,0x1c9c
 3000ed6:	38078793          	addi	a5,a5,896 # 1c9c380 <FLASH_SIZE+0x1c7c384>
 3000eda:	fef42623          	sw	a5,-20(s0)
            break;
 3000ede:	a821                	j	3000ef6 <GetFlashFreq+0x56>
        case CRG_CORE_CLK_SELECT_PLL:
            hclk = HAL_CRG_GetPllFreq();
 3000ee0:	73b030ef          	jal	ra,3004e1a <HAL_CRG_GetPllFreq>
 3000ee4:	fea42623          	sw	a0,-20(s0)
            break;
 3000ee8:	a039                	j	3000ef6 <GetFlashFreq+0x56>
        default:
            hclk = LOSC_FREQ;
 3000eea:	67a1                	lui	a5,0x8
 3000eec:	d0078793          	addi	a5,a5,-768 # 7d00 <RAM_SIZE+0x2d00>
 3000ef0:	fef42623          	sw	a5,-20(s0)
            break;
 3000ef4:	0001                	nop
    }
    return hclk;
 3000ef6:	fec42783          	lw	a5,-20(s0)
}
 3000efa:	853e                	mv	a0,a5
 3000efc:	50b2                	lw	ra,44(sp)
 3000efe:	5422                	lw	s0,40(sp)
 3000f00:	6145                	addi	sp,sp,48
 3000f02:	8082                	ret

03000f04 <FLASH_ClockConfig>:
 * @brief Set flash clock frequence base on hclk
 * @param coreClkSelect core clock select
 * @retval None
 */
void FLASH_ClockConfig(CRG_CoreClkSelect coreClkSelect)
{
 3000f04:	7179                	addi	sp,sp,-48
 3000f06:	d606                	sw	ra,44(sp)
 3000f08:	d422                	sw	s0,40(sp)
 3000f0a:	1800                	addi	s0,sp,48
 3000f0c:	fca42e23          	sw	a0,-36(s0)
    EFC_RegStruct *efc = EFC;
 3000f10:	147107b7          	lui	a5,0x14710
 3000f14:	fef42623          	sw	a5,-20(s0)
    EFLASH_CLK_CFG_REG cfg;
    unsigned int hclk;
    unsigned int nreadDiv;

    /* Step 1: Set nread_div */
    hclk = GetFlashFreq(coreClkSelect);
 3000f18:	fdc42503          	lw	a0,-36(s0)
 3000f1c:	3751                	jal	ra,3000ea0 <GetFlashFreq>
 3000f1e:	fea42423          	sw	a0,-24(s0)
    cfg.reg = efc->EFLASH_CLK_CFG.reg;
 3000f22:	fec42703          	lw	a4,-20(s0)
 3000f26:	6785                	lui	a5,0x1
 3000f28:	97ba                	add	a5,a5,a4
 3000f2a:	9407a783          	lw	a5,-1728(a5) # 940 <cipri+0x153>
 3000f2e:	fef42223          	sw	a5,-28(s0)
    SetFlashDiv(hclk, &nreadDiv);
 3000f32:	fe040793          	addi	a5,s0,-32
 3000f36:	85be                	mv	a1,a5
 3000f38:	fe842503          	lw	a0,-24(s0)
 3000f3c:	3dc9                	jal	ra,3000e0e <SetFlashDiv>
    cfg.BIT.nread_div = nreadDiv;
 3000f3e:	fe042783          	lw	a5,-32(s0)
 3000f42:	8bbd                	andi	a5,a5,15
 3000f44:	0ff7f713          	andi	a4,a5,255
 3000f48:	fe442783          	lw	a5,-28(s0)
 3000f4c:	8b3d                	andi	a4,a4,15
 3000f4e:	0712                	slli	a4,a4,0x4
 3000f50:	f0f7f793          	andi	a5,a5,-241
 3000f54:	8fd9                	or	a5,a5,a4
 3000f56:	fef42223          	sw	a5,-28(s0)
    cfg.BIT.busclk_sw_req = BASE_CFG_SET;
 3000f5a:	fe442783          	lw	a5,-28(s0)
 3000f5e:	00100737          	lui	a4,0x100
 3000f62:	8fd9                	or	a5,a5,a4
 3000f64:	fef42223          	sw	a5,-28(s0)
    cfg.BIT.cur_read_vref_cal = BASE_CFG_SET;
 3000f68:	fe442783          	lw	a5,-28(s0)
 3000f6c:	00400737          	lui	a4,0x400
 3000f70:	8fd9                	or	a5,a5,a4
 3000f72:	fef42223          	sw	a5,-28(s0)

    /* Step 2: Wait Busclk_sw_req */
    cfg.BIT.cur_read_vref_cal = BASE_CFG_SET;
 3000f76:	fe442783          	lw	a5,-28(s0)
 3000f7a:	00400737          	lui	a4,0x400
 3000f7e:	8fd9                	or	a5,a5,a4
 3000f80:	fef42223          	sw	a5,-28(s0)
    cfg.BIT.busclk_sw_req = BASE_CFG_SET;
 3000f84:	fe442783          	lw	a5,-28(s0)
 3000f88:	00100737          	lui	a4,0x100
 3000f8c:	8fd9                	or	a5,a5,a4
 3000f8e:	fef42223          	sw	a5,-28(s0)
    efc->EFLASH_CLK_CFG.reg = cfg.reg;
 3000f92:	fe442703          	lw	a4,-28(s0)
 3000f96:	fec42683          	lw	a3,-20(s0)
 3000f9a:	6785                	lui	a5,0x1
 3000f9c:	97b6                	add	a5,a5,a3
 3000f9e:	94e7a023          	sw	a4,-1728(a5) # 940 <cipri+0x153>
    while (efc->EFLASH_CLK_CFG.BIT.busclk_sw_req == BASE_CFG_SET) {
 3000fa2:	0001                	nop
 3000fa4:	fec42703          	lw	a4,-20(s0)
 3000fa8:	6785                	lui	a5,0x1
 3000faa:	97ba                	add	a5,a5,a4
 3000fac:	9407a783          	lw	a5,-1728(a5) # 940 <cipri+0x153>
 3000fb0:	83d1                	srli	a5,a5,0x14
 3000fb2:	8b85                	andi	a5,a5,1
 3000fb4:	0ff7f713          	andi	a4,a5,255
 3000fb8:	4785                	li	a5,1
 3000fba:	fef705e3          	beq	a4,a5,3000fa4 <FLASH_ClockConfig+0xa0>
        ;
    }
 3000fbe:	0001                	nop
 3000fc0:	50b2                	lw	ra,44(sp)
 3000fc2:	5422                	lw	s0,40(sp)
 3000fc4:	6145                	addi	sp,sp,48
 3000fc6:	8082                	ret

03000fc8 <SYSTICK_Init>:
  * @brief   Init the systick
  * @param   None
  * @retval  None
  */
void SYSTICK_Init(void)
{
 3000fc8:	1141                	addi	sp,sp,-16
 3000fca:	c622                	sw	s0,12(sp)
 3000fcc:	0800                	addi	s0,sp,16
    SYSTICK->TIMER_CTRL.reg = 0;
 3000fce:	143807b7          	lui	a5,0x14380
 3000fd2:	0007a023          	sw	zero,0(a5) # 14380000 <RAM_END+0x10378000>
    SYSTICK->TIMER_CTRL.BIT.enable = 1;
 3000fd6:	14380737          	lui	a4,0x14380
 3000fda:	431c                	lw	a5,0(a4)
 3000fdc:	0017e793          	ori	a5,a5,1
 3000fe0:	c31c                	sw	a5,0(a4)
}
 3000fe2:	0001                	nop
 3000fe4:	4432                	lw	s0,12(sp)
 3000fe6:	0141                	addi	sp,sp,16
 3000fe8:	8082                	ret

03000fea <SYSTICK_GetCRGHZ>:
  * @brief   Get the Systick frep(Hz)
  * @param   None
  * @retval  Clock frep of systick(Hz)
  */
unsigned int SYSTICK_GetCRGHZ(void)
{
 3000fea:	1141                	addi	sp,sp,-16
 3000fec:	c606                	sw	ra,12(sp)
 3000fee:	c422                	sw	s0,8(sp)
 3000ff0:	0800                	addi	s0,sp,16
    /* Get the Systick IP */
    return HAL_CRG_GetIpFreq(SYSTICK_BASE);
 3000ff2:	14380537          	lui	a0,0x14380
 3000ff6:	721030ef          	jal	ra,3004f16 <HAL_CRG_GetIpFreq>
 3000ffa:	87aa                	mv	a5,a0
 3000ffc:	853e                	mv	a0,a5
 3000ffe:	40b2                	lw	ra,12(sp)
 3001000:	4422                	lw	s0,8(sp)
 3001002:	0141                	addi	sp,sp,16
 3001004:	8082                	ret

03001006 <FOTP_CheckReadStatus>:
  * @param efc  Flash control register base address
  * @retval BASE_STATUS_ERROR fail.
  * @retval BASE_STATUS_OK success.
  */
static unsigned int FOTP_CheckReadStatus(EFC_RegStruct *efc)
{
 3001006:	1101                	addi	sp,sp,-32
 3001008:	ce22                	sw	s0,28(sp)
 300100a:	1000                	addi	s0,sp,32
 300100c:	fea42623          	sw	a0,-20(s0)
    /* Check for errors in the flash reading process. */
    if (efc->INT_RAW_STATUS.BIT.int_raw_err_illegal ||
 3001010:	fec42783          	lw	a5,-20(s0)
 3001014:	1007a783          	lw	a5,256(a5)
 3001018:	83c1                	srli	a5,a5,0x10
 300101a:	8b85                	andi	a5,a5,1
 300101c:	9f81                	uxtb	a5
 300101e:	e38d                	bnez	a5,3001040 <FOTP_CheckReadStatus+0x3a>
        efc->INT_RAW_STATUS.BIT.int_raw_err_ecc_corr ||
 3001020:	fec42783          	lw	a5,-20(s0)
 3001024:	1007a783          	lw	a5,256(a5)
 3001028:	83cd                	srli	a5,a5,0x13
 300102a:	8b85                	andi	a5,a5,1
 300102c:	9f81                	uxtb	a5
    if (efc->INT_RAW_STATUS.BIT.int_raw_err_illegal ||
 300102e:	eb89                	bnez	a5,3001040 <FOTP_CheckReadStatus+0x3a>
        efc->INT_RAW_STATUS.BIT.int_raw_err_ecc_chk) {
 3001030:	fec42783          	lw	a5,-20(s0)
 3001034:	1007a783          	lw	a5,256(a5)
 3001038:	83d1                	srli	a5,a5,0x14
 300103a:	8b85                	andi	a5,a5,1
 300103c:	9f81                	uxtb	a5
        efc->INT_RAW_STATUS.BIT.int_raw_err_ecc_corr ||
 300103e:	c3a9                	beqz	a5,3001080 <FOTP_CheckReadStatus+0x7a>
        efc->INT_CLEAR.BIT.int_clr_err_ecc_corr = BASE_CFG_SET;
 3001040:	fec42703          	lw	a4,-20(s0)
 3001044:	10c72783          	lw	a5,268(a4) # 1438010c <RAM_END+0x1037810c>
 3001048:	000806b7          	lui	a3,0x80
 300104c:	8fd5                	or	a5,a5,a3
 300104e:	10f72623          	sw	a5,268(a4)
        efc->INT_CLEAR.BIT.int_clr_err_illegal = BASE_CFG_SET;
 3001052:	fec42703          	lw	a4,-20(s0)
 3001056:	10c72783          	lw	a5,268(a4)
 300105a:	66c1                	lui	a3,0x10
 300105c:	8fd5                	or	a5,a5,a3
 300105e:	10f72623          	sw	a5,268(a4)
        efc->INT_CLEAR.BIT.int_clr_err_ecc_chk = BASE_CFG_SET;
 3001062:	fec42703          	lw	a4,-20(s0)
 3001066:	10c72783          	lw	a5,268(a4)
 300106a:	001006b7          	lui	a3,0x100
 300106e:	8fd5                	or	a5,a5,a3
 3001070:	10f72623          	sw	a5,268(a4)
        efc->MAGIC_LOCK = FLASH_KEY_REGISTER_LOCK_VALUE;
 3001074:	fec42783          	lw	a5,-20(s0)
 3001078:	2007a023          	sw	zero,512(a5)
        return BASE_STATUS_ERROR;
 300107c:	4785                	li	a5,1
 300107e:	a011                	j	3001082 <FOTP_CheckReadStatus+0x7c>
    }
    return BASE_STATUS_OK;
 3001080:	4781                	li	a5,0
}
 3001082:	853e                	mv	a0,a5
 3001084:	4472                	lw	s0,28(sp)
 3001086:	6105                	addi	sp,sp,32
 3001088:	8082                	ret

0300108a <FOTP_InfoGet>:
  * @param buf   Buffer of read data
  * @retval BASE_STATUS_ERROR fail.
  * @retval BASE_STATUS_OK success.
  */
unsigned int FOTP_InfoGet(FOTP_InfoRngType type, unsigned int index, FOTP_CommonData *buf)
{
 300108a:	7179                	addi	sp,sp,-48
 300108c:	d606                	sw	ra,44(sp)
 300108e:	d422                	sw	s0,40(sp)
 3001090:	1800                	addi	s0,sp,48
 3001092:	fca42e23          	sw	a0,-36(s0)
 3001096:	fcb42c23          	sw	a1,-40(s0)
 300109a:	fcc42a23          	sw	a2,-44(s0)
    EFC_RegStruct *p = EFC;
 300109e:	147107b7          	lui	a5,0x14710
 30010a2:	fef42423          	sw	a5,-24(s0)
    unsigned int addr;

    if (buf == NULL) {
 30010a6:	fd442783          	lw	a5,-44(s0)
 30010aa:	e399                	bnez	a5,30010b0 <FOTP_InfoGet+0x26>
        return BASE_STATUS_ERROR;
 30010ac:	4785                	li	a5,1
 30010ae:	aa15                	j	30011e2 <FOTP_InfoGet+0x158>
    }
    
    if ((type >= FOTP_INFO_MAXTYPE) || (index > FOTP_INFO_REG_MAX_ID)) {
 30010b0:	fdc42703          	lw	a4,-36(s0)
 30010b4:	4785                	li	a5,1
 30010b6:	00e7e763          	bltu	a5,a4,30010c4 <FOTP_InfoGet+0x3a>
 30010ba:	fd842703          	lw	a4,-40(s0)
 30010be:	47e5                	li	a5,25
 30010c0:	00e7f463          	bgeu	a5,a4,30010c8 <FOTP_InfoGet+0x3e>
        return BASE_STATUS_ERROR;
 30010c4:	4785                	li	a5,1
 30010c6:	aa31                	j	30011e2 <FOTP_InfoGet+0x158>
    }

    /* If there is a read command, return */
    if (p->EFLASH_CMD.BIT.cmd_start) {
 30010c8:	fe842783          	lw	a5,-24(s0)
 30010cc:	439c                	lw	a5,0(a5)
 30010ce:	8b85                	andi	a5,a5,1
 30010d0:	9f81                	uxtb	a5
 30010d2:	c399                	beqz	a5,30010d8 <FOTP_InfoGet+0x4e>
        return BASE_STATUS_ERROR;
 30010d4:	4785                	li	a5,1
 30010d6:	a231                	j	30011e2 <FOTP_InfoGet+0x158>
    }

    p->MAGIC_LOCK = FLASH_KEY_REGISTER_UNLOCK_VALUE;
 30010d8:	fe842783          	lw	a5,-24(s0)
 30010dc:	fedcc737          	lui	a4,0xfedcc
 30010e0:	a9870713          	addi	a4,a4,-1384 # fedcba98 <RAM_END+0xfadc3a98>
 30010e4:	20e7a023          	sw	a4,512(a5) # 14710200 <RAM_END+0x10708200>

    /* Configure the read command parameters and start the read command */
    addr = (type == FOTP_INFO_RNG0) ? FOTP_INFO_RNG0_BASEADDR : FOTP_INFO_RNG1_BASEADDR;
 30010e8:	fdc42783          	lw	a5,-36(s0)
 30010ec:	e781                	bnez	a5,30010f4 <FOTP_InfoGet+0x6a>
 30010ee:	008007b7          	lui	a5,0x800
 30010f2:	a019                	j	30010f8 <FOTP_InfoGet+0x6e>
 30010f4:	008017b7          	lui	a5,0x801
 30010f8:	fef42223          	sw	a5,-28(s0)
    addr += index * REG_WORDS_NUM;
 30010fc:	fd842783          	lw	a5,-40(s0)
 3001100:	0792                	slli	a5,a5,0x4
 3001102:	fe442703          	lw	a4,-28(s0)
 3001106:	97ba                	add	a5,a5,a4
 3001108:	fef42223          	sw	a5,-28(s0)
    p->EFLASH_ADDR.BIT.cmd_addr = addr >> 2; /* Right shift 2 bit change to word */
 300110c:	fe442783          	lw	a5,-28(s0)
 3001110:	0027d713          	srli	a4,a5,0x2
 3001114:	004007b7          	lui	a5,0x400
 3001118:	17fd                	addi	a5,a5,-1 # 3fffff <FLASH_SIZE+0x3e0003>
 300111a:	00f77633          	and	a2,a4,a5
 300111e:	fe842703          	lw	a4,-24(s0)
 3001122:	435c                	lw	a5,4(a4)
 3001124:	004006b7          	lui	a3,0x400
 3001128:	16fd                	addi	a3,a3,-1 # 3fffff <FLASH_SIZE+0x3e0003>
 300112a:	8ef1                	and	a3,a3,a2
 300112c:	068a                	slli	a3,a3,0x2
 300112e:	ff000637          	lui	a2,0xff000
 3001132:	060d                	addi	a2,a2,3 # ff000003 <RAM_END+0xfaff8003>
 3001134:	8ff1                	and	a5,a5,a2
 3001136:	8fd5                	or	a5,a5,a3
 3001138:	c35c                	sw	a5,4(a4)
    p->EFLASH_CMD.BIT.cmd_code = FLASH_OPERATION_READ;
 300113a:	fe842703          	lw	a4,-24(s0)
 300113e:	431c                	lw	a5,0(a4)
 3001140:	8ff7f793          	andi	a5,a5,-1793
 3001144:	1007e793          	ori	a5,a5,256
 3001148:	c31c                	sw	a5,0(a4)
    p->EFLASH_CMD.BIT.cmd_read_size = FLASH_READ_128BIT;
 300114a:	fe842703          	lw	a4,-24(s0)
 300114e:	431c                	lw	a5,0(a4)
 3001150:	d00006b7          	lui	a3,0xd0000
 3001154:	16fd                	addi	a3,a3,-1 # cfffffff <RAM_END+0xcbff7fff>
 3001156:	8efd                	and	a3,a3,a5
 3001158:	100007b7          	lui	a5,0x10000
 300115c:	8fd5                	or	a5,a5,a3
 300115e:	c31c                	sw	a5,0(a4)
    p->EFLASH_CMD.BIT.cmd_start = BASE_CFG_SET;
 3001160:	fe842703          	lw	a4,-24(s0)
 3001164:	431c                	lw	a5,0(a4)
 3001166:	0017e793          	ori	a5,a5,1
 300116a:	c31c                	sw	a5,0(a4)

    while (p->EFLASH_CMD.BIT.cmd_start) {
 300116c:	0001                	nop
 300116e:	fe842783          	lw	a5,-24(s0)
 3001172:	439c                	lw	a5,0(a5)
 3001174:	8b85                	andi	a5,a5,1
 3001176:	9f81                	uxtb	a5
 3001178:	fbfd                	bnez	a5,300116e <FOTP_InfoGet+0xe4>
        ;
    }
    while (p->EFLASH_CMD.BIT.exec_state) {
 300117a:	0001                	nop
 300117c:	fe842783          	lw	a5,-24(s0)
 3001180:	439c                	lw	a5,0(a5)
 3001182:	8399                	srli	a5,a5,0x6
 3001184:	8b8d                	andi	a5,a5,3
 3001186:	9f81                	uxtb	a5
 3001188:	fbf5                	bnez	a5,300117c <FOTP_InfoGet+0xf2>
        ;
    }
    /* read error, clear interrupt and return */
    if (FOTP_CheckReadStatus(p) != BASE_STATUS_OK) {
 300118a:	fe842503          	lw	a0,-24(s0)
 300118e:	3da5                	jal	ra,3001006 <FOTP_CheckReadStatus>
 3001190:	87aa                	mv	a5,a0
 3001192:	c399                	beqz	a5,3001198 <FOTP_InfoGet+0x10e>
        return BASE_STATUS_ERROR;
 3001194:	4785                	li	a5,1
 3001196:	a0b1                	j	30011e2 <FOTP_InfoGet+0x158>
    }
    /* Read data from FIFO to buffer */
    for (unsigned int i = 0; i < sizeof(buf->data) / sizeof(buf->data[0]); ++i) {
 3001198:	fe042623          	sw	zero,-20(s0)
 300119c:	a00d                	j	30011be <FOTP_InfoGet+0x134>
        buf->data[i] = p->FLASH_RDATA;
 300119e:	fe842783          	lw	a5,-24(s0)
 30011a2:	6007a703          	lw	a4,1536(a5) # 10000600 <RAM_END+0xbff8600>
 30011a6:	fd442683          	lw	a3,-44(s0)
 30011aa:	fec42783          	lw	a5,-20(s0)
 30011ae:	078a                	slli	a5,a5,0x2
 30011b0:	97b6                	add	a5,a5,a3
 30011b2:	c398                	sw	a4,0(a5)
    for (unsigned int i = 0; i < sizeof(buf->data) / sizeof(buf->data[0]); ++i) {
 30011b4:	fec42783          	lw	a5,-20(s0)
 30011b8:	0785                	addi	a5,a5,1
 30011ba:	fef42623          	sw	a5,-20(s0)
 30011be:	fec42703          	lw	a4,-20(s0)
 30011c2:	478d                	li	a5,3
 30011c4:	fce7fde3          	bgeu	a5,a4,300119e <FOTP_InfoGet+0x114>
    }
    p->INT_CLEAR.BIT.int_clr_finish = BASE_CFG_SET;
 30011c8:	fe842703          	lw	a4,-24(s0)
 30011cc:	10c72783          	lw	a5,268(a4)
 30011d0:	0107e793          	ori	a5,a5,16
 30011d4:	10f72623          	sw	a5,268(a4)
    p->MAGIC_LOCK = FLASH_KEY_REGISTER_LOCK_VALUE;
 30011d8:	fe842783          	lw	a5,-24(s0)
 30011dc:	2007a023          	sw	zero,512(a5)
    return BASE_STATUS_OK;
 30011e0:	4781                	li	a5,0
 30011e2:	853e                	mv	a0,a5
 30011e4:	50b2                	lw	ra,44(sp)
 30011e6:	5422                	lw	s0,40(sp)
 30011e8:	6145                	addi	sp,sp,48
 30011ea:	8082                	ret

030011ec <GetCrgIpMatchInfo>:
  * @param baseAddr The ip base address
  * @retval The Address(offset) in g_crgIpMatch if match success
  * @retval 0 if match fail
  */
CHIP_CrgIpMatchInfo *GetCrgIpMatchInfo(const void *baseAddr)
{
 30011ec:	7179                	addi	sp,sp,-48
 30011ee:	d622                	sw	s0,44(sp)
 30011f0:	1800                	addi	s0,sp,48
 30011f2:	fca42e23          	sw	a0,-36(s0)
    unsigned int i;
    for (i = 0; i < sizeof(g_crgIpMatch) / sizeof(g_crgIpMatch[0]); ++i) {
 30011f6:	fe042623          	sw	zero,-20(s0)
 30011fa:	a081                	j	300123a <GetCrgIpMatchInfo+0x4e>
        if (baseAddr == g_crgIpMatch[i].ipBaseAddr) {
 30011fc:	030127b7          	lui	a5,0x3012
 3001200:	89878713          	addi	a4,a5,-1896 # 3011898 <g_crgIpMatch>
 3001204:	fec42683          	lw	a3,-20(s0)
 3001208:	47b1                	li	a5,12
 300120a:	02f687b3          	mul	a5,a3,a5
 300120e:	97ba                	add	a5,a5,a4
 3001210:	439c                	lw	a5,0(a5)
 3001212:	fdc42703          	lw	a4,-36(s0)
 3001216:	00f71d63          	bne	a4,a5,3001230 <GetCrgIpMatchInfo+0x44>
            return (CHIP_CrgIpMatchInfo *)&g_crgIpMatch[i];
 300121a:	fec42703          	lw	a4,-20(s0)
 300121e:	47b1                	li	a5,12
 3001220:	02f70733          	mul	a4,a4,a5
 3001224:	030127b7          	lui	a5,0x3012
 3001228:	89878793          	addi	a5,a5,-1896 # 3011898 <g_crgIpMatch>
 300122c:	97ba                	add	a5,a5,a4
 300122e:	a829                	j	3001248 <GetCrgIpMatchInfo+0x5c>
    for (i = 0; i < sizeof(g_crgIpMatch) / sizeof(g_crgIpMatch[0]); ++i) {
 3001230:	fec42783          	lw	a5,-20(s0)
 3001234:	0785                	addi	a5,a5,1
 3001236:	fef42623          	sw	a5,-20(s0)
 300123a:	fec42703          	lw	a4,-20(s0)
 300123e:	02d00793          	li	a5,45
 3001242:	fae7fde3          	bgeu	a5,a4,30011fc <GetCrgIpMatchInfo+0x10>
        }
    }
    return (CHIP_CrgIpMatchInfo *)0; /* The base address does not match, return 0. */
 3001246:	4781                	li	a5,0
}
 3001248:	853e                	mv	a0,a5
 300124a:	5432                	lw	s0,44(sp)
 300124c:	6145                	addi	sp,sp,48
 300124e:	8082                	ret

03001250 <IsADCSampleChannel>:
 * @brief Check ADC sample input.
 * @param input Number of input.
 * @retval bool
 */
static inline bool IsADCSampleChannel(ADC_Input input)
{
 3001250:	1101                	addi	sp,sp,-32
 3001252:	ce22                	sw	s0,28(sp)
 3001254:	1000                	addi	s0,sp,32
 3001256:	fea42623          	sw	a0,-20(s0)
    return (input >= ADC_CH_ADCINA0) && (input <= ADC_CH_ADCINA19);
 300125a:	fec42783          	lw	a5,-20(s0)
 300125e:	0147b793          	sltiu	a5,a5,20
 3001262:	9f81                	uxtb	a5
}
 3001264:	853e                	mv	a0,a5
 3001266:	4472                	lw	s0,28(sp)
 3001268:	6105                	addi	sp,sp,32
 300126a:	8082                	ret

0300126c <IsADCSOCx>:
 * are configured through the SOC.
 * @param soc Number of SOC.
 * @retval bool
 */
static inline bool IsADCSOCx(ADC_SOCNumber soc)
{
 300126c:	1101                	addi	sp,sp,-32
 300126e:	ce22                	sw	s0,28(sp)
 3001270:	1000                	addi	s0,sp,32
 3001272:	fea42623          	sw	a0,-20(s0)
    return (soc >= ADC_SOC_NUM0) && (soc <= ADC_SOC_NUM15);
 3001276:	fec42783          	lw	a5,-20(s0)
 300127a:	0107b793          	sltiu	a5,a5,16
 300127e:	9f81                	uxtb	a5
}
 3001280:	853e                	mv	a0,a5
 3001282:	4472                	lw	s0,28(sp)
 3001284:	6105                	addi	sp,sp,32
 3001286:	8082                	ret

03001288 <IsADCTrigSource>:
 * @brief Check SOC trigger source.
 * @param trig Type of trigger source.
 * @retval bool
 */
static inline bool IsADCTrigSource(ADC_TrigSource trig)
{
 3001288:	1101                	addi	sp,sp,-32
 300128a:	ce22                	sw	s0,28(sp)
 300128c:	1000                	addi	s0,sp,32
 300128e:	fea42623          	sw	a0,-20(s0)
    return (trig >= ADC_TRIGSOC_SOFT) && (trig <= ADC_TRIGSOC_GPIOPF1);
 3001292:	fec42783          	lw	a5,-20(s0)
 3001296:	0157b793          	sltiu	a5,a5,21
 300129a:	9f81                	uxtb	a5
}
 300129c:	853e                	mv	a0,a5
 300129e:	4472                	lw	s0,28(sp)
 30012a0:	6105                	addi	sp,sp,32
 30012a2:	8082                	ret

030012a4 <IsADCFinishMode>:
 * @brief Check mode of completion of SOC sample
 * @param mode Type of completion.
 * @retval bool
 */
static inline bool IsADCFinishMode(ADC_SOCFinishMode mode)
{
 30012a4:	1101                	addi	sp,sp,-32
 30012a6:	ce22                	sw	s0,28(sp)
 30012a8:	1000                	addi	s0,sp,32
 30012aa:	fea42623          	sw	a0,-20(s0)
    return (mode >= ADC_SOCFINISH_NONE) && (mode <= ADC_SOCFINISH_INT3);
 30012ae:	fec42783          	lw	a5,-20(s0)
 30012b2:	cb81                	beqz	a5,30012c2 <IsADCFinishMode+0x1e>
 30012b4:	fec42703          	lw	a4,-20(s0)
 30012b8:	4799                	li	a5,6
 30012ba:	00e7e463          	bltu	a5,a4,30012c2 <IsADCFinishMode+0x1e>
 30012be:	4785                	li	a5,1
 30012c0:	a011                	j	30012c4 <IsADCFinishMode+0x20>
 30012c2:	4781                	li	a5,0
 30012c4:	8b85                	andi	a5,a5,1
 30012c6:	9f81                	uxtb	a5
}
 30012c8:	853e                	mv	a0,a5
 30012ca:	4472                	lw	s0,28(sp)
 30012cc:	6105                	addi	sp,sp,32
 30012ce:	8082                	ret

030012d0 <IsADCPriorityMode>:
 * @brief Check ADC sample priority parameter.
 * @param mode Priority mode of SOC.
 * @retval bool
 */
static inline bool IsADCPriorityMode(ADC_PriorityMode mode)
{
 30012d0:	1101                	addi	sp,sp,-32
 30012d2:	ce22                	sw	s0,28(sp)
 30012d4:	1000                	addi	s0,sp,32
 30012d6:	fea42623          	sw	a0,-20(s0)
    return (mode >= ADC_PRIMODE_ALL_ROUND) && (mode <= ADC_PRIMODE_ALL_PRIORITY);
 30012da:	fec42703          	lw	a4,-20(s0)
 30012de:	67c1                	lui	a5,0x10
 30012e0:	00f737b3          	sltu	a5,a4,a5
 30012e4:	9f81                	uxtb	a5
}
 30012e6:	853e                	mv	a0,a5
 30012e8:	4472                	lw	s0,28(sp)
 30012ea:	6105                	addi	sp,sp,32
 30012ec:	8082                	ret

030012ee <IsADCTotalTime>:
 * @brief Check time of total ADC sampling time.
 * @param acqps Time of total ADC sampling time.
 * @retval bool
 */
static inline bool IsADCTotalTime(unsigned int acqps)
{
 30012ee:	1101                	addi	sp,sp,-32
 30012f0:	ce22                	sw	s0,28(sp)
 30012f2:	1000                	addi	s0,sp,32
 30012f4:	fea42623          	sw	a0,-20(s0)
    return (acqps <= ADC_SOCSAMPLE_500CLK);
 30012f8:	fec42783          	lw	a5,-20(s0)
 30012fc:	0107b793          	sltiu	a5,a5,16
 3001300:	9f81                	uxtb	a5
}
 3001302:	853e                	mv	a0,a5
 3001304:	4472                	lw	s0,28(sp)
 3001306:	6105                	addi	sp,sp,32
 3001308:	8082                	ret

0300130a <ADC_GetCTRLAddr>:
 * @param adcx ADC register base address.
 * @param socx Number of SOC, @ref ADC_SOCNumber.
 * @retval addr, the base address of the SOC registers.
 */
static unsigned int ADC_GetCTRLAddr(ADC_RegStruct * const adcx, ADC_SOCNumber socx)
{
 300130a:	7179                	addi	sp,sp,-48
 300130c:	d622                	sw	s0,44(sp)
 300130e:	1800                	addi	s0,sp,48
 3001310:	fca42e23          	sw	a0,-36(s0)
 3001314:	fcb42c23          	sw	a1,-40(s0)
    unsigned int addr;
    addr = (uintptr_t)(void *)&(adcx->ADC_SOC0_CFG);
 3001318:	fdc42783          	lw	a5,-36(s0)
 300131c:	10078793          	addi	a5,a5,256 # 10100 <RAM_SIZE+0xb100>
 3001320:	fef42623          	sw	a5,-20(s0)
    addr += ((unsigned int)socx * 4); /* Register base address difference 4 */
 3001324:	fd842783          	lw	a5,-40(s0)
 3001328:	078a                	slli	a5,a5,0x2
 300132a:	fec42703          	lw	a4,-20(s0)
 300132e:	97ba                	add	a5,a5,a4
 3001330:	fef42623          	sw	a5,-20(s0)
    return addr;
 3001334:	fec42783          	lw	a5,-20(s0)
}
 3001338:	853e                	mv	a0,a5
 300133a:	5432                	lw	s0,44(sp)
 300133c:	6145                	addi	sp,sp,48
 300133e:	8082                	ret

03001340 <DCL_ADC_SOCxSelcetChannel>:
 * @param socx Number of SOC, @ref ADC_SOCNumber.
 * @param input ADC input, @ref ADC_Input.
 * @retval None.
 */
static inline void DCL_ADC_SOCxSelcetChannel(ADC_RegStruct * const adcx, ADC_SOCNumber socx, ADC_Input input)
{
 3001340:	7179                	addi	sp,sp,-48
 3001342:	d606                	sw	ra,44(sp)
 3001344:	d422                	sw	s0,40(sp)
 3001346:	1800                	addi	s0,sp,48
 3001348:	fca42e23          	sw	a0,-36(s0)
 300134c:	fcb42c23          	sw	a1,-40(s0)
 3001350:	fcc42a23          	sw	a2,-44(s0)
    ADC_ASSERT_PARAM(IsADCInstance(adcx));
 3001354:	fdc42703          	lw	a4,-36(s0)
 3001358:	180007b7          	lui	a5,0x18000
 300135c:	00f70b63          	beq	a4,a5,3001372 <DCL_ADC_SOCxSelcetChannel+0x32>
 3001360:	6785                	lui	a5,0x1
 3001362:	8fa78593          	addi	a1,a5,-1798 # 8fa <cipri+0x10d>
 3001366:	030127b7          	lui	a5,0x3012
 300136a:	ac078513          	addi	a0,a5,-1344 # 3011ac0 <g_crgIpMatch+0x228>
 300136e:	2349                	jal	ra,30018f0 <AssertErrorLog.trans.0>
 3001370:	a001                	j	3001370 <DCL_ADC_SOCxSelcetChannel+0x30>
    ADC_PARAM_CHECK_NO_RET(IsADCSOCx(socx) && IsADCSampleChannel(input));
 3001372:	fd842503          	lw	a0,-40(s0)
 3001376:	3ddd                	jal	ra,300126c <IsADCSOCx>
 3001378:	87aa                	mv	a5,a0
 300137a:	0017c793          	xori	a5,a5,1
 300137e:	9f81                	uxtb	a5
 3001380:	eb89                	bnez	a5,3001392 <DCL_ADC_SOCxSelcetChannel+0x52>
 3001382:	fd442503          	lw	a0,-44(s0)
 3001386:	35e9                	jal	ra,3001250 <IsADCSampleChannel>
 3001388:	87aa                	mv	a5,a0
 300138a:	0017c793          	xori	a5,a5,1
 300138e:	9f81                	uxtb	a5
 3001390:	cb91                	beqz	a5,30013a4 <DCL_ADC_SOCxSelcetChannel+0x64>
 3001392:	6785                	lui	a5,0x1
 3001394:	8fb78593          	addi	a1,a5,-1797 # 8fb <cipri+0x10e>
 3001398:	030127b7          	lui	a5,0x3012
 300139c:	ac078513          	addi	a0,a5,-1344 # 3011ac0 <g_crgIpMatch+0x228>
 30013a0:	2b81                	jal	ra,30018f0 <AssertErrorLog.trans.0>
 30013a2:	a815                	j	30013d6 <DCL_ADC_SOCxSelcetChannel+0x96>
    ADC_SOC0_CFG_REG *soc = NULL;
 30013a4:	fe042623          	sw	zero,-20(s0)
    unsigned int addr = ADC_GetCTRLAddr(adcx, socx); /* Get the Address After Translation */
 30013a8:	fd842583          	lw	a1,-40(s0)
 30013ac:	fdc42503          	lw	a0,-36(s0)
 30013b0:	3fa9                	jal	ra,300130a <ADC_GetCTRLAddr>
 30013b2:	fea42423          	sw	a0,-24(s0)
    soc = (ADC_SOC0_CFG_REG *)(void *)(uintptr_t)addr;
 30013b6:	fe842783          	lw	a5,-24(s0)
 30013ba:	fef42623          	sw	a5,-20(s0)
    soc->BIT.cfg_soc0_ch_sel = (unsigned int)input;
 30013be:	fd442783          	lw	a5,-44(s0)
 30013c2:	8bfd                	andi	a5,a5,31
 30013c4:	0ff7f693          	andi	a3,a5,255
 30013c8:	fec42703          	lw	a4,-20(s0)
 30013cc:	431c                	lw	a5,0(a4)
 30013ce:	8afd                	andi	a3,a3,31
 30013d0:	9b81                	andi	a5,a5,-32
 30013d2:	8fd5                	or	a5,a5,a3
 30013d4:	c31c                	sw	a5,0(a4)
}
 30013d6:	50b2                	lw	ra,44(sp)
 30013d8:	5422                	lw	s0,40(sp)
 30013da:	6145                	addi	sp,sp,48
 30013dc:	8082                	ret

030013de <DCL_ADC_SOCxSelcetTrigSource>:
 * @param socx Number of SOC, @ref ADC_SOCNumber.
 * @param trig Source of trigger, @ref ADC_TrigSource.
 * @retval None.
 */
static inline void DCL_ADC_SOCxSelcetTrigSource(ADC_RegStruct * const adcx, ADC_SOCNumber socx, ADC_TrigSource trig)
{
 30013de:	7179                	addi	sp,sp,-48
 30013e0:	d606                	sw	ra,44(sp)
 30013e2:	d422                	sw	s0,40(sp)
 30013e4:	1800                	addi	s0,sp,48
 30013e6:	fca42e23          	sw	a0,-36(s0)
 30013ea:	fcb42c23          	sw	a1,-40(s0)
 30013ee:	fcc42a23          	sw	a2,-44(s0)
    ADC_ASSERT_PARAM(IsADCInstance(adcx));
 30013f2:	fdc42703          	lw	a4,-36(s0)
 30013f6:	180007b7          	lui	a5,0x18000
 30013fa:	00f70b63          	beq	a4,a5,3001410 <DCL_ADC_SOCxSelcetTrigSource+0x32>
 30013fe:	6785                	lui	a5,0x1
 3001400:	90b78593          	addi	a1,a5,-1781 # 90b <cipri+0x11e>
 3001404:	030127b7          	lui	a5,0x3012
 3001408:	ac078513          	addi	a0,a5,-1344 # 3011ac0 <g_crgIpMatch+0x228>
 300140c:	21d5                	jal	ra,30018f0 <AssertErrorLog.trans.0>
 300140e:	a001                	j	300140e <DCL_ADC_SOCxSelcetTrigSource+0x30>
    ADC_PARAM_CHECK_NO_RET(IsADCSOCx(socx) && IsADCTrigSource(trig));
 3001410:	fd842503          	lw	a0,-40(s0)
 3001414:	3da1                	jal	ra,300126c <IsADCSOCx>
 3001416:	87aa                	mv	a5,a0
 3001418:	0017c793          	xori	a5,a5,1
 300141c:	9f81                	uxtb	a5
 300141e:	eb89                	bnez	a5,3001430 <DCL_ADC_SOCxSelcetTrigSource+0x52>
 3001420:	fd442503          	lw	a0,-44(s0)
 3001424:	3595                	jal	ra,3001288 <IsADCTrigSource>
 3001426:	87aa                	mv	a5,a0
 3001428:	0017c793          	xori	a5,a5,1
 300142c:	9f81                	uxtb	a5
 300142e:	cb91                	beqz	a5,3001442 <DCL_ADC_SOCxSelcetTrigSource+0x64>
 3001430:	6785                	lui	a5,0x1
 3001432:	90c78593          	addi	a1,a5,-1780 # 90c <cipri+0x11f>
 3001436:	030127b7          	lui	a5,0x3012
 300143a:	ac078513          	addi	a0,a5,-1344 # 3011ac0 <g_crgIpMatch+0x228>
 300143e:	294d                	jal	ra,30018f0 <AssertErrorLog.trans.0>
 3001440:	a835                	j	300147c <DCL_ADC_SOCxSelcetTrigSource+0x9e>
    unsigned int addr = ADC_GetCTRLAddr(adcx, socx); /* Obtaining the Address for Configuring the SOC */
 3001442:	fd842583          	lw	a1,-40(s0)
 3001446:	fdc42503          	lw	a0,-36(s0)
 300144a:	35c1                	jal	ra,300130a <ADC_GetCTRLAddr>
 300144c:	fea42623          	sw	a0,-20(s0)
    ADC_SOC0_CFG_REG *soc = NULL;
 3001450:	fe042423          	sw	zero,-24(s0)
    soc = (ADC_SOC0_CFG_REG *)(void *)(uintptr_t)addr;
 3001454:	fec42783          	lw	a5,-20(s0)
 3001458:	fef42423          	sw	a5,-24(s0)
    soc->BIT.cfg_soc0_trig_sel = (unsigned int)trig;
 300145c:	fd442783          	lw	a5,-44(s0)
 3001460:	8bfd                	andi	a5,a5,31
 3001462:	0ff7f693          	andi	a3,a5,255
 3001466:	fe842703          	lw	a4,-24(s0)
 300146a:	431c                	lw	a5,0(a4)
 300146c:	8afd                	andi	a3,a3,31
 300146e:	06a6                	slli	a3,a3,0x9
 3001470:	7671                	lui	a2,0xffffc
 3001472:	1ff60613          	addi	a2,a2,511 # ffffc1ff <RAM_END+0xfbff41ff>
 3001476:	8ff1                	and	a5,a5,a2
 3001478:	8fd5                	or	a5,a5,a3
 300147a:	c31c                	sw	a5,0(a4)
}
 300147c:	50b2                	lw	ra,44(sp)
 300147e:	5422                	lw	s0,40(sp)
 3001480:	6145                	addi	sp,sp,48
 3001482:	8082                	ret

03001484 <DCL_ADC_SOCxSetAcqps>:
 * @param socx Number of SOC, @ref ADC_SOCNumber.
 * @param acqps Capacitor charging time.
 * @retval None.
 */
static inline void DCL_ADC_SOCxSetAcqps(ADC_RegStruct * const adcx, ADC_SOCNumber socx, unsigned int acqps)
{
 3001484:	7179                	addi	sp,sp,-48
 3001486:	d606                	sw	ra,44(sp)
 3001488:	d422                	sw	s0,40(sp)
 300148a:	1800                	addi	s0,sp,48
 300148c:	fca42e23          	sw	a0,-36(s0)
 3001490:	fcb42c23          	sw	a1,-40(s0)
 3001494:	fcc42a23          	sw	a2,-44(s0)
    ADC_ASSERT_PARAM(IsADCInstance(adcx));
 3001498:	fdc42703          	lw	a4,-36(s0)
 300149c:	180007b7          	lui	a5,0x18000
 30014a0:	00f70b63          	beq	a4,a5,30014b6 <DCL_ADC_SOCxSetAcqps+0x32>
 30014a4:	6785                	lui	a5,0x1
 30014a6:	91c78593          	addi	a1,a5,-1764 # 91c <cipri+0x12f>
 30014aa:	030127b7          	lui	a5,0x3012
 30014ae:	ac078513          	addi	a0,a5,-1344 # 3011ac0 <g_crgIpMatch+0x228>
 30014b2:	293d                	jal	ra,30018f0 <AssertErrorLog.trans.0>
 30014b4:	a001                	j	30014b4 <DCL_ADC_SOCxSetAcqps+0x30>
    ADC_PARAM_CHECK_NO_RET(IsADCSOCx(socx));
 30014b6:	fd842503          	lw	a0,-40(s0)
 30014ba:	3b4d                	jal	ra,300126c <IsADCSOCx>
 30014bc:	87aa                	mv	a5,a0
 30014be:	0017c793          	xori	a5,a5,1
 30014c2:	9f81                	uxtb	a5
 30014c4:	cb91                	beqz	a5,30014d8 <DCL_ADC_SOCxSetAcqps+0x54>
 30014c6:	6785                	lui	a5,0x1
 30014c8:	91d78593          	addi	a1,a5,-1763 # 91d <cipri+0x130>
 30014cc:	030127b7          	lui	a5,0x3012
 30014d0:	ac078513          	addi	a0,a5,-1344 # 3011ac0 <g_crgIpMatch+0x228>
 30014d4:	2931                	jal	ra,30018f0 <AssertErrorLog.trans.0>
 30014d6:	a891                	j	300152a <DCL_ADC_SOCxSetAcqps+0xa6>
    ADC_PARAM_CHECK_NO_RET(acqps <= 15); /* The value of acqps ranges from 0 to 15 */
 30014d8:	fd442703          	lw	a4,-44(s0)
 30014dc:	47bd                	li	a5,15
 30014de:	00e7fb63          	bgeu	a5,a4,30014f4 <DCL_ADC_SOCxSetAcqps+0x70>
 30014e2:	6785                	lui	a5,0x1
 30014e4:	91e78593          	addi	a1,a5,-1762 # 91e <cipri+0x131>
 30014e8:	030127b7          	lui	a5,0x3012
 30014ec:	ac078513          	addi	a0,a5,-1344 # 3011ac0 <g_crgIpMatch+0x228>
 30014f0:	2101                	jal	ra,30018f0 <AssertErrorLog.trans.0>
 30014f2:	a825                	j	300152a <DCL_ADC_SOCxSetAcqps+0xa6>
    unsigned int addr = ADC_GetCTRLAddr(adcx, socx);
 30014f4:	fd842583          	lw	a1,-40(s0)
 30014f8:	fdc42503          	lw	a0,-36(s0)
 30014fc:	3539                	jal	ra,300130a <ADC_GetCTRLAddr>
 30014fe:	fea42623          	sw	a0,-20(s0)
    ADC_SOC0_CFG_REG *soc = NULL;
 3001502:	fe042423          	sw	zero,-24(s0)
    soc = (ADC_SOC0_CFG_REG *)(void *)(uintptr_t)addr;
 3001506:	fec42783          	lw	a5,-20(s0)
 300150a:	fef42423          	sw	a5,-24(s0)
    soc->BIT.cfg_soc0_samptime_sel = acqps;
 300150e:	fd442783          	lw	a5,-44(s0)
 3001512:	8bbd                	andi	a5,a5,15
 3001514:	0ff7f693          	andi	a3,a5,255
 3001518:	fe842703          	lw	a4,-24(s0)
 300151c:	431c                	lw	a5,0(a4)
 300151e:	8abd                	andi	a3,a3,15
 3001520:	0696                	slli	a3,a3,0x5
 3001522:	e1f7f793          	andi	a5,a5,-481
 3001526:	8fd5                	or	a5,a5,a3
 3001528:	c31c                	sw	a5,0(a4)
}
 300152a:	50b2                	lw	ra,44(sp)
 300152c:	5422                	lw	s0,40(sp)
 300152e:	6145                	addi	sp,sp,48
 3001530:	8082                	ret

03001532 <DCL_ADC_SOCxSetPriority>:
 * @param adcx ADC register base address.
 * @param priorityMode Mode of SOC priority, @ref ADC_PriorityMode.
 * @retval None.
 */
static inline void DCL_ADC_SOCxSetPriority(ADC_RegStruct * const adcx, ADC_PriorityMode priorityMode)
{
 3001532:	1101                	addi	sp,sp,-32
 3001534:	ce06                	sw	ra,28(sp)
 3001536:	cc22                	sw	s0,24(sp)
 3001538:	1000                	addi	s0,sp,32
 300153a:	fea42623          	sw	a0,-20(s0)
 300153e:	feb42423          	sw	a1,-24(s0)
    ADC_ASSERT_PARAM(IsADCInstance(adcx));
 3001542:	fec42703          	lw	a4,-20(s0)
 3001546:	180007b7          	lui	a5,0x18000
 300154a:	00f70b63          	beq	a4,a5,3001560 <DCL_ADC_SOCxSetPriority+0x2e>
 300154e:	6785                	lui	a5,0x1
 3001550:	94778593          	addi	a1,a5,-1721 # 947 <cipri+0x15a>
 3001554:	030127b7          	lui	a5,0x3012
 3001558:	ac078513          	addi	a0,a5,-1344 # 3011ac0 <g_crgIpMatch+0x228>
 300155c:	2e51                	jal	ra,30018f0 <AssertErrorLog.trans.0>
 300155e:	a001                	j	300155e <DCL_ADC_SOCxSetPriority+0x2c>
    ADC_PARAM_CHECK_NO_RET(IsADCPriorityMode(priorityMode));
 3001560:	fe842503          	lw	a0,-24(s0)
 3001564:	33b5                	jal	ra,30012d0 <IsADCPriorityMode>
 3001566:	87aa                	mv	a5,a0
 3001568:	0017c793          	xori	a5,a5,1
 300156c:	9f81                	uxtb	a5
 300156e:	cb91                	beqz	a5,3001582 <DCL_ADC_SOCxSetPriority+0x50>
 3001570:	6785                	lui	a5,0x1
 3001572:	94878593          	addi	a1,a5,-1720 # 948 <cipri+0x15b>
 3001576:	030127b7          	lui	a5,0x3012
 300157a:	ac078513          	addi	a0,a5,-1344 # 3011ac0 <g_crgIpMatch+0x228>
 300157e:	2e8d                	jal	ra,30018f0 <AssertErrorLog.trans.0>
 3001580:	a039                	j	300158e <DCL_ADC_SOCxSetPriority+0x5c>
    adcx->ADC_ARBT0.reg = priorityMode;
 3001582:	fec42783          	lw	a5,-20(s0)
 3001586:	fe842703          	lw	a4,-24(s0)
 300158a:	20e7a023          	sw	a4,512(a5)
}
 300158e:	40f2                	lw	ra,28(sp)
 3001590:	4462                	lw	s0,24(sp)
 3001592:	6105                	addi	sp,sp,32
 3001594:	8082                	ret

03001596 <DCL_ADC_EnableSOCxContinue>:
 * @param adcx ADC register base address.
 * @param socx Number of SOC, @ref ADC_SOCNumber.
 * @retval None.
 */
static inline void DCL_ADC_EnableSOCxContinue(ADC_RegStruct * const adcx, ADC_SOCNumber socx)
{
 3001596:	7179                	addi	sp,sp,-48
 3001598:	d606                	sw	ra,44(sp)
 300159a:	d422                	sw	s0,40(sp)
 300159c:	1800                	addi	s0,sp,48
 300159e:	fca42e23          	sw	a0,-36(s0)
 30015a2:	fcb42c23          	sw	a1,-40(s0)
    ADC_ASSERT_PARAM(IsADCInstance(adcx));
 30015a6:	fdc42703          	lw	a4,-36(s0)
 30015aa:	180007b7          	lui	a5,0x18000
 30015ae:	00f70b63          	beq	a4,a5,30015c4 <DCL_ADC_EnableSOCxContinue+0x2e>
 30015b2:	6785                	lui	a5,0x1
 30015b4:	b2178593          	addi	a1,a5,-1247 # b21 <cipri+0x334>
 30015b8:	030127b7          	lui	a5,0x3012
 30015bc:	ac078513          	addi	a0,a5,-1344 # 3011ac0 <g_crgIpMatch+0x228>
 30015c0:	2e05                	jal	ra,30018f0 <AssertErrorLog.trans.0>
 30015c2:	a001                	j	30015c2 <DCL_ADC_EnableSOCxContinue+0x2c>
    ADC_PARAM_CHECK_NO_RET(IsADCSOCx(socx));
 30015c4:	fd842503          	lw	a0,-40(s0)
 30015c8:	3155                	jal	ra,300126c <IsADCSOCx>
 30015ca:	87aa                	mv	a5,a0
 30015cc:	0017c793          	xori	a5,a5,1
 30015d0:	9f81                	uxtb	a5
 30015d2:	cb91                	beqz	a5,30015e6 <DCL_ADC_EnableSOCxContinue+0x50>
 30015d4:	6785                	lui	a5,0x1
 30015d6:	b2278593          	addi	a1,a5,-1246 # b22 <cipri+0x335>
 30015da:	030127b7          	lui	a5,0x3012
 30015de:	ac078513          	addi	a0,a5,-1344 # 3011ac0 <g_crgIpMatch+0x228>
 30015e2:	2639                	jal	ra,30018f0 <AssertErrorLog.trans.0>
 30015e4:	a025                	j	300160c <DCL_ADC_EnableSOCxContinue+0x76>
    unsigned int addr = ADC_GetCTRLAddr(adcx, socx); /* Obtains the SOC base address  */
 30015e6:	fd842583          	lw	a1,-40(s0)
 30015ea:	fdc42503          	lw	a0,-36(s0)
 30015ee:	3b31                	jal	ra,300130a <ADC_GetCTRLAddr>
 30015f0:	fea42623          	sw	a0,-20(s0)
    ADC_SOC0_CFG_REG *soc = NULL;
 30015f4:	fe042423          	sw	zero,-24(s0)
    soc = (ADC_SOC0_CFG_REG *)(void *)(uintptr_t)addr;
 30015f8:	fec42783          	lw	a5,-20(s0)
 30015fc:	fef42423          	sw	a5,-24(s0)
    soc->BIT.cfg_soc0_cont_en = BASE_CFG_ENABLE;
 3001600:	fe842703          	lw	a4,-24(s0)
 3001604:	431c                	lw	a5,0(a4)
 3001606:	6691                	lui	a3,0x4
 3001608:	8fd5                	or	a5,a5,a3
 300160a:	c31c                	sw	a5,0(a4)
}
 300160c:	50b2                	lw	ra,44(sp)
 300160e:	5422                	lw	s0,40(sp)
 3001610:	6145                	addi	sp,sp,48
 3001612:	8082                	ret

03001614 <DCL_ADC_DisableSOCxContinue>:
 * @param adcx ADC register base address.
 * @param socx Number of SOC, @ref ADC_SOCNumber.
 * @retval None.
 */
static inline void DCL_ADC_DisableSOCxContinue(ADC_RegStruct * const adcx, ADC_SOCNumber socx)
{
 3001614:	7179                	addi	sp,sp,-48
 3001616:	d606                	sw	ra,44(sp)
 3001618:	d422                	sw	s0,40(sp)
 300161a:	1800                	addi	s0,sp,48
 300161c:	fca42e23          	sw	a0,-36(s0)
 3001620:	fcb42c23          	sw	a1,-40(s0)
    ADC_ASSERT_PARAM(IsADCInstance(adcx));
 3001624:	fdc42703          	lw	a4,-36(s0)
 3001628:	180007b7          	lui	a5,0x18000
 300162c:	00f70b63          	beq	a4,a5,3001642 <DCL_ADC_DisableSOCxContinue+0x2e>
 3001630:	6785                	lui	a5,0x1
 3001632:	b3178593          	addi	a1,a5,-1231 # b31 <cipri+0x344>
 3001636:	030127b7          	lui	a5,0x3012
 300163a:	ac078513          	addi	a0,a5,-1344 # 3011ac0 <g_crgIpMatch+0x228>
 300163e:	2c4d                	jal	ra,30018f0 <AssertErrorLog.trans.0>
 3001640:	a001                	j	3001640 <DCL_ADC_DisableSOCxContinue+0x2c>
    ADC_PARAM_CHECK_NO_RET(IsADCSOCx(socx));
 3001642:	fd842503          	lw	a0,-40(s0)
 3001646:	311d                	jal	ra,300126c <IsADCSOCx>
 3001648:	87aa                	mv	a5,a0
 300164a:	0017c793          	xori	a5,a5,1
 300164e:	9f81                	uxtb	a5
 3001650:	cb91                	beqz	a5,3001664 <DCL_ADC_DisableSOCxContinue+0x50>
 3001652:	6785                	lui	a5,0x1
 3001654:	b3278593          	addi	a1,a5,-1230 # b32 <cipri+0x345>
 3001658:	030127b7          	lui	a5,0x3012
 300165c:	ac078513          	addi	a0,a5,-1344 # 3011ac0 <g_crgIpMatch+0x228>
 3001660:	2c41                	jal	ra,30018f0 <AssertErrorLog.trans.0>
 3001662:	a02d                	j	300168c <DCL_ADC_DisableSOCxContinue+0x78>
    unsigned int addr = ADC_GetCTRLAddr(adcx, socx); /* Obtains the SOC base address  */
 3001664:	fd842583          	lw	a1,-40(s0)
 3001668:	fdc42503          	lw	a0,-36(s0)
 300166c:	3979                	jal	ra,300130a <ADC_GetCTRLAddr>
 300166e:	fea42623          	sw	a0,-20(s0)
    ADC_SOC0_CFG_REG *soc = NULL;
 3001672:	fe042423          	sw	zero,-24(s0)
    soc = (ADC_SOC0_CFG_REG *)(void *)(uintptr_t)addr;
 3001676:	fec42783          	lw	a5,-20(s0)
 300167a:	fef42423          	sw	a5,-24(s0)
    soc->BIT.cfg_soc0_cont_en = BASE_CFG_DISABLE;
 300167e:	fe842703          	lw	a4,-24(s0)
 3001682:	431c                	lw	a5,0(a4)
 3001684:	76f1                	lui	a3,0xffffc
 3001686:	16fd                	addi	a3,a3,-1 # ffffbfff <RAM_END+0xfbff3fff>
 3001688:	8ff5                	and	a5,a5,a3
 300168a:	c31c                	sw	a5,0(a4)
}
 300168c:	50b2                	lw	ra,44(sp)
 300168e:	5422                	lw	s0,40(sp)
 3001690:	6145                	addi	sp,sp,48
 3001692:	8082                	ret

03001694 <HAL_ADC_Init>:
  * triggered at least 100 us later.
  * @param adcHandle ADC handle.
  * @retval BASE status type: OK, ERROR.
  */
BASE_StatusType HAL_ADC_Init(ADC_Handle *adcHandle)
{
 3001694:	1101                	addi	sp,sp,-32
 3001696:	ce06                	sw	ra,28(sp)
 3001698:	cc22                	sw	s0,24(sp)
 300169a:	1000                	addi	s0,sp,32
 300169c:	fea42623          	sw	a0,-20(s0)
    ADC_ASSERT_PARAM(adcHandle != NULL);
 30016a0:	fec42783          	lw	a5,-20(s0)
 30016a4:	eb89                	bnez	a5,30016b6 <HAL_ADC_Init+0x22>
 30016a6:	02b00593          	li	a1,43
 30016aa:	030127b7          	lui	a5,0x3012
 30016ae:	adc78513          	addi	a0,a5,-1316 # 3011adc <g_crgIpMatch+0x244>
 30016b2:	2c3d                	jal	ra,30018f0 <AssertErrorLog.trans.0>
 30016b4:	a001                	j	30016b4 <HAL_ADC_Init+0x20>
    ADC_ASSERT_PARAM(IsADCInstance(adcHandle->baseAddress));
 30016b6:	fec42783          	lw	a5,-20(s0)
 30016ba:	4398                	lw	a4,0(a5)
 30016bc:	180007b7          	lui	a5,0x18000
 30016c0:	00f70a63          	beq	a4,a5,30016d4 <HAL_ADC_Init+0x40>
 30016c4:	02c00593          	li	a1,44
 30016c8:	030127b7          	lui	a5,0x3012
 30016cc:	adc78513          	addi	a0,a5,-1316 # 3011adc <g_crgIpMatch+0x244>
 30016d0:	2405                	jal	ra,30018f0 <AssertErrorLog.trans.0>
 30016d2:	a001                	j	30016d2 <HAL_ADC_Init+0x3e>
    ADC_PARAM_CHECK_WITH_RET(IsADCPriorityMode(adcHandle->socPriority) == true, BASE_STATUS_ERROR);
 30016d4:	fec42783          	lw	a5,-20(s0)
 30016d8:	43dc                	lw	a5,4(a5)
 30016da:	853e                	mv	a0,a5
 30016dc:	3ed5                	jal	ra,30012d0 <IsADCPriorityMode>
 30016de:	87aa                	mv	a5,a0
 30016e0:	0017c793          	xori	a5,a5,1
 30016e4:	9f81                	uxtb	a5
 30016e6:	cb91                	beqz	a5,30016fa <HAL_ADC_Init+0x66>
 30016e8:	02d00593          	li	a1,45
 30016ec:	030127b7          	lui	a5,0x3012
 30016f0:	adc78513          	addi	a0,a5,-1316 # 3011adc <g_crgIpMatch+0x244>
 30016f4:	2af5                	jal	ra,30018f0 <AssertErrorLog.trans.0>
 30016f6:	4785                	li	a5,1
 30016f8:	a099                	j	300173e <HAL_ADC_Init+0xaa>
    DCL_ADC_SOCxSetPriority(adcHandle->baseAddress, adcHandle->socPriority);
 30016fa:	fec42783          	lw	a5,-20(s0)
 30016fe:	4398                	lw	a4,0(a5)
 3001700:	fec42783          	lw	a5,-20(s0)
 3001704:	43dc                	lw	a5,4(a5)
 3001706:	85be                	mv	a1,a5
 3001708:	853a                	mv	a0,a4
 300170a:	3525                	jal	ra,3001532 <DCL_ADC_SOCxSetPriority>
    adcHandle->baseAddress->ADC_ANA_CTRL0.BIT.cfg_sar_samp_cap_sel = 0x4; /* Set the Number of Sampling Capacitors */
 300170c:	fec42783          	lw	a5,-20(s0)
 3001710:	4398                	lw	a4,0(a5)
 3001712:	65472783          	lw	a5,1620(a4)
 3001716:	100006b7          	lui	a3,0x10000
 300171a:	16fd                	addi	a3,a3,-1 # fffffff <RAM_END+0xbff7fff>
 300171c:	8efd                	and	a3,a3,a5
 300171e:	400007b7          	lui	a5,0x40000
 3001722:	8fd5                	or	a5,a5,a3
 3001724:	64f72a23          	sw	a5,1620(a4)
    adcHandle->baseAddress->ADC_EN.reg = BASE_CFG_ENABLE; /* Enable ADC Controller */
 3001728:	fec42783          	lw	a5,-20(s0)
 300172c:	439c                	lw	a5,0(a5)
 300172e:	4705                	li	a4,1
 3001730:	30e7a023          	sw	a4,768(a5) # 40000300 <RAM_END+0x3bff8300>
    BASE_FUNC_DelayUs(100);  /* Wait for 100 us until the ADC controller is stable */
 3001734:	06400513          	li	a0,100
 3001738:	65c010ef          	jal	ra,3002d94 <BASE_FUNC_DelayUs>
    return BASE_STATUS_OK;
 300173c:	4781                	li	a5,0
}
 300173e:	853e                	mv	a0,a5
 3001740:	40f2                	lw	ra,28(sp)
 3001742:	4462                	lw	s0,24(sp)
 3001744:	6105                	addi	sp,sp,32
 3001746:	8082                	ret

03001748 <HAL_ADC_ConfigureSoc>:
  * @param soc ID of SOC(start of conversion), managing the specific sample inputs.
  * @param socParam Param struct of SOC. This is related to the peripheral circuit design, @ref SOC_Param.
  * @retval BASE status type: OK, ERROR.
  */
BASE_StatusType HAL_ADC_ConfigureSoc(ADC_Handle *adcHandle, ADC_SOCNumber soc, SOC_Param *socParam)
{
 3001748:	1101                	addi	sp,sp,-32
 300174a:	ce06                	sw	ra,28(sp)
 300174c:	cc22                	sw	s0,24(sp)
 300174e:	1000                	addi	s0,sp,32
 3001750:	fea42623          	sw	a0,-20(s0)
 3001754:	feb42423          	sw	a1,-24(s0)
 3001758:	fec42223          	sw	a2,-28(s0)
    ADC_ASSERT_PARAM(adcHandle != NULL);
 300175c:	fec42783          	lw	a5,-20(s0)
 3001760:	eb89                	bnez	a5,3001772 <HAL_ADC_ConfigureSoc+0x2a>
 3001762:	04b00593          	li	a1,75
 3001766:	030127b7          	lui	a5,0x3012
 300176a:	adc78513          	addi	a0,a5,-1316 # 3011adc <g_crgIpMatch+0x244>
 300176e:	2249                	jal	ra,30018f0 <AssertErrorLog.trans.0>
 3001770:	a001                	j	3001770 <HAL_ADC_ConfigureSoc+0x28>
    ADC_ASSERT_PARAM(IsADCInstance(adcHandle->baseAddress));
 3001772:	fec42783          	lw	a5,-20(s0)
 3001776:	4398                	lw	a4,0(a5)
 3001778:	180007b7          	lui	a5,0x18000
 300177c:	00f70a63          	beq	a4,a5,3001790 <HAL_ADC_ConfigureSoc+0x48>
 3001780:	04c00593          	li	a1,76
 3001784:	030127b7          	lui	a5,0x3012
 3001788:	adc78513          	addi	a0,a5,-1316 # 3011adc <g_crgIpMatch+0x244>
 300178c:	2295                	jal	ra,30018f0 <AssertErrorLog.trans.0>
 300178e:	a001                	j	300178e <HAL_ADC_ConfigureSoc+0x46>
    ADC_PARAM_CHECK_WITH_RET(IsADCSOCx(soc) == true, BASE_STATUS_ERROR);
 3001790:	fe842503          	lw	a0,-24(s0)
 3001794:	3ce1                	jal	ra,300126c <IsADCSOCx>
 3001796:	87aa                	mv	a5,a0
 3001798:	0017c793          	xori	a5,a5,1
 300179c:	9f81                	uxtb	a5
 300179e:	cb91                	beqz	a5,30017b2 <HAL_ADC_ConfigureSoc+0x6a>
 30017a0:	04d00593          	li	a1,77
 30017a4:	030127b7          	lui	a5,0x3012
 30017a8:	adc78513          	addi	a0,a5,-1316 # 3011adc <g_crgIpMatch+0x244>
 30017ac:	2291                	jal	ra,30018f0 <AssertErrorLog.trans.0>
 30017ae:	4785                	li	a5,1
 30017b0:	aa1d                	j	30018e6 <HAL_ADC_ConfigureSoc+0x19e>
    ADC_ASSERT_PARAM(socParam != NULL);
 30017b2:	fe442783          	lw	a5,-28(s0)
 30017b6:	eb89                	bnez	a5,30017c8 <HAL_ADC_ConfigureSoc+0x80>
 30017b8:	04e00593          	li	a1,78
 30017bc:	030127b7          	lui	a5,0x3012
 30017c0:	adc78513          	addi	a0,a5,-1316 # 3011adc <g_crgIpMatch+0x244>
 30017c4:	2235                	jal	ra,30018f0 <AssertErrorLog.trans.0>
 30017c6:	a001                	j	30017c6 <HAL_ADC_ConfigureSoc+0x7e>
    ADC_PARAM_CHECK_WITH_RET(IsADCSampleChannel(socParam->adcInput) == true, BASE_STATUS_ERROR);
 30017c8:	fe442783          	lw	a5,-28(s0)
 30017cc:	439c                	lw	a5,0(a5)
 30017ce:	853e                	mv	a0,a5
 30017d0:	3441                	jal	ra,3001250 <IsADCSampleChannel>
 30017d2:	87aa                	mv	a5,a0
 30017d4:	0017c793          	xori	a5,a5,1
 30017d8:	9f81                	uxtb	a5
 30017da:	cb91                	beqz	a5,30017ee <HAL_ADC_ConfigureSoc+0xa6>
 30017dc:	04f00593          	li	a1,79
 30017e0:	030127b7          	lui	a5,0x3012
 30017e4:	adc78513          	addi	a0,a5,-1316 # 3011adc <g_crgIpMatch+0x244>
 30017e8:	2221                	jal	ra,30018f0 <AssertErrorLog.trans.0>
 30017ea:	4785                	li	a5,1
 30017ec:	a8ed                	j	30018e6 <HAL_ADC_ConfigureSoc+0x19e>
    ADC_PARAM_CHECK_WITH_RET(IsADCTotalTime(socParam->sampleTotalTime) == true, BASE_STATUS_ERROR);
 30017ee:	fe442783          	lw	a5,-28(s0)
 30017f2:	43dc                	lw	a5,4(a5)
 30017f4:	853e                	mv	a0,a5
 30017f6:	3ce5                	jal	ra,30012ee <IsADCTotalTime>
 30017f8:	87aa                	mv	a5,a0
 30017fa:	0017c793          	xori	a5,a5,1
 30017fe:	9f81                	uxtb	a5
 3001800:	cb91                	beqz	a5,3001814 <HAL_ADC_ConfigureSoc+0xcc>
 3001802:	05000593          	li	a1,80
 3001806:	030127b7          	lui	a5,0x3012
 300180a:	adc78513          	addi	a0,a5,-1316 # 3011adc <g_crgIpMatch+0x244>
 300180e:	20cd                	jal	ra,30018f0 <AssertErrorLog.trans.0>
 3001810:	4785                	li	a5,1
 3001812:	a8d1                	j	30018e6 <HAL_ADC_ConfigureSoc+0x19e>
    ADC_PARAM_CHECK_WITH_RET(IsADCTrigSource(socParam->trigSource) == true, BASE_STATUS_ERROR);
 3001814:	fe442783          	lw	a5,-28(s0)
 3001818:	479c                	lw	a5,8(a5)
 300181a:	853e                	mv	a0,a5
 300181c:	34b5                	jal	ra,3001288 <IsADCTrigSource>
 300181e:	87aa                	mv	a5,a0
 3001820:	0017c793          	xori	a5,a5,1
 3001824:	9f81                	uxtb	a5
 3001826:	cb91                	beqz	a5,300183a <HAL_ADC_ConfigureSoc+0xf2>
 3001828:	05100593          	li	a1,81
 300182c:	030127b7          	lui	a5,0x3012
 3001830:	adc78513          	addi	a0,a5,-1316 # 3011adc <g_crgIpMatch+0x244>
 3001834:	2875                	jal	ra,30018f0 <AssertErrorLog.trans.0>
 3001836:	4785                	li	a5,1
 3001838:	a07d                	j	30018e6 <HAL_ADC_ConfigureSoc+0x19e>
    ADC_PARAM_CHECK_WITH_RET(IsADCFinishMode(socParam->finishMode) == true, BASE_STATUS_ERROR);
 300183a:	fe442783          	lw	a5,-28(s0)
 300183e:	4b9c                	lw	a5,16(a5)
 3001840:	853e                	mv	a0,a5
 3001842:	348d                	jal	ra,30012a4 <IsADCFinishMode>
 3001844:	87aa                	mv	a5,a0
 3001846:	0017c793          	xori	a5,a5,1
 300184a:	9f81                	uxtb	a5
 300184c:	cb91                	beqz	a5,3001860 <HAL_ADC_ConfigureSoc+0x118>
 300184e:	05200593          	li	a1,82
 3001852:	030127b7          	lui	a5,0x3012
 3001856:	adc78513          	addi	a0,a5,-1316 # 3011adc <g_crgIpMatch+0x244>
 300185a:	2859                	jal	ra,30018f0 <AssertErrorLog.trans.0>
 300185c:	4785                	li	a5,1
 300185e:	a061                	j	30018e6 <HAL_ADC_ConfigureSoc+0x19e>
    DCL_ADC_SOCxSelcetChannel(adcHandle->baseAddress, soc, socParam->adcInput);      /* Set channel */
 3001860:	fec42783          	lw	a5,-20(s0)
 3001864:	4398                	lw	a4,0(a5)
 3001866:	fe442783          	lw	a5,-28(s0)
 300186a:	439c                	lw	a5,0(a5)
 300186c:	863e                	mv	a2,a5
 300186e:	fe842583          	lw	a1,-24(s0)
 3001872:	853a                	mv	a0,a4
 3001874:	34f1                	jal	ra,3001340 <DCL_ADC_SOCxSelcetChannel>
    DCL_ADC_SOCxSetAcqps(adcHandle->baseAddress, soc, socParam->sampleTotalTime);    /* Set sampling time */
 3001876:	fec42783          	lw	a5,-20(s0)
 300187a:	4398                	lw	a4,0(a5)
 300187c:	fe442783          	lw	a5,-28(s0)
 3001880:	43dc                	lw	a5,4(a5)
 3001882:	863e                	mv	a2,a5
 3001884:	fe842583          	lw	a1,-24(s0)
 3001888:	853a                	mv	a0,a4
 300188a:	3eed                	jal	ra,3001484 <DCL_ADC_SOCxSetAcqps>
    DCL_ADC_SOCxSelcetTrigSource(adcHandle->baseAddress, soc, socParam->trigSource); /* Set trigger source */
 300188c:	fec42783          	lw	a5,-20(s0)
 3001890:	4398                	lw	a4,0(a5)
 3001892:	fe442783          	lw	a5,-28(s0)
 3001896:	479c                	lw	a5,8(a5)
 3001898:	863e                	mv	a2,a5
 300189a:	fe842583          	lw	a1,-24(s0)
 300189e:	853a                	mv	a0,a4
 30018a0:	3e3d                	jal	ra,30013de <DCL_ADC_SOCxSelcetTrigSource>
    if (socParam->continueMode == true) { /* Continuous Mode Judgment */
 30018a2:	fe442783          	lw	a5,-28(s0)
 30018a6:	27dc                	lbu	a5,12(a5)
 30018a8:	cb89                	beqz	a5,30018ba <HAL_ADC_ConfigureSoc+0x172>
        DCL_ADC_EnableSOCxContinue(adcHandle->baseAddress, soc);
 30018aa:	fec42783          	lw	a5,-20(s0)
 30018ae:	439c                	lw	a5,0(a5)
 30018b0:	fe842583          	lw	a1,-24(s0)
 30018b4:	853e                	mv	a0,a5
 30018b6:	31c5                	jal	ra,3001596 <DCL_ADC_EnableSOCxContinue>
 30018b8:	a801                	j	30018c8 <HAL_ADC_ConfigureSoc+0x180>
    } else {
        DCL_ADC_DisableSOCxContinue(adcHandle->baseAddress, soc);
 30018ba:	fec42783          	lw	a5,-20(s0)
 30018be:	439c                	lw	a5,0(a5)
 30018c0:	fe842583          	lw	a1,-24(s0)
 30018c4:	853e                	mv	a0,a5
 30018c6:	33b9                	jal	ra,3001614 <DCL_ADC_DisableSOCxContinue>
    }
    adcHandle->ADC_SOCxParam[soc].finishMode = socParam->finishMode;
 30018c8:	fe442783          	lw	a5,-28(s0)
 30018cc:	4b9c                	lw	a5,16(a5)
 30018ce:	01079713          	slli	a4,a5,0x10
 30018d2:	8341                	srli	a4,a4,0x10
 30018d4:	fec42683          	lw	a3,-20(s0)
 30018d8:	fe842783          	lw	a5,-24(s0)
 30018dc:	07a1                	addi	a5,a5,8
 30018de:	0786                	slli	a5,a5,0x1
 30018e0:	97b6                	add	a5,a5,a3
 30018e2:	a3da                	sh	a4,4(a5)
    return BASE_STATUS_OK;
 30018e4:	4781                	li	a5,0
}
 30018e6:	853e                	mv	a0,a5
 30018e8:	40f2                	lw	ra,28(sp)
 30018ea:	4462                	lw	s0,24(sp)
 30018ec:	6105                	addi	sp,sp,32
 30018ee:	8082                	ret

030018f0 <AssertErrorLog.trans.0>:
 30018f0:	4620106f          	j	3002d52 <AssertErrorLog>

030018f4 <APT_TimeBaseInit>:
  * @brief Initialize the time-base counter of APT module.
  * @param aptHandle APT module handle.
  * @retval None.
  */
static void APT_TimeBaseInit(APT_Handle *aptHandle)
{
 30018f4:	1101                	addi	sp,sp,-32
 30018f6:	ce22                	sw	s0,28(sp)
 30018f8:	1000                	addi	s0,sp,32
 30018fa:	fea42623          	sw	a0,-20(s0)
    aptHandle->baseAddress->TC_MODE.BIT.rg_cnt_mode = aptHandle->waveform.cntMode;
 30018fe:	fec42783          	lw	a5,-20(s0)
 3001902:	4b94                	lw	a3,16(a5)
 3001904:	fec42783          	lw	a5,-20(s0)
 3001908:	4398                	lw	a4,0(a5)
 300190a:	87b6                	mv	a5,a3
 300190c:	8b8d                	andi	a5,a5,3
 300190e:	0ff7f693          	andi	a3,a5,255
 3001912:	4b1c                	lw	a5,16(a4)
 3001914:	8a8d                	andi	a3,a3,3
 3001916:	9bf1                	andi	a5,a5,-4
 3001918:	8fd5                	or	a5,a5,a3
 300191a:	cb1c                	sw	a5,16(a4)
    aptHandle->baseAddress->TC_MODE.BIT.rg_div_fac = aptHandle->waveform.dividerFactor;
 300191c:	fec42783          	lw	a5,-20(s0)
 3001920:	2bd6                	lhu	a3,20(a5)
 3001922:	fec42783          	lw	a5,-20(s0)
 3001926:	4398                	lw	a4,0(a5)
 3001928:	6785                	lui	a5,0x1
 300192a:	17fd                	addi	a5,a5,-1 # fff <prithd+0x401>
 300192c:	8ff5                	and	a5,a5,a3
 300192e:	01079613          	slli	a2,a5,0x10
 3001932:	8241                	srli	a2,a2,0x10
 3001934:	4b1c                	lw	a5,16(a4)
 3001936:	6685                	lui	a3,0x1
 3001938:	16fd                	addi	a3,a3,-1 # fff <prithd+0x401>
 300193a:	8ef1                	and	a3,a3,a2
 300193c:	06c2                	slli	a3,a3,0x10
 300193e:	f0010637          	lui	a2,0xf0010
 3001942:	167d                	addi	a2,a2,-1 # f000ffff <RAM_END+0xec007fff>
 3001944:	8ff1                	and	a5,a5,a2
 3001946:	8fd5                	or	a5,a5,a3
 3001948:	cb1c                	sw	a5,16(a4)
    /* Disable buffer mode of TC_PRD */
    aptHandle->baseAddress->TC_BUF_EN.reg &= (~(0b11 << 0));
 300194a:	fec42783          	lw	a5,-20(s0)
 300194e:	439c                	lw	a5,0(a5)
 3001950:	4bb8                	lw	a4,80(a5)
 3001952:	fec42783          	lw	a5,-20(s0)
 3001956:	439c                	lw	a5,0(a5)
 3001958:	9b71                	andi	a4,a4,-4
 300195a:	cbb8                	sw	a4,80(a5)
    aptHandle->baseAddress->TC_PRD.BIT.rg_cnt_prd = aptHandle->waveform.timerPeriod;
 300195c:	fec42783          	lw	a5,-20(s0)
 3001960:	4398                	lw	a4,0(a5)
 3001962:	fec42783          	lw	a5,-20(s0)
 3001966:	2bf2                	lhu	a2,22(a5)
 3001968:	531c                	lw	a5,32(a4)
 300196a:	66c1                	lui	a3,0x10
 300196c:	16fd                	addi	a3,a3,-1 # ffff <RAM_SIZE+0xafff>
 300196e:	8ef1                	and	a3,a3,a2
 3001970:	7641                	lui	a2,0xffff0
 3001972:	8ff1                	and	a5,a5,a2
 3001974:	8fd5                	or	a5,a5,a3
 3001976:	d31c                	sw	a5,32(a4)
    /* Set the override value of divier and timebase counter */
    aptHandle->baseAddress->TC_OVRID.BIT.rg_cnt_ovrid = aptHandle->waveform.cntInitVal;
 3001978:	fec42783          	lw	a5,-20(s0)
 300197c:	4398                	lw	a4,0(a5)
 300197e:	fec42783          	lw	a5,-20(s0)
 3001982:	2fb2                	lhu	a2,26(a5)
 3001984:	4f1c                	lw	a5,24(a4)
 3001986:	66c1                	lui	a3,0x10
 3001988:	16fd                	addi	a3,a3,-1 # ffff <RAM_SIZE+0xafff>
 300198a:	8ef1                	and	a3,a3,a2
 300198c:	7641                	lui	a2,0xffff0
 300198e:	8ff1                	and	a5,a5,a2
 3001990:	8fd5                	or	a5,a5,a3
 3001992:	cf1c                	sw	a5,24(a4)
    aptHandle->baseAddress->TC_OVRID.BIT.rg_cnt_ovrid_en = 1;
 3001994:	fec42783          	lw	a5,-20(s0)
 3001998:	4398                	lw	a4,0(a5)
 300199a:	4f1c                	lw	a5,24(a4)
 300199c:	800006b7          	lui	a3,0x80000
 30019a0:	8fd5                	or	a5,a5,a3
 30019a2:	cf1c                	sw	a5,24(a4)
}
 30019a4:	0001                	nop
 30019a6:	4472                	lw	s0,28(sp)
 30019a8:	6105                	addi	sp,sp,32
 30019aa:	8082                	ret

030019ac <APT_SetPWMCompareVal>:
  * @brief Initialize the count compare points for PWM waveform generation.
  * @param aptHandle APT module handle.
  * @retval None.
  */
static void APT_SetPWMCompareVal(APT_Handle *aptHandle)
{
 30019ac:	7179                	addi	sp,sp,-48
 30019ae:	d622                	sw	s0,44(sp)
 30019b0:	1800                	addi	s0,sp,48
 30019b2:	fca42e23          	sw	a0,-36(s0)
    /* Configure the compare point along the left and right edges of PWM waveform */
    TC_REFC_REG tmpC;
    TC_REFD_REG tmpD;
    /* Set the value of the active register of CMPC and CMPD */
    tmpC = aptHandle->baseAddress->TC_REFC;
 30019b6:	fdc42783          	lw	a5,-36(s0)
 30019ba:	439c                	lw	a5,0(a5)
 30019bc:	5f9c                	lw	a5,56(a5)
 30019be:	fef42223          	sw	a5,-28(s0)
    tmpC.BIT.rg_cnt_refc = aptHandle->waveform.cntCmpLeftEdge;
 30019c2:	fdc42783          	lw	a5,-36(s0)
 30019c6:	2fd6                	lhu	a3,28(a5)
 30019c8:	fe442783          	lw	a5,-28(s0)
 30019cc:	6741                	lui	a4,0x10
 30019ce:	177d                	addi	a4,a4,-1 # ffff <RAM_SIZE+0xafff>
 30019d0:	8f75                	and	a4,a4,a3
 30019d2:	76c1                	lui	a3,0xffff0
 30019d4:	8ff5                	and	a5,a5,a3
 30019d6:	8fd9                	or	a5,a5,a4
 30019d8:	fef42223          	sw	a5,-28(s0)
    aptHandle->baseAddress->TC_REFC = tmpC;
 30019dc:	fdc42783          	lw	a5,-36(s0)
 30019e0:	439c                	lw	a5,0(a5)
 30019e2:	fe442703          	lw	a4,-28(s0)
 30019e6:	df98                	sw	a4,56(a5)
    tmpD = aptHandle->baseAddress->TC_REFD;
 30019e8:	fdc42783          	lw	a5,-36(s0)
 30019ec:	439c                	lw	a5,0(a5)
 30019ee:	5fdc                	lw	a5,60(a5)
 30019f0:	fef42023          	sw	a5,-32(s0)
    tmpD.BIT.rg_cnt_refd = aptHandle->waveform.cntCmpRightEdge;
 30019f4:	fdc42783          	lw	a5,-36(s0)
 30019f8:	2ff6                	lhu	a3,30(a5)
 30019fa:	fe042783          	lw	a5,-32(s0)
 30019fe:	6741                	lui	a4,0x10
 3001a00:	177d                	addi	a4,a4,-1 # ffff <RAM_SIZE+0xafff>
 3001a02:	8f75                	and	a4,a4,a3
 3001a04:	76c1                	lui	a3,0xffff0
 3001a06:	8ff5                	and	a5,a5,a3
 3001a08:	8fd9                	or	a5,a5,a4
 3001a0a:	fef42023          	sw	a5,-32(s0)
    aptHandle->baseAddress->TC_REFD = tmpD;
 3001a0e:	fdc42783          	lw	a5,-36(s0)
 3001a12:	439c                	lw	a5,0(a5)
 3001a14:	fe042703          	lw	a4,-32(s0)
 3001a18:	dfd8                	sw	a4,60(a5)
    /* Set the buffer load mode of CMPC and CMPD */
    if (aptHandle->waveform.cntCmpLoadMode == APT_BUFFER_DISABLE) {
 3001a1a:	fdc42783          	lw	a5,-36(s0)
 3001a1e:	539c                	lw	a5,32(a5)
 3001a20:	e385                	bnez	a5,3001a40 <APT_SetPWMCompareVal+0x94>
        aptHandle->baseAddress->TC_BUF_EN.BIT.rg_refc_buf_en = 0;
 3001a22:	fdc42783          	lw	a5,-36(s0)
 3001a26:	4398                	lw	a4,0(a5)
 3001a28:	4b3c                	lw	a5,80(a4)
 3001a2a:	eff7f793          	andi	a5,a5,-257
 3001a2e:	cb3c                	sw	a5,80(a4)
        aptHandle->baseAddress->TC_BUF_EN.BIT.rg_refd_buf_en = 0;
 3001a30:	fdc42783          	lw	a5,-36(s0)
 3001a34:	4398                	lw	a4,0(a5)
 3001a36:	4b3c                	lw	a5,80(a4)
 3001a38:	bff7f793          	andi	a5,a5,-1025
 3001a3c:	cb3c                	sw	a5,80(a4)
        aptHandle->baseAddress->TC_REFC = tmpC; /* write back changed data back to register */
        tmpD = aptHandle->baseAddress->TC_REFD; /* read register */
        tmpD.BIT.rg_cnt_refd = aptHandle->waveform.cntCmpRightEdge;
        aptHandle->baseAddress->TC_REFD = tmpD; /* write back changed data back to register */
    }
}
 3001a3e:	a2bd                	j	3001bac <APT_SetPWMCompareVal+0x200>
        aptHandle->baseAddress->TC_BUF_EN.BIT.rg_refc_buf_en = 1;
 3001a40:	fdc42783          	lw	a5,-36(s0)
 3001a44:	4398                	lw	a4,0(a5)
 3001a46:	4b3c                	lw	a5,80(a4)
 3001a48:	1007e793          	ori	a5,a5,256
 3001a4c:	cb3c                	sw	a5,80(a4)
        aptHandle->baseAddress->TC_BUF_EN.BIT.rg_refd_buf_en = 1;
 3001a4e:	fdc42783          	lw	a5,-36(s0)
 3001a52:	4398                	lw	a4,0(a5)
 3001a54:	4b3c                	lw	a5,80(a4)
 3001a56:	4007e793          	ori	a5,a5,1024
 3001a5a:	cb3c                	sw	a5,80(a4)
        unsigned int gldLdEn = (aptHandle->waveform.cntCmpLoadMode == APT_BUFFER_GLOBAL_LOAD) ? 1 : 0;
 3001a5c:	fdc42783          	lw	a5,-36(s0)
 3001a60:	539c                	lw	a5,32(a5)
 3001a62:	17f5                	addi	a5,a5,-3
 3001a64:	0017b793          	seqz	a5,a5
 3001a68:	9f81                	uxtb	a5
 3001a6a:	fef42623          	sw	a5,-20(s0)
        aptHandle->baseAddress->TC_BUF_EN.BIT.rg_refc_gld_en = gldLdEn;
 3001a6e:	fdc42783          	lw	a5,-36(s0)
 3001a72:	4398                	lw	a4,0(a5)
 3001a74:	fec42783          	lw	a5,-20(s0)
 3001a78:	8b85                	andi	a5,a5,1
 3001a7a:	0ff7f693          	andi	a3,a5,255
 3001a7e:	4b3c                	lw	a5,80(a4)
 3001a80:	8a85                	andi	a3,a3,1
 3001a82:	06a6                	slli	a3,a3,0x9
 3001a84:	dff7f793          	andi	a5,a5,-513
 3001a88:	8fd5                	or	a5,a5,a3
 3001a8a:	cb3c                	sw	a5,80(a4)
        aptHandle->baseAddress->TC_BUF_EN.BIT.rg_refd_gld_en = gldLdEn;
 3001a8c:	fdc42783          	lw	a5,-36(s0)
 3001a90:	4398                	lw	a4,0(a5)
 3001a92:	fec42783          	lw	a5,-20(s0)
 3001a96:	8b85                	andi	a5,a5,1
 3001a98:	0ff7f693          	andi	a3,a5,255
 3001a9c:	4b3c                	lw	a5,80(a4)
 3001a9e:	8a85                	andi	a3,a3,1
 3001aa0:	06ae                	slli	a3,a3,0xb
 3001aa2:	767d                	lui	a2,0xfffff
 3001aa4:	7ff60613          	addi	a2,a2,2047 # fffff7ff <RAM_END+0xfbff77ff>
 3001aa8:	8ff1                	and	a5,a5,a2
 3001aaa:	8fd5                	or	a5,a5,a3
 3001aac:	cb3c                	sw	a5,80(a4)
        unsigned int refBufField = 8; /* reference buffer field */
 3001aae:	47a1                	li	a5,8
 3001ab0:	fef42423          	sw	a5,-24(s0)
        aptHandle->baseAddress->TC_REF_LOAD.reg &= (~(0x1F << (APT_COMPARE_REFERENCE_C * refBufField)));
 3001ab4:	fdc42783          	lw	a5,-36(s0)
 3001ab8:	439c                	lw	a5,0(a5)
 3001aba:	4fb8                	lw	a4,88(a5)
 3001abc:	fe842783          	lw	a5,-24(s0)
 3001ac0:	0786                	slli	a5,a5,0x1
 3001ac2:	46fd                	li	a3,31
 3001ac4:	00f697b3          	sll	a5,a3,a5
 3001ac8:	fff7c793          	not	a5,a5
 3001acc:	86be                	mv	a3,a5
 3001ace:	fdc42783          	lw	a5,-36(s0)
 3001ad2:	439c                	lw	a5,0(a5)
 3001ad4:	8f75                	and	a4,a4,a3
 3001ad6:	cfb8                	sw	a4,88(a5)
        aptHandle->baseAddress->TC_REF_LOAD.reg &= (~(0x1F << (APT_COMPARE_REFERENCE_D * refBufField)));
 3001ad8:	fdc42783          	lw	a5,-36(s0)
 3001adc:	439c                	lw	a5,0(a5)
 3001ade:	4fb8                	lw	a4,88(a5)
 3001ae0:	fe842683          	lw	a3,-24(s0)
 3001ae4:	478d                	li	a5,3
 3001ae6:	02f687b3          	mul	a5,a3,a5
 3001aea:	46fd                	li	a3,31
 3001aec:	00f697b3          	sll	a5,a3,a5
 3001af0:	fff7c793          	not	a5,a5
 3001af4:	86be                	mv	a3,a5
 3001af6:	fdc42783          	lw	a5,-36(s0)
 3001afa:	439c                	lw	a5,0(a5)
 3001afc:	8f75                	and	a4,a4,a3
 3001afe:	cfb8                	sw	a4,88(a5)
        aptHandle->baseAddress->TC_REF_LOAD.reg |=
 3001b00:	fdc42783          	lw	a5,-36(s0)
 3001b04:	439c                	lw	a5,0(a5)
 3001b06:	4fb4                	lw	a3,88(a5)
            (aptHandle->waveform.cntCmpLoadEvt << (APT_COMPARE_REFERENCE_C * refBufField));
 3001b08:	fdc42783          	lw	a5,-36(s0)
 3001b0c:	53d8                	lw	a4,36(a5)
 3001b0e:	fe842783          	lw	a5,-24(s0)
 3001b12:	0786                	slli	a5,a5,0x1
 3001b14:	00f71733          	sll	a4,a4,a5
        aptHandle->baseAddress->TC_REF_LOAD.reg |=
 3001b18:	fdc42783          	lw	a5,-36(s0)
 3001b1c:	439c                	lw	a5,0(a5)
 3001b1e:	8f55                	or	a4,a4,a3
 3001b20:	cfb8                	sw	a4,88(a5)
        aptHandle->baseAddress->TC_REF_LOAD.reg |=
 3001b22:	fdc42783          	lw	a5,-36(s0)
 3001b26:	439c                	lw	a5,0(a5)
 3001b28:	4fb4                	lw	a3,88(a5)
            (aptHandle->waveform.cntCmpLoadEvt << (APT_COMPARE_REFERENCE_D * refBufField));
 3001b2a:	fdc42783          	lw	a5,-36(s0)
 3001b2e:	53d8                	lw	a4,36(a5)
 3001b30:	fe842603          	lw	a2,-24(s0)
 3001b34:	478d                	li	a5,3
 3001b36:	02f607b3          	mul	a5,a2,a5
 3001b3a:	00f71733          	sll	a4,a4,a5
        aptHandle->baseAddress->TC_REF_LOAD.reg |=
 3001b3e:	fdc42783          	lw	a5,-36(s0)
 3001b42:	439c                	lw	a5,0(a5)
 3001b44:	8f55                	or	a4,a4,a3
 3001b46:	cfb8                	sw	a4,88(a5)
        tmpC = aptHandle->baseAddress->TC_REFC; /* read register */
 3001b48:	fdc42783          	lw	a5,-36(s0)
 3001b4c:	439c                	lw	a5,0(a5)
 3001b4e:	5f9c                	lw	a5,56(a5)
 3001b50:	fef42223          	sw	a5,-28(s0)
        tmpC.BIT.rg_cnt_refc = aptHandle->waveform.cntCmpLeftEdge;
 3001b54:	fdc42783          	lw	a5,-36(s0)
 3001b58:	2fd6                	lhu	a3,28(a5)
 3001b5a:	fe442783          	lw	a5,-28(s0)
 3001b5e:	6741                	lui	a4,0x10
 3001b60:	177d                	addi	a4,a4,-1 # ffff <RAM_SIZE+0xafff>
 3001b62:	8f75                	and	a4,a4,a3
 3001b64:	76c1                	lui	a3,0xffff0
 3001b66:	8ff5                	and	a5,a5,a3
 3001b68:	8fd9                	or	a5,a5,a4
 3001b6a:	fef42223          	sw	a5,-28(s0)
        aptHandle->baseAddress->TC_REFC = tmpC; /* write back changed data back to register */
 3001b6e:	fdc42783          	lw	a5,-36(s0)
 3001b72:	439c                	lw	a5,0(a5)
 3001b74:	fe442703          	lw	a4,-28(s0)
 3001b78:	df98                	sw	a4,56(a5)
        tmpD = aptHandle->baseAddress->TC_REFD; /* read register */
 3001b7a:	fdc42783          	lw	a5,-36(s0)
 3001b7e:	439c                	lw	a5,0(a5)
 3001b80:	5fdc                	lw	a5,60(a5)
 3001b82:	fef42023          	sw	a5,-32(s0)
        tmpD.BIT.rg_cnt_refd = aptHandle->waveform.cntCmpRightEdge;
 3001b86:	fdc42783          	lw	a5,-36(s0)
 3001b8a:	2ff6                	lhu	a3,30(a5)
 3001b8c:	fe042783          	lw	a5,-32(s0)
 3001b90:	6741                	lui	a4,0x10
 3001b92:	177d                	addi	a4,a4,-1 # ffff <RAM_SIZE+0xafff>
 3001b94:	8f75                	and	a4,a4,a3
 3001b96:	76c1                	lui	a3,0xffff0
 3001b98:	8ff5                	and	a5,a5,a3
 3001b9a:	8fd9                	or	a5,a5,a4
 3001b9c:	fef42023          	sw	a5,-32(s0)
        aptHandle->baseAddress->TC_REFD = tmpD; /* write back changed data back to register */
 3001ba0:	fdc42783          	lw	a5,-36(s0)
 3001ba4:	439c                	lw	a5,0(a5)
 3001ba6:	fe042703          	lw	a4,-32(s0)
 3001baa:	dfd8                	sw	a4,60(a5)
}
 3001bac:	0001                	nop
 3001bae:	5432                	lw	s0,44(sp)
 3001bb0:	6145                	addi	sp,sp,48
 3001bb2:	8082                	ret

03001bb4 <APT_SetOutputABasicType>:
  * @param aptHandle APT module handle.
  * @param wavePara PWM waveform parameter.
  * @retval None.
  */
static void APT_SetOutputABasicType(APT_Handle *aptHandle, const APT_WaveformPara *wavePara)
{
 3001bb4:	1101                	addi	sp,sp,-32
 3001bb6:	ce22                	sw	s0,28(sp)
 3001bb8:	1000                	addi	s0,sp,32
 3001bba:	fea42623          	sw	a0,-20(s0)
 3001bbe:	feb42423          	sw	a1,-24(s0)
    switch (aptHandle->waveform.cntMode) {
 3001bc2:	fec42783          	lw	a5,-20(s0)
 3001bc6:	4b9c                	lw	a5,16(a5)
 3001bc8:	4705                	li	a4,1
 3001bca:	06e78363          	beq	a5,a4,3001c30 <APT_SetOutputABasicType+0x7c>
 3001bce:	4705                	li	a4,1
 3001bd0:	00e7e663          	bltu	a5,a4,3001bdc <APT_SetOutputABasicType+0x28>
 3001bd4:	4709                	li	a4,2
 3001bd6:	0ae78763          	beq	a5,a4,3001c84 <APT_SetOutputABasicType+0xd0>
        case APT_COUNT_MODE_UP_DOWN:
            aptHandle->baseAddress->PG_ACT_A.BIT.rg_pga_act_refc_inc = wavePara->leftEdgeActA;
            aptHandle->baseAddress->PG_ACT_A.BIT.rg_pga_act_refd_dec = wavePara->rightEdgeActA;
            break;
        default:
            break;
 3001bda:	a8fd                	j	3001cd8 <APT_SetOutputABasicType+0x124>
            aptHandle->baseAddress->PG_ACT_A.BIT.rg_pga_act_refc_inc = wavePara->leftEdgeActA;
 3001bdc:	fe842783          	lw	a5,-24(s0)
 3001be0:	4394                	lw	a3,0(a5)
 3001be2:	fec42783          	lw	a5,-20(s0)
 3001be6:	4398                	lw	a4,0(a5)
 3001be8:	87b6                	mv	a5,a3
 3001bea:	8b8d                	andi	a5,a5,3
 3001bec:	0ff7f693          	andi	a3,a5,255
 3001bf0:	10072783          	lw	a5,256(a4)
 3001bf4:	8a8d                	andi	a3,a3,3
 3001bf6:	06b2                	slli	a3,a3,0xc
 3001bf8:	7675                	lui	a2,0xffffd
 3001bfa:	167d                	addi	a2,a2,-1 # ffffcfff <RAM_END+0xfbff4fff>
 3001bfc:	8ff1                	and	a5,a5,a2
 3001bfe:	8fd5                	or	a5,a5,a3
 3001c00:	10f72023          	sw	a5,256(a4)
            aptHandle->baseAddress->PG_ACT_A.BIT.rg_pga_act_refd_inc = wavePara->rightEdgeActA;
 3001c04:	fe842783          	lw	a5,-24(s0)
 3001c08:	43d4                	lw	a3,4(a5)
 3001c0a:	fec42783          	lw	a5,-20(s0)
 3001c0e:	4398                	lw	a4,0(a5)
 3001c10:	87b6                	mv	a5,a3
 3001c12:	8b8d                	andi	a5,a5,3
 3001c14:	0ff7f693          	andi	a3,a5,255
 3001c18:	10072783          	lw	a5,256(a4)
 3001c1c:	8a8d                	andi	a3,a3,3
 3001c1e:	06c2                	slli	a3,a3,0x10
 3001c20:	fffd0637          	lui	a2,0xfffd0
 3001c24:	167d                	addi	a2,a2,-1 # fffcffff <RAM_END+0xfbfc7fff>
 3001c26:	8ff1                	and	a5,a5,a2
 3001c28:	8fd5                	or	a5,a5,a3
 3001c2a:	10f72023          	sw	a5,256(a4)
            break;
 3001c2e:	a06d                	j	3001cd8 <APT_SetOutputABasicType+0x124>
            aptHandle->baseAddress->PG_ACT_A.BIT.rg_pga_act_refc_dec = wavePara->rightEdgeActA;
 3001c30:	fe842783          	lw	a5,-24(s0)
 3001c34:	43d4                	lw	a3,4(a5)
 3001c36:	fec42783          	lw	a5,-20(s0)
 3001c3a:	4398                	lw	a4,0(a5)
 3001c3c:	87b6                	mv	a5,a3
 3001c3e:	8b8d                	andi	a5,a5,3
 3001c40:	0ff7f693          	andi	a3,a5,255
 3001c44:	10072783          	lw	a5,256(a4)
 3001c48:	8a8d                	andi	a3,a3,3
 3001c4a:	06ba                	slli	a3,a3,0xe
 3001c4c:	7651                	lui	a2,0xffff4
 3001c4e:	167d                	addi	a2,a2,-1 # ffff3fff <RAM_END+0xfbfebfff>
 3001c50:	8ff1                	and	a5,a5,a2
 3001c52:	8fd5                	or	a5,a5,a3
 3001c54:	10f72023          	sw	a5,256(a4)
            aptHandle->baseAddress->PG_ACT_A.BIT.rg_pga_act_refd_dec = wavePara->leftEdgeActA;
 3001c58:	fe842783          	lw	a5,-24(s0)
 3001c5c:	4394                	lw	a3,0(a5)
 3001c5e:	fec42783          	lw	a5,-20(s0)
 3001c62:	4398                	lw	a4,0(a5)
 3001c64:	87b6                	mv	a5,a3
 3001c66:	8b8d                	andi	a5,a5,3
 3001c68:	0ff7f693          	andi	a3,a5,255
 3001c6c:	10072783          	lw	a5,256(a4)
 3001c70:	8a8d                	andi	a3,a3,3
 3001c72:	06ca                	slli	a3,a3,0x12
 3001c74:	fff40637          	lui	a2,0xfff40
 3001c78:	167d                	addi	a2,a2,-1 # fff3ffff <RAM_END+0xfbf37fff>
 3001c7a:	8ff1                	and	a5,a5,a2
 3001c7c:	8fd5                	or	a5,a5,a3
 3001c7e:	10f72023          	sw	a5,256(a4)
            break;
 3001c82:	a899                	j	3001cd8 <APT_SetOutputABasicType+0x124>
            aptHandle->baseAddress->PG_ACT_A.BIT.rg_pga_act_refc_inc = wavePara->leftEdgeActA;
 3001c84:	fe842783          	lw	a5,-24(s0)
 3001c88:	4394                	lw	a3,0(a5)
 3001c8a:	fec42783          	lw	a5,-20(s0)
 3001c8e:	4398                	lw	a4,0(a5)
 3001c90:	87b6                	mv	a5,a3
 3001c92:	8b8d                	andi	a5,a5,3
 3001c94:	0ff7f693          	andi	a3,a5,255
 3001c98:	10072783          	lw	a5,256(a4)
 3001c9c:	8a8d                	andi	a3,a3,3
 3001c9e:	06b2                	slli	a3,a3,0xc
 3001ca0:	7675                	lui	a2,0xffffd
 3001ca2:	167d                	addi	a2,a2,-1 # ffffcfff <RAM_END+0xfbff4fff>
 3001ca4:	8ff1                	and	a5,a5,a2
 3001ca6:	8fd5                	or	a5,a5,a3
 3001ca8:	10f72023          	sw	a5,256(a4)
            aptHandle->baseAddress->PG_ACT_A.BIT.rg_pga_act_refd_dec = wavePara->rightEdgeActA;
 3001cac:	fe842783          	lw	a5,-24(s0)
 3001cb0:	43d4                	lw	a3,4(a5)
 3001cb2:	fec42783          	lw	a5,-20(s0)
 3001cb6:	4398                	lw	a4,0(a5)
 3001cb8:	87b6                	mv	a5,a3
 3001cba:	8b8d                	andi	a5,a5,3
 3001cbc:	0ff7f693          	andi	a3,a5,255
 3001cc0:	10072783          	lw	a5,256(a4)
 3001cc4:	8a8d                	andi	a3,a3,3
 3001cc6:	06ca                	slli	a3,a3,0x12
 3001cc8:	fff40637          	lui	a2,0xfff40
 3001ccc:	167d                	addi	a2,a2,-1 # fff3ffff <RAM_END+0xfbf37fff>
 3001cce:	8ff1                	and	a5,a5,a2
 3001cd0:	8fd5                	or	a5,a5,a3
 3001cd2:	10f72023          	sw	a5,256(a4)
            break;
 3001cd6:	0001                	nop
    }
    return;
 3001cd8:	0001                	nop
}
 3001cda:	4472                	lw	s0,28(sp)
 3001cdc:	6105                	addi	sp,sp,32
 3001cde:	8082                	ret

03001ce0 <APT_SetOutputBBasicType>:
  * @param aptHandle APT module handle.
  * @param wavePara PWM waveform parameter.
  * @retval None.
  */
static void APT_SetOutputBBasicType(APT_Handle *aptHandle, const APT_WaveformPara *wavePara)
{
 3001ce0:	1101                	addi	sp,sp,-32
 3001ce2:	ce22                	sw	s0,28(sp)
 3001ce4:	1000                	addi	s0,sp,32
 3001ce6:	fea42623          	sw	a0,-20(s0)
 3001cea:	feb42423          	sw	a1,-24(s0)
    switch (aptHandle->waveform.cntMode) {
 3001cee:	fec42783          	lw	a5,-20(s0)
 3001cf2:	4b9c                	lw	a5,16(a5)
 3001cf4:	4705                	li	a4,1
 3001cf6:	06e78363          	beq	a5,a4,3001d5c <APT_SetOutputBBasicType+0x7c>
 3001cfa:	4705                	li	a4,1
 3001cfc:	00e7e663          	bltu	a5,a4,3001d08 <APT_SetOutputBBasicType+0x28>
 3001d00:	4709                	li	a4,2
 3001d02:	0ae78763          	beq	a5,a4,3001db0 <APT_SetOutputBBasicType+0xd0>
        case APT_COUNT_MODE_UP_DOWN:
            aptHandle->baseAddress->PG_ACT_B.BIT.rg_pgb_act_refc_inc = wavePara->leftEdgeActB;
            aptHandle->baseAddress->PG_ACT_B.BIT.rg_pgb_act_refd_dec = wavePara->rightEdgeActB;
            break;
        default:
            break;
 3001d06:	a8fd                	j	3001e04 <APT_SetOutputBBasicType+0x124>
            aptHandle->baseAddress->PG_ACT_B.BIT.rg_pgb_act_refc_inc = wavePara->leftEdgeActB;
 3001d08:	fe842783          	lw	a5,-24(s0)
 3001d0c:	4794                	lw	a3,8(a5)
 3001d0e:	fec42783          	lw	a5,-20(s0)
 3001d12:	4398                	lw	a4,0(a5)
 3001d14:	87b6                	mv	a5,a3
 3001d16:	8b8d                	andi	a5,a5,3
 3001d18:	0ff7f693          	andi	a3,a5,255
 3001d1c:	10472783          	lw	a5,260(a4)
 3001d20:	8a8d                	andi	a3,a3,3
 3001d22:	06b2                	slli	a3,a3,0xc
 3001d24:	7675                	lui	a2,0xffffd
 3001d26:	167d                	addi	a2,a2,-1 # ffffcfff <RAM_END+0xfbff4fff>
 3001d28:	8ff1                	and	a5,a5,a2
 3001d2a:	8fd5                	or	a5,a5,a3
 3001d2c:	10f72223          	sw	a5,260(a4)
            aptHandle->baseAddress->PG_ACT_B.BIT.rg_pgb_act_refd_inc = wavePara->rightEdgeActB;
 3001d30:	fe842783          	lw	a5,-24(s0)
 3001d34:	47d4                	lw	a3,12(a5)
 3001d36:	fec42783          	lw	a5,-20(s0)
 3001d3a:	4398                	lw	a4,0(a5)
 3001d3c:	87b6                	mv	a5,a3
 3001d3e:	8b8d                	andi	a5,a5,3
 3001d40:	0ff7f693          	andi	a3,a5,255
 3001d44:	10472783          	lw	a5,260(a4)
 3001d48:	8a8d                	andi	a3,a3,3
 3001d4a:	06c2                	slli	a3,a3,0x10
 3001d4c:	fffd0637          	lui	a2,0xfffd0
 3001d50:	167d                	addi	a2,a2,-1 # fffcffff <RAM_END+0xfbfc7fff>
 3001d52:	8ff1                	and	a5,a5,a2
 3001d54:	8fd5                	or	a5,a5,a3
 3001d56:	10f72223          	sw	a5,260(a4)
            break;
 3001d5a:	a06d                	j	3001e04 <APT_SetOutputBBasicType+0x124>
            aptHandle->baseAddress->PG_ACT_B.BIT.rg_pgb_act_refc_dec = wavePara->rightEdgeActB;
 3001d5c:	fe842783          	lw	a5,-24(s0)
 3001d60:	47d4                	lw	a3,12(a5)
 3001d62:	fec42783          	lw	a5,-20(s0)
 3001d66:	4398                	lw	a4,0(a5)
 3001d68:	87b6                	mv	a5,a3
 3001d6a:	8b8d                	andi	a5,a5,3
 3001d6c:	0ff7f693          	andi	a3,a5,255
 3001d70:	10472783          	lw	a5,260(a4)
 3001d74:	8a8d                	andi	a3,a3,3
 3001d76:	06ba                	slli	a3,a3,0xe
 3001d78:	7651                	lui	a2,0xffff4
 3001d7a:	167d                	addi	a2,a2,-1 # ffff3fff <RAM_END+0xfbfebfff>
 3001d7c:	8ff1                	and	a5,a5,a2
 3001d7e:	8fd5                	or	a5,a5,a3
 3001d80:	10f72223          	sw	a5,260(a4)
            aptHandle->baseAddress->PG_ACT_B.BIT.rg_pgb_act_refd_dec = wavePara->leftEdgeActB;
 3001d84:	fe842783          	lw	a5,-24(s0)
 3001d88:	4794                	lw	a3,8(a5)
 3001d8a:	fec42783          	lw	a5,-20(s0)
 3001d8e:	4398                	lw	a4,0(a5)
 3001d90:	87b6                	mv	a5,a3
 3001d92:	8b8d                	andi	a5,a5,3
 3001d94:	0ff7f693          	andi	a3,a5,255
 3001d98:	10472783          	lw	a5,260(a4)
 3001d9c:	8a8d                	andi	a3,a3,3
 3001d9e:	06ca                	slli	a3,a3,0x12
 3001da0:	fff40637          	lui	a2,0xfff40
 3001da4:	167d                	addi	a2,a2,-1 # fff3ffff <RAM_END+0xfbf37fff>
 3001da6:	8ff1                	and	a5,a5,a2
 3001da8:	8fd5                	or	a5,a5,a3
 3001daa:	10f72223          	sw	a5,260(a4)
            break;
 3001dae:	a899                	j	3001e04 <APT_SetOutputBBasicType+0x124>
            aptHandle->baseAddress->PG_ACT_B.BIT.rg_pgb_act_refc_inc = wavePara->leftEdgeActB;
 3001db0:	fe842783          	lw	a5,-24(s0)
 3001db4:	4794                	lw	a3,8(a5)
 3001db6:	fec42783          	lw	a5,-20(s0)
 3001dba:	4398                	lw	a4,0(a5)
 3001dbc:	87b6                	mv	a5,a3
 3001dbe:	8b8d                	andi	a5,a5,3
 3001dc0:	0ff7f693          	andi	a3,a5,255
 3001dc4:	10472783          	lw	a5,260(a4)
 3001dc8:	8a8d                	andi	a3,a3,3
 3001dca:	06b2                	slli	a3,a3,0xc
 3001dcc:	7675                	lui	a2,0xffffd
 3001dce:	167d                	addi	a2,a2,-1 # ffffcfff <RAM_END+0xfbff4fff>
 3001dd0:	8ff1                	and	a5,a5,a2
 3001dd2:	8fd5                	or	a5,a5,a3
 3001dd4:	10f72223          	sw	a5,260(a4)
            aptHandle->baseAddress->PG_ACT_B.BIT.rg_pgb_act_refd_dec = wavePara->rightEdgeActB;
 3001dd8:	fe842783          	lw	a5,-24(s0)
 3001ddc:	47d4                	lw	a3,12(a5)
 3001dde:	fec42783          	lw	a5,-20(s0)
 3001de2:	4398                	lw	a4,0(a5)
 3001de4:	87b6                	mv	a5,a3
 3001de6:	8b8d                	andi	a5,a5,3
 3001de8:	0ff7f693          	andi	a3,a5,255
 3001dec:	10472783          	lw	a5,260(a4)
 3001df0:	8a8d                	andi	a3,a3,3
 3001df2:	06ca                	slli	a3,a3,0x12
 3001df4:	fff40637          	lui	a2,0xfff40
 3001df8:	167d                	addi	a2,a2,-1 # fff3ffff <RAM_END+0xfbf37fff>
 3001dfa:	8ff1                	and	a5,a5,a2
 3001dfc:	8fd5                	or	a5,a5,a3
 3001dfe:	10f72223          	sw	a5,260(a4)
            break;
 3001e02:	0001                	nop
    }
    return;
 3001e04:	0001                	nop
}
 3001e06:	4472                	lw	s0,28(sp)
 3001e08:	6105                	addi	sp,sp,32
 3001e0a:	8082                	ret

03001e0c <APT_SetPWMBasicType>:
  * @param aptHandle APT module handle.
  * @param wavePara PWM waveform parameter.
  * @retval None.
  */
static void APT_SetPWMBasicType(APT_Handle *aptHandle, const APT_WaveformPara *wavePara)
{
 3001e0c:	1101                	addi	sp,sp,-32
 3001e0e:	ce06                	sw	ra,28(sp)
 3001e10:	cc22                	sw	s0,24(sp)
 3001e12:	1000                	addi	s0,sp,32
 3001e14:	fea42623          	sw	a0,-20(s0)
 3001e18:	feb42423          	sw	a1,-24(s0)
    /* Configure PWM waveform of PWM channel A */
    if (aptHandle->waveform.chAOutType == APT_PWM_OUT_BASIC_TYPE) {
 3001e1c:	fec42783          	lw	a5,-20(s0)
 3001e20:	479c                	lw	a5,8(a5)
 3001e22:	e791                	bnez	a5,3001e2e <APT_SetPWMBasicType+0x22>
        APT_SetOutputABasicType(aptHandle, wavePara);
 3001e24:	fe842583          	lw	a1,-24(s0)
 3001e28:	fec42503          	lw	a0,-20(s0)
 3001e2c:	3361                	jal	ra,3001bb4 <APT_SetOutputABasicType>
    }
    /* Configure PWM waveform of PWM channel B */
    if (aptHandle->waveform.chBOutType == APT_PWM_OUT_BASIC_TYPE) {
 3001e2e:	fec42783          	lw	a5,-20(s0)
 3001e32:	47dc                	lw	a5,12(a5)
 3001e34:	e791                	bnez	a5,3001e40 <APT_SetPWMBasicType+0x34>
        APT_SetOutputBBasicType(aptHandle, wavePara);
 3001e36:	fe842583          	lw	a1,-24(s0)
 3001e3a:	fec42503          	lw	a0,-20(s0)
 3001e3e:	354d                	jal	ra,3001ce0 <APT_SetOutputBBasicType>
    }
    /* Configure dead band of PWM channel A and channel B */
    if (aptHandle->waveform.chAOutType == APT_PWM_OUT_BASIC_TYPE &&
 3001e40:	fec42783          	lw	a5,-20(s0)
 3001e44:	479c                	lw	a5,8(a5)
 3001e46:	eff1                	bnez	a5,3001f22 <APT_SetPWMBasicType+0x116>
        aptHandle->waveform.chBOutType == APT_PWM_OUT_BASIC_TYPE) {
 3001e48:	fec42783          	lw	a5,-20(s0)
 3001e4c:	47dc                	lw	a5,12(a5)
    if (aptHandle->waveform.chAOutType == APT_PWM_OUT_BASIC_TYPE &&
 3001e4e:	ebf1                	bnez	a5,3001f22 <APT_SetPWMBasicType+0x116>
        aptHandle->baseAddress->DG_CFG.BIT.rg_dg_red_isel = wavePara->redInput;
 3001e50:	fe842783          	lw	a5,-24(s0)
 3001e54:	4b94                	lw	a3,16(a5)
 3001e56:	fec42783          	lw	a5,-20(s0)
 3001e5a:	4398                	lw	a4,0(a5)
 3001e5c:	87b6                	mv	a5,a3
 3001e5e:	8b8d                	andi	a5,a5,3
 3001e60:	0ff7f693          	andi	a3,a5,255
 3001e64:	20872783          	lw	a5,520(a4)
 3001e68:	8a8d                	andi	a3,a3,3
 3001e6a:	9bf1                	andi	a5,a5,-4
 3001e6c:	8fd5                	or	a5,a5,a3
 3001e6e:	20f72423          	sw	a5,520(a4)
        aptHandle->baseAddress->DG_CFG.BIT.rg_dg_red_osel = wavePara->redOutMode;
 3001e72:	fe842783          	lw	a5,-24(s0)
 3001e76:	4bd4                	lw	a3,20(a5)
 3001e78:	fec42783          	lw	a5,-20(s0)
 3001e7c:	4398                	lw	a4,0(a5)
 3001e7e:	87b6                	mv	a5,a3
 3001e80:	8b8d                	andi	a5,a5,3
 3001e82:	0ff7f693          	andi	a3,a5,255
 3001e86:	20872783          	lw	a5,520(a4)
 3001e8a:	8a8d                	andi	a3,a3,3
 3001e8c:	0692                	slli	a3,a3,0x4
 3001e8e:	fcf7f793          	andi	a5,a5,-49
 3001e92:	8fd5                	or	a5,a5,a3
 3001e94:	20f72423          	sw	a5,520(a4)
        aptHandle->baseAddress->DG_RED.BIT.rg_dg_red = aptHandle->waveform.deadBandCnt;
 3001e98:	fec42783          	lw	a5,-20(s0)
 3001e9c:	4398                	lw	a4,0(a5)
 3001e9e:	fec42783          	lw	a5,-20(s0)
 3001ea2:	3792                	lhu	a2,40(a5)
 3001ea4:	20072783          	lw	a5,512(a4)
 3001ea8:	66c1                	lui	a3,0x10
 3001eaa:	16fd                	addi	a3,a3,-1 # ffff <RAM_SIZE+0xafff>
 3001eac:	8ef1                	and	a3,a3,a2
 3001eae:	7641                	lui	a2,0xffff0
 3001eb0:	8ff1                	and	a5,a5,a2
 3001eb2:	8fd5                	or	a5,a5,a3
 3001eb4:	20f72023          	sw	a5,512(a4)
        aptHandle->baseAddress->DG_CFG.BIT.rg_dg_fed_isel = wavePara->fedInput;
 3001eb8:	fe842783          	lw	a5,-24(s0)
 3001ebc:	4f94                	lw	a3,24(a5)
 3001ebe:	fec42783          	lw	a5,-20(s0)
 3001ec2:	4398                	lw	a4,0(a5)
 3001ec4:	87b6                	mv	a5,a3
 3001ec6:	8b8d                	andi	a5,a5,3
 3001ec8:	0ff7f693          	andi	a3,a5,255
 3001ecc:	20872783          	lw	a5,520(a4)
 3001ed0:	8a8d                	andi	a3,a3,3
 3001ed2:	068a                	slli	a3,a3,0x2
 3001ed4:	9bcd                	andi	a5,a5,-13
 3001ed6:	8fd5                	or	a5,a5,a3
 3001ed8:	20f72423          	sw	a5,520(a4)
        aptHandle->baseAddress->DG_CFG.BIT.rg_dg_fed_osel = wavePara->fedOutMode;
 3001edc:	fe842783          	lw	a5,-24(s0)
 3001ee0:	4fd4                	lw	a3,28(a5)
 3001ee2:	fec42783          	lw	a5,-20(s0)
 3001ee6:	4398                	lw	a4,0(a5)
 3001ee8:	87b6                	mv	a5,a3
 3001eea:	8b8d                	andi	a5,a5,3
 3001eec:	0ff7f693          	andi	a3,a5,255
 3001ef0:	20872783          	lw	a5,520(a4)
 3001ef4:	8a8d                	andi	a3,a3,3
 3001ef6:	069a                	slli	a3,a3,0x6
 3001ef8:	f3f7f793          	andi	a5,a5,-193
 3001efc:	8fd5                	or	a5,a5,a3
 3001efe:	20f72423          	sw	a5,520(a4)
        aptHandle->baseAddress->DG_FED.BIT.rg_dg_fed = aptHandle->waveform.deadBandCnt;
 3001f02:	fec42783          	lw	a5,-20(s0)
 3001f06:	4398                	lw	a4,0(a5)
 3001f08:	fec42783          	lw	a5,-20(s0)
 3001f0c:	3792                	lhu	a2,40(a5)
 3001f0e:	20472783          	lw	a5,516(a4)
 3001f12:	66c1                	lui	a3,0x10
 3001f14:	16fd                	addi	a3,a3,-1 # ffff <RAM_SIZE+0xafff>
 3001f16:	8ef1                	and	a3,a3,a2
 3001f18:	7641                	lui	a2,0xffff0
 3001f1a:	8ff1                	and	a5,a5,a2
 3001f1c:	8fd5                	or	a5,a5,a3
 3001f1e:	20f72223          	sw	a5,516(a4)
    }
}
 3001f22:	0001                	nop
 3001f24:	40f2                	lw	ra,28(sp)
 3001f26:	4462                	lw	s0,24(sp)
 3001f28:	6105                	addi	sp,sp,32
 3001f2a:	8082                	ret

03001f2c <APT_SetContWaveform>:
  * @brief Set the actual outputs of PWM channelA and channelB when basic PWM waveform type is not used.
  * @param aptHandle APT module handle.
  * @retval None.
  */
static void APT_SetContWaveform(APT_Handle *aptHandle)
{
 3001f2c:	7179                	addi	sp,sp,-48
 3001f2e:	d622                	sw	s0,44(sp)
 3001f30:	1800                	addi	s0,sp,48
 3001f32:	fca42e23          	sw	a0,-36(s0)
    if (aptHandle->waveform.chAOutType != APT_PWM_OUT_BASIC_TYPE) {
 3001f36:	fdc42783          	lw	a5,-36(s0)
 3001f3a:	479c                	lw	a5,8(a5)
 3001f3c:	cb9d                	beqz	a5,3001f72 <APT_SetContWaveform+0x46>
        unsigned int contActA = (aptHandle->waveform.chAOutType == APT_PWM_OUT_ALWAYS_LOW) ? 0b01 : 0b10;
 3001f3e:	fdc42783          	lw	a5,-36(s0)
 3001f42:	4798                	lw	a4,8(a5)
 3001f44:	4785                	li	a5,1
 3001f46:	00f71463          	bne	a4,a5,3001f4e <APT_SetContWaveform+0x22>
 3001f4a:	4785                	li	a5,1
 3001f4c:	a011                	j	3001f50 <APT_SetContWaveform+0x24>
 3001f4e:	4789                	li	a5,2
 3001f50:	fef42623          	sw	a5,-20(s0)
        aptHandle->baseAddress->PG_ACT_A.BIT.rg_pga_act_zro = contActA;
 3001f54:	fdc42783          	lw	a5,-36(s0)
 3001f58:	4398                	lw	a4,0(a5)
 3001f5a:	fec42783          	lw	a5,-20(s0)
 3001f5e:	8b8d                	andi	a5,a5,3
 3001f60:	0ff7f693          	andi	a3,a5,255
 3001f64:	10072783          	lw	a5,256(a4)
 3001f68:	8a8d                	andi	a3,a3,3
 3001f6a:	9bf1                	andi	a5,a5,-4
 3001f6c:	8fd5                	or	a5,a5,a3
 3001f6e:	10f72023          	sw	a5,256(a4)
    }
    if (aptHandle->waveform.chBOutType != APT_PWM_OUT_BASIC_TYPE) {
 3001f72:	fdc42783          	lw	a5,-36(s0)
 3001f76:	47dc                	lw	a5,12(a5)
 3001f78:	cb9d                	beqz	a5,3001fae <APT_SetContWaveform+0x82>
        unsigned int contActB = (aptHandle->waveform.chBOutType == APT_PWM_OUT_ALWAYS_LOW) ? 0b01 : 0b10;
 3001f7a:	fdc42783          	lw	a5,-36(s0)
 3001f7e:	47d8                	lw	a4,12(a5)
 3001f80:	4785                	li	a5,1
 3001f82:	00f71463          	bne	a4,a5,3001f8a <APT_SetContWaveform+0x5e>
 3001f86:	4785                	li	a5,1
 3001f88:	a011                	j	3001f8c <APT_SetContWaveform+0x60>
 3001f8a:	4789                	li	a5,2
 3001f8c:	fef42423          	sw	a5,-24(s0)
        aptHandle->baseAddress->PG_ACT_B.BIT.rg_pgb_act_zro = contActB;
 3001f90:	fdc42783          	lw	a5,-36(s0)
 3001f94:	4398                	lw	a4,0(a5)
 3001f96:	fe842783          	lw	a5,-24(s0)
 3001f9a:	8b8d                	andi	a5,a5,3
 3001f9c:	0ff7f693          	andi	a3,a5,255
 3001fa0:	10472783          	lw	a5,260(a4)
 3001fa4:	8a8d                	andi	a3,a3,3
 3001fa6:	9bf1                	andi	a5,a5,-4
 3001fa8:	8fd5                	or	a5,a5,a3
 3001faa:	10f72223          	sw	a5,260(a4)
    }
}
 3001fae:	0001                	nop
 3001fb0:	5432                	lw	s0,44(sp)
 3001fb2:	6145                	addi	sp,sp,48
 3001fb4:	8082                	ret

03001fb6 <APT_SetPWMWaveform>:
  * @brief Initialize the PWM waveform parameters according to the selected PWM basic type.
  * @param aptHandle APT module handle.
  * @retval None.
  */
static void APT_SetPWMWaveform(APT_Handle *aptHandle)
{
 3001fb6:	7139                	addi	sp,sp,-64
 3001fb8:	de06                	sw	ra,60(sp)
 3001fba:	dc22                	sw	s0,56(sp)
 3001fbc:	0080                	addi	s0,sp,64
 3001fbe:	fca42623          	sw	a0,-52(s0)
    APT_SetContWaveform(aptHandle);
 3001fc2:	fcc42503          	lw	a0,-52(s0)
 3001fc6:	379d                	jal	ra,3001f2c <APT_SetContWaveform>
    /* Configure the basic type of PWM waveform */
    APT_WaveformPara wavePara = {0, 0, 0, 0, 0, 0, 0, 0};
 3001fc8:	fc042823          	sw	zero,-48(s0)
 3001fcc:	fc042a23          	sw	zero,-44(s0)
 3001fd0:	fc042c23          	sw	zero,-40(s0)
 3001fd4:	fc042e23          	sw	zero,-36(s0)
 3001fd8:	fe042023          	sw	zero,-32(s0)
 3001fdc:	fe042223          	sw	zero,-28(s0)
 3001fe0:	fe042423          	sw	zero,-24(s0)
 3001fe4:	fe042623          	sw	zero,-20(s0)
    switch (aptHandle->waveform.basicType) {
 3001fe8:	fcc42783          	lw	a5,-52(s0)
 3001fec:	43dc                	lw	a5,4(a5)
 3001fee:	4705                	li	a4,1
 3001ff0:	04e78263          	beq	a5,a4,3002034 <APT_SetPWMWaveform+0x7e>
 3001ff4:	4705                	li	a4,1
 3001ff6:	00e7e963          	bltu	a5,a4,3002008 <APT_SetPWMWaveform+0x52>
 3001ffa:	4709                	li	a4,2
 3001ffc:	06e78463          	beq	a5,a4,3002064 <APT_SetPWMWaveform+0xae>
 3002000:	470d                	li	a4,3
 3002002:	08e78663          	beq	a5,a4,300208e <APT_SetPWMWaveform+0xd8>
            wavePara.fedOutMode = APT_DB_FED_OUTPUT_NOT_INVERT;
            wavePara.redInput = APT_DB_RED_INPUT_PWM_B;
            wavePara.redOutMode = APT_DB_RED_OUTPUT_NOT_INVERT;
            break;
        default:
            break;
 3002006:	a85d                	j	30020bc <APT_SetPWMWaveform+0x106>
            wavePara.leftEdgeActA = APT_PWM_ACTION_HIGH;
 3002008:	4789                	li	a5,2
 300200a:	fcf42823          	sw	a5,-48(s0)
            wavePara.rightEdgeActA = APT_PWM_ACTION_LOW;
 300200e:	4785                	li	a5,1
 3002010:	fcf42a23          	sw	a5,-44(s0)
            wavePara.leftEdgeActB = APT_PWM_ACTION_HIGH;
 3002014:	4789                	li	a5,2
 3002016:	fcf42c23          	sw	a5,-40(s0)
            wavePara.rightEdgeActB = APT_PWM_ACTION_LOW;
 300201a:	4785                	li	a5,1
 300201c:	fcf42e23          	sw	a5,-36(s0)
            wavePara.redInput = APT_DB_RED_INPUT_PWM_A;
 3002020:	fe042023          	sw	zero,-32(s0)
            wavePara.redOutMode = APT_DB_RED_OUTPUT_NOT_INVERT;
 3002024:	fe042223          	sw	zero,-28(s0)
            wavePara.fedInput = APT_DB_FED_INPUT_PWM_B;
 3002028:	fe042423          	sw	zero,-24(s0)
            wavePara.fedOutMode = APT_DB_FED_OUTPUT_INVERT;
 300202c:	4789                	li	a5,2
 300202e:	fef42623          	sw	a5,-20(s0)
            break;
 3002032:	a069                	j	30020bc <APT_SetPWMWaveform+0x106>
            wavePara.leftEdgeActA = APT_PWM_ACTION_LOW;
 3002034:	4785                	li	a5,1
 3002036:	fcf42823          	sw	a5,-48(s0)
            wavePara.rightEdgeActA = APT_PWM_ACTION_HIGH;
 300203a:	4789                	li	a5,2
 300203c:	fcf42a23          	sw	a5,-44(s0)
            wavePara.leftEdgeActB = APT_PWM_ACTION_LOW;
 3002040:	4785                	li	a5,1
 3002042:	fcf42c23          	sw	a5,-40(s0)
            wavePara.rightEdgeActB = APT_PWM_ACTION_HIGH;
 3002046:	4789                	li	a5,2
 3002048:	fcf42e23          	sw	a5,-36(s0)
            wavePara.fedInput = APT_DB_FED_INPUT_PWM_A;
 300204c:	4785                	li	a5,1
 300204e:	fef42423          	sw	a5,-24(s0)
            wavePara.fedOutMode = APT_DB_FED_OUTPUT_INVERT;
 3002052:	4789                	li	a5,2
 3002054:	fef42623          	sw	a5,-20(s0)
            wavePara.redInput = APT_DB_RED_INPUT_PWM_B;
 3002058:	4785                	li	a5,1
 300205a:	fef42023          	sw	a5,-32(s0)
            wavePara.redOutMode = APT_DB_RED_OUTPUT_NOT_INVERT;
 300205e:	fe042223          	sw	zero,-28(s0)
            break;
 3002062:	a8a9                	j	30020bc <APT_SetPWMWaveform+0x106>
            wavePara.leftEdgeActA = APT_PWM_ACTION_HIGH;
 3002064:	4789                	li	a5,2
 3002066:	fcf42823          	sw	a5,-48(s0)
            wavePara.rightEdgeActA = APT_PWM_ACTION_LOW;
 300206a:	4785                	li	a5,1
 300206c:	fcf42a23          	sw	a5,-44(s0)
            wavePara.leftEdgeActB = APT_PWM_ACTION_HIGH;
 3002070:	4789                	li	a5,2
 3002072:	fcf42c23          	sw	a5,-40(s0)
            wavePara.rightEdgeActB = APT_PWM_ACTION_LOW;
 3002076:	4785                	li	a5,1
 3002078:	fcf42e23          	sw	a5,-36(s0)
            wavePara.redInput = APT_DB_RED_INPUT_PWM_A;
 300207c:	fe042023          	sw	zero,-32(s0)
            wavePara.redOutMode = APT_DB_RED_OUTPUT_NOT_INVERT;
 3002080:	fe042223          	sw	zero,-28(s0)
            wavePara.fedInput = APT_DB_FED_INPUT_PWM_B;
 3002084:	fe042423          	sw	zero,-24(s0)
            wavePara.fedOutMode = APT_DB_FED_OUTPUT_NOT_INVERT;
 3002088:	fe042623          	sw	zero,-20(s0)
            break;
 300208c:	a805                	j	30020bc <APT_SetPWMWaveform+0x106>
            wavePara.leftEdgeActA = APT_PWM_ACTION_LOW;
 300208e:	4785                	li	a5,1
 3002090:	fcf42823          	sw	a5,-48(s0)
            wavePara.rightEdgeActA = APT_PWM_ACTION_HIGH;
 3002094:	4789                	li	a5,2
 3002096:	fcf42a23          	sw	a5,-44(s0)
            wavePara.leftEdgeActB = APT_PWM_ACTION_LOW;
 300209a:	4785                	li	a5,1
 300209c:	fcf42c23          	sw	a5,-40(s0)
            wavePara.rightEdgeActB = APT_PWM_ACTION_HIGH;
 30020a0:	4789                	li	a5,2
 30020a2:	fcf42e23          	sw	a5,-36(s0)
            wavePara.fedInput = APT_DB_FED_INPUT_PWM_A;
 30020a6:	4785                	li	a5,1
 30020a8:	fef42423          	sw	a5,-24(s0)
            wavePara.fedOutMode = APT_DB_FED_OUTPUT_NOT_INVERT;
 30020ac:	fe042623          	sw	zero,-20(s0)
            wavePara.redInput = APT_DB_RED_INPUT_PWM_B;
 30020b0:	4785                	li	a5,1
 30020b2:	fef42023          	sw	a5,-32(s0)
            wavePara.redOutMode = APT_DB_RED_OUTPUT_NOT_INVERT;
 30020b6:	fe042223          	sw	zero,-28(s0)
            break;
 30020ba:	0001                	nop
    }
    APT_SetPWMBasicType(aptHandle, &wavePara);
 30020bc:	fd040793          	addi	a5,s0,-48
 30020c0:	85be                	mv	a1,a5
 30020c2:	fcc42503          	lw	a0,-52(s0)
 30020c6:	3399                	jal	ra,3001e0c <APT_SetPWMBasicType>
}
 30020c8:	0001                	nop
 30020ca:	50f2                	lw	ra,60(sp)
 30020cc:	5462                	lw	s0,56(sp)
 30020ce:	6121                	addi	sp,sp,64
 30020d0:	8082                	ret

030020d2 <APT_SetADCTrgCompareVal>:
  * @brief Initialize the count compare points for triggering ADC sampling.
  * @param aptHandle APT module handle.
  * @retval None.
  */
static void APT_SetADCTrgCompareVal(APT_Handle *aptHandle)
{
 30020d2:	7179                	addi	sp,sp,-48
 30020d4:	d622                	sw	s0,44(sp)
 30020d6:	1800                	addi	s0,sp,48
 30020d8:	fca42e23          	sw	a0,-36(s0)
    /* Configure the count compare point for triggering SOCA and SOCB */
    TC_REFA_REG tmpA;
    TC_REFB_REG tmpB;
    /* Set the value of active register for CMPA and CMPB */
    tmpA = aptHandle->baseAddress->TC_REFA; /* read register */
 30020dc:	fdc42783          	lw	a5,-36(s0)
 30020e0:	439c                	lw	a5,0(a5)
 30020e2:	5b9c                	lw	a5,48(a5)
 30020e4:	fef42223          	sw	a5,-28(s0)
    tmpA.BIT.rg_cnt_refa = aptHandle->adcTrg.cntCmpSOCA;
 30020e8:	fdc42783          	lw	a5,-36(s0)
 30020ec:	3bf6                	lhu	a3,54(a5)
 30020ee:	fe442783          	lw	a5,-28(s0)
 30020f2:	6741                	lui	a4,0x10
 30020f4:	177d                	addi	a4,a4,-1 # ffff <RAM_SIZE+0xafff>
 30020f6:	8f75                	and	a4,a4,a3
 30020f8:	76c1                	lui	a3,0xffff0
 30020fa:	8ff5                	and	a5,a5,a3
 30020fc:	8fd9                	or	a5,a5,a4
 30020fe:	fef42223          	sw	a5,-28(s0)
    aptHandle->baseAddress->TC_REFA = tmpA; /* write back changed data to register */
 3002102:	fdc42783          	lw	a5,-36(s0)
 3002106:	439c                	lw	a5,0(a5)
 3002108:	fe442703          	lw	a4,-28(s0)
 300210c:	db98                	sw	a4,48(a5)
    tmpB = aptHandle->baseAddress->TC_REFB;
 300210e:	fdc42783          	lw	a5,-36(s0)
 3002112:	439c                	lw	a5,0(a5)
 3002114:	5bdc                	lw	a5,52(a5)
 3002116:	fef42023          	sw	a5,-32(s0)
    tmpB.BIT.rg_cnt_refb = aptHandle->adcTrg.cntCmpSOCB;
 300211a:	fdc42783          	lw	a5,-36(s0)
 300211e:	0427d683          	lhu	a3,66(a5)
 3002122:	fe042783          	lw	a5,-32(s0)
 3002126:	6741                	lui	a4,0x10
 3002128:	177d                	addi	a4,a4,-1 # ffff <RAM_SIZE+0xafff>
 300212a:	8f75                	and	a4,a4,a3
 300212c:	76c1                	lui	a3,0xffff0
 300212e:	8ff5                	and	a5,a5,a3
 3002130:	8fd9                	or	a5,a5,a4
 3002132:	fef42023          	sw	a5,-32(s0)
    aptHandle->baseAddress->TC_REFB = tmpB;
 3002136:	fdc42783          	lw	a5,-36(s0)
 300213a:	439c                	lw	a5,0(a5)
 300213c:	fe042703          	lw	a4,-32(s0)
 3002140:	dbd8                	sw	a4,52(a5)
    /* Set the buffer load mode of CMPA and CMPB */
    if (aptHandle->adcTrg.cntCmpLoadMode == APT_BUFFER_DISABLE) {
 3002142:	fdc42783          	lw	a5,-36(s0)
 3002146:	43fc                	lw	a5,68(a5)
 3002148:	ef99                	bnez	a5,3002166 <APT_SetADCTrgCompareVal+0x94>
        aptHandle->baseAddress->TC_BUF_EN.BIT.rg_refa_buf_en = 0; /* disable buffer function */
 300214a:	fdc42783          	lw	a5,-36(s0)
 300214e:	4398                	lw	a4,0(a5)
 3002150:	4b3c                	lw	a5,80(a4)
 3002152:	9bbd                	andi	a5,a5,-17
 3002154:	cb3c                	sw	a5,80(a4)
        aptHandle->baseAddress->TC_BUF_EN.BIT.rg_refb_buf_en = 0; /* disable buffer function */
 3002156:	fdc42783          	lw	a5,-36(s0)
 300215a:	4398                	lw	a4,0(a5)
 300215c:	4b3c                	lw	a5,80(a4)
 300215e:	fbf7f793          	andi	a5,a5,-65
 3002162:	cb3c                	sw	a5,80(a4)
        aptHandle->baseAddress->TC_REFA = tmpA;
        tmpB = aptHandle->baseAddress->TC_REFB;
        tmpB.BIT.rg_cnt_refb = aptHandle->adcTrg.cntCmpSOCB;
        aptHandle->baseAddress->TC_REFB = tmpB;
    }
}
 3002164:	a291                	j	30022a8 <APT_SetADCTrgCompareVal+0x1d6>
        aptHandle->baseAddress->TC_BUF_EN.BIT.rg_refa_buf_en = 1;
 3002166:	fdc42783          	lw	a5,-36(s0)
 300216a:	4398                	lw	a4,0(a5)
 300216c:	4b3c                	lw	a5,80(a4)
 300216e:	0107e793          	ori	a5,a5,16
 3002172:	cb3c                	sw	a5,80(a4)
        aptHandle->baseAddress->TC_BUF_EN.BIT.rg_refb_buf_en = 1;
 3002174:	fdc42783          	lw	a5,-36(s0)
 3002178:	4398                	lw	a4,0(a5)
 300217a:	4b3c                	lw	a5,80(a4)
 300217c:	0407e793          	ori	a5,a5,64
 3002180:	cb3c                	sw	a5,80(a4)
        unsigned int gldLdEn = (aptHandle->adcTrg.cntCmpLoadMode == APT_BUFFER_GLOBAL_LOAD) ? 1 : 0;
 3002182:	fdc42783          	lw	a5,-36(s0)
 3002186:	43fc                	lw	a5,68(a5)
 3002188:	17f5                	addi	a5,a5,-3
 300218a:	0017b793          	seqz	a5,a5
 300218e:	9f81                	uxtb	a5
 3002190:	fef42623          	sw	a5,-20(s0)
        aptHandle->baseAddress->TC_BUF_EN.BIT.rg_refa_gld_en = gldLdEn;
 3002194:	fdc42783          	lw	a5,-36(s0)
 3002198:	4398                	lw	a4,0(a5)
 300219a:	fec42783          	lw	a5,-20(s0)
 300219e:	8b85                	andi	a5,a5,1
 30021a0:	0ff7f693          	andi	a3,a5,255
 30021a4:	4b3c                	lw	a5,80(a4)
 30021a6:	8a85                	andi	a3,a3,1
 30021a8:	0696                	slli	a3,a3,0x5
 30021aa:	fdf7f793          	andi	a5,a5,-33
 30021ae:	8fd5                	or	a5,a5,a3
 30021b0:	cb3c                	sw	a5,80(a4)
        aptHandle->baseAddress->TC_BUF_EN.BIT.rg_refb_gld_en = gldLdEn;
 30021b2:	fdc42783          	lw	a5,-36(s0)
 30021b6:	4398                	lw	a4,0(a5)
 30021b8:	fec42783          	lw	a5,-20(s0)
 30021bc:	8b85                	andi	a5,a5,1
 30021be:	0ff7f693          	andi	a3,a5,255
 30021c2:	4b3c                	lw	a5,80(a4)
 30021c4:	8a85                	andi	a3,a3,1
 30021c6:	069e                	slli	a3,a3,0x7
 30021c8:	f7f7f793          	andi	a5,a5,-129
 30021cc:	8fd5                	or	a5,a5,a3
 30021ce:	cb3c                	sw	a5,80(a4)
        unsigned int refBufField = 8;
 30021d0:	47a1                	li	a5,8
 30021d2:	fef42423          	sw	a5,-24(s0)
        aptHandle->baseAddress->TC_REF_LOAD.reg &= (~(0x1F << (APT_COMPARE_REFERENCE_A * refBufField)));
 30021d6:	fdc42783          	lw	a5,-36(s0)
 30021da:	439c                	lw	a5,0(a5)
 30021dc:	4fb8                	lw	a4,88(a5)
 30021de:	fdc42783          	lw	a5,-36(s0)
 30021e2:	439c                	lw	a5,0(a5)
 30021e4:	9b01                	andi	a4,a4,-32
 30021e6:	cfb8                	sw	a4,88(a5)
        aptHandle->baseAddress->TC_REF_LOAD.reg &= (~(0x1F << (APT_COMPARE_REFERENCE_B * refBufField)));
 30021e8:	fdc42783          	lw	a5,-36(s0)
 30021ec:	439c                	lw	a5,0(a5)
 30021ee:	4fb8                	lw	a4,88(a5)
 30021f0:	46fd                	li	a3,31
 30021f2:	fe842783          	lw	a5,-24(s0)
 30021f6:	00f697b3          	sll	a5,a3,a5
 30021fa:	fff7c793          	not	a5,a5
 30021fe:	86be                	mv	a3,a5
 3002200:	fdc42783          	lw	a5,-36(s0)
 3002204:	439c                	lw	a5,0(a5)
 3002206:	8f75                	and	a4,a4,a3
 3002208:	cfb8                	sw	a4,88(a5)
        aptHandle->baseAddress->TC_REF_LOAD.reg |=
 300220a:	fdc42783          	lw	a5,-36(s0)
 300220e:	439c                	lw	a5,0(a5)
 3002210:	4fb4                	lw	a3,88(a5)
            (aptHandle->adcTrg.cntCmpLoadEvt << (APT_COMPARE_REFERENCE_A * refBufField));
 3002212:	fdc42783          	lw	a5,-36(s0)
 3002216:	47b8                	lw	a4,72(a5)
        aptHandle->baseAddress->TC_REF_LOAD.reg |=
 3002218:	fdc42783          	lw	a5,-36(s0)
 300221c:	439c                	lw	a5,0(a5)
 300221e:	8f55                	or	a4,a4,a3
 3002220:	cfb8                	sw	a4,88(a5)
        aptHandle->baseAddress->TC_REF_LOAD.reg |=
 3002222:	fdc42783          	lw	a5,-36(s0)
 3002226:	439c                	lw	a5,0(a5)
 3002228:	4fb4                	lw	a3,88(a5)
            (aptHandle->adcTrg.cntCmpLoadEvt << (APT_COMPARE_REFERENCE_B * refBufField));
 300222a:	fdc42783          	lw	a5,-36(s0)
 300222e:	47b8                	lw	a4,72(a5)
 3002230:	fe842783          	lw	a5,-24(s0)
 3002234:	00f71733          	sll	a4,a4,a5
        aptHandle->baseAddress->TC_REF_LOAD.reg |=
 3002238:	fdc42783          	lw	a5,-36(s0)
 300223c:	439c                	lw	a5,0(a5)
 300223e:	8f55                	or	a4,a4,a3
 3002240:	cfb8                	sw	a4,88(a5)
        tmpA = aptHandle->baseAddress->TC_REFA;
 3002242:	fdc42783          	lw	a5,-36(s0)
 3002246:	439c                	lw	a5,0(a5)
 3002248:	5b9c                	lw	a5,48(a5)
 300224a:	fef42223          	sw	a5,-28(s0)
        tmpA.BIT.rg_cnt_refa = aptHandle->adcTrg.cntCmpSOCA;
 300224e:	fdc42783          	lw	a5,-36(s0)
 3002252:	3bf6                	lhu	a3,54(a5)
 3002254:	fe442783          	lw	a5,-28(s0)
 3002258:	6741                	lui	a4,0x10
 300225a:	177d                	addi	a4,a4,-1 # ffff <RAM_SIZE+0xafff>
 300225c:	8f75                	and	a4,a4,a3
 300225e:	76c1                	lui	a3,0xffff0
 3002260:	8ff5                	and	a5,a5,a3
 3002262:	8fd9                	or	a5,a5,a4
 3002264:	fef42223          	sw	a5,-28(s0)
        aptHandle->baseAddress->TC_REFA = tmpA;
 3002268:	fdc42783          	lw	a5,-36(s0)
 300226c:	439c                	lw	a5,0(a5)
 300226e:	fe442703          	lw	a4,-28(s0)
 3002272:	db98                	sw	a4,48(a5)
        tmpB = aptHandle->baseAddress->TC_REFB;
 3002274:	fdc42783          	lw	a5,-36(s0)
 3002278:	439c                	lw	a5,0(a5)
 300227a:	5bdc                	lw	a5,52(a5)
 300227c:	fef42023          	sw	a5,-32(s0)
        tmpB.BIT.rg_cnt_refb = aptHandle->adcTrg.cntCmpSOCB;
 3002280:	fdc42783          	lw	a5,-36(s0)
 3002284:	0427d683          	lhu	a3,66(a5)
 3002288:	fe042783          	lw	a5,-32(s0)
 300228c:	6741                	lui	a4,0x10
 300228e:	177d                	addi	a4,a4,-1 # ffff <RAM_SIZE+0xafff>
 3002290:	8f75                	and	a4,a4,a3
 3002292:	76c1                	lui	a3,0xffff0
 3002294:	8ff5                	and	a5,a5,a3
 3002296:	8fd9                	or	a5,a5,a4
 3002298:	fef42023          	sw	a5,-32(s0)
        aptHandle->baseAddress->TC_REFB = tmpB;
 300229c:	fdc42783          	lw	a5,-36(s0)
 30022a0:	439c                	lw	a5,0(a5)
 30022a2:	fe042703          	lw	a4,-32(s0)
 30022a6:	dbd8                	sw	a4,52(a5)
}
 30022a8:	0001                	nop
 30022aa:	5432                	lw	s0,44(sp)
 30022ac:	6145                	addi	sp,sp,48
 30022ae:	8082                	ret

030022b0 <APT_SetADCTrigger>:
  * @brief Initialize the ADC trigger function of APT module.
  * @param aptHandle APT module handle
  * @retval None.
  */
static void APT_SetADCTrigger(APT_Handle *aptHandle)
{
 30022b0:	1101                	addi	sp,sp,-32
 30022b2:	ce06                	sw	ra,28(sp)
 30022b4:	cc22                	sw	s0,24(sp)
 30022b6:	1000                	addi	s0,sp,32
 30022b8:	fea42623          	sw	a0,-20(s0)
    APT_PARAM_CHECK_NO_RET(aptHandle->adcTrg.trgScaleSOCA <= ADC_CONVERSION_START_CNT_MAX);
 30022bc:	fec42783          	lw	a5,-20(s0)
 30022c0:	3bda                	lhu	a4,52(a5)
 30022c2:	47bd                	li	a5,15
 30022c4:	00e7fa63          	bgeu	a5,a4,30022d8 <APT_SetADCTrigger+0x28>
 30022c8:	13e00593          	li	a1,318
 30022cc:	030127b7          	lui	a5,0x3012
 30022d0:	b1478513          	addi	a0,a5,-1260 # 3011b14 <g_crgIpMatch+0x27c>
 30022d4:	26a9                	jal	ra,300261e <AssertErrorLog.trans.1>
 30022d6:	a0fd                	j	30023c4 <APT_SetADCTrigger+0x114>
    APT_PARAM_CHECK_NO_RET(aptHandle->adcTrg.trgScaleSOCB <= ADC_CONVERSION_START_CNT_MAX);
 30022d8:	fec42783          	lw	a5,-20(s0)
 30022dc:	0407d703          	lhu	a4,64(a5)
 30022e0:	47bd                	li	a5,15
 30022e2:	00e7fa63          	bgeu	a5,a4,30022f6 <APT_SetADCTrigger+0x46>
 30022e6:	13f00593          	li	a1,319
 30022ea:	030127b7          	lui	a5,0x3012
 30022ee:	b1478513          	addi	a0,a5,-1260 # 3011b14 <g_crgIpMatch+0x27c>
 30022f2:	2635                	jal	ra,300261e <AssertErrorLog.trans.1>
 30022f4:	a8c1                	j	30023c4 <APT_SetADCTrigger+0x114>
    /* Configure ADC trigger source SOCA */
    aptHandle->baseAddress->CS_TMR_SELA.BIT.rg_csa_tmr_sel = aptHandle->adcTrg.trgSrcSOCA;
 30022f6:	fec42783          	lw	a5,-20(s0)
 30022fa:	5b94                	lw	a3,48(a5)
 30022fc:	fec42783          	lw	a5,-20(s0)
 3002300:	4398                	lw	a4,0(a5)
 3002302:	87b6                	mv	a5,a3
 3002304:	8bbd                	andi	a5,a5,15
 3002306:	0ff7f693          	andi	a3,a5,255
 300230a:	50072783          	lw	a5,1280(a4)
 300230e:	8abd                	andi	a3,a3,15
 3002310:	9bc1                	andi	a5,a5,-16
 3002312:	8fd5                	or	a5,a5,a3
 3002314:	50f72023          	sw	a5,1280(a4)
    aptHandle->baseAddress->CS_PRSCA_CFG.BIT.rg_csa_prsc_prd = aptHandle->adcTrg.trgScaleSOCA;
 3002318:	fec42783          	lw	a5,-20(s0)
 300231c:	3bd6                	lhu	a3,52(a5)
 300231e:	fec42783          	lw	a5,-20(s0)
 3002322:	4398                	lw	a4,0(a5)
 3002324:	87b6                	mv	a5,a3
 3002326:	8bbd                	andi	a5,a5,15
 3002328:	0ff7f693          	andi	a3,a5,255
 300232c:	50872783          	lw	a5,1288(a4)
 3002330:	8abd                	andi	a3,a3,15
 3002332:	9bc1                	andi	a5,a5,-16
 3002334:	8fd5                	or	a5,a5,a3
 3002336:	50f72423          	sw	a5,1288(a4)
    aptHandle->baseAddress->CS_TMR_SELA.BIT.rg_csa_en_cs = aptHandle->adcTrg.trgEnSOCA;
 300233a:	fec42783          	lw	a5,-20(s0)
 300233e:	4398                	lw	a4,0(a5)
 3002340:	fec42783          	lw	a5,-20(s0)
 3002344:	02c7c683          	lbu	a3,44(a5)
 3002348:	50072783          	lw	a5,1280(a4)
 300234c:	8a85                	andi	a3,a3,1
 300234e:	06c2                	slli	a3,a3,0x10
 3002350:	7641                	lui	a2,0xffff0
 3002352:	167d                	addi	a2,a2,-1 # fffeffff <RAM_END+0xfbfe7fff>
 3002354:	8ff1                	and	a5,a5,a2
 3002356:	8fd5                	or	a5,a5,a3
 3002358:	50f72023          	sw	a5,1280(a4)
    /* Configure ADC trigger source SOCB */
    aptHandle->baseAddress->CS_TMR_SELB.BIT.rg_csb_tmr_sel = aptHandle->adcTrg.trgSrcSOCB;
 300235c:	fec42783          	lw	a5,-20(s0)
 3002360:	5fd4                	lw	a3,60(a5)
 3002362:	fec42783          	lw	a5,-20(s0)
 3002366:	4398                	lw	a4,0(a5)
 3002368:	87b6                	mv	a5,a3
 300236a:	8bbd                	andi	a5,a5,15
 300236c:	0ff7f693          	andi	a3,a5,255
 3002370:	50472783          	lw	a5,1284(a4)
 3002374:	8abd                	andi	a3,a3,15
 3002376:	9bc1                	andi	a5,a5,-16
 3002378:	8fd5                	or	a5,a5,a3
 300237a:	50f72223          	sw	a5,1284(a4)
    aptHandle->baseAddress->CS_PRSCB_CFG.BIT.rg_csb_prsc_prd = aptHandle->adcTrg.trgScaleSOCB;
 300237e:	fec42783          	lw	a5,-20(s0)
 3002382:	0407d683          	lhu	a3,64(a5)
 3002386:	fec42783          	lw	a5,-20(s0)
 300238a:	4398                	lw	a4,0(a5)
 300238c:	87b6                	mv	a5,a3
 300238e:	8bbd                	andi	a5,a5,15
 3002390:	0ff7f693          	andi	a3,a5,255
 3002394:	50c72783          	lw	a5,1292(a4)
 3002398:	8abd                	andi	a3,a3,15
 300239a:	9bc1                	andi	a5,a5,-16
 300239c:	8fd5                	or	a5,a5,a3
 300239e:	50f72623          	sw	a5,1292(a4)
    aptHandle->baseAddress->CS_TMR_SELB.BIT.rg_csb_en_cs = aptHandle->adcTrg.trgEnSOCB;
 30023a2:	fec42783          	lw	a5,-20(s0)
 30023a6:	4398                	lw	a4,0(a5)
 30023a8:	fec42783          	lw	a5,-20(s0)
 30023ac:	0387c683          	lbu	a3,56(a5)
 30023b0:	50472783          	lw	a5,1284(a4)
 30023b4:	8a85                	andi	a3,a3,1
 30023b6:	06c2                	slli	a3,a3,0x10
 30023b8:	7641                	lui	a2,0xffff0
 30023ba:	167d                	addi	a2,a2,-1 # fffeffff <RAM_END+0xfbfe7fff>
 30023bc:	8ff1                	and	a5,a5,a2
 30023be:	8fd5                	or	a5,a5,a3
 30023c0:	50f72223          	sw	a5,1284(a4)
}
 30023c4:	40f2                	lw	ra,28(sp)
 30023c6:	4462                	lw	s0,24(sp)
 30023c8:	6105                	addi	sp,sp,32
 30023ca:	8082                	ret

030023cc <APT_SetTimerInterrupt>:
  * @brief Initialize the timer interrupt of APT module.
  * @param aptHandle APT module handle.
  * @retval None.
  */
static void APT_SetTimerInterrupt(APT_Handle *aptHandle)
{
 30023cc:	1101                	addi	sp,sp,-32
 30023ce:	ce06                	sw	ra,28(sp)
 30023d0:	cc22                	sw	s0,24(sp)
 30023d2:	1000                	addi	s0,sp,32
 30023d4:	fea42623          	sw	a0,-20(s0)
    APT_PARAM_CHECK_NO_RET(aptHandle->tmrInterrupt.tmrInterruptScale <= TIMER_INTERRUPT_CNT_MAX);
 30023d8:	fec42783          	lw	a5,-20(s0)
 30023dc:	0547d703          	lhu	a4,84(a5)
 30023e0:	47bd                	li	a5,15
 30023e2:	00e7fa63          	bgeu	a5,a4,30023f6 <APT_SetTimerInterrupt+0x2a>
 30023e6:	15100593          	li	a1,337
 30023ea:	030127b7          	lui	a5,0x3012
 30023ee:	b1478513          	addi	a0,a5,-1260 # 3011b14 <g_crgIpMatch+0x27c>
 30023f2:	2435                	jal	ra,300261e <AssertErrorLog.trans.1>
 30023f4:	a095                	j	3002458 <APT_SetTimerInterrupt+0x8c>
    aptHandle->baseAddress->INT_TMR_SEL.BIT.rg_int_tmr_sel = aptHandle->tmrInterrupt.tmrInterruptSrc;
 30023f6:	fec42783          	lw	a5,-20(s0)
 30023fa:	4bb4                	lw	a3,80(a5)
 30023fc:	fec42783          	lw	a5,-20(s0)
 3002400:	4398                	lw	a4,0(a5)
 3002402:	87b6                	mv	a5,a3
 3002404:	8bbd                	andi	a5,a5,15
 3002406:	0ff7f693          	andi	a3,a5,255
 300240a:	42472783          	lw	a5,1060(a4)
 300240e:	8abd                	andi	a3,a3,15
 3002410:	9bc1                	andi	a5,a5,-16
 3002412:	8fd5                	or	a5,a5,a3
 3002414:	42f72223          	sw	a5,1060(a4)
    aptHandle->baseAddress->INT_PRSC_CFG.BIT.rg_int_prsc_prd = aptHandle->tmrInterrupt.tmrInterruptScale;
 3002418:	fec42783          	lw	a5,-20(s0)
 300241c:	0547d683          	lhu	a3,84(a5)
 3002420:	fec42783          	lw	a5,-20(s0)
 3002424:	4398                	lw	a4,0(a5)
 3002426:	87b6                	mv	a5,a3
 3002428:	8bbd                	andi	a5,a5,15
 300242a:	0ff7f693          	andi	a3,a5,255
 300242e:	42872783          	lw	a5,1064(a4)
 3002432:	8abd                	andi	a3,a3,15
 3002434:	9bc1                	andi	a5,a5,-16
 3002436:	8fd5                	or	a5,a5,a3
 3002438:	42f72423          	sw	a5,1064(a4)
    aptHandle->baseAddress->INT_TMR_EN.BIT.rg_int_en_tmr = aptHandle->tmrInterrupt.tmrInterruptEn;
 300243c:	fec42783          	lw	a5,-20(s0)
 3002440:	4398                	lw	a4,0(a5)
 3002442:	fec42783          	lw	a5,-20(s0)
 3002446:	04c7c683          	lbu	a3,76(a5)
 300244a:	41472783          	lw	a5,1044(a4)
 300244e:	8a85                	andi	a3,a3,1
 3002450:	9bf9                	andi	a5,a5,-2
 3002452:	8fd5                	or	a5,a5,a3
 3002454:	40f72a23          	sw	a5,1044(a4)
}
 3002458:	40f2                	lw	ra,28(sp)
 300245a:	4462                	lw	s0,24(sp)
 300245c:	6105                	addi	sp,sp,32
 300245e:	8082                	ret

03002460 <HAL_APT_PWMInit>:
  * @brief Initialize the APT hardware configuration based on the APT module handle.
  * @param aptHandle APT module handle.
  * @retval BASE_StatusType: OK, ERROR, BUSY, TIMEOUT.
  */
BASE_StatusType HAL_APT_PWMInit(APT_Handle *aptHandle)
{
 3002460:	1101                	addi	sp,sp,-32
 3002462:	ce06                	sw	ra,28(sp)
 3002464:	cc22                	sw	s0,24(sp)
 3002466:	1000                	addi	s0,sp,32
 3002468:	fea42623          	sw	a0,-20(s0)
    APT_ASSERT_PARAM(aptHandle != NULL);
 300246c:	fec42783          	lw	a5,-20(s0)
 3002470:	eb89                	bnez	a5,3002482 <HAL_APT_PWMInit+0x22>
 3002472:	15e00593          	li	a1,350
 3002476:	030127b7          	lui	a5,0x3012
 300247a:	b1478513          	addi	a0,a5,-1260 # 3011b14 <g_crgIpMatch+0x27c>
 300247e:	2245                	jal	ra,300261e <AssertErrorLog.trans.1>
 3002480:	a001                	j	3002480 <HAL_APT_PWMInit+0x20>
    APT_ASSERT_PARAM(IsAPTInstance(aptHandle->baseAddress));
 3002482:	fec42783          	lw	a5,-20(s0)
 3002486:	4398                	lw	a4,0(a5)
 3002488:	14a007b7          	lui	a5,0x14a00
 300248c:	02f70f63          	beq	a4,a5,30024ca <HAL_APT_PWMInit+0x6a>
 3002490:	fec42783          	lw	a5,-20(s0)
 3002494:	4398                	lw	a4,0(a5)
 3002496:	14a017b7          	lui	a5,0x14a01
 300249a:	02f70863          	beq	a4,a5,30024ca <HAL_APT_PWMInit+0x6a>
 300249e:	fec42783          	lw	a5,-20(s0)
 30024a2:	4398                	lw	a4,0(a5)
 30024a4:	14a027b7          	lui	a5,0x14a02
 30024a8:	02f70163          	beq	a4,a5,30024ca <HAL_APT_PWMInit+0x6a>
 30024ac:	fec42783          	lw	a5,-20(s0)
 30024b0:	4398                	lw	a4,0(a5)
 30024b2:	14a037b7          	lui	a5,0x14a03
 30024b6:	00f70a63          	beq	a4,a5,30024ca <HAL_APT_PWMInit+0x6a>
 30024ba:	15f00593          	li	a1,351
 30024be:	030127b7          	lui	a5,0x3012
 30024c2:	b1478513          	addi	a0,a5,-1260 # 3011b14 <g_crgIpMatch+0x27c>
 30024c6:	2aa1                	jal	ra,300261e <AssertErrorLog.trans.1>
 30024c8:	a001                	j	30024c8 <HAL_APT_PWMInit+0x68>
    APT_PARAM_CHECK_WITH_RET(aptHandle->waveform.dividerFactor <= DIVIDER_FACTOR_MAX, BASE_STATUS_ERROR);
 30024ca:	fec42783          	lw	a5,-20(s0)
 30024ce:	2bda                	lhu	a4,20(a5)
 30024d0:	6785                	lui	a5,0x1
 30024d2:	00f76b63          	bltu	a4,a5,30024e8 <HAL_APT_PWMInit+0x88>
 30024d6:	16000593          	li	a1,352
 30024da:	030127b7          	lui	a5,0x3012
 30024de:	b1478513          	addi	a0,a5,-1260 # 3011b14 <g_crgIpMatch+0x27c>
 30024e2:	2a35                	jal	ra,300261e <AssertErrorLog.trans.1>
 30024e4:	4785                	li	a5,1
 30024e6:	a23d                	j	3002614 <HAL_APT_PWMInit+0x1b4>
    APT_PARAM_CHECK_WITH_RET(aptHandle->waveform.divInitVal <= aptHandle->waveform.dividerFactor, BASE_STATUS_ERROR);
 30024e8:	fec42783          	lw	a5,-20(s0)
 30024ec:	2f9a                	lhu	a4,24(a5)
 30024ee:	fec42783          	lw	a5,-20(s0)
 30024f2:	2bde                	lhu	a5,20(a5)
 30024f4:	00e7fb63          	bgeu	a5,a4,300250a <HAL_APT_PWMInit+0xaa>
 30024f8:	16100593          	li	a1,353
 30024fc:	030127b7          	lui	a5,0x3012
 3002500:	b1478513          	addi	a0,a5,-1260 # 3011b14 <g_crgIpMatch+0x27c>
 3002504:	2a29                	jal	ra,300261e <AssertErrorLog.trans.1>
 3002506:	4785                	li	a5,1
 3002508:	a231                	j	3002614 <HAL_APT_PWMInit+0x1b4>
    APT_PARAM_CHECK_WITH_RET(aptHandle->waveform.cntInitVal < aptHandle->waveform.timerPeriod, BASE_STATUS_ERROR);
 300250a:	fec42783          	lw	a5,-20(s0)
 300250e:	2fba                	lhu	a4,26(a5)
 3002510:	fec42783          	lw	a5,-20(s0)
 3002514:	2bfe                	lhu	a5,22(a5)
 3002516:	00f76b63          	bltu	a4,a5,300252c <HAL_APT_PWMInit+0xcc>
 300251a:	16200593          	li	a1,354
 300251e:	030127b7          	lui	a5,0x3012
 3002522:	b1478513          	addi	a0,a5,-1260 # 3011b14 <g_crgIpMatch+0x27c>
 3002526:	28e5                	jal	ra,300261e <AssertErrorLog.trans.1>
 3002528:	4785                	li	a5,1
 300252a:	a0ed                	j	3002614 <HAL_APT_PWMInit+0x1b4>
    APT_PARAM_CHECK_WITH_RET(aptHandle->waveform.cntCmpLeftEdge > 0, BASE_STATUS_ERROR);
 300252c:	fec42783          	lw	a5,-20(s0)
 3002530:	2fde                	lhu	a5,28(a5)
 3002532:	eb91                	bnez	a5,3002546 <HAL_APT_PWMInit+0xe6>
 3002534:	16300593          	li	a1,355
 3002538:	030127b7          	lui	a5,0x3012
 300253c:	b1478513          	addi	a0,a5,-1260 # 3011b14 <g_crgIpMatch+0x27c>
 3002540:	28f9                	jal	ra,300261e <AssertErrorLog.trans.1>
 3002542:	4785                	li	a5,1
 3002544:	a8c1                	j	3002614 <HAL_APT_PWMInit+0x1b4>
    APT_PARAM_CHECK_WITH_RET(aptHandle->waveform.cntCmpLeftEdge < aptHandle->waveform.timerPeriod, BASE_STATUS_ERROR);
 3002546:	fec42783          	lw	a5,-20(s0)
 300254a:	2fda                	lhu	a4,28(a5)
 300254c:	fec42783          	lw	a5,-20(s0)
 3002550:	2bfe                	lhu	a5,22(a5)
 3002552:	00f76b63          	bltu	a4,a5,3002568 <HAL_APT_PWMInit+0x108>
 3002556:	16400593          	li	a1,356
 300255a:	030127b7          	lui	a5,0x3012
 300255e:	b1478513          	addi	a0,a5,-1260 # 3011b14 <g_crgIpMatch+0x27c>
 3002562:	2875                	jal	ra,300261e <AssertErrorLog.trans.1>
 3002564:	4785                	li	a5,1
 3002566:	a07d                	j	3002614 <HAL_APT_PWMInit+0x1b4>
    APT_PARAM_CHECK_WITH_RET(aptHandle->waveform.cntCmpRightEdge > 0, BASE_STATUS_ERROR);
 3002568:	fec42783          	lw	a5,-20(s0)
 300256c:	2ffe                	lhu	a5,30(a5)
 300256e:	eb91                	bnez	a5,3002582 <HAL_APT_PWMInit+0x122>
 3002570:	16500593          	li	a1,357
 3002574:	030127b7          	lui	a5,0x3012
 3002578:	b1478513          	addi	a0,a5,-1260 # 3011b14 <g_crgIpMatch+0x27c>
 300257c:	204d                	jal	ra,300261e <AssertErrorLog.trans.1>
 300257e:	4785                	li	a5,1
 3002580:	a851                	j	3002614 <HAL_APT_PWMInit+0x1b4>
    APT_PARAM_CHECK_WITH_RET(aptHandle->waveform.cntCmpRightEdge < aptHandle->waveform.timerPeriod, BASE_STATUS_ERROR);
 3002582:	fec42783          	lw	a5,-20(s0)
 3002586:	2ffa                	lhu	a4,30(a5)
 3002588:	fec42783          	lw	a5,-20(s0)
 300258c:	2bfe                	lhu	a5,22(a5)
 300258e:	00f76b63          	bltu	a4,a5,30025a4 <HAL_APT_PWMInit+0x144>
 3002592:	16600593          	li	a1,358
 3002596:	030127b7          	lui	a5,0x3012
 300259a:	b1478513          	addi	a0,a5,-1260 # 3011b14 <g_crgIpMatch+0x27c>
 300259e:	2041                	jal	ra,300261e <AssertErrorLog.trans.1>
 30025a0:	4785                	li	a5,1
 30025a2:	a88d                	j	3002614 <HAL_APT_PWMInit+0x1b4>
    APT_PARAM_CHECK_WITH_RET(aptHandle->adcTrg.cntCmpSOCA >= 0, BASE_STATUS_ERROR);
    APT_PARAM_CHECK_WITH_RET(aptHandle->adcTrg.cntCmpSOCA < aptHandle->waveform.timerPeriod, BASE_STATUS_ERROR);
 30025a4:	fec42783          	lw	a5,-20(s0)
 30025a8:	3bfa                	lhu	a4,54(a5)
 30025aa:	fec42783          	lw	a5,-20(s0)
 30025ae:	2bfe                	lhu	a5,22(a5)
 30025b0:	00f76b63          	bltu	a4,a5,30025c6 <HAL_APT_PWMInit+0x166>
 30025b4:	16800593          	li	a1,360
 30025b8:	030127b7          	lui	a5,0x3012
 30025bc:	b1478513          	addi	a0,a5,-1260 # 3011b14 <g_crgIpMatch+0x27c>
 30025c0:	28b9                	jal	ra,300261e <AssertErrorLog.trans.1>
 30025c2:	4785                	li	a5,1
 30025c4:	a881                	j	3002614 <HAL_APT_PWMInit+0x1b4>
    APT_PARAM_CHECK_WITH_RET(aptHandle->adcTrg.cntCmpSOCB >= 0, BASE_STATUS_ERROR);
    APT_PARAM_CHECK_WITH_RET(aptHandle->adcTrg.cntCmpSOCB < aptHandle->waveform.timerPeriod, BASE_STATUS_ERROR);
 30025c6:	fec42783          	lw	a5,-20(s0)
 30025ca:	0427d703          	lhu	a4,66(a5)
 30025ce:	fec42783          	lw	a5,-20(s0)
 30025d2:	2bfe                	lhu	a5,22(a5)
 30025d4:	00f76b63          	bltu	a4,a5,30025ea <HAL_APT_PWMInit+0x18a>
 30025d8:	16a00593          	li	a1,362
 30025dc:	030127b7          	lui	a5,0x3012
 30025e0:	b1478513          	addi	a0,a5,-1260 # 3011b14 <g_crgIpMatch+0x27c>
 30025e4:	282d                	jal	ra,300261e <AssertErrorLog.trans.1>
 30025e6:	4785                	li	a5,1
 30025e8:	a035                	j	3002614 <HAL_APT_PWMInit+0x1b4>
    APT_TimeBaseInit(aptHandle);
 30025ea:	fec42503          	lw	a0,-20(s0)
 30025ee:	b06ff0ef          	jal	ra,30018f4 <APT_TimeBaseInit>
    APT_SetPWMCompareVal(aptHandle);
 30025f2:	fec42503          	lw	a0,-20(s0)
 30025f6:	bb6ff0ef          	jal	ra,30019ac <APT_SetPWMCompareVal>
    APT_SetPWMWaveform(aptHandle);
 30025fa:	fec42503          	lw	a0,-20(s0)
 30025fe:	3a65                	jal	ra,3001fb6 <APT_SetPWMWaveform>
    APT_SetADCTrgCompareVal(aptHandle);
 3002600:	fec42503          	lw	a0,-20(s0)
 3002604:	34f9                	jal	ra,30020d2 <APT_SetADCTrgCompareVal>
    APT_SetADCTrigger(aptHandle);
 3002606:	fec42503          	lw	a0,-20(s0)
 300260a:	315d                	jal	ra,30022b0 <APT_SetADCTrigger>
    APT_SetTimerInterrupt(aptHandle);
 300260c:	fec42503          	lw	a0,-20(s0)
 3002610:	3b75                	jal	ra,30023cc <APT_SetTimerInterrupt>
    return BASE_STATUS_OK;
 3002612:	4781                	li	a5,0
}
 3002614:	853e                	mv	a0,a5
 3002616:	40f2                	lw	ra,28(sp)
 3002618:	4462                	lw	s0,24(sp)
 300261a:	6105                	addi	sp,sp,32
 300261c:	8082                	ret

0300261e <AssertErrorLog.trans.1>:
 300261e:	7340006f          	j	3002d52 <AssertErrorLog>

03002622 <HAL_APT_StartModule>:
  *            RUN_APT7 - apt7_run bit in SYSCTRL1 register.
  *            RUN_APT8 - apt8_run bit in SYSCTRL1 register.
  * @retval None.
  */
void HAL_APT_StartModule(unsigned int aptRunMask)
{
 3002622:	1101                	addi	sp,sp,-32
 3002624:	ce22                	sw	s0,28(sp)
 3002626:	1000                	addi	s0,sp,32
 3002628:	fea42623          	sw	a0,-20(s0)
    SYSCTRL1->APT_RUN.reg |= aptRunMask;
 300262c:	10100737          	lui	a4,0x10100
 3002630:	67a1                	lui	a5,0x8
 3002632:	97ba                	add	a5,a5,a4
 3002634:	4398                	lw	a4,0(a5)
 3002636:	101006b7          	lui	a3,0x10100
 300263a:	fec42783          	lw	a5,-20(s0)
 300263e:	8f5d                	or	a4,a4,a5
 3002640:	67a1                	lui	a5,0x8
 3002642:	97b6                	add	a5,a5,a3
 3002644:	c398                	sw	a4,0(a5)
}
 3002646:	0001                	nop
 3002648:	4472                	lw	s0,28(sp)
 300264a:	6105                	addi	sp,sp,32
 300264c:	8082                	ret

0300264e <HAL_APT_StopModule>:
  *            RUN_APT7 - apt7_run bit in SYSCTRL1 register.
  *            RUN_APT8 - apt8_run bit in SYSCTRL1 register.
  * @retval None.
  */
void HAL_APT_StopModule(unsigned int aptRunMask)
{
 300264e:	1101                	addi	sp,sp,-32
 3002650:	ce22                	sw	s0,28(sp)
 3002652:	1000                	addi	s0,sp,32
 3002654:	fea42623          	sw	a0,-20(s0)
    SYSCTRL1->APT_RUN.reg &= (~aptRunMask);
 3002658:	10100737          	lui	a4,0x10100
 300265c:	67a1                	lui	a5,0x8
 300265e:	97ba                	add	a5,a5,a4
 3002660:	4398                	lw	a4,0(a5)
 3002662:	fec42783          	lw	a5,-20(s0)
 3002666:	fff7c793          	not	a5,a5
 300266a:	101006b7          	lui	a3,0x10100
 300266e:	8f7d                	and	a4,a4,a5
 3002670:	67a1                	lui	a5,0x8
 3002672:	97b6                	add	a5,a5,a3
 3002674:	c398                	sw	a4,0(a5)
}
 3002676:	0001                	nop
 3002678:	4472                	lw	s0,28(sp)
 300267a:	6105                	addi	sp,sp,32
 300267c:	8082                	ret

0300267e <HAL_APT_SetPWMDutyByNumber>:
  * @param aptHandle APT module handle.
  * @param duty PWM duty. Range: 1 ~ 99.
  * @retval BASE_StatusType: OK, ERROR, BUSY, TIMEOUT.
  */
BASE_StatusType HAL_APT_SetPWMDutyByNumber(APT_Handle *aptHandle, unsigned int duty)
{
 300267e:	7179                	addi	sp,sp,-48
 3002680:	d606                	sw	ra,44(sp)
 3002682:	d422                	sw	s0,40(sp)
 3002684:	1800                	addi	s0,sp,48
 3002686:	fca42e23          	sw	a0,-36(s0)
 300268a:	fcb42c23          	sw	a1,-40(s0)
    APT_ASSERT_PARAM(aptHandle != NULL);
 300268e:	fdc42783          	lw	a5,-36(s0)
 3002692:	eb89                	bnez	a5,30026a4 <HAL_APT_SetPWMDutyByNumber+0x26>
 3002694:	42d00593          	li	a1,1069
 3002698:	030127b7          	lui	a5,0x3012
 300269c:	b1478513          	addi	a0,a5,-1260 # 3011b14 <g_crgIpMatch+0x27c>
 30026a0:	2d4d                	jal	ra,3002d52 <AssertErrorLog>
 30026a2:	a001                	j	30026a2 <HAL_APT_SetPWMDutyByNumber+0x24>
    APT_ASSERT_PARAM(IsAPTInstance(aptHandle->baseAddress));
 30026a4:	fdc42783          	lw	a5,-36(s0)
 30026a8:	4398                	lw	a4,0(a5)
 30026aa:	14a007b7          	lui	a5,0x14a00
 30026ae:	02f70f63          	beq	a4,a5,30026ec <HAL_APT_SetPWMDutyByNumber+0x6e>
 30026b2:	fdc42783          	lw	a5,-36(s0)
 30026b6:	4398                	lw	a4,0(a5)
 30026b8:	14a017b7          	lui	a5,0x14a01
 30026bc:	02f70863          	beq	a4,a5,30026ec <HAL_APT_SetPWMDutyByNumber+0x6e>
 30026c0:	fdc42783          	lw	a5,-36(s0)
 30026c4:	4398                	lw	a4,0(a5)
 30026c6:	14a027b7          	lui	a5,0x14a02
 30026ca:	02f70163          	beq	a4,a5,30026ec <HAL_APT_SetPWMDutyByNumber+0x6e>
 30026ce:	fdc42783          	lw	a5,-36(s0)
 30026d2:	4398                	lw	a4,0(a5)
 30026d4:	14a037b7          	lui	a5,0x14a03
 30026d8:	00f70a63          	beq	a4,a5,30026ec <HAL_APT_SetPWMDutyByNumber+0x6e>
 30026dc:	42e00593          	li	a1,1070
 30026e0:	030127b7          	lui	a5,0x3012
 30026e4:	b1478513          	addi	a0,a5,-1260 # 3011b14 <g_crgIpMatch+0x27c>
 30026e8:	25ad                	jal	ra,3002d52 <AssertErrorLog>
 30026ea:	a001                	j	30026ea <HAL_APT_SetPWMDutyByNumber+0x6c>
    APT_PARAM_CHECK_WITH_RET(duty < MAX_DUTY, BASE_STATUS_ERROR);
 30026ec:	fd842703          	lw	a4,-40(s0)
 30026f0:	06300793          	li	a5,99
 30026f4:	00e7fb63          	bgeu	a5,a4,300270a <HAL_APT_SetPWMDutyByNumber+0x8c>
 30026f8:	42f00593          	li	a1,1071
 30026fc:	030127b7          	lui	a5,0x3012
 3002700:	b1478513          	addi	a0,a5,-1260 # 3011b14 <g_crgIpMatch+0x27c>
 3002704:	25b9                	jal	ra,3002d52 <AssertErrorLog>
 3002706:	4785                	li	a5,1
 3002708:	aa01                	j	3002818 <HAL_APT_SetPWMDutyByNumber+0x19a>
    APT_PARAM_CHECK_WITH_RET(duty > 0, BASE_STATUS_ERROR);
 300270a:	fd842783          	lw	a5,-40(s0)
 300270e:	eb91                	bnez	a5,3002722 <HAL_APT_SetPWMDutyByNumber+0xa4>
 3002710:	43000593          	li	a1,1072
 3002714:	030127b7          	lui	a5,0x3012
 3002718:	b1478513          	addi	a0,a5,-1260 # 3011b14 <g_crgIpMatch+0x27c>
 300271c:	2d1d                	jal	ra,3002d52 <AssertErrorLog>
 300271e:	4785                	li	a5,1
 3002720:	a8e5                	j	3002818 <HAL_APT_SetPWMDutyByNumber+0x19a>

    unsigned int cntCmpLeftEdge, cntCmpRightEdge;
    TC_REFC_REG tmpC;
    TC_REFD_REG tmpD;

    if (aptHandle->waveform.cntMode == APT_COUNT_MODE_UP_DOWN) {
 3002722:	fdc42783          	lw	a5,-36(s0)
 3002726:	4b98                	lw	a4,16(a5)
 3002728:	4789                	li	a5,2
 300272a:	04f71263          	bne	a4,a5,300276e <HAL_APT_SetPWMDutyByNumber+0xf0>
        cntCmpLeftEdge = aptHandle->waveform.timerPeriod - \
 300272e:	fdc42783          	lw	a5,-36(s0)
 3002732:	2bfe                	lhu	a5,22(a5)
 3002734:	873e                	mv	a4,a5
                         (int)(((float)aptHandle->waveform.timerPeriod / MAX_DUTY) * duty);
 3002736:	fdc42783          	lw	a5,-36(s0)
 300273a:	2bfe                	lhu	a5,22(a5)
 300273c:	d017f753          	fcvt.s.wu	fa4,a5
 3002740:	030127b7          	lui	a5,0x3012
 3002744:	b407a787          	flw	fa5,-1216(a5) # 3011b40 <g_crgIpMatch+0x2a8>
 3002748:	18f77753          	fdiv.s	fa4,fa4,fa5
 300274c:	fd842783          	lw	a5,-40(s0)
 3002750:	d017f7d3          	fcvt.s.wu	fa5,a5
 3002754:	10f777d3          	fmul.s	fa5,fa4,fa5
 3002758:	c00797d3          	fcvt.w.s	a5,fa5,rtz
        cntCmpLeftEdge = aptHandle->waveform.timerPeriod - \
 300275c:	40f707b3          	sub	a5,a4,a5
 3002760:	fef42623          	sw	a5,-20(s0)
        cntCmpRightEdge = cntCmpLeftEdge;
 3002764:	fec42783          	lw	a5,-20(s0)
 3002768:	fef42423          	sw	a5,-24(s0)
 300276c:	a83d                	j	30027aa <HAL_APT_SetPWMDutyByNumber+0x12c>
    } else {
        cntCmpLeftEdge = 1;
 300276e:	4785                	li	a5,1
 3002770:	fef42623          	sw	a5,-20(s0)
        cntCmpRightEdge = (int)(((float)aptHandle->waveform.timerPeriod / MAX_DUTY) * duty + cntCmpLeftEdge);
 3002774:	fdc42783          	lw	a5,-36(s0)
 3002778:	2bfe                	lhu	a5,22(a5)
 300277a:	d017f753          	fcvt.s.wu	fa4,a5
 300277e:	030127b7          	lui	a5,0x3012
 3002782:	b407a787          	flw	fa5,-1216(a5) # 3011b40 <g_crgIpMatch+0x2a8>
 3002786:	18f77753          	fdiv.s	fa4,fa4,fa5
 300278a:	fd842783          	lw	a5,-40(s0)
 300278e:	d017f7d3          	fcvt.s.wu	fa5,a5
 3002792:	10f77753          	fmul.s	fa4,fa4,fa5
 3002796:	fec42783          	lw	a5,-20(s0)
 300279a:	d017f7d3          	fcvt.s.wu	fa5,a5
 300279e:	00f777d3          	fadd.s	fa5,fa4,fa5
 30027a2:	c00797d3          	fcvt.w.s	a5,fa5,rtz
 30027a6:	fef42423          	sw	a5,-24(s0)
    }
    tmpC = aptHandle->baseAddress->TC_REFC;
 30027aa:	fdc42783          	lw	a5,-36(s0)
 30027ae:	439c                	lw	a5,0(a5)
 30027b0:	5f9c                	lw	a5,56(a5)
 30027b2:	fef42223          	sw	a5,-28(s0)
    tmpC.BIT.rg_cnt_refc = cntCmpLeftEdge;
 30027b6:	fec42783          	lw	a5,-20(s0)
 30027ba:	01079693          	slli	a3,a5,0x10
 30027be:	82c1                	srli	a3,a3,0x10
 30027c0:	fe442783          	lw	a5,-28(s0)
 30027c4:	6741                	lui	a4,0x10
 30027c6:	177d                	addi	a4,a4,-1 # ffff <RAM_SIZE+0xafff>
 30027c8:	8f75                	and	a4,a4,a3
 30027ca:	76c1                	lui	a3,0xffff0
 30027cc:	8ff5                	and	a5,a5,a3
 30027ce:	8fd9                	or	a5,a5,a4
 30027d0:	fef42223          	sw	a5,-28(s0)
    aptHandle->baseAddress->TC_REFC = tmpC;
 30027d4:	fdc42783          	lw	a5,-36(s0)
 30027d8:	439c                	lw	a5,0(a5)
 30027da:	fe442703          	lw	a4,-28(s0)
 30027de:	df98                	sw	a4,56(a5)
    tmpD = aptHandle->baseAddress->TC_REFD;
 30027e0:	fdc42783          	lw	a5,-36(s0)
 30027e4:	439c                	lw	a5,0(a5)
 30027e6:	5fdc                	lw	a5,60(a5)
 30027e8:	fef42023          	sw	a5,-32(s0)
    tmpD.BIT.rg_cnt_refd = cntCmpRightEdge;
 30027ec:	fe842783          	lw	a5,-24(s0)
 30027f0:	01079693          	slli	a3,a5,0x10
 30027f4:	82c1                	srli	a3,a3,0x10
 30027f6:	fe042783          	lw	a5,-32(s0)
 30027fa:	6741                	lui	a4,0x10
 30027fc:	177d                	addi	a4,a4,-1 # ffff <RAM_SIZE+0xafff>
 30027fe:	8f75                	and	a4,a4,a3
 3002800:	76c1                	lui	a3,0xffff0
 3002802:	8ff5                	and	a5,a5,a3
 3002804:	8fd9                	or	a5,a5,a4
 3002806:	fef42023          	sw	a5,-32(s0)
    aptHandle->baseAddress->TC_REFD = tmpD;
 300280a:	fdc42783          	lw	a5,-36(s0)
 300280e:	439c                	lw	a5,0(a5)
 3002810:	fe042703          	lw	a4,-32(s0)
 3002814:	dfd8                	sw	a4,60(a5)
    return BASE_STATUS_OK;
 3002816:	4781                	li	a5,0
}
 3002818:	853e                	mv	a0,a5
 300281a:	50b2                	lw	ra,44(sp)
 300281c:	5422                	lw	s0,40(sp)
 300281e:	6145                	addi	sp,sp,48
 3002820:	8082                	ret

03002822 <APT_ConfigAction>:
  * @param aptHandle APT module handle.
  * @param refDotParameters Attribute structure of a reference point.
  * @retval BASE_StatusType: OK, ERROR.
  */
static BASE_StatusType APT_ConfigAction(APT_Handle *aptHandle, APT_RefDotParameters *refDotParameters)
{
 3002822:	1101                	addi	sp,sp,-32
 3002824:	ce22                	sw	s0,28(sp)
 3002826:	1000                	addi	s0,sp,32
 3002828:	fea42623          	sw	a0,-20(s0)
 300282c:	feb42423          	sw	a1,-24(s0)
    /* Action configuration of the reference point of channel B. */
    if (refDotParameters->pwmChannel == APT_PWM_CHANNEL_B) {
 3002830:	fe842783          	lw	a5,-24(s0)
 3002834:	43d8                	lw	a4,4(a5)
 3002836:	4785                	li	a5,1
 3002838:	04f71b63          	bne	a4,a5,300288e <APT_ConfigAction+0x6c>
        aptHandle->baseAddress->PG_ACT_B.reg &= (~(0b11 << refDotParameters->actionEvent)); /* Reset configuration */
 300283c:	fec42783          	lw	a5,-20(s0)
 3002840:	439c                	lw	a5,0(a5)
 3002842:	1047a703          	lw	a4,260(a5)
 3002846:	fe842783          	lw	a5,-24(s0)
 300284a:	479c                	lw	a5,8(a5)
 300284c:	468d                	li	a3,3
 300284e:	00f697b3          	sll	a5,a3,a5
 3002852:	fff7c793          	not	a5,a5
 3002856:	86be                	mv	a3,a5
 3002858:	fec42783          	lw	a5,-20(s0)
 300285c:	439c                	lw	a5,0(a5)
 300285e:	8f75                	and	a4,a4,a3
 3002860:	10e7a223          	sw	a4,260(a5)
        aptHandle->baseAddress->PG_ACT_B.reg |=  (refDotParameters->action << refDotParameters->actionEvent);
 3002864:	fec42783          	lw	a5,-20(s0)
 3002868:	439c                	lw	a5,0(a5)
 300286a:	1047a683          	lw	a3,260(a5)
 300286e:	fe842783          	lw	a5,-24(s0)
 3002872:	47d8                	lw	a4,12(a5)
 3002874:	fe842783          	lw	a5,-24(s0)
 3002878:	479c                	lw	a5,8(a5)
 300287a:	00f71733          	sll	a4,a4,a5
 300287e:	fec42783          	lw	a5,-20(s0)
 3002882:	439c                	lw	a5,0(a5)
 3002884:	8f55                	or	a4,a4,a3
 3002886:	10e7a223          	sw	a4,260(a5)
        return BASE_STATUS_OK;
 300288a:	4781                	li	a5,0
 300288c:	a8b9                	j	30028ea <APT_ConfigAction+0xc8>
    }
    /* Action configuration of the reference point of channel A. */
    if (refDotParameters->pwmChannel == APT_PWM_CHANNEL_A) {
 300288e:	fe842783          	lw	a5,-24(s0)
 3002892:	43dc                	lw	a5,4(a5)
 3002894:	ebb1                	bnez	a5,30028e8 <APT_ConfigAction+0xc6>
        aptHandle->baseAddress->PG_ACT_A.reg &= (~(0b11 << refDotParameters->actionEvent)); /* Reset configuration */
 3002896:	fec42783          	lw	a5,-20(s0)
 300289a:	439c                	lw	a5,0(a5)
 300289c:	1007a703          	lw	a4,256(a5)
 30028a0:	fe842783          	lw	a5,-24(s0)
 30028a4:	479c                	lw	a5,8(a5)
 30028a6:	468d                	li	a3,3
 30028a8:	00f697b3          	sll	a5,a3,a5
 30028ac:	fff7c793          	not	a5,a5
 30028b0:	86be                	mv	a3,a5
 30028b2:	fec42783          	lw	a5,-20(s0)
 30028b6:	439c                	lw	a5,0(a5)
 30028b8:	8f75                	and	a4,a4,a3
 30028ba:	10e7a023          	sw	a4,256(a5)
        aptHandle->baseAddress->PG_ACT_A.reg |=  (refDotParameters->action << refDotParameters->actionEvent);
 30028be:	fec42783          	lw	a5,-20(s0)
 30028c2:	439c                	lw	a5,0(a5)
 30028c4:	1007a683          	lw	a3,256(a5)
 30028c8:	fe842783          	lw	a5,-24(s0)
 30028cc:	47d8                	lw	a4,12(a5)
 30028ce:	fe842783          	lw	a5,-24(s0)
 30028d2:	479c                	lw	a5,8(a5)
 30028d4:	00f71733          	sll	a4,a4,a5
 30028d8:	fec42783          	lw	a5,-20(s0)
 30028dc:	439c                	lw	a5,0(a5)
 30028de:	8f55                	or	a4,a4,a3
 30028e0:	10e7a023          	sw	a4,256(a5)
        return BASE_STATUS_OK;
 30028e4:	4781                	li	a5,0
 30028e6:	a011                	j	30028ea <APT_ConfigAction+0xc8>
    }
    return BASE_STATUS_ERROR;
 30028e8:	4785                	li	a5,1
}
 30028ea:	853e                	mv	a0,a5
 30028ec:	4472                	lw	s0,28(sp)
 30028ee:	6105                	addi	sp,sp,32
 30028f0:	8082                	ret

030028f2 <APT_ConfigRefA>:
  * @param aptHandle APT module handle.
  * @param refDotParameters Reference point A configuration property set.
  * @retval BASE_StatusType: OK, ERROR.
  */
BASE_StatusType APT_ConfigRefA(APT_Handle *aptHandle, APT_RefDotParameters *refDotParameters)
{
 30028f2:	1101                	addi	sp,sp,-32
 30028f4:	ce06                	sw	ra,28(sp)
 30028f6:	cc22                	sw	s0,24(sp)
 30028f8:	1000                	addi	s0,sp,32
 30028fa:	fea42623          	sw	a0,-20(s0)
 30028fe:	feb42423          	sw	a1,-24(s0)
    APT_ASSERT_PARAM(aptHandle != NULL);
 3002902:	fec42783          	lw	a5,-20(s0)
 3002906:	eb89                	bnez	a5,3002918 <APT_ConfigRefA+0x26>
 3002908:	51c00593          	li	a1,1308
 300290c:	030127b7          	lui	a5,0x3012
 3002910:	b1478513          	addi	a0,a5,-1260 # 3011b14 <g_crgIpMatch+0x27c>
 3002914:	293d                	jal	ra,3002d52 <AssertErrorLog>
 3002916:	a001                	j	3002916 <APT_ConfigRefA+0x24>
    APT_ASSERT_PARAM(aptHandle->baseAddress != NULL);
 3002918:	fec42783          	lw	a5,-20(s0)
 300291c:	439c                	lw	a5,0(a5)
 300291e:	eb89                	bnez	a5,3002930 <APT_ConfigRefA+0x3e>
 3002920:	51d00593          	li	a1,1309
 3002924:	030127b7          	lui	a5,0x3012
 3002928:	b1478513          	addi	a0,a5,-1260 # 3011b14 <g_crgIpMatch+0x27c>
 300292c:	211d                	jal	ra,3002d52 <AssertErrorLog>
 300292e:	a001                	j	300292e <APT_ConfigRefA+0x3c>
    APT_ASSERT_PARAM(IsAPTInstance(aptHandle->baseAddress));
 3002930:	fec42783          	lw	a5,-20(s0)
 3002934:	4398                	lw	a4,0(a5)
 3002936:	14a007b7          	lui	a5,0x14a00
 300293a:	02f70f63          	beq	a4,a5,3002978 <APT_ConfigRefA+0x86>
 300293e:	fec42783          	lw	a5,-20(s0)
 3002942:	4398                	lw	a4,0(a5)
 3002944:	14a017b7          	lui	a5,0x14a01
 3002948:	02f70863          	beq	a4,a5,3002978 <APT_ConfigRefA+0x86>
 300294c:	fec42783          	lw	a5,-20(s0)
 3002950:	4398                	lw	a4,0(a5)
 3002952:	14a027b7          	lui	a5,0x14a02
 3002956:	02f70163          	beq	a4,a5,3002978 <APT_ConfigRefA+0x86>
 300295a:	fec42783          	lw	a5,-20(s0)
 300295e:	4398                	lw	a4,0(a5)
 3002960:	14a037b7          	lui	a5,0x14a03
 3002964:	00f70a63          	beq	a4,a5,3002978 <APT_ConfigRefA+0x86>
 3002968:	51e00593          	li	a1,1310
 300296c:	030127b7          	lui	a5,0x3012
 3002970:	b1478513          	addi	a0,a5,-1260 # 3011b14 <g_crgIpMatch+0x27c>
 3002974:	2ef9                	jal	ra,3002d52 <AssertErrorLog>
 3002976:	a001                	j	3002976 <APT_ConfigRefA+0x84>
    /* Check the attributes of the reference point A: PWM Channel. */
    APT_PARAM_CHECK_WITH_RET(refDotParameters->pwmChannel >= APT_PWM_CHANNEL_A, BASE_STATUS_ERROR);
    APT_PARAM_CHECK_WITH_RET(refDotParameters->pwmChannel <= APT_PWM_CHANNEL_B, BASE_STATUS_ERROR);
 3002978:	fe842783          	lw	a5,-24(s0)
 300297c:	43d8                	lw	a4,4(a5)
 300297e:	4785                	li	a5,1
 3002980:	00e7fb63          	bgeu	a5,a4,3002996 <APT_ConfigRefA+0xa4>
 3002984:	52100593          	li	a1,1313
 3002988:	030127b7          	lui	a5,0x3012
 300298c:	b1478513          	addi	a0,a5,-1260 # 3011b14 <g_crgIpMatch+0x27c>
 3002990:	26c9                	jal	ra,3002d52 <AssertErrorLog>
 3002992:	4785                	li	a5,1
 3002994:	a0b5                	j	3002a00 <APT_ConfigRefA+0x10e>
    /* Check the attributes of the reference point A: triggle action event. */
    APT_PARAM_CHECK_WITH_RET(refDotParameters->actionEvent >= APT_PWM_ACTION_ON_TIMEBASE_ZERO, BASE_STATUS_ERROR);
    APT_PARAM_CHECK_WITH_RET(refDotParameters->actionEvent <= APT_PWM_ACTION_ON_C2_COUNT_DOWN, BASE_STATUS_ERROR);
 3002996:	fe842783          	lw	a5,-24(s0)
 300299a:	4798                	lw	a4,8(a5)
 300299c:	47e9                	li	a5,26
 300299e:	00e7fb63          	bgeu	a5,a4,30029b4 <APT_ConfigRefA+0xc2>
 30029a2:	52400593          	li	a1,1316
 30029a6:	030127b7          	lui	a5,0x3012
 30029aa:	b1478513          	addi	a0,a5,-1260 # 3011b14 <g_crgIpMatch+0x27c>
 30029ae:	2655                	jal	ra,3002d52 <AssertErrorLog>
 30029b0:	4785                	li	a5,1
 30029b2:	a0b9                	j	3002a00 <APT_ConfigRefA+0x10e>
    /* Check the attributes of the reference point A: triggle action. */
    APT_PARAM_CHECK_WITH_RET(refDotParameters->action <= APT_PWM_ACTION_TOGGLE, BASE_STATUS_ERROR);
 30029b4:	fe842783          	lw	a5,-24(s0)
 30029b8:	47d8                	lw	a4,12(a5)
 30029ba:	478d                	li	a5,3
 30029bc:	00e7fb63          	bgeu	a5,a4,30029d2 <APT_ConfigRefA+0xe0>
 30029c0:	52600593          	li	a1,1318
 30029c4:	030127b7          	lui	a5,0x3012
 30029c8:	b1478513          	addi	a0,a5,-1260 # 3011b14 <g_crgIpMatch+0x27c>
 30029cc:	2659                	jal	ra,3002d52 <AssertErrorLog>
 30029ce:	4785                	li	a5,1
 30029d0:	a805                	j	3002a00 <APT_ConfigRefA+0x10e>
    /* Change reference dot A value and division value. */
    aptHandle->baseAddress->TC_REFA.BIT.rg_cnt_refa = refDotParameters->refDotValue;
 30029d2:	fe842783          	lw	a5,-24(s0)
 30029d6:	4394                	lw	a3,0(a5)
 30029d8:	fec42783          	lw	a5,-20(s0)
 30029dc:	4398                	lw	a4,0(a5)
 30029de:	01069613          	slli	a2,a3,0x10
 30029e2:	8241                	srli	a2,a2,0x10
 30029e4:	5b1c                	lw	a5,48(a4)
 30029e6:	66c1                	lui	a3,0x10
 30029e8:	16fd                	addi	a3,a3,-1 # ffff <RAM_SIZE+0xafff>
 30029ea:	8ef1                	and	a3,a3,a2
 30029ec:	7641                	lui	a2,0xffff0
 30029ee:	8ff1                	and	a5,a5,a2
 30029f0:	8fd5                	or	a5,a5,a3
 30029f2:	db1c                	sw	a5,48(a4)
    /* Reference dot A triggle event and action */
    return APT_ConfigAction(aptHandle, refDotParameters);
 30029f4:	fe842583          	lw	a1,-24(s0)
 30029f8:	fec42503          	lw	a0,-20(s0)
 30029fc:	351d                	jal	ra,3002822 <APT_ConfigAction>
 30029fe:	87aa                	mv	a5,a0
}
 3002a00:	853e                	mv	a0,a5
 3002a02:	40f2                	lw	ra,28(sp)
 3002a04:	4462                	lw	s0,24(sp)
 3002a06:	6105                	addi	sp,sp,32
 3002a08:	8082                	ret

03002a0a <APT_ConfigRefB>:
  * @param aptHandle APT module handle.
  * @param refDotParameters Reference point B configuration property set.
  * @retval BASE_StatusType: OK, ERROR.
  */
BASE_StatusType APT_ConfigRefB(APT_Handle *aptHandle, APT_RefDotParameters *refDotParameters)
{
 3002a0a:	1101                	addi	sp,sp,-32
 3002a0c:	ce06                	sw	ra,28(sp)
 3002a0e:	cc22                	sw	s0,24(sp)
 3002a10:	1000                	addi	s0,sp,32
 3002a12:	fea42623          	sw	a0,-20(s0)
 3002a16:	feb42423          	sw	a1,-24(s0)
    APT_ASSERT_PARAM(aptHandle != NULL);
 3002a1a:	fec42783          	lw	a5,-20(s0)
 3002a1e:	eb89                	bnez	a5,3002a30 <APT_ConfigRefB+0x26>
 3002a20:	53500593          	li	a1,1333
 3002a24:	030127b7          	lui	a5,0x3012
 3002a28:	b1478513          	addi	a0,a5,-1260 # 3011b14 <g_crgIpMatch+0x27c>
 3002a2c:	261d                	jal	ra,3002d52 <AssertErrorLog>
 3002a2e:	a001                	j	3002a2e <APT_ConfigRefB+0x24>
    APT_ASSERT_PARAM(aptHandle->baseAddress != NULL);
 3002a30:	fec42783          	lw	a5,-20(s0)
 3002a34:	439c                	lw	a5,0(a5)
 3002a36:	eb89                	bnez	a5,3002a48 <APT_ConfigRefB+0x3e>
 3002a38:	53600593          	li	a1,1334
 3002a3c:	030127b7          	lui	a5,0x3012
 3002a40:	b1478513          	addi	a0,a5,-1260 # 3011b14 <g_crgIpMatch+0x27c>
 3002a44:	2639                	jal	ra,3002d52 <AssertErrorLog>
 3002a46:	a001                	j	3002a46 <APT_ConfigRefB+0x3c>
    APT_ASSERT_PARAM(IsAPTInstance(aptHandle->baseAddress));
 3002a48:	fec42783          	lw	a5,-20(s0)
 3002a4c:	4398                	lw	a4,0(a5)
 3002a4e:	14a007b7          	lui	a5,0x14a00
 3002a52:	02f70f63          	beq	a4,a5,3002a90 <APT_ConfigRefB+0x86>
 3002a56:	fec42783          	lw	a5,-20(s0)
 3002a5a:	4398                	lw	a4,0(a5)
 3002a5c:	14a017b7          	lui	a5,0x14a01
 3002a60:	02f70863          	beq	a4,a5,3002a90 <APT_ConfigRefB+0x86>
 3002a64:	fec42783          	lw	a5,-20(s0)
 3002a68:	4398                	lw	a4,0(a5)
 3002a6a:	14a027b7          	lui	a5,0x14a02
 3002a6e:	02f70163          	beq	a4,a5,3002a90 <APT_ConfigRefB+0x86>
 3002a72:	fec42783          	lw	a5,-20(s0)
 3002a76:	4398                	lw	a4,0(a5)
 3002a78:	14a037b7          	lui	a5,0x14a03
 3002a7c:	00f70a63          	beq	a4,a5,3002a90 <APT_ConfigRefB+0x86>
 3002a80:	53700593          	li	a1,1335
 3002a84:	030127b7          	lui	a5,0x3012
 3002a88:	b1478513          	addi	a0,a5,-1260 # 3011b14 <g_crgIpMatch+0x27c>
 3002a8c:	24d9                	jal	ra,3002d52 <AssertErrorLog>
 3002a8e:	a001                	j	3002a8e <APT_ConfigRefB+0x84>
    /* Check the attributes of the reference point B: PWM Channel. */
    APT_PARAM_CHECK_WITH_RET(refDotParameters->pwmChannel >= APT_PWM_CHANNEL_A, BASE_STATUS_ERROR);
    APT_PARAM_CHECK_WITH_RET(refDotParameters->pwmChannel <= APT_PWM_CHANNEL_B, BASE_STATUS_ERROR);
 3002a90:	fe842783          	lw	a5,-24(s0)
 3002a94:	43d8                	lw	a4,4(a5)
 3002a96:	4785                	li	a5,1
 3002a98:	00e7fb63          	bgeu	a5,a4,3002aae <APT_ConfigRefB+0xa4>
 3002a9c:	53a00593          	li	a1,1338
 3002aa0:	030127b7          	lui	a5,0x3012
 3002aa4:	b1478513          	addi	a0,a5,-1260 # 3011b14 <g_crgIpMatch+0x27c>
 3002aa8:	246d                	jal	ra,3002d52 <AssertErrorLog>
 3002aaa:	4785                	li	a5,1
 3002aac:	a0b5                	j	3002b18 <APT_ConfigRefB+0x10e>
    /* Check the attributes of the reference point B: triggle action event. */
    APT_PARAM_CHECK_WITH_RET(refDotParameters->actionEvent >= APT_PWM_ACTION_ON_TIMEBASE_ZERO, BASE_STATUS_ERROR);
    APT_PARAM_CHECK_WITH_RET(refDotParameters->actionEvent <= APT_PWM_ACTION_ON_C2_COUNT_DOWN, BASE_STATUS_ERROR);
 3002aae:	fe842783          	lw	a5,-24(s0)
 3002ab2:	4798                	lw	a4,8(a5)
 3002ab4:	47e9                	li	a5,26
 3002ab6:	00e7fb63          	bgeu	a5,a4,3002acc <APT_ConfigRefB+0xc2>
 3002aba:	53d00593          	li	a1,1341
 3002abe:	030127b7          	lui	a5,0x3012
 3002ac2:	b1478513          	addi	a0,a5,-1260 # 3011b14 <g_crgIpMatch+0x27c>
 3002ac6:	2471                	jal	ra,3002d52 <AssertErrorLog>
 3002ac8:	4785                	li	a5,1
 3002aca:	a0b9                	j	3002b18 <APT_ConfigRefB+0x10e>
    /* Check the attributes of the reference point B: triggle action. */
    APT_PARAM_CHECK_WITH_RET(refDotParameters->action <= APT_PWM_ACTION_TOGGLE, BASE_STATUS_ERROR);
 3002acc:	fe842783          	lw	a5,-24(s0)
 3002ad0:	47d8                	lw	a4,12(a5)
 3002ad2:	478d                	li	a5,3
 3002ad4:	00e7fb63          	bgeu	a5,a4,3002aea <APT_ConfigRefB+0xe0>
 3002ad8:	53f00593          	li	a1,1343
 3002adc:	030127b7          	lui	a5,0x3012
 3002ae0:	b1478513          	addi	a0,a5,-1260 # 3011b14 <g_crgIpMatch+0x27c>
 3002ae4:	24bd                	jal	ra,3002d52 <AssertErrorLog>
 3002ae6:	4785                	li	a5,1
 3002ae8:	a805                	j	3002b18 <APT_ConfigRefB+0x10e>
    /* Change reference dot B value and division value. */
    aptHandle->baseAddress->TC_REFB.BIT.rg_cnt_refb = refDotParameters->refDotValue;
 3002aea:	fe842783          	lw	a5,-24(s0)
 3002aee:	4394                	lw	a3,0(a5)
 3002af0:	fec42783          	lw	a5,-20(s0)
 3002af4:	4398                	lw	a4,0(a5)
 3002af6:	01069613          	slli	a2,a3,0x10
 3002afa:	8241                	srli	a2,a2,0x10
 3002afc:	5b5c                	lw	a5,52(a4)
 3002afe:	66c1                	lui	a3,0x10
 3002b00:	16fd                	addi	a3,a3,-1 # ffff <RAM_SIZE+0xafff>
 3002b02:	8ef1                	and	a3,a3,a2
 3002b04:	7641                	lui	a2,0xffff0
 3002b06:	8ff1                	and	a5,a5,a2
 3002b08:	8fd5                	or	a5,a5,a3
 3002b0a:	db5c                	sw	a5,52(a4)
    /* Reference dot B triggle event and action. */
    return APT_ConfigAction(aptHandle, refDotParameters);
 3002b0c:	fe842583          	lw	a1,-24(s0)
 3002b10:	fec42503          	lw	a0,-20(s0)
 3002b14:	3339                	jal	ra,3002822 <APT_ConfigAction>
 3002b16:	87aa                	mv	a5,a0
}
 3002b18:	853e                	mv	a0,a5
 3002b1a:	40f2                	lw	ra,28(sp)
 3002b1c:	4462                	lw	s0,24(sp)
 3002b1e:	6105                	addi	sp,sp,32
 3002b20:	8082                	ret

03002b22 <APT_ConfigRefC>:
  * @param aptHandle APT module handle.
  * @param refDotParameters Reference point C configuration property set.
  * @retval BASE_StatusType: OK, ERROR.
  */
BASE_StatusType APT_ConfigRefC(APT_Handle *aptHandle, APT_RefDotParameters *refDotParameters)
{
 3002b22:	1101                	addi	sp,sp,-32
 3002b24:	ce06                	sw	ra,28(sp)
 3002b26:	cc22                	sw	s0,24(sp)
 3002b28:	1000                	addi	s0,sp,32
 3002b2a:	fea42623          	sw	a0,-20(s0)
 3002b2e:	feb42423          	sw	a1,-24(s0)
    APT_ASSERT_PARAM(aptHandle != NULL);
 3002b32:	fec42783          	lw	a5,-20(s0)
 3002b36:	eb89                	bnez	a5,3002b48 <APT_ConfigRefC+0x26>
 3002b38:	54e00593          	li	a1,1358
 3002b3c:	030127b7          	lui	a5,0x3012
 3002b40:	b1478513          	addi	a0,a5,-1260 # 3011b14 <g_crgIpMatch+0x27c>
 3002b44:	2439                	jal	ra,3002d52 <AssertErrorLog>
 3002b46:	a001                	j	3002b46 <APT_ConfigRefC+0x24>
    APT_ASSERT_PARAM(aptHandle->baseAddress != NULL);
 3002b48:	fec42783          	lw	a5,-20(s0)
 3002b4c:	439c                	lw	a5,0(a5)
 3002b4e:	eb89                	bnez	a5,3002b60 <APT_ConfigRefC+0x3e>
 3002b50:	54f00593          	li	a1,1359
 3002b54:	030127b7          	lui	a5,0x3012
 3002b58:	b1478513          	addi	a0,a5,-1260 # 3011b14 <g_crgIpMatch+0x27c>
 3002b5c:	2add                	jal	ra,3002d52 <AssertErrorLog>
 3002b5e:	a001                	j	3002b5e <APT_ConfigRefC+0x3c>
    APT_ASSERT_PARAM(IsAPTInstance(aptHandle->baseAddress));
 3002b60:	fec42783          	lw	a5,-20(s0)
 3002b64:	4398                	lw	a4,0(a5)
 3002b66:	14a007b7          	lui	a5,0x14a00
 3002b6a:	02f70f63          	beq	a4,a5,3002ba8 <APT_ConfigRefC+0x86>
 3002b6e:	fec42783          	lw	a5,-20(s0)
 3002b72:	4398                	lw	a4,0(a5)
 3002b74:	14a017b7          	lui	a5,0x14a01
 3002b78:	02f70863          	beq	a4,a5,3002ba8 <APT_ConfigRefC+0x86>
 3002b7c:	fec42783          	lw	a5,-20(s0)
 3002b80:	4398                	lw	a4,0(a5)
 3002b82:	14a027b7          	lui	a5,0x14a02
 3002b86:	02f70163          	beq	a4,a5,3002ba8 <APT_ConfigRefC+0x86>
 3002b8a:	fec42783          	lw	a5,-20(s0)
 3002b8e:	4398                	lw	a4,0(a5)
 3002b90:	14a037b7          	lui	a5,0x14a03
 3002b94:	00f70a63          	beq	a4,a5,3002ba8 <APT_ConfigRefC+0x86>
 3002b98:	55000593          	li	a1,1360
 3002b9c:	030127b7          	lui	a5,0x3012
 3002ba0:	b1478513          	addi	a0,a5,-1260 # 3011b14 <g_crgIpMatch+0x27c>
 3002ba4:	227d                	jal	ra,3002d52 <AssertErrorLog>
 3002ba6:	a001                	j	3002ba6 <APT_ConfigRefC+0x84>
    /* Check the attributes of the reference point C: PWM Channel. */
    APT_PARAM_CHECK_WITH_RET(refDotParameters->pwmChannel >= APT_PWM_CHANNEL_A, BASE_STATUS_ERROR);
    APT_PARAM_CHECK_WITH_RET(refDotParameters->pwmChannel <= APT_PWM_CHANNEL_B, BASE_STATUS_ERROR);
 3002ba8:	fe842783          	lw	a5,-24(s0)
 3002bac:	43d8                	lw	a4,4(a5)
 3002bae:	4785                	li	a5,1
 3002bb0:	00e7fb63          	bgeu	a5,a4,3002bc6 <APT_ConfigRefC+0xa4>
 3002bb4:	55300593          	li	a1,1363
 3002bb8:	030127b7          	lui	a5,0x3012
 3002bbc:	b1478513          	addi	a0,a5,-1260 # 3011b14 <g_crgIpMatch+0x27c>
 3002bc0:	2a49                	jal	ra,3002d52 <AssertErrorLog>
 3002bc2:	4785                	li	a5,1
 3002bc4:	a0b5                	j	3002c30 <APT_ConfigRefC+0x10e>
    /* Check the attributes of the reference point C: triggle action event. */
    APT_PARAM_CHECK_WITH_RET(refDotParameters->actionEvent >= APT_PWM_ACTION_ON_TIMEBASE_ZERO, BASE_STATUS_ERROR);
    APT_PARAM_CHECK_WITH_RET(refDotParameters->actionEvent <= APT_PWM_ACTION_ON_C2_COUNT_DOWN, BASE_STATUS_ERROR);
 3002bc6:	fe842783          	lw	a5,-24(s0)
 3002bca:	4798                	lw	a4,8(a5)
 3002bcc:	47e9                	li	a5,26
 3002bce:	00e7fb63          	bgeu	a5,a4,3002be4 <APT_ConfigRefC+0xc2>
 3002bd2:	55600593          	li	a1,1366
 3002bd6:	030127b7          	lui	a5,0x3012
 3002bda:	b1478513          	addi	a0,a5,-1260 # 3011b14 <g_crgIpMatch+0x27c>
 3002bde:	2a95                	jal	ra,3002d52 <AssertErrorLog>
 3002be0:	4785                	li	a5,1
 3002be2:	a0b9                	j	3002c30 <APT_ConfigRefC+0x10e>
    /* Check the attributes of the reference point C: triggle action. */
    APT_PARAM_CHECK_WITH_RET(refDotParameters->action <= APT_PWM_ACTION_TOGGLE, BASE_STATUS_ERROR);
 3002be4:	fe842783          	lw	a5,-24(s0)
 3002be8:	47d8                	lw	a4,12(a5)
 3002bea:	478d                	li	a5,3
 3002bec:	00e7fb63          	bgeu	a5,a4,3002c02 <APT_ConfigRefC+0xe0>
 3002bf0:	55800593          	li	a1,1368
 3002bf4:	030127b7          	lui	a5,0x3012
 3002bf8:	b1478513          	addi	a0,a5,-1260 # 3011b14 <g_crgIpMatch+0x27c>
 3002bfc:	2a99                	jal	ra,3002d52 <AssertErrorLog>
 3002bfe:	4785                	li	a5,1
 3002c00:	a805                	j	3002c30 <APT_ConfigRefC+0x10e>
    /* Change reference dot C value and division value. */
    aptHandle->baseAddress->TC_REFC.BIT.rg_cnt_refc = refDotParameters->refDotValue;
 3002c02:	fe842783          	lw	a5,-24(s0)
 3002c06:	4394                	lw	a3,0(a5)
 3002c08:	fec42783          	lw	a5,-20(s0)
 3002c0c:	4398                	lw	a4,0(a5)
 3002c0e:	01069613          	slli	a2,a3,0x10
 3002c12:	8241                	srli	a2,a2,0x10
 3002c14:	5f1c                	lw	a5,56(a4)
 3002c16:	66c1                	lui	a3,0x10
 3002c18:	16fd                	addi	a3,a3,-1 # ffff <RAM_SIZE+0xafff>
 3002c1a:	8ef1                	and	a3,a3,a2
 3002c1c:	7641                	lui	a2,0xffff0
 3002c1e:	8ff1                	and	a5,a5,a2
 3002c20:	8fd5                	or	a5,a5,a3
 3002c22:	df1c                	sw	a5,56(a4)
    /* Reference dot C triggle event and action. */
    return APT_ConfigAction(aptHandle, refDotParameters);
 3002c24:	fe842583          	lw	a1,-24(s0)
 3002c28:	fec42503          	lw	a0,-20(s0)
 3002c2c:	3edd                	jal	ra,3002822 <APT_ConfigAction>
 3002c2e:	87aa                	mv	a5,a0
}
 3002c30:	853e                	mv	a0,a5
 3002c32:	40f2                	lw	ra,28(sp)
 3002c34:	4462                	lw	s0,24(sp)
 3002c36:	6105                	addi	sp,sp,32
 3002c38:	8082                	ret

03002c3a <APT_ConfigRefD>:
  * @param aptHandle APT module handle.
  * @param refDotParameters Reference point D configuration property set.
  * @retval BASE_StatusType: OK, ERROR.
  */
BASE_StatusType APT_ConfigRefD(APT_Handle *aptHandle, APT_RefDotParameters *refDotParameters)
{
 3002c3a:	1101                	addi	sp,sp,-32
 3002c3c:	ce06                	sw	ra,28(sp)
 3002c3e:	cc22                	sw	s0,24(sp)
 3002c40:	1000                	addi	s0,sp,32
 3002c42:	fea42623          	sw	a0,-20(s0)
 3002c46:	feb42423          	sw	a1,-24(s0)
    APT_ASSERT_PARAM(aptHandle != NULL);
 3002c4a:	fec42783          	lw	a5,-20(s0)
 3002c4e:	eb89                	bnez	a5,3002c60 <APT_ConfigRefD+0x26>
 3002c50:	56700593          	li	a1,1383
 3002c54:	030127b7          	lui	a5,0x3012
 3002c58:	b1478513          	addi	a0,a5,-1260 # 3011b14 <g_crgIpMatch+0x27c>
 3002c5c:	28dd                	jal	ra,3002d52 <AssertErrorLog>
 3002c5e:	a001                	j	3002c5e <APT_ConfigRefD+0x24>
    APT_ASSERT_PARAM(aptHandle->baseAddress != NULL);
 3002c60:	fec42783          	lw	a5,-20(s0)
 3002c64:	439c                	lw	a5,0(a5)
 3002c66:	eb89                	bnez	a5,3002c78 <APT_ConfigRefD+0x3e>
 3002c68:	56800593          	li	a1,1384
 3002c6c:	030127b7          	lui	a5,0x3012
 3002c70:	b1478513          	addi	a0,a5,-1260 # 3011b14 <g_crgIpMatch+0x27c>
 3002c74:	28f9                	jal	ra,3002d52 <AssertErrorLog>
 3002c76:	a001                	j	3002c76 <APT_ConfigRefD+0x3c>
    APT_ASSERT_PARAM(IsAPTInstance(aptHandle->baseAddress));
 3002c78:	fec42783          	lw	a5,-20(s0)
 3002c7c:	4398                	lw	a4,0(a5)
 3002c7e:	14a007b7          	lui	a5,0x14a00
 3002c82:	02f70f63          	beq	a4,a5,3002cc0 <APT_ConfigRefD+0x86>
 3002c86:	fec42783          	lw	a5,-20(s0)
 3002c8a:	4398                	lw	a4,0(a5)
 3002c8c:	14a017b7          	lui	a5,0x14a01
 3002c90:	02f70863          	beq	a4,a5,3002cc0 <APT_ConfigRefD+0x86>
 3002c94:	fec42783          	lw	a5,-20(s0)
 3002c98:	4398                	lw	a4,0(a5)
 3002c9a:	14a027b7          	lui	a5,0x14a02
 3002c9e:	02f70163          	beq	a4,a5,3002cc0 <APT_ConfigRefD+0x86>
 3002ca2:	fec42783          	lw	a5,-20(s0)
 3002ca6:	4398                	lw	a4,0(a5)
 3002ca8:	14a037b7          	lui	a5,0x14a03
 3002cac:	00f70a63          	beq	a4,a5,3002cc0 <APT_ConfigRefD+0x86>
 3002cb0:	56900593          	li	a1,1385
 3002cb4:	030127b7          	lui	a5,0x3012
 3002cb8:	b1478513          	addi	a0,a5,-1260 # 3011b14 <g_crgIpMatch+0x27c>
 3002cbc:	2859                	jal	ra,3002d52 <AssertErrorLog>
 3002cbe:	a001                	j	3002cbe <APT_ConfigRefD+0x84>
    /* Check the attributes of the reference point D: PWM Channel. */
    APT_PARAM_CHECK_WITH_RET(refDotParameters->pwmChannel >= APT_PWM_CHANNEL_A, BASE_STATUS_ERROR);
    APT_PARAM_CHECK_WITH_RET(refDotParameters->pwmChannel <= APT_PWM_CHANNEL_B, BASE_STATUS_ERROR);
 3002cc0:	fe842783          	lw	a5,-24(s0)
 3002cc4:	43d8                	lw	a4,4(a5)
 3002cc6:	4785                	li	a5,1
 3002cc8:	00e7fb63          	bgeu	a5,a4,3002cde <APT_ConfigRefD+0xa4>
 3002ccc:	56c00593          	li	a1,1388
 3002cd0:	030127b7          	lui	a5,0x3012
 3002cd4:	b1478513          	addi	a0,a5,-1260 # 3011b14 <g_crgIpMatch+0x27c>
 3002cd8:	28ad                	jal	ra,3002d52 <AssertErrorLog>
 3002cda:	4785                	li	a5,1
 3002cdc:	a0b5                	j	3002d48 <APT_ConfigRefD+0x10e>
    /* Check the attributes of the reference point D: triggle action event. */
    APT_PARAM_CHECK_WITH_RET(refDotParameters->actionEvent >= APT_PWM_ACTION_ON_TIMEBASE_ZERO, BASE_STATUS_ERROR);
    APT_PARAM_CHECK_WITH_RET(refDotParameters->actionEvent <= APT_PWM_ACTION_ON_C2_COUNT_DOWN, BASE_STATUS_ERROR);
 3002cde:	fe842783          	lw	a5,-24(s0)
 3002ce2:	4798                	lw	a4,8(a5)
 3002ce4:	47e9                	li	a5,26
 3002ce6:	00e7fb63          	bgeu	a5,a4,3002cfc <APT_ConfigRefD+0xc2>
 3002cea:	56f00593          	li	a1,1391
 3002cee:	030127b7          	lui	a5,0x3012
 3002cf2:	b1478513          	addi	a0,a5,-1260 # 3011b14 <g_crgIpMatch+0x27c>
 3002cf6:	28b1                	jal	ra,3002d52 <AssertErrorLog>
 3002cf8:	4785                	li	a5,1
 3002cfa:	a0b9                	j	3002d48 <APT_ConfigRefD+0x10e>
    /* Check the attributes of the reference point D: triggle action. */
    APT_PARAM_CHECK_WITH_RET(refDotParameters->action <= APT_PWM_ACTION_TOGGLE, BASE_STATUS_ERROR);
 3002cfc:	fe842783          	lw	a5,-24(s0)
 3002d00:	47d8                	lw	a4,12(a5)
 3002d02:	478d                	li	a5,3
 3002d04:	00e7fb63          	bgeu	a5,a4,3002d1a <APT_ConfigRefD+0xe0>
 3002d08:	57100593          	li	a1,1393
 3002d0c:	030127b7          	lui	a5,0x3012
 3002d10:	b1478513          	addi	a0,a5,-1260 # 3011b14 <g_crgIpMatch+0x27c>
 3002d14:	283d                	jal	ra,3002d52 <AssertErrorLog>
 3002d16:	4785                	li	a5,1
 3002d18:	a805                	j	3002d48 <APT_ConfigRefD+0x10e>
    /* Change reference dot D value and division value. */
    aptHandle->baseAddress->TC_REFD.BIT.rg_cnt_refd = refDotParameters->refDotValue;
 3002d1a:	fe842783          	lw	a5,-24(s0)
 3002d1e:	4394                	lw	a3,0(a5)
 3002d20:	fec42783          	lw	a5,-20(s0)
 3002d24:	4398                	lw	a4,0(a5)
 3002d26:	01069613          	slli	a2,a3,0x10
 3002d2a:	8241                	srli	a2,a2,0x10
 3002d2c:	5f5c                	lw	a5,60(a4)
 3002d2e:	66c1                	lui	a3,0x10
 3002d30:	16fd                	addi	a3,a3,-1 # ffff <RAM_SIZE+0xafff>
 3002d32:	8ef1                	and	a3,a3,a2
 3002d34:	7641                	lui	a2,0xffff0
 3002d36:	8ff1                	and	a5,a5,a2
 3002d38:	8fd5                	or	a5,a5,a3
 3002d3a:	df5c                	sw	a5,60(a4)
    /* Reference dot D triggle event and action. */
    return APT_ConfigAction(aptHandle, refDotParameters);
 3002d3c:	fe842583          	lw	a1,-24(s0)
 3002d40:	fec42503          	lw	a0,-20(s0)
 3002d44:	3cf9                	jal	ra,3002822 <APT_ConfigAction>
 3002d46:	87aa                	mv	a5,a0
}
 3002d48:	853e                	mv	a0,a5
 3002d4a:	40f2                	lw	ra,28(sp)
 3002d4c:	4462                	lw	s0,24(sp)
 3002d4e:	6105                	addi	sp,sp,32
 3002d50:	8082                	ret

03002d52 <AssertErrorLog>:
  * @param file Pointer to the name of the file where the error occurs.
  * @param line Number of the line where the error occurs.
  * @retval None.
  */
__weak void AssertErrorLog(char *file, unsigned int line)
{
 3002d52:	1101                	addi	sp,sp,-32
 3002d54:	ce22                	sw	s0,28(sp)
 3002d56:	1000                	addi	s0,sp,32
 3002d58:	fea42623          	sw	a0,-20(s0)
 3002d5c:	feb42423          	sw	a1,-24(s0)
    /* Use only if the user apllication is not defined. */
    BASE_FUNC_UNUSED(file);
    BASE_FUNC_UNUSED(line);
 3002d60:	0001                	nop
 3002d62:	4472                	lw	s0,28(sp)
 3002d64:	6105                	addi	sp,sp,32
 3002d66:	8082                	ret

03002d68 <DCL_SYSTICK_GetTick>:
  * @brief   Get the systick
  * @param   None
  * @retval  The SysTick Value
  */
static inline unsigned int DCL_SYSTICK_GetTick(void)
{
 3002d68:	1141                	addi	sp,sp,-16
 3002d6a:	c622                	sw	s0,12(sp)
 3002d6c:	0800                	addi	s0,sp,16
    return SYSTICK->MTIME;   /* Systick value(Lower 32bit register) */
 3002d6e:	143807b7          	lui	a5,0x14380
 3002d72:	479c                	lw	a5,8(a5)
}
 3002d74:	853e                	mv	a0,a5
 3002d76:	4432                	lw	s0,12(sp)
 3002d78:	0141                	addi	sp,sp,16
 3002d7a:	8082                	ret

03002d7c <BASE_FUNC_GetCpuFreqHz>:
  * @brief Get the current CPU frequency.
  * @param None.
  * @retval System clock frequency in Hz.
  */
unsigned int BASE_FUNC_GetCpuFreqHz(void)
{
 3002d7c:	1141                	addi	sp,sp,-16
 3002d7e:	c606                	sw	ra,12(sp)
 3002d80:	c422                	sw	s0,8(sp)
 3002d82:	0800                	addi	s0,sp,16
    return HAL_CRG_GetCoreClkFreq();
 3002d84:	100020ef          	jal	ra,3004e84 <HAL_CRG_GetCoreClkFreq>
 3002d88:	87aa                	mv	a5,a0
}
 3002d8a:	853e                	mv	a0,a5
 3002d8c:	40b2                	lw	ra,12(sp)
 3002d8e:	4422                	lw	s0,8(sp)
 3002d90:	0141                	addi	sp,sp,16
 3002d92:	8082                	ret

03002d94 <BASE_FUNC_DelayUs>:
  * @brief Delay number of us.
  * @param us The number of us to delay.
  * @retval None.
  */
void BASE_FUNC_DelayUs(unsigned int us)
{
 3002d94:	7179                	addi	sp,sp,-48
 3002d96:	d606                	sw	ra,44(sp)
 3002d98:	d422                	sw	s0,40(sp)
 3002d9a:	1800                	addi	s0,sp,48
 3002d9c:	fca42e23          	sw	a0,-36(s0)
    unsigned int preTick = DCL_SYSTICK_GetTick();
 3002da0:	37e1                	jal	ra,3002d68 <DCL_SYSTICK_GetTick>
 3002da2:	fea42623          	sw	a0,-20(s0)
    unsigned int tickInUs = (SYSTICK_GetCRGHZ() / CRG_FREQ_1MHz) * us;
 3002da6:	a44fe0ef          	jal	ra,3000fea <SYSTICK_GetCRGHZ>
 3002daa:	872a                	mv	a4,a0
 3002dac:	000f47b7          	lui	a5,0xf4
 3002db0:	24078793          	addi	a5,a5,576 # f4240 <FLASH_SIZE+0xd4244>
 3002db4:	02f757b3          	divu	a5,a4,a5
 3002db8:	fdc42703          	lw	a4,-36(s0)
 3002dbc:	02f707b3          	mul	a5,a4,a5
 3002dc0:	fef42423          	sw	a5,-24(s0)
    unsigned int curTick;
    unsigned int delta;

	/* Wait until the delta is greater than tickInUs */
    do {
        curTick = DCL_SYSTICK_GetTick();
 3002dc4:	3755                	jal	ra,3002d68 <DCL_SYSTICK_GetTick>
 3002dc6:	fea42223          	sw	a0,-28(s0)
        delta = (curTick >= preTick) ? curTick - preTick : SYSTICK_MAX_VALUE - preTick + curTick + 1;
 3002dca:	fe442703          	lw	a4,-28(s0)
 3002dce:	fec42783          	lw	a5,-20(s0)
 3002dd2:	40f707b3          	sub	a5,a4,a5
 3002dd6:	fef42023          	sw	a5,-32(s0)
    } while (delta < tickInUs);
 3002dda:	fe042703          	lw	a4,-32(s0)
 3002dde:	fe842783          	lw	a5,-24(s0)
 3002de2:	fef761e3          	bltu	a4,a5,3002dc4 <BASE_FUNC_DelayUs+0x30>
}
 3002de6:	0001                	nop
 3002de8:	50b2                	lw	ra,44(sp)
 3002dea:	5422                	lw	s0,40(sp)
 3002dec:	6145                	addi	sp,sp,48
 3002dee:	8082                	ret

03002df0 <BASE_FUNC_DelayMs>:
  * @brief Delay number of ms.
  * @param ms The number of ms to delay.
  * @retval None.
  */
void BASE_FUNC_DelayMs(unsigned int ms)
{
 3002df0:	7179                	addi	sp,sp,-48
 3002df2:	d606                	sw	ra,44(sp)
 3002df4:	d422                	sw	s0,40(sp)
 3002df6:	1800                	addi	s0,sp,48
 3002df8:	fca42e23          	sw	a0,-36(s0)
    for (unsigned int i = 0; i < ms; ++i) {
 3002dfc:	fe042623          	sw	zero,-20(s0)
 3002e00:	a809                	j	3002e12 <BASE_FUNC_DelayMs+0x22>
        BASE_FUNC_DelayUs(BASE_DEFINE_DELAY_US_IN_MS);
 3002e02:	3e800513          	li	a0,1000
 3002e06:	3779                	jal	ra,3002d94 <BASE_FUNC_DelayUs>
    for (unsigned int i = 0; i < ms; ++i) {
 3002e08:	fec42783          	lw	a5,-20(s0)
 3002e0c:	0785                	addi	a5,a5,1
 3002e0e:	fef42623          	sw	a5,-20(s0)
 3002e12:	fec42703          	lw	a4,-20(s0)
 3002e16:	fdc42783          	lw	a5,-36(s0)
 3002e1a:	fef764e3          	bltu	a4,a5,3002e02 <BASE_FUNC_DelayMs+0x12>
    }
}
 3002e1e:	0001                	nop
 3002e20:	50b2                	lw	ra,44(sp)
 3002e22:	5422                	lw	s0,40(sp)
 3002e24:	6145                	addi	sp,sp,48
 3002e26:	8082                	ret

03002e28 <BASE_FUNC_DelaySeconds>:
  * @brief Delay number of seconds.
  * @param seconds The number of seconds to delay.
  * @retval None.
  */
void BASE_FUNC_DelaySeconds(unsigned int seconds)
{
 3002e28:	7179                	addi	sp,sp,-48
 3002e2a:	d606                	sw	ra,44(sp)
 3002e2c:	d422                	sw	s0,40(sp)
 3002e2e:	1800                	addi	s0,sp,48
 3002e30:	fca42e23          	sw	a0,-36(s0)
    for (unsigned int i = 0; i < seconds; ++i) {
 3002e34:	fe042623          	sw	zero,-20(s0)
 3002e38:	a809                	j	3002e4a <BASE_FUNC_DelaySeconds+0x22>
        BASE_FUNC_DelayMs(BASE_DEFINE_DELAY_MS_IN_SEC);
 3002e3a:	3e800513          	li	a0,1000
 3002e3e:	3f4d                	jal	ra,3002df0 <BASE_FUNC_DelayMs>
    for (unsigned int i = 0; i < seconds; ++i) {
 3002e40:	fec42783          	lw	a5,-20(s0)
 3002e44:	0785                	addi	a5,a5,1
 3002e46:	fef42623          	sw	a5,-20(s0)
 3002e4a:	fec42703          	lw	a4,-20(s0)
 3002e4e:	fdc42783          	lw	a5,-36(s0)
 3002e52:	fef764e3          	bltu	a4,a5,3002e3a <BASE_FUNC_DelaySeconds+0x12>
    }
}
 3002e56:	0001                	nop
 3002e58:	50b2                	lw	ra,44(sp)
 3002e5a:	5422                	lw	s0,40(sp)
 3002e5c:	6145                	addi	sp,sp,48
 3002e5e:	8082                	ret

03002e60 <BASE_FUNC_Delay>:
  * @param delay The number of 'units' to delay.
  * @param units Specifies the delay unit.
  * @retval None.
  */
void BASE_FUNC_Delay(unsigned int delay, BASE_DelayUnit units)
{
 3002e60:	1101                	addi	sp,sp,-32
 3002e62:	ce06                	sw	ra,28(sp)
 3002e64:	cc22                	sw	s0,24(sp)
 3002e66:	1000                	addi	s0,sp,32
 3002e68:	fea42623          	sw	a0,-20(s0)
 3002e6c:	feb42423          	sw	a1,-24(s0)
    switch (units) {
 3002e70:	fe842783          	lw	a5,-24(s0)
 3002e74:	3e800713          	li	a4,1000
 3002e78:	02e78063          	beq	a5,a4,3002e98 <BASE_FUNC_Delay+0x38>
 3002e7c:	000f4737          	lui	a4,0xf4
 3002e80:	24070713          	addi	a4,a4,576 # f4240 <FLASH_SIZE+0xd4244>
 3002e84:	00e78e63          	beq	a5,a4,3002ea0 <BASE_FUNC_Delay+0x40>
 3002e88:	4705                	li	a4,1
 3002e8a:	00e78363          	beq	a5,a4,3002e90 <BASE_FUNC_Delay+0x30>
            break;
        case BASE_DEFINE_DELAY_MICROSECS:
            BASE_FUNC_DelayUs(delay);
            break;
        default:
            break;
 3002e8e:	a829                	j	3002ea8 <BASE_FUNC_Delay+0x48>
            BASE_FUNC_DelaySeconds(delay);
 3002e90:	fec42503          	lw	a0,-20(s0)
 3002e94:	3f51                	jal	ra,3002e28 <BASE_FUNC_DelaySeconds>
            break;
 3002e96:	a809                	j	3002ea8 <BASE_FUNC_Delay+0x48>
            BASE_FUNC_DelayMs(delay);
 3002e98:	fec42503          	lw	a0,-20(s0)
 3002e9c:	3f91                	jal	ra,3002df0 <BASE_FUNC_DelayMs>
            break;
 3002e9e:	a029                	j	3002ea8 <BASE_FUNC_Delay+0x48>
            BASE_FUNC_DelayUs(delay);
 3002ea0:	fec42503          	lw	a0,-20(s0)
 3002ea4:	3dc5                	jal	ra,3002d94 <BASE_FUNC_DelayUs>
            break;
 3002ea6:	0001                	nop
    }
    return;
 3002ea8:	0001                	nop
 3002eaa:	40f2                	lw	ra,28(sp)
 3002eac:	4462                	lw	s0,24(sp)
 3002eae:	6105                	addi	sp,sp,32
 3002eb0:	8082                	ret

03002eb2 <IRQ_ClearN>:
  * @brief  Clear external interrupt
  * @param irqNum external interrupt number
  * @retval BASE_STATUS_OK or IRQ_ERRNO_NUM_INVALID or IRQ_ERRNO_NOT_CREATED
  */
static inline void IRQ_ClearN(unsigned int irqNum)
{
 3002eb2:	1101                	addi	sp,sp,-32
 3002eb4:	ce22                	sw	s0,28(sp)
 3002eb6:	1000                	addi	s0,sp,32
 3002eb8:	fea42623          	sw	a0,-20(s0)
    asm volatile("fence");
 3002ebc:	0ff0000f          	fence
    WRITE_CUSTOM_CSR_VAL(LOCIPCLR, irqNum);
 3002ec0:	fec42783          	lw	a5,-20(s0)
 3002ec4:	82be                	mv	t0,a5
 3002ec6:	bf029073          	csrw	0xbf0,t0
}
 3002eca:	0001                	nop
 3002ecc:	4472                	lw	s0,28(sp)
 3002ece:	6105                	addi	sp,sp,32
 3002ed0:	8082                	ret

03002ed2 <InterruptEntry>:
  * @brief Exception/Interrupt Handler Entry.
  * @param irqNum external interrupt number.
  * @retval None
  */
void InterruptEntry(unsigned int irqNum)
{
 3002ed2:	1101                	addi	sp,sp,-32
 3002ed4:	ce06                	sw	ra,28(sp)
 3002ed6:	cc22                	sw	s0,24(sp)
 3002ed8:	1000                	addi	s0,sp,32
 3002eda:	fea42623          	sw	a0,-20(s0)
    g_irqCallbackFunc[irqNum].pfnHandler(g_irqCallbackFunc[irqNum].param);
 3002ede:	040007b7          	lui	a5,0x4000
 3002ee2:	18478713          	addi	a4,a5,388 # 4000184 <g_irqCallbackFunc>
 3002ee6:	fec42783          	lw	a5,-20(s0)
 3002eea:	078e                	slli	a5,a5,0x3
 3002eec:	97ba                	add	a5,a5,a4
 3002eee:	4394                	lw	a3,0(a5)
 3002ef0:	040007b7          	lui	a5,0x4000
 3002ef4:	18478713          	addi	a4,a5,388 # 4000184 <g_irqCallbackFunc>
 3002ef8:	fec42783          	lw	a5,-20(s0)
 3002efc:	078e                	slli	a5,a5,0x3
 3002efe:	97ba                	add	a5,a5,a4
 3002f00:	43dc                	lw	a5,4(a5)
 3002f02:	853e                	mv	a0,a5
 3002f04:	9682                	jalr	a3
    IRQ_ClearN(irqNum);
 3002f06:	fec42503          	lw	a0,-20(s0)
 3002f0a:	3765                	jal	ra,3002eb2 <IRQ_ClearN>
}
 3002f0c:	0001                	nop
 3002f0e:	40f2                	lw	ra,28(sp)
 3002f10:	4462                	lw	s0,24(sp)
 3002f12:	6105                	addi	sp,sp,32
 3002f14:	8082                	ret

03002f16 <IRQ_Init>:
  * @brief Irq initialization.
  * @param none.
  * @retval None
  */
void IRQ_Init(void)
{
 3002f16:	1101                	addi	sp,sp,-32
 3002f18:	ce22                	sw	s0,28(sp)
 3002f1a:	1000                	addi	s0,sp,32
    unsigned int index;

    for (index = 0; index < IRQ_MAX; index++) {
 3002f1c:	fe042623          	sw	zero,-20(s0)
 3002f20:	a82d                	j	3002f5a <IRQ_Init+0x44>
        g_irqCallbackFunc[index].pfnHandler = IRQ_DummyHandler;
 3002f22:	040007b7          	lui	a5,0x4000
 3002f26:	18478713          	addi	a4,a5,388 # 4000184 <g_irqCallbackFunc>
 3002f2a:	fec42783          	lw	a5,-20(s0)
 3002f2e:	078e                	slli	a5,a5,0x3
 3002f30:	97ba                	add	a5,a5,a4
 3002f32:	03004737          	lui	a4,0x3004
 3002f36:	80070713          	addi	a4,a4,-2048 # 3003800 <IRQ_DummyHandler>
 3002f3a:	c398                	sw	a4,0(a5)
        g_irqCallbackFunc[index].param = NULL;
 3002f3c:	040007b7          	lui	a5,0x4000
 3002f40:	18478713          	addi	a4,a5,388 # 4000184 <g_irqCallbackFunc>
 3002f44:	fec42783          	lw	a5,-20(s0)
 3002f48:	078e                	slli	a5,a5,0x3
 3002f4a:	97ba                	add	a5,a5,a4
 3002f4c:	0007a223          	sw	zero,4(a5)
    for (index = 0; index < IRQ_MAX; index++) {
 3002f50:	fec42783          	lw	a5,-20(s0)
 3002f54:	0785                	addi	a5,a5,1
 3002f56:	fef42623          	sw	a5,-20(s0)
 3002f5a:	fec42703          	lw	a4,-20(s0)
 3002f5e:	07200793          	li	a5,114
 3002f62:	fce7f0e3          	bgeu	a5,a4,3002f22 <IRQ_Init+0xc>
    }
}
 3002f66:	0001                	nop
 3002f68:	4472                	lw	s0,28(sp)
 3002f6a:	6105                	addi	sp,sp,32
 3002f6c:	8082                	ret

03002f6e <IRQ_Register>:
  * @note    In the corresponding interrupt handler, manually clear the interrupt source and the corresponding interrupt
  *          flag bit (call the IRQ_ClearN function to clear the interrupt), otherwise the interrupt will always be
  *          triggered.
  */
unsigned int IRQ_Register(unsigned int irqNum, IRQ_PROC_FUNC func, void *arg)
{
 3002f6e:	1101                	addi	sp,sp,-32
 3002f70:	ce06                	sw	ra,28(sp)
 3002f72:	cc22                	sw	s0,24(sp)
 3002f74:	1000                	addi	s0,sp,32
 3002f76:	fea42623          	sw	a0,-20(s0)
 3002f7a:	feb42423          	sw	a1,-24(s0)
 3002f7e:	fec42223          	sw	a2,-28(s0)
    INTERRUPT_ASSERT_PARAM(func != NULL);
 3002f82:	fe842783          	lw	a5,-24(s0)
 3002f86:	eb89                	bnez	a5,3002f98 <IRQ_Register+0x2a>
 3002f88:	06300593          	li	a1,99
 3002f8c:	030127b7          	lui	a5,0x3012
 3002f90:	b4478513          	addi	a0,a5,-1212 # 3011b44 <g_crgIpMatch+0x2ac>
 3002f94:	3b7d                	jal	ra,3002d52 <AssertErrorLog>
 3002f96:	a001                	j	3002f96 <IRQ_Register+0x28>
    INTERRUPT_PARAM_CHECK_WITH_RET(irqNum < IRQ_MAX, IRQ_ERRNO_NUM_INVALID);
 3002f98:	fec42703          	lw	a4,-20(s0)
 3002f9c:	07200793          	li	a5,114
 3002fa0:	00e7fb63          	bgeu	a5,a4,3002fb6 <IRQ_Register+0x48>
 3002fa4:	06400593          	li	a1,100
 3002fa8:	030127b7          	lui	a5,0x3012
 3002fac:	b4478513          	addi	a0,a5,-1212 # 3011b44 <g_crgIpMatch+0x2ac>
 3002fb0:	334d                	jal	ra,3002d52 <AssertErrorLog>
 3002fb2:	4789                	li	a5,2
 3002fb4:	a81d                	j	3002fea <IRQ_Register+0x7c>

    if (g_irqCallbackFunc[irqNum].pfnHandler != IRQ_DummyHandler) {
 3002fb6:	040007b7          	lui	a5,0x4000
 3002fba:	18478713          	addi	a4,a5,388 # 4000184 <g_irqCallbackFunc>
 3002fbe:	fec42783          	lw	a5,-20(s0)
 3002fc2:	078e                	slli	a5,a5,0x3
 3002fc4:	97ba                	add	a5,a5,a4
 3002fc6:	4398                	lw	a4,0(a5)
 3002fc8:	030047b7          	lui	a5,0x3004
 3002fcc:	80078793          	addi	a5,a5,-2048 # 3003800 <IRQ_DummyHandler>
 3002fd0:	00f70463          	beq	a4,a5,3002fd8 <IRQ_Register+0x6a>
        return IRQ_ERRNO_ALREADY_CREATED;
 3002fd4:	478d                	li	a5,3
 3002fd6:	a811                	j	3002fea <IRQ_Register+0x7c>
    }
    IRQ_SetCallBack(irqNum, func, arg);
 3002fd8:	fe442603          	lw	a2,-28(s0)
 3002fdc:	fe842583          	lw	a1,-24(s0)
 3002fe0:	fec42503          	lw	a0,-20(s0)
 3002fe4:	02f000ef          	jal	ra,3003812 <IRQ_SetCallBack>
    return BASE_STATUS_OK;
 3002fe8:	4781                	li	a5,0
}
 3002fea:	853e                	mv	a0,a5
 3002fec:	40f2                	lw	ra,28(sp)
 3002fee:	4462                	lw	s0,24(sp)
 3002ff0:	6105                	addi	sp,sp,32
 3002ff2:	8082                	ret

03002ff4 <IRQ_EnableN>:
  * @brief Enable the specified interrupt.
  * @param irqNum  External interrupt number.
  * @retval BASE_STATUS_OK or IRQ_ERRNO_NUM_INVALID.
  */
unsigned int IRQ_EnableN(unsigned int irqNum)
{
 3002ff4:	7139                	addi	sp,sp,-64
 3002ff6:	de06                	sw	ra,60(sp)
 3002ff8:	dc22                	sw	s0,56(sp)
 3002ffa:	0080                	addi	s0,sp,64
 3002ffc:	fca42623          	sw	a0,-52(s0)
    unsigned int irqOrder;
    unsigned int locienVal;
#if defined(USER_MODE_ENABLE) && (USER_MODE_ENABLE == 1)
    unsigned int priv = IRQ_GetCpuPrivilege();
 3003000:	059000ef          	jal	ra,3003858 <IRQ_GetCpuPrivilege>
 3003004:	fea42623          	sw	a0,-20(s0)
#endif

    INTERRUPT_PARAM_CHECK_WITH_RET((irqNum >= IRQ_VECTOR_CNT && irqNum < IRQ_MAX), IRQ_ERRNO_NUM_INVALID);
 3003008:	fcc42703          	lw	a4,-52(s0)
 300300c:	47e5                	li	a5,25
 300300e:	00e7f863          	bgeu	a5,a4,300301e <IRQ_EnableN+0x2a>
 3003012:	fcc42703          	lw	a4,-52(s0)
 3003016:	07200793          	li	a5,114
 300301a:	00e7fb63          	bgeu	a5,a4,3003030 <IRQ_EnableN+0x3c>
 300301e:	0c300593          	li	a1,195
 3003022:	030127b7          	lui	a5,0x3012
 3003026:	b4478513          	addi	a0,a5,-1212 # 3011b44 <g_crgIpMatch+0x2ac>
 300302a:	3325                	jal	ra,3002d52 <AssertErrorLog>
 300302c:	4789                	li	a5,2
 300302e:	a239                	j	300313c <IRQ_EnableN+0x148>

    /* The interrupt enable bits that can be controlled in the mie register (32 bits), up to 32
       can be controlled, and each bit corresponds to an interrupt enable */

    RISCV_PRIV_MODE_SWITCH(priv);
 3003030:	fec42703          	lw	a4,-20(s0)
 3003034:	47a1                	li	a5,8
 3003036:	00f71463          	bne	a4,a5,300303e <IRQ_EnableN+0x4a>
 300303a:	00000073          	ecall

    if (irqNum < IRQ_MIE_TOTAL_CNT) {
 300303e:	fcc42703          	lw	a4,-52(s0)
 3003042:	47fd                	li	a5,31
 3003044:	02e7e063          	bltu	a5,a4,3003064 <IRQ_EnableN+0x70>
        irqOrder = 1U << irqNum;
 3003048:	4705                	li	a4,1
 300304a:	fcc42783          	lw	a5,-52(s0)
 300304e:	00f717b3          	sll	a5,a4,a5
 3003052:	fef42423          	sw	a5,-24(s0)
        SET_CSR(mie, irqOrder);
 3003056:	fe842783          	lw	a5,-24(s0)
 300305a:	3047a7f3          	csrrs	a5,mie,a5
 300305e:	fcf42a23          	sw	a5,-44(s0)
 3003062:	a0e9                	j	300312c <IRQ_EnableN+0x138>
    } else if (irqNum < IRQ_LOCIEN1_OFFSET) {
 3003064:	fcc42703          	lw	a4,-52(s0)
 3003068:	03f00793          	li	a5,63
 300306c:	02e7ef63          	bltu	a5,a4,30030aa <IRQ_EnableN+0xb6>
        irqOrder = irqNum - IRQ_MIE_TOTAL_CNT;
 3003070:	fcc42783          	lw	a5,-52(s0)
 3003074:	1781                	addi	a5,a5,-32
 3003076:	fef42423          	sw	a5,-24(s0)
        locienVal = READ_CUSTOM_CSR(LOCIEN0);
 300307a:	be0027f3          	csrr	a5,0xbe0
 300307e:	fcf42c23          	sw	a5,-40(s0)
 3003082:	fd842783          	lw	a5,-40(s0)
 3003086:	fef42023          	sw	a5,-32(s0)
        locienVal |= (1U << irqOrder);
 300308a:	4705                	li	a4,1
 300308c:	fe842783          	lw	a5,-24(s0)
 3003090:	00f717b3          	sll	a5,a4,a5
 3003094:	fe042703          	lw	a4,-32(s0)
 3003098:	8fd9                	or	a5,a5,a4
 300309a:	fef42023          	sw	a5,-32(s0)
        WRITE_CUSTOM_CSR_VAL(LOCIEN0, locienVal);
 300309e:	fe042783          	lw	a5,-32(s0)
 30030a2:	82be                	mv	t0,a5
 30030a4:	be029073          	csrw	0xbe0,t0
 30030a8:	a051                	j	300312c <IRQ_EnableN+0x138>
    } else if (irqNum < IRQ_LOCIEN2_OFFSET) {
 30030aa:	fcc42703          	lw	a4,-52(s0)
 30030ae:	05f00793          	li	a5,95
 30030b2:	04e7e063          	bltu	a5,a4,30030f2 <IRQ_EnableN+0xfe>
        irqOrder = irqNum - IRQ_LOCIEN1_OFFSET;
 30030b6:	fcc42783          	lw	a5,-52(s0)
 30030ba:	fc078793          	addi	a5,a5,-64
 30030be:	fef42423          	sw	a5,-24(s0)
        locienVal = READ_CUSTOM_CSR(LOCIEN1);
 30030c2:	be1027f3          	csrr	a5,0xbe1
 30030c6:	fcf42e23          	sw	a5,-36(s0)
 30030ca:	fdc42783          	lw	a5,-36(s0)
 30030ce:	fef42023          	sw	a5,-32(s0)
        locienVal |= (1U << irqOrder);
 30030d2:	4705                	li	a4,1
 30030d4:	fe842783          	lw	a5,-24(s0)
 30030d8:	00f717b3          	sll	a5,a4,a5
 30030dc:	fe042703          	lw	a4,-32(s0)
 30030e0:	8fd9                	or	a5,a5,a4
 30030e2:	fef42023          	sw	a5,-32(s0)
        WRITE_CUSTOM_CSR_VAL(LOCIEN1, locienVal);
 30030e6:	fe042783          	lw	a5,-32(s0)
 30030ea:	82be                	mv	t0,a5
 30030ec:	be129073          	csrw	0xbe1,t0
 30030f0:	a835                	j	300312c <IRQ_EnableN+0x138>
    } else {
        irqOrder = irqNum - IRQ_LOCIEN2_OFFSET;
 30030f2:	fcc42783          	lw	a5,-52(s0)
 30030f6:	fa078793          	addi	a5,a5,-96
 30030fa:	fef42423          	sw	a5,-24(s0)
        locienVal = READ_CUSTOM_CSR(LOCIEN2);
 30030fe:	be2027f3          	csrr	a5,0xbe2
 3003102:	fef42223          	sw	a5,-28(s0)
 3003106:	fe442783          	lw	a5,-28(s0)
 300310a:	fef42023          	sw	a5,-32(s0)
        locienVal |= (1U << irqOrder);
 300310e:	4705                	li	a4,1
 3003110:	fe842783          	lw	a5,-24(s0)
 3003114:	00f717b3          	sll	a5,a4,a5
 3003118:	fe042703          	lw	a4,-32(s0)
 300311c:	8fd9                	or	a5,a5,a4
 300311e:	fef42023          	sw	a5,-32(s0)
        WRITE_CUSTOM_CSR_VAL(LOCIEN2, locienVal);
 3003122:	fe042783          	lw	a5,-32(s0)
 3003126:	82be                	mv	t0,a5
 3003128:	be229073          	csrw	0xbe2,t0
    }

    RISCV_PRIV_MODE_SWITCH(priv);
 300312c:	fec42703          	lw	a4,-20(s0)
 3003130:	47a1                	li	a5,8
 3003132:	00f71463          	bne	a4,a5,300313a <IRQ_EnableN+0x146>
 3003136:	00000073          	ecall

    return BASE_STATUS_OK;
 300313a:	4781                	li	a5,0
}
 300313c:	853e                	mv	a0,a5
 300313e:	50f2                	lw	ra,60(sp)
 3003140:	5462                	lw	s0,56(sp)
 3003142:	6121                	addi	sp,sp,64
 3003144:	8082                	ret

03003146 <SysErrPrint>:
  * @param context.
  * @note  The actual code is generated by IDE
  * @retval None.
  */
__weak void SysErrPrint(const SyserrContext *context)
{
 3003146:	1101                	addi	sp,sp,-32
 3003148:	ce22                	sw	s0,28(sp)
 300314a:	1000                	addi	s0,sp,32
 300314c:	fea42623          	sw	a0,-20(s0)
    BASE_FUNC_UNUSED(context);
}
 3003150:	0001                	nop
 3003152:	4472                	lw	s0,28(sp)
 3003154:	6105                	addi	sp,sp,32
 3003156:	8082                	ret

03003158 <SysErrFinish>:
  * @brief System error completion processing
  * @param None.
  * @retval None.
  */
static void SysErrFinish(void)
{
 3003158:	1141                	addi	sp,sp,-16
 300315a:	c622                	sw	s0,12(sp)
 300315c:	0800                	addi	s0,sp,16
}
 300315e:	0001                	nop
 3003160:	4432                	lw	s0,12(sp)
 3003162:	0141                	addi	sp,sp,16
 3003164:	8082                	ret

03003166 <SysErrExcEntry>:
  * @brief Exception Handler Entry.
  * @param context error context.
  * @retval None.
  */
void SysErrExcEntry(const SyserrContext *context)
{
 3003166:	1101                	addi	sp,sp,-32
 3003168:	ce06                	sw	ra,28(sp)
 300316a:	cc22                	sw	s0,24(sp)
 300316c:	1000                	addi	s0,sp,32
 300316e:	fea42623          	sw	a0,-20(s0)
    SysErrPrint(context);
 3003172:	fec42503          	lw	a0,-20(s0)
 3003176:	3fc1                	jal	ra,3003146 <SysErrPrint>
    SysErrFinish();
 3003178:	37c5                	jal	ra,3003158 <SysErrFinish>
}
 300317a:	0001                	nop
 300317c:	40f2                	lw	ra,28(sp)
 300317e:	4462                	lw	s0,24(sp)
 3003180:	6105                	addi	sp,sp,32
 3003182:	8082                	ret

03003184 <SysErrNmiEntry>:
  * @brief NMI Interrupt Handler Entry.
  * @param context error context.
  * @retval None.
  */
void SysErrNmiEntry(const SyserrContext *context)
{
 3003184:	1101                	addi	sp,sp,-32
 3003186:	ce06                	sw	ra,28(sp)
 3003188:	cc22                	sw	s0,24(sp)
 300318a:	1000                	addi	s0,sp,32
 300318c:	fea42623          	sw	a0,-20(s0)
    INTERRUPT_ASSERT_PARAM(context != NULL);
 3003190:	fec42783          	lw	a5,-20(s0)
 3003194:	eb89                	bnez	a5,30031a6 <SysErrNmiEntry+0x22>
 3003196:	12d00593          	li	a1,301
 300319a:	030127b7          	lui	a5,0x3012
 300319e:	b4478513          	addi	a0,a5,-1212 # 3011b44 <g_crgIpMatch+0x2ac>
 30031a2:	3e45                	jal	ra,3002d52 <AssertErrorLog>
 30031a4:	a001                	j	30031a4 <SysErrNmiEntry+0x20>
    SysErrPrint(context);
 30031a6:	fec42503          	lw	a0,-20(s0)
 30031aa:	3f71                	jal	ra,3003146 <SysErrPrint>
    SysErrFinish();
 30031ac:	3775                	jal	ra,3003158 <SysErrFinish>
}
 30031ae:	0001                	nop
 30031b0:	40f2                	lw	ra,28(sp)
 30031b2:	4462                	lw	s0,24(sp)
 30031b4:	6105                	addi	sp,sp,32
 30031b6:	8082                	ret

030031b8 <SetLocalIntNumPri>:
  * @param interPriNum Local interrupt number, which equals external interrupt number - IRQ_VECTOR_CN.
  * @param prior local int prioroty.
  * @retval None
  */
static void SetLocalIntNumPri(unsigned int intNum, unsigned int interPriNum, unsigned int prior)
{
 30031b8:	711d                	addi	sp,sp,-96
 30031ba:	cea2                	sw	s0,92(sp)
 30031bc:	1080                	addi	s0,sp,96
 30031be:	faa42623          	sw	a0,-84(s0)
 30031c2:	fab42423          	sw	a1,-88(s0)
 30031c6:	fac42223          	sw	a2,-92(s0)
    switch (intNum) {
 30031ca:	fac42783          	lw	a5,-84(s0)
 30031ce:	17e1                	addi	a5,a5,-8
 30031d0:	471d                	li	a4,7
 30031d2:	2af76363          	bltu	a4,a5,3003478 <SetLocalIntNumPri+0x2c0>
 30031d6:	00279713          	slli	a4,a5,0x2
 30031da:	030127b7          	lui	a5,0x3012
 30031de:	b6478793          	addi	a5,a5,-1180 # 3011b64 <g_crgIpMatch+0x2cc>
 30031e2:	97ba                	add	a5,a5,a4
 30031e4:	439c                	lw	a5,0(a5)
 30031e6:	8782                	jr	a5
        case 8:  /* GROUP8 */
            SET_LOCAL_INTER_NUM_PRI(8, interPriNum, prior);
 30031e8:	bc8027f3          	csrr	a5,0xbc8
 30031ec:	faf42a23          	sw	a5,-76(s0)
 30031f0:	fb442783          	lw	a5,-76(s0)
 30031f4:	faf42823          	sw	a5,-80(s0)
 30031f8:	fa842783          	lw	a5,-88(s0)
 30031fc:	078a                	slli	a5,a5,0x2
 30031fe:	8bf1                	andi	a5,a5,28
 3003200:	473d                	li	a4,15
 3003202:	00f717b3          	sll	a5,a4,a5
 3003206:	fff7c793          	not	a5,a5
 300320a:	fb042703          	lw	a4,-80(s0)
 300320e:	8ff9                	and	a5,a5,a4
 3003210:	faf42823          	sw	a5,-80(s0)
 3003214:	fa842783          	lw	a5,-88(s0)
 3003218:	078a                	slli	a5,a5,0x2
 300321a:	8bf1                	andi	a5,a5,28
 300321c:	fa442703          	lw	a4,-92(s0)
 3003220:	00f717b3          	sll	a5,a4,a5
 3003224:	fb042703          	lw	a4,-80(s0)
 3003228:	8fd9                	or	a5,a5,a4
 300322a:	faf42823          	sw	a5,-80(s0)
 300322e:	fb042783          	lw	a5,-80(s0)
 3003232:	82be                	mv	t0,a5
 3003234:	bc829073          	csrw	0xbc8,t0
            break;
 3003238:	a489                	j	300347a <SetLocalIntNumPri+0x2c2>
        case 9:  /* GROUP9 */
            SET_LOCAL_INTER_NUM_PRI(9, interPriNum, prior);
 300323a:	bc9027f3          	csrr	a5,0xbc9
 300323e:	faf42e23          	sw	a5,-68(s0)
 3003242:	fbc42783          	lw	a5,-68(s0)
 3003246:	faf42c23          	sw	a5,-72(s0)
 300324a:	fa842783          	lw	a5,-88(s0)
 300324e:	078a                	slli	a5,a5,0x2
 3003250:	8bf1                	andi	a5,a5,28
 3003252:	473d                	li	a4,15
 3003254:	00f717b3          	sll	a5,a4,a5
 3003258:	fff7c793          	not	a5,a5
 300325c:	fb842703          	lw	a4,-72(s0)
 3003260:	8ff9                	and	a5,a5,a4
 3003262:	faf42c23          	sw	a5,-72(s0)
 3003266:	fa842783          	lw	a5,-88(s0)
 300326a:	078a                	slli	a5,a5,0x2
 300326c:	8bf1                	andi	a5,a5,28
 300326e:	fa442703          	lw	a4,-92(s0)
 3003272:	00f717b3          	sll	a5,a4,a5
 3003276:	fb842703          	lw	a4,-72(s0)
 300327a:	8fd9                	or	a5,a5,a4
 300327c:	faf42c23          	sw	a5,-72(s0)
 3003280:	fb842783          	lw	a5,-72(s0)
 3003284:	82be                	mv	t0,a5
 3003286:	bc929073          	csrw	0xbc9,t0
            break;
 300328a:	aac5                	j	300347a <SetLocalIntNumPri+0x2c2>
        case 10:  /* GROUP10 */
            SET_LOCAL_INTER_NUM_PRI(10, interPriNum, prior);
 300328c:	bca027f3          	csrr	a5,0xbca
 3003290:	fcf42223          	sw	a5,-60(s0)
 3003294:	fc442783          	lw	a5,-60(s0)
 3003298:	fcf42023          	sw	a5,-64(s0)
 300329c:	fa842783          	lw	a5,-88(s0)
 30032a0:	078a                	slli	a5,a5,0x2
 30032a2:	8bf1                	andi	a5,a5,28
 30032a4:	473d                	li	a4,15
 30032a6:	00f717b3          	sll	a5,a4,a5
 30032aa:	fff7c793          	not	a5,a5
 30032ae:	fc042703          	lw	a4,-64(s0)
 30032b2:	8ff9                	and	a5,a5,a4
 30032b4:	fcf42023          	sw	a5,-64(s0)
 30032b8:	fa842783          	lw	a5,-88(s0)
 30032bc:	078a                	slli	a5,a5,0x2
 30032be:	8bf1                	andi	a5,a5,28
 30032c0:	fa442703          	lw	a4,-92(s0)
 30032c4:	00f717b3          	sll	a5,a4,a5
 30032c8:	fc042703          	lw	a4,-64(s0)
 30032cc:	8fd9                	or	a5,a5,a4
 30032ce:	fcf42023          	sw	a5,-64(s0)
 30032d2:	fc042783          	lw	a5,-64(s0)
 30032d6:	82be                	mv	t0,a5
 30032d8:	bca29073          	csrw	0xbca,t0
            break;
 30032dc:	aa79                	j	300347a <SetLocalIntNumPri+0x2c2>
        case 11:  /* GROUP11 */
            SET_LOCAL_INTER_NUM_PRI(11, interPriNum, prior);
 30032de:	bcb027f3          	csrr	a5,0xbcb
 30032e2:	fcf42623          	sw	a5,-52(s0)
 30032e6:	fcc42783          	lw	a5,-52(s0)
 30032ea:	fcf42423          	sw	a5,-56(s0)
 30032ee:	fa842783          	lw	a5,-88(s0)
 30032f2:	078a                	slli	a5,a5,0x2
 30032f4:	8bf1                	andi	a5,a5,28
 30032f6:	473d                	li	a4,15
 30032f8:	00f717b3          	sll	a5,a4,a5
 30032fc:	fff7c793          	not	a5,a5
 3003300:	fc842703          	lw	a4,-56(s0)
 3003304:	8ff9                	and	a5,a5,a4
 3003306:	fcf42423          	sw	a5,-56(s0)
 300330a:	fa842783          	lw	a5,-88(s0)
 300330e:	078a                	slli	a5,a5,0x2
 3003310:	8bf1                	andi	a5,a5,28
 3003312:	fa442703          	lw	a4,-92(s0)
 3003316:	00f717b3          	sll	a5,a4,a5
 300331a:	fc842703          	lw	a4,-56(s0)
 300331e:	8fd9                	or	a5,a5,a4
 3003320:	fcf42423          	sw	a5,-56(s0)
 3003324:	fc842783          	lw	a5,-56(s0)
 3003328:	82be                	mv	t0,a5
 300332a:	bcb29073          	csrw	0xbcb,t0
            break;
 300332e:	a2b1                	j	300347a <SetLocalIntNumPri+0x2c2>
        case 12:  /* GROUP12 */
            SET_LOCAL_INTER_NUM_PRI(12, interPriNum, prior);
 3003330:	bcc027f3          	csrr	a5,0xbcc
 3003334:	fcf42a23          	sw	a5,-44(s0)
 3003338:	fd442783          	lw	a5,-44(s0)
 300333c:	fcf42823          	sw	a5,-48(s0)
 3003340:	fa842783          	lw	a5,-88(s0)
 3003344:	078a                	slli	a5,a5,0x2
 3003346:	8bf1                	andi	a5,a5,28
 3003348:	473d                	li	a4,15
 300334a:	00f717b3          	sll	a5,a4,a5
 300334e:	fff7c793          	not	a5,a5
 3003352:	fd042703          	lw	a4,-48(s0)
 3003356:	8ff9                	and	a5,a5,a4
 3003358:	fcf42823          	sw	a5,-48(s0)
 300335c:	fa842783          	lw	a5,-88(s0)
 3003360:	078a                	slli	a5,a5,0x2
 3003362:	8bf1                	andi	a5,a5,28
 3003364:	fa442703          	lw	a4,-92(s0)
 3003368:	00f717b3          	sll	a5,a4,a5
 300336c:	fd042703          	lw	a4,-48(s0)
 3003370:	8fd9                	or	a5,a5,a4
 3003372:	fcf42823          	sw	a5,-48(s0)
 3003376:	fd042783          	lw	a5,-48(s0)
 300337a:	82be                	mv	t0,a5
 300337c:	bcc29073          	csrw	0xbcc,t0
            break;
 3003380:	a8ed                	j	300347a <SetLocalIntNumPri+0x2c2>
        case 13:  /* GROUP13 */
            SET_LOCAL_INTER_NUM_PRI(13, interPriNum, prior);
 3003382:	bcd027f3          	csrr	a5,0xbcd
 3003386:	fcf42e23          	sw	a5,-36(s0)
 300338a:	fdc42783          	lw	a5,-36(s0)
 300338e:	fcf42c23          	sw	a5,-40(s0)
 3003392:	fa842783          	lw	a5,-88(s0)
 3003396:	078a                	slli	a5,a5,0x2
 3003398:	8bf1                	andi	a5,a5,28
 300339a:	473d                	li	a4,15
 300339c:	00f717b3          	sll	a5,a4,a5
 30033a0:	fff7c793          	not	a5,a5
 30033a4:	fd842703          	lw	a4,-40(s0)
 30033a8:	8ff9                	and	a5,a5,a4
 30033aa:	fcf42c23          	sw	a5,-40(s0)
 30033ae:	fa842783          	lw	a5,-88(s0)
 30033b2:	078a                	slli	a5,a5,0x2
 30033b4:	8bf1                	andi	a5,a5,28
 30033b6:	fa442703          	lw	a4,-92(s0)
 30033ba:	00f717b3          	sll	a5,a4,a5
 30033be:	fd842703          	lw	a4,-40(s0)
 30033c2:	8fd9                	or	a5,a5,a4
 30033c4:	fcf42c23          	sw	a5,-40(s0)
 30033c8:	fd842783          	lw	a5,-40(s0)
 30033cc:	82be                	mv	t0,a5
 30033ce:	bcd29073          	csrw	0xbcd,t0
            break;
 30033d2:	a065                	j	300347a <SetLocalIntNumPri+0x2c2>
        case 14:  /* GROUP14 */
            SET_LOCAL_INTER_NUM_PRI(14, interPriNum, prior);
 30033d4:	bce027f3          	csrr	a5,0xbce
 30033d8:	fef42223          	sw	a5,-28(s0)
 30033dc:	fe442783          	lw	a5,-28(s0)
 30033e0:	fef42023          	sw	a5,-32(s0)
 30033e4:	fa842783          	lw	a5,-88(s0)
 30033e8:	078a                	slli	a5,a5,0x2
 30033ea:	8bf1                	andi	a5,a5,28
 30033ec:	473d                	li	a4,15
 30033ee:	00f717b3          	sll	a5,a4,a5
 30033f2:	fff7c793          	not	a5,a5
 30033f6:	fe042703          	lw	a4,-32(s0)
 30033fa:	8ff9                	and	a5,a5,a4
 30033fc:	fef42023          	sw	a5,-32(s0)
 3003400:	fa842783          	lw	a5,-88(s0)
 3003404:	078a                	slli	a5,a5,0x2
 3003406:	8bf1                	andi	a5,a5,28
 3003408:	fa442703          	lw	a4,-92(s0)
 300340c:	00f717b3          	sll	a5,a4,a5
 3003410:	fe042703          	lw	a4,-32(s0)
 3003414:	8fd9                	or	a5,a5,a4
 3003416:	fef42023          	sw	a5,-32(s0)
 300341a:	fe042783          	lw	a5,-32(s0)
 300341e:	82be                	mv	t0,a5
 3003420:	bce29073          	csrw	0xbce,t0
            break;
 3003424:	a899                	j	300347a <SetLocalIntNumPri+0x2c2>
        case 15:  /* GROUP15 */
            SET_LOCAL_INTER_NUM_PRI(15, interPriNum, prior);
 3003426:	bcf027f3          	csrr	a5,0xbcf
 300342a:	fef42623          	sw	a5,-20(s0)
 300342e:	fec42783          	lw	a5,-20(s0)
 3003432:	fef42423          	sw	a5,-24(s0)
 3003436:	fa842783          	lw	a5,-88(s0)
 300343a:	078a                	slli	a5,a5,0x2
 300343c:	8bf1                	andi	a5,a5,28
 300343e:	473d                	li	a4,15
 3003440:	00f717b3          	sll	a5,a4,a5
 3003444:	fff7c793          	not	a5,a5
 3003448:	fe842703          	lw	a4,-24(s0)
 300344c:	8ff9                	and	a5,a5,a4
 300344e:	fef42423          	sw	a5,-24(s0)
 3003452:	fa842783          	lw	a5,-88(s0)
 3003456:	078a                	slli	a5,a5,0x2
 3003458:	8bf1                	andi	a5,a5,28
 300345a:	fa442703          	lw	a4,-92(s0)
 300345e:	00f717b3          	sll	a5,a4,a5
 3003462:	fe842703          	lw	a4,-24(s0)
 3003466:	8fd9                	or	a5,a5,a4
 3003468:	fef42423          	sw	a5,-24(s0)
 300346c:	fe842783          	lw	a5,-24(s0)
 3003470:	82be                	mv	t0,a5
 3003472:	bcf29073          	csrw	0xbcf,t0
            break;
 3003476:	a011                	j	300347a <SetLocalIntNumPri+0x2c2>
        default:
            break;
 3003478:	0001                	nop
    }
}
 300347a:	0001                	nop
 300347c:	4476                	lw	s0,92(sp)
 300347e:	6125                	addi	sp,sp,96
 3003480:	8082                	ret

03003482 <IRQ_SetLocalPriority>:
  * @param interPriNum Local interrupt number, which equals external interrupt number - IRQ_VECTOR_CN.
  * @param prior       Priority of this local interrupt to be set.
  * @retval None.
  */
static void IRQ_SetLocalPriority(unsigned int interPriNum, unsigned int prior)
{
 3003482:	7159                	addi	sp,sp,-112
 3003484:	d686                	sw	ra,108(sp)
 3003486:	d4a2                	sw	s0,104(sp)
 3003488:	1880                	addi	s0,sp,112
 300348a:	f8a42e23          	sw	a0,-100(s0)
 300348e:	f8b42c23          	sw	a1,-104(s0)
#if defined(USER_MODE_ENABLE) && (USER_MODE_ENABLE == 1)
    unsigned int priv = IRQ_GetCpuPrivilege();
 3003492:	26d9                	jal	ra,3003858 <IRQ_GetCpuPrivilege>
 3003494:	fea42623          	sw	a0,-20(s0)
#endif
    RISCV_PRIV_MODE_SWITCH(priv);
 3003498:	fec42703          	lw	a4,-20(s0)
 300349c:	47a1                	li	a5,8
 300349e:	00f71463          	bne	a4,a5,30034a6 <IRQ_SetLocalPriority+0x24>
 30034a2:	00000073          	ecall
    unsigned int intNum = GET_LOCAL_INTER_CONFIGREG_NUM(interPriNum);
 30034a6:	f9c42783          	lw	a5,-100(s0)
 30034aa:	838d                	srli	a5,a5,0x3
 30034ac:	fef42423          	sw	a5,-24(s0)
    switch (intNum) {
 30034b0:	fe842703          	lw	a4,-24(s0)
 30034b4:	479d                	li	a5,7
 30034b6:	2ae7e563          	bltu	a5,a4,3003760 <IRQ_SetLocalPriority+0x2de>
 30034ba:	fe842783          	lw	a5,-24(s0)
 30034be:	00279713          	slli	a4,a5,0x2
 30034c2:	030127b7          	lui	a5,0x3012
 30034c6:	b8478793          	addi	a5,a5,-1148 # 3011b84 <g_crgIpMatch+0x2ec>
 30034ca:	97ba                	add	a5,a5,a4
 30034cc:	439c                	lw	a5,0(a5)
 30034ce:	8782                	jr	a5
        case 0:  /* GROUP0 */
            SET_LOCAL_INTER_NUM_PRI(0, interPriNum, prior);
 30034d0:	bc0027f3          	csrr	a5,0xbc0
 30034d4:	faf42623          	sw	a5,-84(s0)
 30034d8:	fac42783          	lw	a5,-84(s0)
 30034dc:	faf42423          	sw	a5,-88(s0)
 30034e0:	f9c42783          	lw	a5,-100(s0)
 30034e4:	078a                	slli	a5,a5,0x2
 30034e6:	8bf1                	andi	a5,a5,28
 30034e8:	473d                	li	a4,15
 30034ea:	00f717b3          	sll	a5,a4,a5
 30034ee:	fff7c793          	not	a5,a5
 30034f2:	fa842703          	lw	a4,-88(s0)
 30034f6:	8ff9                	and	a5,a5,a4
 30034f8:	faf42423          	sw	a5,-88(s0)
 30034fc:	f9c42783          	lw	a5,-100(s0)
 3003500:	078a                	slli	a5,a5,0x2
 3003502:	8bf1                	andi	a5,a5,28
 3003504:	f9842703          	lw	a4,-104(s0)
 3003508:	00f717b3          	sll	a5,a4,a5
 300350c:	fa842703          	lw	a4,-88(s0)
 3003510:	8fd9                	or	a5,a5,a4
 3003512:	faf42423          	sw	a5,-88(s0)
 3003516:	fa842783          	lw	a5,-88(s0)
 300351a:	82be                	mv	t0,a5
 300351c:	bc029073          	csrw	0xbc0,t0
            break;
 3003520:	ac81                	j	3003770 <IRQ_SetLocalPriority+0x2ee>
        case 1:  /* GROUP1 */
            SET_LOCAL_INTER_NUM_PRI(1, interPriNum, prior);
 3003522:	bc1027f3          	csrr	a5,0xbc1
 3003526:	faf42a23          	sw	a5,-76(s0)
 300352a:	fb442783          	lw	a5,-76(s0)
 300352e:	faf42823          	sw	a5,-80(s0)
 3003532:	f9c42783          	lw	a5,-100(s0)
 3003536:	078a                	slli	a5,a5,0x2
 3003538:	8bf1                	andi	a5,a5,28
 300353a:	473d                	li	a4,15
 300353c:	00f717b3          	sll	a5,a4,a5
 3003540:	fff7c793          	not	a5,a5
 3003544:	fb042703          	lw	a4,-80(s0)
 3003548:	8ff9                	and	a5,a5,a4
 300354a:	faf42823          	sw	a5,-80(s0)
 300354e:	f9c42783          	lw	a5,-100(s0)
 3003552:	078a                	slli	a5,a5,0x2
 3003554:	8bf1                	andi	a5,a5,28
 3003556:	f9842703          	lw	a4,-104(s0)
 300355a:	00f717b3          	sll	a5,a4,a5
 300355e:	fb042703          	lw	a4,-80(s0)
 3003562:	8fd9                	or	a5,a5,a4
 3003564:	faf42823          	sw	a5,-80(s0)
 3003568:	fb042783          	lw	a5,-80(s0)
 300356c:	82be                	mv	t0,a5
 300356e:	bc129073          	csrw	0xbc1,t0
            break;
 3003572:	aafd                	j	3003770 <IRQ_SetLocalPriority+0x2ee>
        case 2:  /* GROUP2 */
            SET_LOCAL_INTER_NUM_PRI(2, interPriNum, prior);
 3003574:	bc2027f3          	csrr	a5,0xbc2
 3003578:	faf42e23          	sw	a5,-68(s0)
 300357c:	fbc42783          	lw	a5,-68(s0)
 3003580:	faf42c23          	sw	a5,-72(s0)
 3003584:	f9c42783          	lw	a5,-100(s0)
 3003588:	078a                	slli	a5,a5,0x2
 300358a:	8bf1                	andi	a5,a5,28
 300358c:	473d                	li	a4,15
 300358e:	00f717b3          	sll	a5,a4,a5
 3003592:	fff7c793          	not	a5,a5
 3003596:	fb842703          	lw	a4,-72(s0)
 300359a:	8ff9                	and	a5,a5,a4
 300359c:	faf42c23          	sw	a5,-72(s0)
 30035a0:	f9c42783          	lw	a5,-100(s0)
 30035a4:	078a                	slli	a5,a5,0x2
 30035a6:	8bf1                	andi	a5,a5,28
 30035a8:	f9842703          	lw	a4,-104(s0)
 30035ac:	00f717b3          	sll	a5,a4,a5
 30035b0:	fb842703          	lw	a4,-72(s0)
 30035b4:	8fd9                	or	a5,a5,a4
 30035b6:	faf42c23          	sw	a5,-72(s0)
 30035ba:	fb842783          	lw	a5,-72(s0)
 30035be:	82be                	mv	t0,a5
 30035c0:	bc229073          	csrw	0xbc2,t0
            break;
 30035c4:	a275                	j	3003770 <IRQ_SetLocalPriority+0x2ee>
        case 3:  /* GROUP3 */
            SET_LOCAL_INTER_NUM_PRI(3, interPriNum, prior);
 30035c6:	bc3027f3          	csrr	a5,0xbc3
 30035ca:	fcf42223          	sw	a5,-60(s0)
 30035ce:	fc442783          	lw	a5,-60(s0)
 30035d2:	fcf42023          	sw	a5,-64(s0)
 30035d6:	f9c42783          	lw	a5,-100(s0)
 30035da:	078a                	slli	a5,a5,0x2
 30035dc:	8bf1                	andi	a5,a5,28
 30035de:	473d                	li	a4,15
 30035e0:	00f717b3          	sll	a5,a4,a5
 30035e4:	fff7c793          	not	a5,a5
 30035e8:	fc042703          	lw	a4,-64(s0)
 30035ec:	8ff9                	and	a5,a5,a4
 30035ee:	fcf42023          	sw	a5,-64(s0)
 30035f2:	f9c42783          	lw	a5,-100(s0)
 30035f6:	078a                	slli	a5,a5,0x2
 30035f8:	8bf1                	andi	a5,a5,28
 30035fa:	f9842703          	lw	a4,-104(s0)
 30035fe:	00f717b3          	sll	a5,a4,a5
 3003602:	fc042703          	lw	a4,-64(s0)
 3003606:	8fd9                	or	a5,a5,a4
 3003608:	fcf42023          	sw	a5,-64(s0)
 300360c:	fc042783          	lw	a5,-64(s0)
 3003610:	82be                	mv	t0,a5
 3003612:	bc329073          	csrw	0xbc3,t0
            break;
 3003616:	aaa9                	j	3003770 <IRQ_SetLocalPriority+0x2ee>
        case 4:  /* GROUP4 */
            SET_LOCAL_INTER_NUM_PRI(4, interPriNum, prior);
 3003618:	bc4027f3          	csrr	a5,0xbc4
 300361c:	fcf42623          	sw	a5,-52(s0)
 3003620:	fcc42783          	lw	a5,-52(s0)
 3003624:	fcf42423          	sw	a5,-56(s0)
 3003628:	f9c42783          	lw	a5,-100(s0)
 300362c:	078a                	slli	a5,a5,0x2
 300362e:	8bf1                	andi	a5,a5,28
 3003630:	473d                	li	a4,15
 3003632:	00f717b3          	sll	a5,a4,a5
 3003636:	fff7c793          	not	a5,a5
 300363a:	fc842703          	lw	a4,-56(s0)
 300363e:	8ff9                	and	a5,a5,a4
 3003640:	fcf42423          	sw	a5,-56(s0)
 3003644:	f9c42783          	lw	a5,-100(s0)
 3003648:	078a                	slli	a5,a5,0x2
 300364a:	8bf1                	andi	a5,a5,28
 300364c:	f9842703          	lw	a4,-104(s0)
 3003650:	00f717b3          	sll	a5,a4,a5
 3003654:	fc842703          	lw	a4,-56(s0)
 3003658:	8fd9                	or	a5,a5,a4
 300365a:	fcf42423          	sw	a5,-56(s0)
 300365e:	fc842783          	lw	a5,-56(s0)
 3003662:	82be                	mv	t0,a5
 3003664:	bc429073          	csrw	0xbc4,t0
            break;
 3003668:	a221                	j	3003770 <IRQ_SetLocalPriority+0x2ee>
        case 5:  /* GROUP5 */
            SET_LOCAL_INTER_NUM_PRI(5, interPriNum, prior);
 300366a:	bc5027f3          	csrr	a5,0xbc5
 300366e:	fcf42a23          	sw	a5,-44(s0)
 3003672:	fd442783          	lw	a5,-44(s0)
 3003676:	fcf42823          	sw	a5,-48(s0)
 300367a:	f9c42783          	lw	a5,-100(s0)
 300367e:	078a                	slli	a5,a5,0x2
 3003680:	8bf1                	andi	a5,a5,28
 3003682:	473d                	li	a4,15
 3003684:	00f717b3          	sll	a5,a4,a5
 3003688:	fff7c793          	not	a5,a5
 300368c:	fd042703          	lw	a4,-48(s0)
 3003690:	8ff9                	and	a5,a5,a4
 3003692:	fcf42823          	sw	a5,-48(s0)
 3003696:	f9c42783          	lw	a5,-100(s0)
 300369a:	078a                	slli	a5,a5,0x2
 300369c:	8bf1                	andi	a5,a5,28
 300369e:	f9842703          	lw	a4,-104(s0)
 30036a2:	00f717b3          	sll	a5,a4,a5
 30036a6:	fd042703          	lw	a4,-48(s0)
 30036aa:	8fd9                	or	a5,a5,a4
 30036ac:	fcf42823          	sw	a5,-48(s0)
 30036b0:	fd042783          	lw	a5,-48(s0)
 30036b4:	82be                	mv	t0,a5
 30036b6:	bc529073          	csrw	0xbc5,t0
            break;
 30036ba:	a85d                	j	3003770 <IRQ_SetLocalPriority+0x2ee>
        case 6:  /* GROUP6 */
            SET_LOCAL_INTER_NUM_PRI(6, interPriNum, prior);
 30036bc:	bc6027f3          	csrr	a5,0xbc6
 30036c0:	fcf42e23          	sw	a5,-36(s0)
 30036c4:	fdc42783          	lw	a5,-36(s0)
 30036c8:	fcf42c23          	sw	a5,-40(s0)
 30036cc:	f9c42783          	lw	a5,-100(s0)
 30036d0:	078a                	slli	a5,a5,0x2
 30036d2:	8bf1                	andi	a5,a5,28
 30036d4:	473d                	li	a4,15
 30036d6:	00f717b3          	sll	a5,a4,a5
 30036da:	fff7c793          	not	a5,a5
 30036de:	fd842703          	lw	a4,-40(s0)
 30036e2:	8ff9                	and	a5,a5,a4
 30036e4:	fcf42c23          	sw	a5,-40(s0)
 30036e8:	f9c42783          	lw	a5,-100(s0)
 30036ec:	078a                	slli	a5,a5,0x2
 30036ee:	8bf1                	andi	a5,a5,28
 30036f0:	f9842703          	lw	a4,-104(s0)
 30036f4:	00f717b3          	sll	a5,a4,a5
 30036f8:	fd842703          	lw	a4,-40(s0)
 30036fc:	8fd9                	or	a5,a5,a4
 30036fe:	fcf42c23          	sw	a5,-40(s0)
 3003702:	fd842783          	lw	a5,-40(s0)
 3003706:	82be                	mv	t0,a5
 3003708:	bc629073          	csrw	0xbc6,t0
            break;
 300370c:	a095                	j	3003770 <IRQ_SetLocalPriority+0x2ee>
        case 7:  /* GROUP7 */
            SET_LOCAL_INTER_NUM_PRI(7, interPriNum, prior);
 300370e:	bc7027f3          	csrr	a5,0xbc7
 3003712:	fef42223          	sw	a5,-28(s0)
 3003716:	fe442783          	lw	a5,-28(s0)
 300371a:	fef42023          	sw	a5,-32(s0)
 300371e:	f9c42783          	lw	a5,-100(s0)
 3003722:	078a                	slli	a5,a5,0x2
 3003724:	8bf1                	andi	a5,a5,28
 3003726:	473d                	li	a4,15
 3003728:	00f717b3          	sll	a5,a4,a5
 300372c:	fff7c793          	not	a5,a5
 3003730:	fe042703          	lw	a4,-32(s0)
 3003734:	8ff9                	and	a5,a5,a4
 3003736:	fef42023          	sw	a5,-32(s0)
 300373a:	f9c42783          	lw	a5,-100(s0)
 300373e:	078a                	slli	a5,a5,0x2
 3003740:	8bf1                	andi	a5,a5,28
 3003742:	f9842703          	lw	a4,-104(s0)
 3003746:	00f717b3          	sll	a5,a4,a5
 300374a:	fe042703          	lw	a4,-32(s0)
 300374e:	8fd9                	or	a5,a5,a4
 3003750:	fef42023          	sw	a5,-32(s0)
 3003754:	fe042783          	lw	a5,-32(s0)
 3003758:	82be                	mv	t0,a5
 300375a:	bc729073          	csrw	0xbc7,t0
            break;
 300375e:	a809                	j	3003770 <IRQ_SetLocalPriority+0x2ee>
        default:
            SetLocalIntNumPri(intNum, interPriNum, prior);
 3003760:	f9842603          	lw	a2,-104(s0)
 3003764:	f9c42583          	lw	a1,-100(s0)
 3003768:	fe842503          	lw	a0,-24(s0)
 300376c:	34b1                	jal	ra,30031b8 <SetLocalIntNumPri>
            break;
 300376e:	0001                	nop
    }
    RISCV_PRIV_MODE_SWITCH(priv);
 3003770:	fec42703          	lw	a4,-20(s0)
 3003774:	47a1                	li	a5,8
 3003776:	00f71463          	bne	a4,a5,300377e <IRQ_SetLocalPriority+0x2fc>
 300377a:	00000073          	ecall
}
 300377e:	0001                	nop
 3003780:	50b6                	lw	ra,108(sp)
 3003782:	5426                	lw	s0,104(sp)
 3003784:	6165                	addi	sp,sp,112
 3003786:	8082                	ret

03003788 <IRQ_SetPriority>:
  * @param irqNum  External interrupt number.
  * @param priority.
  * @retval IRQ_ERRNO_NUM_INVALID or IRQ_ERRNO_PRIORITY_INVALID or BASE_STATUS_OK.
  */
unsigned int IRQ_SetPriority(unsigned int irqNum, unsigned int priority)
{
 3003788:	1101                	addi	sp,sp,-32
 300378a:	ce06                	sw	ra,28(sp)
 300378c:	cc22                	sw	s0,24(sp)
 300378e:	1000                	addi	s0,sp,32
 3003790:	fea42623          	sw	a0,-20(s0)
 3003794:	feb42423          	sw	a1,-24(s0)
    INTERRUPT_PARAM_CHECK_WITH_RET((irqNum >= IRQ_VECTOR_CNT && irqNum < IRQ_MAX), IRQ_ERRNO_NUM_INVALID);
 3003798:	fec42703          	lw	a4,-20(s0)
 300379c:	47e5                	li	a5,25
 300379e:	00e7f863          	bgeu	a5,a4,30037ae <IRQ_SetPriority+0x26>
 30037a2:	fec42703          	lw	a4,-20(s0)
 30037a6:	07200793          	li	a5,114
 30037aa:	00e7fc63          	bgeu	a5,a4,30037c2 <IRQ_SetPriority+0x3a>
 30037ae:	18c00593          	li	a1,396
 30037b2:	030127b7          	lui	a5,0x3012
 30037b6:	b4478513          	addi	a0,a5,-1212 # 3011b44 <g_crgIpMatch+0x2ac>
 30037ba:	d98ff0ef          	jal	ra,3002d52 <AssertErrorLog>
 30037be:	4789                	li	a5,2
 30037c0:	a81d                	j	30037f6 <IRQ_SetPriority+0x6e>
    INTERRUPT_PARAM_CHECK_WITH_RET((priority >= IRQ_PRIO_LOWEST && priority <= IRQ_PRIO_HIGHEST), \
 30037c2:	fe842783          	lw	a5,-24(s0)
 30037c6:	c791                	beqz	a5,30037d2 <IRQ_SetPriority+0x4a>
 30037c8:	fe842703          	lw	a4,-24(s0)
 30037cc:	47bd                	li	a5,15
 30037ce:	00e7fc63          	bgeu	a5,a4,30037e6 <IRQ_SetPriority+0x5e>
 30037d2:	18d00593          	li	a1,397
 30037d6:	030127b7          	lui	a5,0x3012
 30037da:	b4478513          	addi	a0,a5,-1212 # 3011b44 <g_crgIpMatch+0x2ac>
 30037de:	d74ff0ef          	jal	ra,3002d52 <AssertErrorLog>
 30037e2:	4795                	li	a5,5
 30037e4:	a809                	j	30037f6 <IRQ_SetPriority+0x6e>
                                   IRQ_ERRNO_PRIORITY_INVALID);

    /* The locipri register is specifically used to configure the priority of the
       external non-standard interrupts of the CPU, so the number of internal
       standard interrupts should be subtracted */
    IRQ_SetLocalPriority(irqNum - IRQ_VECTOR_CNT, priority);
 30037e6:	fec42783          	lw	a5,-20(s0)
 30037ea:	1799                	addi	a5,a5,-26
 30037ec:	fe842583          	lw	a1,-24(s0)
 30037f0:	853e                	mv	a0,a5
 30037f2:	3941                	jal	ra,3003482 <IRQ_SetLocalPriority>

    return BASE_STATUS_OK;
 30037f4:	4781                	li	a5,0
}
 30037f6:	853e                	mv	a0,a5
 30037f8:	40f2                	lw	ra,28(sp)
 30037fa:	4462                	lw	s0,24(sp)
 30037fc:	6105                	addi	sp,sp,32
 30037fe:	8082                	ret

03003800 <IRQ_DummyHandler>:
  * @brief Interrupt dummy handler
  * @param arg     Not used
  * @retval None.
  */
static void IRQ_DummyHandler(void *arg)
{
 3003800:	1101                	addi	sp,sp,-32
 3003802:	ce22                	sw	s0,28(sp)
 3003804:	1000                	addi	s0,sp,32
 3003806:	fea42623          	sw	a0,-20(s0)
    BASE_FUNC_UNUSED(arg);
}
 300380a:	0001                	nop
 300380c:	4472                	lw	s0,28(sp)
 300380e:	6105                	addi	sp,sp,32
 3003810:	8082                	ret

03003812 <IRQ_SetCallBack>:
  * @param func   callback function
  * @param arg    callback arg
  * @retval None.
  */
static inline void IRQ_SetCallBack(unsigned int irqNum, IRQ_PROC_FUNC func, void *arg)
{
 3003812:	1101                	addi	sp,sp,-32
 3003814:	ce22                	sw	s0,28(sp)
 3003816:	1000                	addi	s0,sp,32
 3003818:	fea42623          	sw	a0,-20(s0)
 300381c:	feb42423          	sw	a1,-24(s0)
 3003820:	fec42223          	sw	a2,-28(s0)
    g_irqCallbackFunc[irqNum].param = arg;
 3003824:	040007b7          	lui	a5,0x4000
 3003828:	18478713          	addi	a4,a5,388 # 4000184 <g_irqCallbackFunc>
 300382c:	fec42783          	lw	a5,-20(s0)
 3003830:	078e                	slli	a5,a5,0x3
 3003832:	97ba                	add	a5,a5,a4
 3003834:	fe442703          	lw	a4,-28(s0)
 3003838:	c3d8                	sw	a4,4(a5)
    g_irqCallbackFunc[irqNum].pfnHandler = func;
 300383a:	040007b7          	lui	a5,0x4000
 300383e:	18478713          	addi	a4,a5,388 # 4000184 <g_irqCallbackFunc>
 3003842:	fec42783          	lw	a5,-20(s0)
 3003846:	078e                	slli	a5,a5,0x3
 3003848:	97ba                	add	a5,a5,a4
 300384a:	fe842703          	lw	a4,-24(s0)
 300384e:	c398                	sw	a4,0(a5)
}
 3003850:	0001                	nop
 3003852:	4472                	lw	s0,28(sp)
 3003854:	6105                	addi	sp,sp,32
 3003856:	8082                	ret

03003858 <IRQ_GetCpuPrivilege>:
  * @param none
  * @retval mcause value
  */
#if defined(USER_MODE_ENABLE) && (USER_MODE_ENABLE == 1)
static inline unsigned int IRQ_GetCpuPrivilege(void)
{
 3003858:	1141                	addi	sp,sp,-16
 300385a:	c622                	sw	s0,12(sp)
 300385c:	0800                	addi	s0,sp,16
    return (g_RiscvPrivMode == 0) ? RISCV_U_MODE : RISCV_M_MODE;
 300385e:	8761a783          	lw	a5,-1930(gp) # 4000180 <g_RiscvPrivMode>
 3003862:	e399                	bnez	a5,3003868 <IRQ_GetCpuPrivilege+0x10>
 3003864:	47a1                	li	a5,8
 3003866:	a011                	j	300386a <IRQ_GetCpuPrivilege+0x12>
 3003868:	47ad                	li	a5,11
}
 300386a:	853e                	mv	a0,a5
 300386c:	4432                	lw	s0,12(sp)
 300386e:	0141                	addi	sp,sp,16
 3003870:	8082                	ret

03003872 <CAN_WaitTime>:
 * @brief Wait 11 CAN bit time.
 * @param canHandle CAN handle.
 * @retval void
 */
static void CAN_WaitTime(CAN_Handle *canHandle)
{
 3003872:	7179                	addi	sp,sp,-48
 3003874:	d606                	sw	ra,44(sp)
 3003876:	d422                	sw	s0,40(sp)
 3003878:	1800                	addi	s0,sp,48
 300387a:	fca42e23          	sw	a0,-36(s0)
    /* CAN clock frequency */
    unsigned int canFrep = HAL_CRG_GetIpFreq((void *)canHandle->baseAddress) / (canHandle->prescalser);
 300387e:	fdc42783          	lw	a5,-36(s0)
 3003882:	439c                	lw	a5,0(a5)
 3003884:	853e                	mv	a0,a5
 3003886:	690010ef          	jal	ra,3004f16 <HAL_CRG_GetIpFreq>
 300388a:	872a                	mv	a4,a0
 300388c:	fdc42783          	lw	a5,-36(s0)
 3003890:	4bdc                	lw	a5,20(a5)
 3003892:	02f757b3          	divu	a5,a4,a5
 3003896:	fef42623          	sw	a5,-20(s0)
    unsigned int waitTime = canFrep / (1 + canHandle->seg1Phase + canHandle->seg2Phase);
 300389a:	fdc42783          	lw	a5,-36(s0)
 300389e:	47d8                	lw	a4,12(a5)
 30038a0:	fdc42783          	lw	a5,-36(s0)
 30038a4:	4b9c                	lw	a5,16(a5)
 30038a6:	97ba                	add	a5,a5,a4
 30038a8:	0785                	addi	a5,a5,1
 30038aa:	fec42703          	lw	a4,-20(s0)
 30038ae:	02f757b3          	divu	a5,a4,a5
 30038b2:	fef42423          	sw	a5,-24(s0)
    /* 1000000 equals 1 us to wait for 11 time bits */
    unsigned int waitTimeCount = CAN_TIME_WAIT * ((1000000) / waitTime);
 30038b6:	000f47b7          	lui	a5,0xf4
 30038ba:	24078713          	addi	a4,a5,576 # f4240 <FLASH_SIZE+0xd4244>
 30038be:	fe842783          	lw	a5,-24(s0)
 30038c2:	02f75733          	divu	a4,a4,a5
 30038c6:	47ad                	li	a5,11
 30038c8:	02f707b3          	mul	a5,a4,a5
 30038cc:	fef42223          	sw	a5,-28(s0)
    BASE_FUNC_DelayUs(waitTimeCount);
 30038d0:	fe442503          	lw	a0,-28(s0)
 30038d4:	cc0ff0ef          	jal	ra,3002d94 <BASE_FUNC_DelayUs>
}
 30038d8:	0001                	nop
 30038da:	50b2                	lw	ra,44(sp)
 30038dc:	5422                	lw	s0,40(sp)
 30038de:	6145                	addi	sp,sp,48
 30038e0:	8082                	ret

030038e2 <CAN_AutoRetrans>:
 * @brief CAN Setting Automatic Retransmission.
 * @param canHandle CAN handle.
 * @retval void
 */
static void CAN_AutoRetrans(CAN_Handle *canHandle)
{
 30038e2:	1101                	addi	sp,sp,-32
 30038e4:	ce22                	sw	s0,28(sp)
 30038e6:	1000                	addi	s0,sp,32
 30038e8:	fea42623          	sw	a0,-20(s0)
    if (canHandle->autoRetrans == BASE_CFG_DISABLE) {
 30038ec:	fec42783          	lw	a5,-20(s0)
 30038f0:	02c7c783          	lbu	a5,44(a5)
 30038f4:	0017c793          	xori	a5,a5,1
 30038f8:	9f81                	uxtb	a5
 30038fa:	cb89                	beqz	a5,300390c <CAN_AutoRetrans+0x2a>
        /* Turn off auto retransmission */
        canHandle->baseAddress->CAN_CONTROL.BIT.DAR = BASE_CFG_ENABLE;
 30038fc:	fec42783          	lw	a5,-20(s0)
 3003900:	4398                	lw	a4,0(a5)
 3003902:	431c                	lw	a5,0(a4)
 3003904:	0207e793          	ori	a5,a5,32
 3003908:	c31c                	sw	a5,0(a4)
    } else {
        /* Turn on auto retransmission */
        canHandle->baseAddress->CAN_CONTROL.BIT.DAR = BASE_CFG_DISABLE;
    }
}
 300390a:	a801                	j	300391a <CAN_AutoRetrans+0x38>
        canHandle->baseAddress->CAN_CONTROL.BIT.DAR = BASE_CFG_DISABLE;
 300390c:	fec42783          	lw	a5,-20(s0)
 3003910:	4398                	lw	a4,0(a5)
 3003912:	431c                	lw	a5,0(a4)
 3003914:	fdf7f793          	andi	a5,a5,-33
 3003918:	c31c                	sw	a5,0(a4)
}
 300391a:	0001                	nop
 300391c:	4472                	lw	s0,28(sp)
 300391e:	6105                	addi	sp,sp,32
 3003920:	8082                	ret

03003922 <HAL_CAN_Init>:
  * @brief Initialize the CAN hardware configuration and configure parameters based on the specified handle.
  * @param canHandle CAN handle.
  * @retval BASE status type: OK, ERROR, BUSY, TIMEOUT
  */
BASE_StatusType HAL_CAN_Init(CAN_Handle *canHandle)
{
 3003922:	7179                	addi	sp,sp,-48
 3003924:	d606                	sw	ra,44(sp)
 3003926:	d422                	sw	s0,40(sp)
 3003928:	1800                	addi	s0,sp,48
 300392a:	fca42e23          	sw	a0,-36(s0)
    CAN_PARAM_CHECK_WITH_RET(IsCanSeg1phase(canHandle->seg1Phase), BASE_STATUS_ERROR);
    CAN_PARAM_CHECK_WITH_RET(IsCanSeg2phase(canHandle->seg2Phase), BASE_STATUS_ERROR);
    CAN_PARAM_CHECK_WITH_RET(IsCanSJW(canHandle->sjw), BASE_STATUS_ERROR);
    unsigned int busy;
    /* Step1: init enable */
    canHandle->baseAddress->CAN_CONTROL.BIT.Init = BASE_CFG_ENABLE;
 300392e:	fdc42783          	lw	a5,-36(s0)
 3003932:	4398                	lw	a4,0(a5)
 3003934:	431c                	lw	a5,0(a4)
 3003936:	0017e793          	ori	a5,a5,1
 300393a:	c31c                	sw	a5,0(a4)
    /* Step2: configuration command mask register, set 0xF3 to write into packet objects */
    canHandle->baseAddress->IF1_COMMAND_MASK.reg = 0xF3;
 300393c:	fdc42783          	lw	a5,-36(s0)
 3003940:	439c                	lw	a5,0(a5)
 3003942:	0f300713          	li	a4,243
 3003946:	d3d8                	sw	a4,36(a5)
    /* Step3 ~ 4: init packet object 1 ~ 32 */
    for (int i = 1; i <= CAN_OBJ_MAXNUM; i++) {
 3003948:	4785                	li	a5,1
 300394a:	fef42623          	sw	a5,-20(s0)
 300394e:	a815                	j	3003982 <HAL_CAN_Init+0x60>
        canHandle->baseAddress->IF1_COMMAND_REQUEST.reg = i;
 3003950:	fdc42783          	lw	a5,-36(s0)
 3003954:	439c                	lw	a5,0(a5)
 3003956:	fec42703          	lw	a4,-20(s0)
 300395a:	d398                	sw	a4,32(a5)
        do {
            busy = canHandle->baseAddress->IF1_COMMAND_REQUEST.BIT.BUSY;
 300395c:	fdc42783          	lw	a5,-36(s0)
 3003960:	439c                	lw	a5,0(a5)
 3003962:	539c                	lw	a5,32(a5)
 3003964:	83bd                	srli	a5,a5,0xf
 3003966:	8b85                	andi	a5,a5,1
 3003968:	9f81                	uxtb	a5
 300396a:	fef42023          	sw	a5,-32(s0)
        } while (busy == BASE_CFG_ENABLE);
 300396e:	fe042703          	lw	a4,-32(s0)
 3003972:	4785                	li	a5,1
 3003974:	fef704e3          	beq	a4,a5,300395c <HAL_CAN_Init+0x3a>
    for (int i = 1; i <= CAN_OBJ_MAXNUM; i++) {
 3003978:	fec42783          	lw	a5,-20(s0)
 300397c:	0785                	addi	a5,a5,1
 300397e:	fef42623          	sw	a5,-20(s0)
 3003982:	fec42703          	lw	a4,-20(s0)
 3003986:	02000793          	li	a5,32
 300398a:	fce7d3e3          	bge	a5,a4,3003950 <HAL_CAN_Init+0x2e>
    }
    /* Step5: Bit_Timing setting enable, [0]bit and [6]bit need are set, others clear */
    canHandle->baseAddress->CAN_CONTROL.reg = 0x41;
 300398e:	fdc42783          	lw	a5,-36(s0)
 3003992:	439c                	lw	a5,0(a5)
 3003994:	04100713          	li	a4,65
 3003998:	c398                	sw	a4,0(a5)
    /* Step6: Bit_Timing configuration */
    unsigned int val = canHandle->prescalser - 1;  /* The prescalser is set to the lower 6 bits, [5:0] */
 300399a:	fdc42783          	lw	a5,-36(s0)
 300399e:	4bdc                	lw	a5,20(a5)
 30039a0:	17fd                	addi	a5,a5,-1
 30039a2:	fef42223          	sw	a5,-28(s0)
    val |= (canHandle->sjw - 1) << 6;              /* The sjw needs to be shifted leftwards by 6 bits, [7:6] */
 30039a6:	fdc42783          	lw	a5,-36(s0)
 30039aa:	4f9c                	lw	a5,24(a5)
 30039ac:	17fd                	addi	a5,a5,-1
 30039ae:	079a                	slli	a5,a5,0x6
 30039b0:	fe442703          	lw	a4,-28(s0)
 30039b4:	8fd9                	or	a5,a5,a4
 30039b6:	fef42223          	sw	a5,-28(s0)
    val |= (canHandle->seg1Phase - 1) << 8;        /* The seg1Phase needs to be shifted leftwards by 8 bits, [11:8] */
 30039ba:	fdc42783          	lw	a5,-36(s0)
 30039be:	47dc                	lw	a5,12(a5)
 30039c0:	17fd                	addi	a5,a5,-1
 30039c2:	07a2                	slli	a5,a5,0x8
 30039c4:	fe442703          	lw	a4,-28(s0)
 30039c8:	8fd9                	or	a5,a5,a4
 30039ca:	fef42223          	sw	a5,-28(s0)
    val |= (canHandle->seg2Phase - 1) << 12;       /* The seg2Phase needs to be shifted leftwards by 12 bits, [14:12] */
 30039ce:	fdc42783          	lw	a5,-36(s0)
 30039d2:	4b9c                	lw	a5,16(a5)
 30039d4:	17fd                	addi	a5,a5,-1
 30039d6:	07b2                	slli	a5,a5,0xc
 30039d8:	fe442703          	lw	a4,-28(s0)
 30039dc:	8fd9                	or	a5,a5,a4
 30039de:	fef42223          	sw	a5,-28(s0)
    DBG_PRINTF("BAUD RATE: %d\r\n", val);
 30039e2:	fe442583          	lw	a1,-28(s0)
 30039e6:	030127b7          	lui	a5,0x3012
 30039ea:	ba478513          	addi	a0,a5,-1116 # 3011ba4 <g_crgIpMatch+0x30c>
 30039ee:	7fd020ef          	jal	ra,30069ea <DBG_UartPrintf>
    canHandle->baseAddress->BIT_TIMING.reg = val;
 30039f2:	fdc42783          	lw	a5,-36(s0)
 30039f6:	439c                	lw	a5,0(a5)
 30039f8:	fe442703          	lw	a4,-28(s0)
 30039fc:	c7d8                	sw	a4,12(a5)
    /* Step7: setting interrupt configuration, error interrupt and module interrupt */
    canHandle->baseAddress->CAN_CONTROL.reg = 0x0F;
 30039fe:	fdc42783          	lw	a5,-36(s0)
 3003a02:	439c                	lw	a5,0(a5)
 3003a04:	473d                	li	a4,15
 3003a06:	c398                	sw	a4,0(a5)
    /* Step8: setting automatic retransmission */
    CAN_AutoRetrans(canHandle);
 3003a08:	fdc42503          	lw	a0,-36(s0)
 3003a0c:	3dd9                	jal	ra,30038e2 <CAN_AutoRetrans>
    /* Step9: finish init */
    if (canHandle->typeMode == CAN_MODE_TEST && canHandle->testModeConfigure != NULL) {
 3003a0e:	fdc42783          	lw	a5,-36(s0)
 3003a12:	43d8                	lw	a4,4(a5)
 3003a14:	4785                	li	a5,1
 3003a16:	08f71063          	bne	a4,a5,3003a96 <HAL_CAN_Init+0x174>
 3003a1a:	fdc42783          	lw	a5,-36(s0)
 3003a1e:	479c                	lw	a5,8(a5)
 3003a20:	cbbd                	beqz	a5,3003a96 <HAL_CAN_Init+0x174>
        canHandle->baseAddress->CAN_CONTROL.BIT.Test = BASE_CFG_ENABLE;
 3003a22:	fdc42783          	lw	a5,-36(s0)
 3003a26:	4398                	lw	a4,0(a5)
 3003a28:	431c                	lw	a5,0(a4)
 3003a2a:	0807e793          	ori	a5,a5,128
 3003a2e:	c31c                	sw	a5,0(a4)
        canHandle->baseAddress->CAN_TEST.BIT.Lback = canHandle->testModeConfigure->loopBack;
 3003a30:	fdc42783          	lw	a5,-36(s0)
 3003a34:	479c                	lw	a5,8(a5)
 3003a36:	4394                	lw	a3,0(a5)
 3003a38:	fdc42783          	lw	a5,-36(s0)
 3003a3c:	4398                	lw	a4,0(a5)
 3003a3e:	87b6                	mv	a5,a3
 3003a40:	8b85                	andi	a5,a5,1
 3003a42:	0ff7f693          	andi	a3,a5,255
 3003a46:	4b5c                	lw	a5,20(a4)
 3003a48:	8a85                	andi	a3,a3,1
 3003a4a:	0692                	slli	a3,a3,0x4
 3003a4c:	9bbd                	andi	a5,a5,-17
 3003a4e:	8fd5                	or	a5,a5,a3
 3003a50:	cb5c                	sw	a5,20(a4)
        canHandle->baseAddress->CAN_TEST.BIT.Silent = canHandle->testModeConfigure->silent;
 3003a52:	fdc42783          	lw	a5,-36(s0)
 3003a56:	479c                	lw	a5,8(a5)
 3003a58:	43d4                	lw	a3,4(a5)
 3003a5a:	fdc42783          	lw	a5,-36(s0)
 3003a5e:	4398                	lw	a4,0(a5)
 3003a60:	87b6                	mv	a5,a3
 3003a62:	8b85                	andi	a5,a5,1
 3003a64:	0ff7f693          	andi	a3,a5,255
 3003a68:	4b5c                	lw	a5,20(a4)
 3003a6a:	8a85                	andi	a3,a3,1
 3003a6c:	068e                	slli	a3,a3,0x3
 3003a6e:	9bdd                	andi	a5,a5,-9
 3003a70:	8fd5                	or	a5,a5,a3
 3003a72:	cb5c                	sw	a5,20(a4)
        canHandle->baseAddress->CAN_TEST.BIT.Basic = canHandle->testModeConfigure->basic;
 3003a74:	fdc42783          	lw	a5,-36(s0)
 3003a78:	479c                	lw	a5,8(a5)
 3003a7a:	4794                	lw	a3,8(a5)
 3003a7c:	fdc42783          	lw	a5,-36(s0)
 3003a80:	4398                	lw	a4,0(a5)
 3003a82:	87b6                	mv	a5,a3
 3003a84:	8b85                	andi	a5,a5,1
 3003a86:	0ff7f693          	andi	a3,a5,255
 3003a8a:	4b5c                	lw	a5,20(a4)
 3003a8c:	8a85                	andi	a3,a3,1
 3003a8e:	068a                	slli	a3,a3,0x2
 3003a90:	9bed                	andi	a5,a5,-5
 3003a92:	8fd5                	or	a5,a5,a3
 3003a94:	cb5c                	sw	a5,20(a4)
    }
    canHandle->baseAddress->CAN_CONTROL.BIT.Init = BASE_CFG_DISABLE;
 3003a96:	fdc42783          	lw	a5,-36(s0)
 3003a9a:	4398                	lw	a4,0(a5)
 3003a9c:	431c                	lw	a5,0(a4)
 3003a9e:	9bf9                	andi	a5,a5,-2
 3003aa0:	c31c                	sw	a5,0(a4)
    /* Each packet object configuration before read CAN frame */
    for (int i = 1; i <= CAN_OBJ_MAXNUM; i++) {
 3003aa2:	4785                	li	a5,1
 3003aa4:	fef42423          	sw	a5,-24(s0)
 3003aa8:	a81d                	j	3003ade <HAL_CAN_Init+0x1bc>
        if (i <= BOUND_ID) {
 3003aaa:	fe842703          	lw	a4,-24(s0)
 3003aae:	47e1                	li	a5,24
 3003ab0:	00e7c963          	blt	a5,a4,3003ac2 <HAL_CAN_Init+0x1a0>
            CAN_ConfigReadReq(canHandle, i);  /* The default configuration is no filter receive */
 3003ab4:	fe842783          	lw	a5,-24(s0)
 3003ab8:	85be                	mv	a1,a5
 3003aba:	fdc42503          	lw	a0,-36(s0)
 3003abe:	02f000ef          	jal	ra,30042ec <CAN_ConfigReadReq>
        }
        g_msgObj[i - 1] = 0;
 3003ac2:	fe842783          	lw	a5,-24(s0)
 3003ac6:	17fd                	addi	a5,a5,-1
 3003ac8:	c1218713          	addi	a4,gp,-1006 # 400051c <g_msgObj>
 3003acc:	078a                	slli	a5,a5,0x2
 3003ace:	97ba                	add	a5,a5,a4
 3003ad0:	0007a023          	sw	zero,0(a5)
    for (int i = 1; i <= CAN_OBJ_MAXNUM; i++) {
 3003ad4:	fe842783          	lw	a5,-24(s0)
 3003ad8:	0785                	addi	a5,a5,1
 3003ada:	fef42423          	sw	a5,-24(s0)
 3003ade:	fe842703          	lw	a4,-24(s0)
 3003ae2:	02000793          	li	a5,32
 3003ae6:	fce7d2e3          	bge	a5,a4,3003aaa <HAL_CAN_Init+0x188>
    }
    CAN_WaitTime(canHandle);
 3003aea:	fdc42503          	lw	a0,-36(s0)
 3003aee:	3351                	jal	ra,3003872 <CAN_WaitTime>
    canHandle->state = CAN_STATE_READY;
 3003af0:	fdc42783          	lw	a5,-36(s0)
 3003af4:	4705                	li	a4,1
 3003af6:	cfd8                	sw	a4,28(a5)
    return BASE_STATUS_OK;
 3003af8:	4781                	li	a5,0
}
 3003afa:	853e                	mv	a0,a5
 3003afc:	50b2                	lw	ra,44(sp)
 3003afe:	5422                	lw	s0,40(sp)
 3003b00:	6145                	addi	sp,sp,48
 3003b02:	8082                	ret

03003b04 <WriteData>:
  * @param canHandle CAN handle.
  * @param data Pointer address of the CAN data frame to be sent, @ref CANFrame
  * @retval None.
  */
static void WriteData(CAN_Handle *canHandle, CANFrame *data)
{   
 3003b04:	7179                	addi	sp,sp,-48
 3003b06:	d606                	sw	ra,44(sp)
 3003b08:	d422                	sw	s0,40(sp)
 3003b0a:	1800                	addi	s0,sp,48
 3003b0c:	fca42e23          	sw	a0,-36(s0)
 3003b10:	fcb42c23          	sw	a1,-40(s0)
    DBG_PRINTF("WriteData!\r\n");
 3003b14:	030127b7          	lui	a5,0x3012
 3003b18:	bb478513          	addi	a0,a5,-1100 # 3011bb4 <g_crgIpMatch+0x31c>
 3003b1c:	6cf020ef          	jal	ra,30069ea <DBG_UartPrintf>
    IF1_DATAA1_REG dataA1;
    dataA1.BIT.DATA0 = data->frame[0];  /* Data of bit 0 */
 3003b20:	fd842783          	lw	a5,-40(s0)
 3003b24:	27d8                	lbu	a4,12(a5)
 3003b26:	fec42783          	lw	a5,-20(s0)
 3003b2a:	0ff77713          	andi	a4,a4,255
 3003b2e:	f007f793          	andi	a5,a5,-256
 3003b32:	8fd9                	or	a5,a5,a4
 3003b34:	fef42623          	sw	a5,-20(s0)
    dataA1.BIT.DATA1 = data->frame[1];  /* Data of bit 0 */
 3003b38:	fd842783          	lw	a5,-40(s0)
 3003b3c:	37d8                	lbu	a4,13(a5)
 3003b3e:	fec42783          	lw	a5,-20(s0)
 3003b42:	0ff77713          	andi	a4,a4,255
 3003b46:	0722                	slli	a4,a4,0x8
 3003b48:	76c1                	lui	a3,0xffff0
 3003b4a:	0ff68693          	addi	a3,a3,255 # ffff00ff <RAM_END+0xfbfe80ff>
 3003b4e:	8ff5                	and	a5,a5,a3
 3003b50:	8fd9                	or	a5,a5,a4
 3003b52:	fef42623          	sw	a5,-20(s0)
    canHandle->baseAddress->IF1_DATAA1 = dataA1;
 3003b56:	fdc42783          	lw	a5,-36(s0)
 3003b5a:	439c                	lw	a5,0(a5)
 3003b5c:	fec42703          	lw	a4,-20(s0)
 3003b60:	dfd8                	sw	a4,60(a5)
    IF1_DATAA2_REG dataA2;
    dataA2.BIT.DATA2 = data->frame[2];  /* Data of bit 2 */
 3003b62:	fd842783          	lw	a5,-40(s0)
 3003b66:	27f8                	lbu	a4,14(a5)
 3003b68:	fe842783          	lw	a5,-24(s0)
 3003b6c:	0ff77713          	andi	a4,a4,255
 3003b70:	f007f793          	andi	a5,a5,-256
 3003b74:	8fd9                	or	a5,a5,a4
 3003b76:	fef42423          	sw	a5,-24(s0)
    dataA2.BIT.DATA3 = data->frame[3];  /* Data of bit 3 */
 3003b7a:	fd842783          	lw	a5,-40(s0)
 3003b7e:	37f8                	lbu	a4,15(a5)
 3003b80:	fe842783          	lw	a5,-24(s0)
 3003b84:	0ff77713          	andi	a4,a4,255
 3003b88:	0722                	slli	a4,a4,0x8
 3003b8a:	76c1                	lui	a3,0xffff0
 3003b8c:	0ff68693          	addi	a3,a3,255 # ffff00ff <RAM_END+0xfbfe80ff>
 3003b90:	8ff5                	and	a5,a5,a3
 3003b92:	8fd9                	or	a5,a5,a4
 3003b94:	fef42423          	sw	a5,-24(s0)
    canHandle->baseAddress->IF1_DATAA2 = dataA2;
 3003b98:	fdc42783          	lw	a5,-36(s0)
 3003b9c:	439c                	lw	a5,0(a5)
 3003b9e:	fe842703          	lw	a4,-24(s0)
 3003ba2:	c3b8                	sw	a4,64(a5)
    IF1_DATAB1_REG dataB1;
    dataB1.BIT.DATA4 = data->frame[4];  /* Data of bit 4 */
 3003ba4:	fd842783          	lw	a5,-40(s0)
 3003ba8:	2b98                	lbu	a4,16(a5)
 3003baa:	fe442783          	lw	a5,-28(s0)
 3003bae:	0ff77713          	andi	a4,a4,255
 3003bb2:	f007f793          	andi	a5,a5,-256
 3003bb6:	8fd9                	or	a5,a5,a4
 3003bb8:	fef42223          	sw	a5,-28(s0)
    dataB1.BIT.DATA5 = data->frame[5];  /* Data of bit 5 */
 3003bbc:	fd842783          	lw	a5,-40(s0)
 3003bc0:	3b98                	lbu	a4,17(a5)
 3003bc2:	fe442783          	lw	a5,-28(s0)
 3003bc6:	0ff77713          	andi	a4,a4,255
 3003bca:	0722                	slli	a4,a4,0x8
 3003bcc:	76c1                	lui	a3,0xffff0
 3003bce:	0ff68693          	addi	a3,a3,255 # ffff00ff <RAM_END+0xfbfe80ff>
 3003bd2:	8ff5                	and	a5,a5,a3
 3003bd4:	8fd9                	or	a5,a5,a4
 3003bd6:	fef42223          	sw	a5,-28(s0)
    canHandle->baseAddress->IF1_DATAB1 = dataB1;
 3003bda:	fdc42783          	lw	a5,-36(s0)
 3003bde:	439c                	lw	a5,0(a5)
 3003be0:	fe442703          	lw	a4,-28(s0)
 3003be4:	c3f8                	sw	a4,68(a5)
    IF1_DATAB2_REG dataB2;
    dataB2.BIT.DATA6 = data->frame[6];  /* Data of bit 6 */
 3003be6:	fd842783          	lw	a5,-40(s0)
 3003bea:	2bb8                	lbu	a4,18(a5)
 3003bec:	fe042783          	lw	a5,-32(s0)
 3003bf0:	0ff77713          	andi	a4,a4,255
 3003bf4:	f007f793          	andi	a5,a5,-256
 3003bf8:	8fd9                	or	a5,a5,a4
 3003bfa:	fef42023          	sw	a5,-32(s0)
    dataB2.BIT.DATA7 = data->frame[7];  /* Data of bit 7 */
 3003bfe:	fd842783          	lw	a5,-40(s0)
 3003c02:	3bb8                	lbu	a4,19(a5)
 3003c04:	fe042783          	lw	a5,-32(s0)
 3003c08:	0ff77713          	andi	a4,a4,255
 3003c0c:	0722                	slli	a4,a4,0x8
 3003c0e:	76c1                	lui	a3,0xffff0
 3003c10:	0ff68693          	addi	a3,a3,255 # ffff00ff <RAM_END+0xfbfe80ff>
 3003c14:	8ff5                	and	a5,a5,a3
 3003c16:	8fd9                	or	a5,a5,a4
 3003c18:	fef42023          	sw	a5,-32(s0)
    canHandle->baseAddress->IF1_DATAB2 = dataB2;
 3003c1c:	fdc42783          	lw	a5,-36(s0)
 3003c20:	439c                	lw	a5,0(a5)
 3003c22:	fe042703          	lw	a4,-32(s0)
 3003c26:	c7b8                	sw	a4,72(a5)
}
 3003c28:	0001                	nop
 3003c2a:	50b2                	lw	ra,44(sp)
 3003c2c:	5422                	lw	s0,40(sp)
 3003c2e:	6145                	addi	sp,sp,48
 3003c30:	8082                	ret

03003c32 <HAL_CAN_Write>:
  * @note:
  *      IF1 and IF2 have the same functions. To facilitate management,
  *      IF1 is used for sending and IF2 is used for receiving.
  */
BASE_StatusType HAL_CAN_Write(CAN_Handle *canHandle, CANFrame *data)
{
 3003c32:	7179                	addi	sp,sp,-48
 3003c34:	d606                	sw	ra,44(sp)
 3003c36:	d422                	sw	s0,40(sp)
 3003c38:	1800                	addi	s0,sp,48
 3003c3a:	fca42e23          	sw	a0,-36(s0)
 3003c3e:	fcb42c23          	sw	a1,-40(s0)
    CAN_ASSERT_PARAM(canHandle != NULL && data != NULL);
    CAN_ASSERT_PARAM(IsCANInstance(canHandle->baseAddress));
    CAN_PARAM_CHECK_WITH_RET(data->dataLength <= 8, BASE_STATUS_ERROR);  /* CAN frame length: 1 ~ 8 */
    if (canHandle->state != CAN_STATE_READY) {
 3003c42:	fdc42783          	lw	a5,-36(s0)
 3003c46:	4fd8                	lw	a4,28(a5)
 3003c48:	4785                	li	a5,1
 3003c4a:	00f70463          	beq	a4,a5,3003c52 <HAL_CAN_Write+0x20>
        return BASE_STATUS_BUSY;
 3003c4e:	4789                	li	a5,2
 3003c50:	a2dd                	j	3003e36 <HAL_CAN_Write+0x204>
    }
    canHandle->state = CAN_STATE_BUSY_TX;
 3003c52:	fdc42783          	lw	a5,-36(s0)
 3003c56:	4709                	li	a4,2
 3003c58:	cfd8                	sw	a4,28(a5)
    unsigned int objId = 0;
 3003c5a:	fe042623          	sw	zero,-20(s0)
    unsigned int id;
    for (int i = BOUND_ID + 1; i <= CAN_OBJ_MAXNUM; i++) {
 3003c5e:	47e5                	li	a5,25
 3003c60:	fef42223          	sw	a5,-28(s0)
 3003c64:	a82d                	j	3003c9e <HAL_CAN_Write+0x6c>
        if (g_msgObj[i - 1] == 0) {
 3003c66:	fe442783          	lw	a5,-28(s0)
 3003c6a:	17fd                	addi	a5,a5,-1
 3003c6c:	c1218713          	addi	a4,gp,-1006 # 400051c <g_msgObj>
 3003c70:	078a                	slli	a5,a5,0x2
 3003c72:	97ba                	add	a5,a5,a4
 3003c74:	439c                	lw	a5,0(a5)
 3003c76:	ef99                	bnez	a5,3003c94 <HAL_CAN_Write+0x62>
            g_msgObj[i - 1] = 1;
 3003c78:	fe442783          	lw	a5,-28(s0)
 3003c7c:	17fd                	addi	a5,a5,-1
 3003c7e:	c1218713          	addi	a4,gp,-1006 # 400051c <g_msgObj>
 3003c82:	078a                	slli	a5,a5,0x2
 3003c84:	97ba                	add	a5,a5,a4
 3003c86:	4705                	li	a4,1
 3003c88:	c398                	sw	a4,0(a5)
            objId = i;
 3003c8a:	fe442783          	lw	a5,-28(s0)
 3003c8e:	fef42623          	sw	a5,-20(s0)
            break;
 3003c92:	a821                	j	3003caa <HAL_CAN_Write+0x78>
    for (int i = BOUND_ID + 1; i <= CAN_OBJ_MAXNUM; i++) {
 3003c94:	fe442783          	lw	a5,-28(s0)
 3003c98:	0785                	addi	a5,a5,1
 3003c9a:	fef42223          	sw	a5,-28(s0)
 3003c9e:	fe442703          	lw	a4,-28(s0)
 3003ca2:	02000793          	li	a5,32
 3003ca6:	fce7d0e3          	bge	a5,a4,3003c66 <HAL_CAN_Write+0x34>
        }
    }
    if (objId == 0) {
 3003caa:	fec42783          	lw	a5,-20(s0)
 3003cae:	e399                	bnez	a5,3003cb4 <HAL_CAN_Write+0x82>
        return BASE_STATUS_ERROR;
 3003cb0:	4785                	li	a5,1
 3003cb2:	a251                	j	3003e36 <HAL_CAN_Write+0x204>
    }
    /* Step1: write id into register arbitration according frame type */
    switch (data->type) {
 3003cb4:	fd842783          	lw	a5,-40(s0)
 3003cb8:	439c                	lw	a5,0(a5)
 3003cba:	4705                	li	a4,1
 3003cbc:	04e78263          	beq	a5,a4,3003d00 <HAL_CAN_Write+0xce>
 3003cc0:	4705                	li	a4,1
 3003cc2:	00e7e963          	bltu	a5,a4,3003cd4 <HAL_CAN_Write+0xa2>
 3003cc6:	4709                	li	a4,2
 3003cc8:	06e78763          	beq	a5,a4,3003d36 <HAL_CAN_Write+0x104>
 3003ccc:	470d                	li	a4,3
 3003cce:	08e78c63          	beq	a5,a4,3003d66 <HAL_CAN_Write+0x134>
 3003cd2:	a0e9                	j	3003d9c <HAL_CAN_Write+0x16a>
        case CAN_TYPEFRAME_STD_DATA:                                /* Standard data frame */
            id = (data->CANId & CAN_STD_MASK) << 2;                 /* Bit[12:2] = CANId */
 3003cd4:	fd842783          	lw	a5,-40(s0)
 3003cd8:	479c                	lw	a5,8(a5)
 3003cda:	00279713          	slli	a4,a5,0x2
 3003cde:	6789                	lui	a5,0x2
 3003ce0:	17f1                	addi	a5,a5,-4 # 1ffc <__bss_size__+0xf68>
 3003ce2:	8ff9                	and	a5,a5,a4
 3003ce4:	fef42423          	sw	a5,-24(s0)
            id |= 0xA000;                                           /* [15:13] = 0x05 */
 3003ce8:	fe842703          	lw	a4,-24(s0)
 3003cec:	67a9                	lui	a5,0xa
 3003cee:	8fd9                	or	a5,a5,a4
 3003cf0:	fef42423          	sw	a5,-24(s0)
            canHandle->baseAddress->IF1_ARBITRATION1.reg = 0x00;
 3003cf4:	fdc42783          	lw	a5,-36(s0)
 3003cf8:	439c                	lw	a5,0(a5)
 3003cfa:	0207a823          	sw	zero,48(a5) # a030 <RAM_SIZE+0x5030>
            break;
 3003cfe:	a04d                	j	3003da0 <HAL_CAN_Write+0x16e>
        case CAN_TYPEFRAME_EXT_DATA:                                /* Extended data frame */
            id = (data->CANId & CAN_EXT_MASK) >> 16;                /* Bit[12:0] = CANId(28bit~16bit) */
 3003d00:	fd842783          	lw	a5,-40(s0)
 3003d04:	479c                	lw	a5,8(a5)
 3003d06:	0107d713          	srli	a4,a5,0x10
 3003d0a:	6789                	lui	a5,0x2
 3003d0c:	17fd                	addi	a5,a5,-1 # 1fff <__bss_size__+0xf6b>
 3003d0e:	8ff9                	and	a5,a5,a4
 3003d10:	fef42423          	sw	a5,-24(s0)
            id |= 0xE000;                                           /* [15:13] = 0x07 */
 3003d14:	fe842703          	lw	a4,-24(s0)
 3003d18:	67b9                	lui	a5,0xe
 3003d1a:	8fd9                	or	a5,a5,a4
 3003d1c:	fef42423          	sw	a5,-24(s0)
            canHandle->baseAddress->IF1_ARBITRATION1.reg = (data->CANId & 0xFFFF);  /* write lower 16bits CANId */
 3003d20:	fd842783          	lw	a5,-40(s0)
 3003d24:	4794                	lw	a3,8(a5)
 3003d26:	fdc42783          	lw	a5,-36(s0)
 3003d2a:	439c                	lw	a5,0(a5)
 3003d2c:	6741                	lui	a4,0x10
 3003d2e:	177d                	addi	a4,a4,-1 # ffff <RAM_SIZE+0xafff>
 3003d30:	8f75                	and	a4,a4,a3
 3003d32:	db98                	sw	a4,48(a5)
            break;
 3003d34:	a0b5                	j	3003da0 <HAL_CAN_Write+0x16e>
        case CAN_TYPEFRAME_STD_REMOTE:                              /* Standard remote frame */
            id = (data->CANId & CAN_EXT_MASK) << 2;                 /* Bit[12:2] = CANId */
 3003d36:	fd842783          	lw	a5,-40(s0)
 3003d3a:	479c                	lw	a5,8(a5)
 3003d3c:	00279713          	slli	a4,a5,0x2
 3003d40:	800007b7          	lui	a5,0x80000
 3003d44:	ffc7c793          	xori	a5,a5,-4
 3003d48:	8ff9                	and	a5,a5,a4
 3003d4a:	fef42423          	sw	a5,-24(s0)
            id |= 0x8000;                                           /* [15:13] = 0x04 */
 3003d4e:	fe842703          	lw	a4,-24(s0)
 3003d52:	67a1                	lui	a5,0x8
 3003d54:	8fd9                	or	a5,a5,a4
 3003d56:	fef42423          	sw	a5,-24(s0)
            canHandle->baseAddress->IF1_ARBITRATION1.reg = 0x00;
 3003d5a:	fdc42783          	lw	a5,-36(s0)
 3003d5e:	439c                	lw	a5,0(a5)
 3003d60:	0207a823          	sw	zero,48(a5) # 8030 <RAM_SIZE+0x3030>
            break;
 3003d64:	a835                	j	3003da0 <HAL_CAN_Write+0x16e>
        case CAN_TYPEFRAME_EXT_REMOTE:                              /* Extended remote frame */
            id = (data->CANId & CAN_EXT_MASK) >> 16;                /* Bit[12:0] = CANId(28bit~16bit) */
 3003d66:	fd842783          	lw	a5,-40(s0)
 3003d6a:	479c                	lw	a5,8(a5)
 3003d6c:	0107d713          	srli	a4,a5,0x10
 3003d70:	6789                	lui	a5,0x2
 3003d72:	17fd                	addi	a5,a5,-1 # 1fff <__bss_size__+0xf6b>
 3003d74:	8ff9                	and	a5,a5,a4
 3003d76:	fef42423          	sw	a5,-24(s0)
            id |= 0xC000;                                           /* [15:13] = 0x06 */
 3003d7a:	fe842703          	lw	a4,-24(s0)
 3003d7e:	67b1                	lui	a5,0xc
 3003d80:	8fd9                	or	a5,a5,a4
 3003d82:	fef42423          	sw	a5,-24(s0)
            canHandle->baseAddress->IF1_ARBITRATION1.reg = (data->CANId & 0xFFFF);  /* write lower 16bits CANId */
 3003d86:	fd842783          	lw	a5,-40(s0)
 3003d8a:	4794                	lw	a3,8(a5)
 3003d8c:	fdc42783          	lw	a5,-36(s0)
 3003d90:	439c                	lw	a5,0(a5)
 3003d92:	6741                	lui	a4,0x10
 3003d94:	177d                	addi	a4,a4,-1 # ffff <RAM_SIZE+0xafff>
 3003d96:	8f75                	and	a4,a4,a3
 3003d98:	db98                	sw	a4,48(a5)
            break;
 3003d9a:	a019                	j	3003da0 <HAL_CAN_Write+0x16e>
        default:
            return BASE_STATUS_ERROR;
 3003d9c:	4785                	li	a5,1
 3003d9e:	a861                	j	3003e36 <HAL_CAN_Write+0x204>
    }
    canHandle->baseAddress->IF1_ARBITRATION2.reg = id;
 3003da0:	fdc42783          	lw	a5,-36(s0)
 3003da4:	439c                	lw	a5,0(a5)
 3003da6:	fe842703          	lw	a4,-24(s0)
 3003daa:	dbd8                	sw	a4,52(a5)
    /* Step2: setting mask register 2 */
    canHandle->baseAddress->IF1_MASK2.reg = 0x8000;
 3003dac:	fdc42783          	lw	a5,-36(s0)
 3003db0:	439c                	lw	a5,0(a5)
 3003db2:	6721                	lui	a4,0x8
 3003db4:	d7d8                	sw	a4,44(a5)
    /* Step3: setting mask register 1 */
    canHandle->baseAddress->IF1_MASK1.reg = 0x0000;
 3003db6:	fdc42783          	lw	a5,-36(s0)
 3003dba:	439c                	lw	a5,0(a5)
 3003dbc:	0207a423          	sw	zero,40(a5) # c028 <RAM_SIZE+0x7028>
    /* Step4: setting message control register */
    canHandle->baseAddress->IF1_MESSAGE_CONTROL.reg |= 0x8980;
 3003dc0:	fdc42783          	lw	a5,-36(s0)
 3003dc4:	439c                	lw	a5,0(a5)
 3003dc6:	5f94                	lw	a3,56(a5)
 3003dc8:	fdc42783          	lw	a5,-36(s0)
 3003dcc:	439c                	lw	a5,0(a5)
 3003dce:	6725                	lui	a4,0x9
 3003dd0:	98070713          	addi	a4,a4,-1664 # 8980 <RAM_SIZE+0x3980>
 3003dd4:	8f55                	or	a4,a4,a3
 3003dd6:	df98                	sw	a4,56(a5)
    canHandle->baseAddress->IF1_MESSAGE_CONTROL.BIT.DLC = data->dataLength;
 3003dd8:	fd842783          	lw	a5,-40(s0)
 3003ddc:	43d4                	lw	a3,4(a5)
 3003dde:	fdc42783          	lw	a5,-36(s0)
 3003de2:	4398                	lw	a4,0(a5)
 3003de4:	87b6                	mv	a5,a3
 3003de6:	8bbd                	andi	a5,a5,15
 3003de8:	0ff7f693          	andi	a3,a5,255
 3003dec:	5f1c                	lw	a5,56(a4)
 3003dee:	8abd                	andi	a3,a3,15
 3003df0:	9bc1                	andi	a5,a5,-16
 3003df2:	8fd5                	or	a5,a5,a3
 3003df4:	df1c                	sw	a5,56(a4)
    /* Step5: write data to be sent */
    WriteData(canHandle, data);
 3003df6:	fd842583          	lw	a1,-40(s0)
 3003dfa:	fdc42503          	lw	a0,-36(s0)
 3003dfe:	3319                	jal	ra,3003b04 <WriteData>
    /* Step6: send configuration to packet objects */
    canHandle->baseAddress->IF1_COMMAND_MASK.reg = 0xF3;
 3003e00:	fdc42783          	lw	a5,-36(s0)
 3003e04:	439c                	lw	a5,0(a5)
 3003e06:	0f300713          	li	a4,243
 3003e0a:	d3d8                	sw	a4,36(a5)
    /* Step7: write IF1 request command */
    canHandle->baseAddress->IF1_COMMAND_REQUEST.BIT.MessageNumber = objId;
 3003e0c:	fdc42783          	lw	a5,-36(s0)
 3003e10:	4398                	lw	a4,0(a5)
 3003e12:	fec42783          	lw	a5,-20(s0)
 3003e16:	03f7f793          	andi	a5,a5,63
 3003e1a:	0ff7f693          	andi	a3,a5,255
 3003e1e:	531c                	lw	a5,32(a4)
 3003e20:	03f6f693          	andi	a3,a3,63
 3003e24:	fc07f793          	andi	a5,a5,-64
 3003e28:	8fd5                	or	a5,a5,a3
 3003e2a:	d31c                	sw	a5,32(a4)
    canHandle->state = CAN_STATE_READY;
 3003e2c:	fdc42783          	lw	a5,-36(s0)
 3003e30:	4705                	li	a4,1
 3003e32:	cfd8                	sw	a4,28(a5)
    return BASE_STATUS_OK;
 3003e34:	4781                	li	a5,0
}
 3003e36:	853e                	mv	a0,a5
 3003e38:	50b2                	lw	ra,44(sp)
 3003e3a:	5422                	lw	s0,40(sp)
 3003e3c:	6145                	addi	sp,sp,48
 3003e3e:	8082                	ret

03003e40 <CAN_ReadCallback>:
  * @param canHandle CAN handle.
  * @param objId Indicates the packet object ID.
  * @retval BASE status type: OK, ERROR, BUSY, TIMEOUT.
  */
static BASE_StatusType CAN_ReadCallback(CAN_Handle *canHandle, unsigned int objId)
{   
 3003e40:	7139                	addi	sp,sp,-64
 3003e42:	de22                	sw	s0,60(sp)
 3003e44:	0080                	addi	s0,sp,64
 3003e46:	fca42623          	sw	a0,-52(s0)
 3003e4a:	fcb42423          	sw	a1,-56(s0)
    CAN_ASSERT_PARAM(IsCANInstance(canHandle->baseAddress));
    CAN_PARAM_CHECK_WITH_RET(canHandle->rxFrame != NULL, BASE_STATUS_ERROR);
    CAN_PARAM_CHECK_WITH_RET((objID >= MESSAGE_NUMBER_MIN) && (objID <= MESSAGE_NUMBER_MAX), BASE_STATUS_ERROR);
    unsigned int busy, id, idLow, idHigh,  extendedFrame, remoteFrame;
    /* Step1: setting request transfer to packet object */
    canHandle->baseAddress->IF2_COMMAND_MASK.reg = 0x7F;  /* 0x7F indicates reading data from the packet object */
 3003e4e:	fcc42783          	lw	a5,-52(s0)
 3003e52:	439c                	lw	a5,0(a5)
 3003e54:	07f00713          	li	a4,127
 3003e58:	08e7a223          	sw	a4,132(a5)
    /* Step2: Request specififed packet object */
    canHandle->baseAddress->IF2_COMMAND_REQUEST.BIT.MessageNumber = objId;
 3003e5c:	fcc42783          	lw	a5,-52(s0)
 3003e60:	4398                	lw	a4,0(a5)
 3003e62:	fc842783          	lw	a5,-56(s0)
 3003e66:	03f7f793          	andi	a5,a5,63
 3003e6a:	0ff7f693          	andi	a3,a5,255
 3003e6e:	08072783          	lw	a5,128(a4)
 3003e72:	03f6f693          	andi	a3,a3,63
 3003e76:	fc07f793          	andi	a5,a5,-64
 3003e7a:	8fd5                	or	a5,a5,a3
 3003e7c:	08f72023          	sw	a5,128(a4)
    do {
        busy = canHandle->baseAddress->IF2_COMMAND_REQUEST.BIT.BUSY;
 3003e80:	fcc42783          	lw	a5,-52(s0)
 3003e84:	439c                	lw	a5,0(a5)
 3003e86:	0807a783          	lw	a5,128(a5)
 3003e8a:	83bd                	srli	a5,a5,0xf
 3003e8c:	8b85                	andi	a5,a5,1
 3003e8e:	9f81                	uxtb	a5
 3003e90:	fef42623          	sw	a5,-20(s0)
    } while (busy != 0x00);
 3003e94:	fec42783          	lw	a5,-20(s0)
 3003e98:	f7e5                	bnez	a5,3003e80 <CAN_ReadCallback+0x40>
    /* Step3: Obtains packet information */
    extendedFrame = canHandle->baseAddress->IF2_ARBITRATION2.BIT.Xtd;
 3003e9a:	fcc42783          	lw	a5,-52(s0)
 3003e9e:	439c                	lw	a5,0(a5)
 3003ea0:	0947a783          	lw	a5,148(a5)
 3003ea4:	83b9                	srli	a5,a5,0xe
 3003ea6:	8b85                	andi	a5,a5,1
 3003ea8:	9f81                	uxtb	a5
 3003eaa:	fef42423          	sw	a5,-24(s0)
    remoteFrame = canHandle->baseAddress->IF2_ARBITRATION2.BIT.Dir;
 3003eae:	fcc42783          	lw	a5,-52(s0)
 3003eb2:	439c                	lw	a5,0(a5)
 3003eb4:	0947a783          	lw	a5,148(a5)
 3003eb8:	83b5                	srli	a5,a5,0xd
 3003eba:	8b85                	andi	a5,a5,1
 3003ebc:	9f81                	uxtb	a5
 3003ebe:	fef42223          	sw	a5,-28(s0)
    if (extendedFrame == BASE_CFG_ENABLE) {
 3003ec2:	fe842703          	lw	a4,-24(s0)
 3003ec6:	4785                	li	a5,1
 3003ec8:	08f71b63          	bne	a4,a5,3003f5e <CAN_ReadCallback+0x11e>
        idLow = canHandle->baseAddress->IF2_ARBITRATION1.BIT.ID;
 3003ecc:	fcc42783          	lw	a5,-52(s0)
 3003ed0:	439c                	lw	a5,0(a5)
 3003ed2:	0907a783          	lw	a5,144(a5)
 3003ed6:	9fa1                	uxth	a5
 3003ed8:	fcf42e23          	sw	a5,-36(s0)
        idHigh = canHandle->baseAddress->IF2_ARBITRATION2.BIT.ID;
 3003edc:	fcc42783          	lw	a5,-52(s0)
 3003ee0:	439c                	lw	a5,0(a5)
 3003ee2:	0947a783          	lw	a5,148(a5)
 3003ee6:	873e                	mv	a4,a5
 3003ee8:	6789                	lui	a5,0x2
 3003eea:	17fd                	addi	a5,a5,-1 # 1fff <__bss_size__+0xf6b>
 3003eec:	8ff9                	and	a5,a5,a4
 3003eee:	9fa1                	uxth	a5
 3003ef0:	fcf42c23          	sw	a5,-40(s0)
        id = idLow;
 3003ef4:	fdc42783          	lw	a5,-36(s0)
 3003ef8:	fef42023          	sw	a5,-32(s0)
        idHigh <<= 16;  /* High 16 bits ID */
 3003efc:	fd842783          	lw	a5,-40(s0)
 3003f00:	07c2                	slli	a5,a5,0x10
 3003f02:	fcf42c23          	sw	a5,-40(s0)
        id |= idHigh;
 3003f06:	fe042703          	lw	a4,-32(s0)
 3003f0a:	fd842783          	lw	a5,-40(s0)
 3003f0e:	8fd9                	or	a5,a5,a4
 3003f10:	fef42023          	sw	a5,-32(s0)
        canHandle->rxFrame->CANId = id;
 3003f14:	fcc42783          	lw	a5,-52(s0)
 3003f18:	539c                	lw	a5,32(a5)
 3003f1a:	fe042703          	lw	a4,-32(s0)
 3003f1e:	c798                	sw	a4,8(a5)
        id |= CAN_EFF_FLAG;
 3003f20:	fe042703          	lw	a4,-32(s0)
 3003f24:	800007b7          	lui	a5,0x80000
 3003f28:	8fd9                	or	a5,a5,a4
 3003f2a:	fef42023          	sw	a5,-32(s0)
        if (remoteFrame == BASE_CFG_ENABLE) {
 3003f2e:	fe442703          	lw	a4,-28(s0)
 3003f32:	4785                	li	a5,1
 3003f34:	00f71f63          	bne	a4,a5,3003f52 <CAN_ReadCallback+0x112>
            id |= CAN_RTR_FLAG;
 3003f38:	fe042703          	lw	a4,-32(s0)
 3003f3c:	400007b7          	lui	a5,0x40000
 3003f40:	8fd9                	or	a5,a5,a4
 3003f42:	fef42023          	sw	a5,-32(s0)
            canHandle->rxFrame->type = CAN_TYPEFRAME_EXT_REMOTE;
 3003f46:	fcc42783          	lw	a5,-52(s0)
 3003f4a:	539c                	lw	a5,32(a5)
 3003f4c:	470d                	li	a4,3
 3003f4e:	c398                	sw	a4,0(a5)
 3003f50:	a0ad                	j	3003fba <CAN_ReadCallback+0x17a>
        } else {
            canHandle->rxFrame->type = CAN_TYPEFRAME_EXT_DATA;
 3003f52:	fcc42783          	lw	a5,-52(s0)
 3003f56:	539c                	lw	a5,32(a5)
 3003f58:	4705                	li	a4,1
 3003f5a:	c398                	sw	a4,0(a5)
 3003f5c:	a8b9                	j	3003fba <CAN_ReadCallback+0x17a>
        }
    } else {
        id = canHandle->baseAddress->IF2_ARBITRATION2.BIT.ID;
 3003f5e:	fcc42783          	lw	a5,-52(s0)
 3003f62:	439c                	lw	a5,0(a5)
 3003f64:	0947a783          	lw	a5,148(a5) # 40000094 <RAM_END+0x3bff8094>
 3003f68:	873e                	mv	a4,a5
 3003f6a:	6789                	lui	a5,0x2
 3003f6c:	17fd                	addi	a5,a5,-1 # 1fff <__bss_size__+0xf6b>
 3003f6e:	8ff9                	and	a5,a5,a4
 3003f70:	9fa1                	uxth	a5
 3003f72:	fef42023          	sw	a5,-32(s0)
        id >>= 2;  /* 2: Standard frame CAN id. */
 3003f76:	fe042783          	lw	a5,-32(s0)
 3003f7a:	8389                	srli	a5,a5,0x2
 3003f7c:	fef42023          	sw	a5,-32(s0)
        canHandle->rxFrame->CANId = id;
 3003f80:	fcc42783          	lw	a5,-52(s0)
 3003f84:	539c                	lw	a5,32(a5)
 3003f86:	fe042703          	lw	a4,-32(s0)
 3003f8a:	c798                	sw	a4,8(a5)
        if (remoteFrame == BASE_CFG_ENABLE) {
 3003f8c:	fe442703          	lw	a4,-28(s0)
 3003f90:	4785                	li	a5,1
 3003f92:	00f71f63          	bne	a4,a5,3003fb0 <CAN_ReadCallback+0x170>
            id |= CAN_RTR_FLAG;
 3003f96:	fe042703          	lw	a4,-32(s0)
 3003f9a:	400007b7          	lui	a5,0x40000
 3003f9e:	8fd9                	or	a5,a5,a4
 3003fa0:	fef42023          	sw	a5,-32(s0)
            canHandle->rxFrame->type = CAN_TYPEFRAME_STD_REMOTE;
 3003fa4:	fcc42783          	lw	a5,-52(s0)
 3003fa8:	539c                	lw	a5,32(a5)
 3003faa:	4709                	li	a4,2
 3003fac:	c398                	sw	a4,0(a5)
 3003fae:	a031                	j	3003fba <CAN_ReadCallback+0x17a>
        } else {
            canHandle->rxFrame->type = CAN_TYPEFRAME_STD_DATA;
 3003fb0:	fcc42783          	lw	a5,-52(s0)
 3003fb4:	539c                	lw	a5,32(a5)
 3003fb6:	0007a023          	sw	zero,0(a5) # 40000000 <RAM_END+0x3bff8000>
        }
    }
    canHandle->rxFrame->dataLength = canHandle->baseAddress->IF2_MESSAGE_CONTROL.BIT.DLC;
 3003fba:	fcc42783          	lw	a5,-52(s0)
 3003fbe:	439c                	lw	a5,0(a5)
 3003fc0:	0987a783          	lw	a5,152(a5)
 3003fc4:	8bbd                	andi	a5,a5,15
 3003fc6:	0ff7f713          	andi	a4,a5,255
 3003fca:	fcc42783          	lw	a5,-52(s0)
 3003fce:	539c                	lw	a5,32(a5)
 3003fd0:	c3d8                	sw	a4,4(a5)
    canHandle->rxFrame->frame[0] = canHandle->baseAddress->IF2_DATAA1.BIT.DATA0;  /* Data of bit 0 */
 3003fd2:	fcc42783          	lw	a5,-52(s0)
 3003fd6:	4398                	lw	a4,0(a5)
 3003fd8:	fcc42783          	lw	a5,-52(s0)
 3003fdc:	539c                	lw	a5,32(a5)
 3003fde:	09c72703          	lw	a4,156(a4)
 3003fe2:	9f01                	uxtb	a4
 3003fe4:	a7d8                	sb	a4,12(a5)
    canHandle->rxFrame->frame[1] = canHandle->baseAddress->IF2_DATAA1.BIT.DATA1;  /* Data of bit 1 */
 3003fe6:	fcc42783          	lw	a5,-52(s0)
 3003fea:	4398                	lw	a4,0(a5)
 3003fec:	fcc42783          	lw	a5,-52(s0)
 3003ff0:	539c                	lw	a5,32(a5)
 3003ff2:	09c72703          	lw	a4,156(a4)
 3003ff6:	8321                	srli	a4,a4,0x8
 3003ff8:	9b7d                	andi	a4,a4,-1
 3003ffa:	9f01                	uxtb	a4
 3003ffc:	b7d8                	sb	a4,13(a5)
    canHandle->rxFrame->frame[2] = canHandle->baseAddress->IF2_DATAA2.BIT.DATA2;  /* Data of bit 2 */
 3003ffe:	fcc42783          	lw	a5,-52(s0)
 3004002:	4398                	lw	a4,0(a5)
 3004004:	fcc42783          	lw	a5,-52(s0)
 3004008:	539c                	lw	a5,32(a5)
 300400a:	0a072703          	lw	a4,160(a4)
 300400e:	9f01                	uxtb	a4
 3004010:	a7f8                	sb	a4,14(a5)
    canHandle->rxFrame->frame[3] = canHandle->baseAddress->IF2_DATAA2.BIT.DATA3;  /* Data of bit 3 */
 3004012:	fcc42783          	lw	a5,-52(s0)
 3004016:	4398                	lw	a4,0(a5)
 3004018:	fcc42783          	lw	a5,-52(s0)
 300401c:	539c                	lw	a5,32(a5)
 300401e:	0a072703          	lw	a4,160(a4)
 3004022:	8321                	srli	a4,a4,0x8
 3004024:	9b7d                	andi	a4,a4,-1
 3004026:	9f01                	uxtb	a4
 3004028:	b7f8                	sb	a4,15(a5)
    canHandle->rxFrame->frame[4] = canHandle->baseAddress->IF2_DATAB1.BIT.DATA4;  /* Data of bit 4 */
 300402a:	fcc42783          	lw	a5,-52(s0)
 300402e:	4398                	lw	a4,0(a5)
 3004030:	fcc42783          	lw	a5,-52(s0)
 3004034:	539c                	lw	a5,32(a5)
 3004036:	0a472703          	lw	a4,164(a4)
 300403a:	9f01                	uxtb	a4
 300403c:	ab98                	sb	a4,16(a5)
    canHandle->rxFrame->frame[5] = canHandle->baseAddress->IF2_DATAB1.BIT.DATA5;  /* Data of bit 5 */
 300403e:	fcc42783          	lw	a5,-52(s0)
 3004042:	4398                	lw	a4,0(a5)
 3004044:	fcc42783          	lw	a5,-52(s0)
 3004048:	539c                	lw	a5,32(a5)
 300404a:	0a472703          	lw	a4,164(a4)
 300404e:	8321                	srli	a4,a4,0x8
 3004050:	9b7d                	andi	a4,a4,-1
 3004052:	9f01                	uxtb	a4
 3004054:	bb98                	sb	a4,17(a5)
    canHandle->rxFrame->frame[6] = canHandle->baseAddress->IF2_DATAB2.BIT.DATA6;  /* Data of bit 6 */
 3004056:	fcc42783          	lw	a5,-52(s0)
 300405a:	4398                	lw	a4,0(a5)
 300405c:	fcc42783          	lw	a5,-52(s0)
 3004060:	539c                	lw	a5,32(a5)
 3004062:	0a872703          	lw	a4,168(a4)
 3004066:	9f01                	uxtb	a4
 3004068:	abb8                	sb	a4,18(a5)
    canHandle->rxFrame->frame[7] = canHandle->baseAddress->IF2_DATAB2.BIT.DATA7;  /* Data of bit 7 */
 300406a:	fcc42783          	lw	a5,-52(s0)
 300406e:	4398                	lw	a4,0(a5)
 3004070:	fcc42783          	lw	a5,-52(s0)
 3004074:	539c                	lw	a5,32(a5)
 3004076:	0a872703          	lw	a4,168(a4)
 300407a:	8321                	srli	a4,a4,0x8
 300407c:	9b7d                	andi	a4,a4,-1
 300407e:	9f01                	uxtb	a4
 3004080:	bbb8                	sb	a4,19(a5)
    return BASE_STATUS_OK;
 3004082:	4781                	li	a5,0
}
 3004084:	853e                	mv	a0,a5
 3004086:	5472                	lw	s0,60(sp)
 3004088:	6121                	addi	sp,sp,64
 300408a:	8082                	ret

0300408c <CAN_ReceiveFilter>:
  * @param CAN_FilterConfigure handle of filtering configuration, @ref CAN_FilterConfigure
  * @param objId Indicates the packet object ID.
  * @retval BASE status type: OK, ERROR, BUSY, TIMEOUT.
  */
static void CAN_ReceiveFilter(CAN_Handle *canHandle, const CAN_FilterConfigure *filterConfigure, unsigned int objId)
{
 300408c:	7179                	addi	sp,sp,-48
 300408e:	d622                	sw	s0,44(sp)
 3004090:	1800                	addi	s0,sp,48
 3004092:	fca42e23          	sw	a0,-36(s0)
 3004096:	fcb42c23          	sw	a1,-40(s0)
 300409a:	fcc42a23          	sw	a2,-44(s0)
    unsigned int id, idChg;
    unsigned int mask, maskChg;
    idChg = filterConfigure->filterID & 0xFFFF;
 300409e:	fd842783          	lw	a5,-40(s0)
 30040a2:	43d8                	lw	a4,4(a5)
 30040a4:	67c1                	lui	a5,0x10
 30040a6:	17fd                	addi	a5,a5,-1 # ffff <RAM_SIZE+0xafff>
 30040a8:	8ff9                	and	a5,a5,a4
 30040aa:	fef42423          	sw	a5,-24(s0)
    maskChg = filterConfigure->filterMask & 0xFFFF;
 30040ae:	fd842783          	lw	a5,-40(s0)
 30040b2:	4798                	lw	a4,8(a5)
 30040b4:	67c1                	lui	a5,0x10
 30040b6:	17fd                	addi	a5,a5,-1 # ffff <RAM_SIZE+0xafff>
 30040b8:	8ff9                	and	a5,a5,a4
 30040ba:	fef42023          	sw	a5,-32(s0)
    switch (filterConfigure->receiveType) {
 30040be:	fd842783          	lw	a5,-40(s0)
 30040c2:	439c                	lw	a5,0(a5)
 30040c4:	4705                	li	a4,1
 30040c6:	04e78e63          	beq	a5,a4,3004122 <CAN_ReceiveFilter+0x96>
 30040ca:	4705                	li	a4,1
 30040cc:	00e7e663          	bltu	a5,a4,30040d8 <CAN_ReceiveFilter+0x4c>
 30040d0:	4709                	li	a4,2
 30040d2:	08e78963          	beq	a5,a4,3004164 <CAN_ReceiveFilter+0xd8>
            id |= 0xC000;
            mask = (filterConfigure->filterMask & CAN_EXT_MASK) >> 16;  /* Remove the lower 16 bits */
            mask |= 0x4000;                                             /* [15]MXtd = 0 */
            break;
        default:
            return;
 30040d6:	aa41                	j	3004266 <CAN_ReceiveFilter+0x1da>
            id = (filterConfigure->filterID & CAN_STD_MASK) << 2;       /* Bit[12:2] = CANId */
 30040d8:	fd842783          	lw	a5,-40(s0)
 30040dc:	43dc                	lw	a5,4(a5)
 30040de:	00279713          	slli	a4,a5,0x2
 30040e2:	6789                	lui	a5,0x2
 30040e4:	17f1                	addi	a5,a5,-4 # 1ffc <__bss_size__+0xf68>
 30040e6:	8ff9                	and	a5,a5,a4
 30040e8:	fef42623          	sw	a5,-20(s0)
            id |= 0x8000;
 30040ec:	fec42703          	lw	a4,-20(s0)
 30040f0:	67a1                	lui	a5,0x8
 30040f2:	8fd9                	or	a5,a5,a4
 30040f4:	fef42623          	sw	a5,-20(s0)
            idChg = 0x0000;
 30040f8:	fe042423          	sw	zero,-24(s0)
            mask = (filterConfigure->filterMask & CAN_STD_MASK) << 2;
 30040fc:	fd842783          	lw	a5,-40(s0)
 3004100:	479c                	lw	a5,8(a5)
 3004102:	00279713          	slli	a4,a5,0x2
 3004106:	6789                	lui	a5,0x2
 3004108:	17f1                	addi	a5,a5,-4 # 1ffc <__bss_size__+0xf68>
 300410a:	8ff9                	and	a5,a5,a4
 300410c:	fef42223          	sw	a5,-28(s0)
            mask |= 0xC000;
 3004110:	fe442703          	lw	a4,-28(s0)
 3004114:	67b1                	lui	a5,0xc
 3004116:	8fd9                	or	a5,a5,a4
 3004118:	fef42223          	sw	a5,-28(s0)
            maskChg = 0x0000;
 300411c:	fe042023          	sw	zero,-32(s0)
            break;
 3004120:	a059                	j	30041a6 <CAN_ReceiveFilter+0x11a>
            id = (filterConfigure->filterID & CAN_EXT_MASK) >> 16;              /* Bit[12:0] = CANId(28bit ~ 16bit) */
 3004122:	fd842783          	lw	a5,-40(s0)
 3004126:	43dc                	lw	a5,4(a5)
 3004128:	0107d713          	srli	a4,a5,0x10
 300412c:	6789                	lui	a5,0x2
 300412e:	17fd                	addi	a5,a5,-1 # 1fff <__bss_size__+0xf6b>
 3004130:	8ff9                	and	a5,a5,a4
 3004132:	fef42623          	sw	a5,-20(s0)
            id |= 0xC000;
 3004136:	fec42703          	lw	a4,-20(s0)
 300413a:	67b1                	lui	a5,0xc
 300413c:	8fd9                	or	a5,a5,a4
 300413e:	fef42623          	sw	a5,-20(s0)
            mask = (filterConfigure->filterMask & CAN_EXT_MASK) >> 16;  /* Remove the lower 16 bits */
 3004142:	fd842783          	lw	a5,-40(s0)
 3004146:	479c                	lw	a5,8(a5)
 3004148:	0107d713          	srli	a4,a5,0x10
 300414c:	6789                	lui	a5,0x2
 300414e:	17fd                	addi	a5,a5,-1 # 1fff <__bss_size__+0xf6b>
 3004150:	8ff9                	and	a5,a5,a4
 3004152:	fef42223          	sw	a5,-28(s0)
            mask |= 0xC000;
 3004156:	fe442703          	lw	a4,-28(s0)
 300415a:	67b1                	lui	a5,0xc
 300415c:	8fd9                	or	a5,a5,a4
 300415e:	fef42223          	sw	a5,-28(s0)
            break;
 3004162:	a091                	j	30041a6 <CAN_ReceiveFilter+0x11a>
            id = (filterConfigure->filterID & CAN_EXT_MASK) >> 16;       /* Remove the lower 16 bits */
 3004164:	fd842783          	lw	a5,-40(s0)
 3004168:	43dc                	lw	a5,4(a5)
 300416a:	0107d713          	srli	a4,a5,0x10
 300416e:	6789                	lui	a5,0x2
 3004170:	17fd                	addi	a5,a5,-1 # 1fff <__bss_size__+0xf6b>
 3004172:	8ff9                	and	a5,a5,a4
 3004174:	fef42623          	sw	a5,-20(s0)
            id |= 0xC000;
 3004178:	fec42703          	lw	a4,-20(s0)
 300417c:	67b1                	lui	a5,0xc
 300417e:	8fd9                	or	a5,a5,a4
 3004180:	fef42623          	sw	a5,-20(s0)
            mask = (filterConfigure->filterMask & CAN_EXT_MASK) >> 16;  /* Remove the lower 16 bits */
 3004184:	fd842783          	lw	a5,-40(s0)
 3004188:	479c                	lw	a5,8(a5)
 300418a:	0107d713          	srli	a4,a5,0x10
 300418e:	6789                	lui	a5,0x2
 3004190:	17fd                	addi	a5,a5,-1 # 1fff <__bss_size__+0xf6b>
 3004192:	8ff9                	and	a5,a5,a4
 3004194:	fef42223          	sw	a5,-28(s0)
            mask |= 0x4000;                                             /* [15]MXtd = 0 */
 3004198:	fe442703          	lw	a4,-28(s0)
 300419c:	6791                	lui	a5,0x4
 300419e:	8fd9                	or	a5,a5,a4
 30041a0:	fef42223          	sw	a5,-28(s0)
            break;
 30041a4:	0001                	nop
    }
    canHandle->baseAddress->IF2_ARBITRATION2.reg = id;
 30041a6:	fdc42783          	lw	a5,-36(s0)
 30041aa:	439c                	lw	a5,0(a5)
 30041ac:	fec42703          	lw	a4,-20(s0)
 30041b0:	08e7aa23          	sw	a4,148(a5) # 4094 <STACK_SIZE+0x1494>
    canHandle->baseAddress->IF2_ARBITRATION1.reg = idChg;
 30041b4:	fdc42783          	lw	a5,-36(s0)
 30041b8:	439c                	lw	a5,0(a5)
 30041ba:	fe842703          	lw	a4,-24(s0)
 30041be:	08e7a823          	sw	a4,144(a5)
    canHandle->baseAddress->IF2_MASK2.reg = mask;
 30041c2:	fdc42783          	lw	a5,-36(s0)
 30041c6:	439c                	lw	a5,0(a5)
 30041c8:	fe442703          	lw	a4,-28(s0)
 30041cc:	08e7a623          	sw	a4,140(a5)
    canHandle->baseAddress->IF2_MASK1.reg = maskChg;
 30041d0:	fdc42783          	lw	a5,-36(s0)
 30041d4:	439c                	lw	a5,0(a5)
 30041d6:	fe042703          	lw	a4,-32(s0)
 30041da:	08e7a423          	sw	a4,136(a5)
    if (canHandle->rxFIFODepth > BOUND_ID) {
 30041de:	fdc42783          	lw	a5,-36(s0)
 30041e2:	5798                	lw	a4,40(a5)
 30041e4:	47e1                	li	a5,24
 30041e6:	00e7f663          	bgeu	a5,a4,30041f2 <CAN_ReceiveFilter+0x166>
        canHandle->rxFIFODepth = BOUND_ID;
 30041ea:	fdc42783          	lw	a5,-36(s0)
 30041ee:	4761                	li	a4,24
 30041f0:	d798                	sw	a4,40(a5)
    }
    if (objId < canHandle->rxFIFODepth) {  /* packet objects form the receiving FIFO */
 30041f2:	fdc42783          	lw	a5,-36(s0)
 30041f6:	579c                	lw	a5,40(a5)
 30041f8:	fd442703          	lw	a4,-44(s0)
 30041fc:	00f77b63          	bgeu	a4,a5,3004212 <CAN_ReceiveFilter+0x186>
        canHandle->baseAddress->IF2_MESSAGE_CONTROL.reg = 0x1408;   /* EOB is set 0 */
 3004200:	fdc42783          	lw	a5,-36(s0)
 3004204:	439c                	lw	a5,0(a5)
 3004206:	6705                	lui	a4,0x1
 3004208:	40870713          	addi	a4,a4,1032 # 1408 <__bss_size__+0x374>
 300420c:	08e7ac23          	sw	a4,152(a5)
 3004210:	a809                	j	3004222 <CAN_ReceiveFilter+0x196>
    } else {
        canHandle->baseAddress->IF2_MESSAGE_CONTROL.reg = 0x1488;   /* EOB is set 1 */
 3004212:	fdc42783          	lw	a5,-36(s0)
 3004216:	439c                	lw	a5,0(a5)
 3004218:	6705                	lui	a4,0x1
 300421a:	48870713          	addi	a4,a4,1160 # 1488 <__bss_size__+0x3f4>
 300421e:	08e7ac23          	sw	a4,152(a5)
    }
    /* Step5: send configuration to packet objects */
    canHandle->baseAddress->IF2_COMMAND_MASK.reg = 0x00F3;
 3004222:	fdc42783          	lw	a5,-36(s0)
 3004226:	439c                	lw	a5,0(a5)
 3004228:	0f300713          	li	a4,243
 300422c:	08e7a223          	sw	a4,132(a5)
    /* Step6: write IF2 request command */
    canHandle->baseAddress->IF2_COMMAND_REQUEST.BIT.MessageNumber = objId;
 3004230:	fdc42783          	lw	a5,-36(s0)
 3004234:	4398                	lw	a4,0(a5)
 3004236:	fd442783          	lw	a5,-44(s0)
 300423a:	03f7f793          	andi	a5,a5,63
 300423e:	0ff7f693          	andi	a3,a5,255
 3004242:	08072783          	lw	a5,128(a4)
 3004246:	03f6f693          	andi	a3,a3,63
 300424a:	fc07f793          	andi	a5,a5,-64
 300424e:	8fd5                	or	a5,a5,a3
 3004250:	08f72023          	sw	a5,128(a4)
    canHandle->baseAddress->IF2_COMMAND_REQUEST.BIT.BUSY = 0x01;
 3004254:	fdc42783          	lw	a5,-36(s0)
 3004258:	4398                	lw	a4,0(a5)
 300425a:	08072783          	lw	a5,128(a4)
 300425e:	66a1                	lui	a3,0x8
 3004260:	8fd5                	or	a5,a5,a3
 3004262:	08f72023          	sw	a5,128(a4)
}
 3004266:	5432                	lw	s0,44(sp)
 3004268:	6145                	addi	sp,sp,48
 300426a:	8082                	ret

0300426c <HAL_CAN_ReadIT>:
  * @param data Address for storing CAN data frames, @ref CANFrame
  * @param filterConfigure handle of filtering configuration, @ref CAN_FilterConfigure
  * @retval BASE status type: OK, ERROR, BUSY, TIMEOUT.
  */
BASE_StatusType HAL_CAN_ReadIT(CAN_Handle *canHandle, CANFrame *data, CAN_FilterConfigure *filterConfigure)
{
 300426c:	7179                	addi	sp,sp,-48
 300426e:	d606                	sw	ra,44(sp)
 3004270:	d422                	sw	s0,40(sp)
 3004272:	1800                	addi	s0,sp,48
 3004274:	fca42e23          	sw	a0,-36(s0)
 3004278:	fcb42c23          	sw	a1,-40(s0)
 300427c:	fcc42a23          	sw	a2,-44(s0)
    CAN_ASSERT_PARAM(canHandle != NULL);
    CAN_ASSERT_PARAM(IsCANInstance(canHandle->baseAddress));
    CAN_PARAM_CHECK_WITH_RET(data != NULL, BASE_STATUS_ERROR);
    CAN_PARAM_CHECK_WITH_RET(filterConfigure != NULL, BASE_STATUS_ERROR);
    if (canHandle->state != CAN_STATE_READY) {
 3004280:	fdc42783          	lw	a5,-36(s0)
 3004284:	4fd8                	lw	a4,28(a5)
 3004286:	4785                	li	a5,1
 3004288:	00f70463          	beq	a4,a5,3004290 <HAL_CAN_ReadIT+0x24>
        return BASE_STATUS_BUSY;
 300428c:	4789                	li	a5,2
 300428e:	a891                	j	30042e2 <HAL_CAN_ReadIT+0x76>
    }
    canHandle->state = CAN_STATE_BUSY_RX;
 3004290:	fdc42783          	lw	a5,-36(s0)
 3004294:	470d                	li	a4,3
 3004296:	cfd8                	sw	a4,28(a5)
    canHandle->rxFrame = data;
 3004298:	fdc42783          	lw	a5,-36(s0)
 300429c:	fd842703          	lw	a4,-40(s0)
 30042a0:	d398                	sw	a4,32(a5)
    canHandle->rxFilter = filterConfigure;
 30042a2:	fdc42783          	lw	a5,-36(s0)
 30042a6:	fd442703          	lw	a4,-44(s0)
 30042aa:	d3d8                	sw	a4,36(a5)
    for (int i = 1; i <= BOUND_ID; i++) {
 30042ac:	4785                	li	a5,1
 30042ae:	fef42623          	sw	a5,-20(s0)
 30042b2:	a831                	j	30042ce <HAL_CAN_ReadIT+0x62>
        CAN_ReceiveFilter(canHandle, filterConfigure, i);
 30042b4:	fec42783          	lw	a5,-20(s0)
 30042b8:	863e                	mv	a2,a5
 30042ba:	fd442583          	lw	a1,-44(s0)
 30042be:	fdc42503          	lw	a0,-36(s0)
 30042c2:	33e9                	jal	ra,300408c <CAN_ReceiveFilter>
    for (int i = 1; i <= BOUND_ID; i++) {
 30042c4:	fec42783          	lw	a5,-20(s0)
 30042c8:	0785                	addi	a5,a5,1
 30042ca:	fef42623          	sw	a5,-20(s0)
 30042ce:	fec42703          	lw	a4,-20(s0)
 30042d2:	47e1                	li	a5,24
 30042d4:	fee7d0e3          	bge	a5,a4,30042b4 <HAL_CAN_ReadIT+0x48>
    }
    canHandle->state = CAN_STATE_READY;
 30042d8:	fdc42783          	lw	a5,-36(s0)
 30042dc:	4705                	li	a4,1
 30042de:	cfd8                	sw	a4,28(a5)
    return BASE_STATUS_OK;
 30042e0:	4781                	li	a5,0
}
 30042e2:	853e                	mv	a0,a5
 30042e4:	50b2                	lw	ra,44(sp)
 30042e6:	5422                	lw	s0,40(sp)
 30042e8:	6145                	addi	sp,sp,48
 30042ea:	8082                	ret

030042ec <CAN_ConfigReadReq>:
  * @param canHandle CAN handle.
  * @param objId Indicates the packet object ID.
  * @retval BASE status type: OK, ERROR, BUSY, TIMEOUT.
  */
static BASE_StatusType CAN_ConfigReadReq(CAN_Handle *canHandle, unsigned int objId)
{
 30042ec:	7179                	addi	sp,sp,-48
 30042ee:	d622                	sw	s0,44(sp)
 30042f0:	1800                	addi	s0,sp,48
 30042f2:	fca42e23          	sw	a0,-36(s0)
 30042f6:	fcb42c23          	sw	a1,-40(s0)
    CAN_ASSERT_PARAM(canHandle != NULL);
    CAN_ASSERT_PARAM(IsCANInstance(canHandle->baseAddress));
    unsigned int map = 1;
 30042fa:	4785                	li	a5,1
 30042fc:	fef42623          	sw	a5,-20(s0)
    map <<= objId - 1;
 3004300:	fd842783          	lw	a5,-40(s0)
 3004304:	17fd                	addi	a5,a5,-1
 3004306:	fec42703          	lw	a4,-20(s0)
 300430a:	00f717b3          	sll	a5,a4,a5
 300430e:	fef42623          	sw	a5,-20(s0)
    /* Step1: write id into register arbitration according frame type */
    if ((map & g_stdRecvMap) != 0) {            /* STD DATA FRAME */
 3004312:	040007b7          	lui	a5,0x4000
 3004316:	0047a703          	lw	a4,4(a5) # 4000004 <g_stdRecvMap>
 300431a:	fec42783          	lw	a5,-20(s0)
 300431e:	8ff9                	and	a5,a5,a4
 3004320:	cf89                	beqz	a5,300433a <CAN_ConfigReadReq+0x4e>
        canHandle->baseAddress->IF2_ARBITRATION2.reg = 0x8000;
 3004322:	fdc42783          	lw	a5,-36(s0)
 3004326:	439c                	lw	a5,0(a5)
 3004328:	6721                	lui	a4,0x8
 300432a:	08e7aa23          	sw	a4,148(a5)
        canHandle->baseAddress->IF2_ARBITRATION1.reg = 0x0000;
 300432e:	fdc42783          	lw	a5,-36(s0)
 3004332:	439c                	lw	a5,0(a5)
 3004334:	0807a823          	sw	zero,144(a5)
 3004338:	a03d                	j	3004366 <CAN_ConfigReadReq+0x7a>
    } else if ((map & g_extRecvMap) != 0) {     /* EXTENDED DATA FRAME */
 300433a:	040007b7          	lui	a5,0x4000
 300433e:	0087a703          	lw	a4,8(a5) # 4000008 <g_extRecvMap>
 3004342:	fec42783          	lw	a5,-20(s0)
 3004346:	8ff9                	and	a5,a5,a4
 3004348:	cf89                	beqz	a5,3004362 <CAN_ConfigReadReq+0x76>
        canHandle->baseAddress->IF2_ARBITRATION2.reg = 0xC000;
 300434a:	fdc42783          	lw	a5,-36(s0)
 300434e:	439c                	lw	a5,0(a5)
 3004350:	6731                	lui	a4,0xc
 3004352:	08e7aa23          	sw	a4,148(a5)
        canHandle->baseAddress->IF2_ARBITRATION1.reg = 0x0000;
 3004356:	fdc42783          	lw	a5,-36(s0)
 300435a:	439c                	lw	a5,0(a5)
 300435c:	0807a823          	sw	zero,144(a5)
 3004360:	a019                	j	3004366 <CAN_ConfigReadReq+0x7a>
    } else {
        return BASE_STATUS_ERROR;
 3004362:	4785                	li	a5,1
 3004364:	a0bd                	j	30043d2 <CAN_ConfigReadReq+0xe6>
    }
    /* Step2: setting mask register 2 */
    canHandle->baseAddress->IF2_MASK2.reg = 0xC000;
 3004366:	fdc42783          	lw	a5,-36(s0)
 300436a:	439c                	lw	a5,0(a5)
 300436c:	6731                	lui	a4,0xc
 300436e:	08e7a623          	sw	a4,140(a5)
    /* Step3: setting mask register 1 */
    canHandle->baseAddress->IF2_MASK1.reg = 0x0000;
 3004372:	fdc42783          	lw	a5,-36(s0)
 3004376:	439c                	lw	a5,0(a5)
 3004378:	0807a423          	sw	zero,136(a5)
    /* Step4: setting message control register. By default, there is no RX FIFO and no filtering is performed */
    canHandle->baseAddress->IF2_MESSAGE_CONTROL.reg = 0x1488;
 300437c:	fdc42783          	lw	a5,-36(s0)
 3004380:	439c                	lw	a5,0(a5)
 3004382:	6705                	lui	a4,0x1
 3004384:	48870713          	addi	a4,a4,1160 # 1488 <__bss_size__+0x3f4>
 3004388:	08e7ac23          	sw	a4,152(a5)
    /* Step5: send configuration to packet objects */
    canHandle->baseAddress->IF2_COMMAND_MASK.reg = 0x00F3;
 300438c:	fdc42783          	lw	a5,-36(s0)
 3004390:	439c                	lw	a5,0(a5)
 3004392:	0f300713          	li	a4,243
 3004396:	08e7a223          	sw	a4,132(a5)
    /* Step6: write IF2 request command */
    canHandle->baseAddress->IF2_COMMAND_REQUEST.BIT.MessageNumber = objId;
 300439a:	fdc42783          	lw	a5,-36(s0)
 300439e:	4398                	lw	a4,0(a5)
 30043a0:	fd842783          	lw	a5,-40(s0)
 30043a4:	03f7f793          	andi	a5,a5,63
 30043a8:	0ff7f693          	andi	a3,a5,255
 30043ac:	08072783          	lw	a5,128(a4)
 30043b0:	03f6f693          	andi	a3,a3,63
 30043b4:	fc07f793          	andi	a5,a5,-64
 30043b8:	8fd5                	or	a5,a5,a3
 30043ba:	08f72023          	sw	a5,128(a4)
    canHandle->baseAddress->IF2_COMMAND_REQUEST.BIT.BUSY = BASE_CFG_ENABLE;
 30043be:	fdc42783          	lw	a5,-36(s0)
 30043c2:	4398                	lw	a4,0(a5)
 30043c4:	08072783          	lw	a5,128(a4)
 30043c8:	66a1                	lui	a3,0x8
 30043ca:	8fd5                	or	a5,a5,a3
 30043cc:	08f72023          	sw	a5,128(a4)
    return BASE_STATUS_OK;
 30043d0:	4781                	li	a5,0
}
 30043d2:	853e                	mv	a0,a5
 30043d4:	5432                	lw	s0,44(sp)
 30043d6:	6145                	addi	sp,sp,48
 30043d8:	8082                	ret

030043da <WriteFinishClear>:
  * @param canHandle CAN handle.
  * @param objId Indicates the packet object ID.
  * @retval BASE status type: OK, ERROR, BUSY, TIMEOUT.
  */
static BASE_StatusType WriteFinishClear(CAN_Handle *canHandle, unsigned int objId)
{
 30043da:	7179                	addi	sp,sp,-48
 30043dc:	d622                	sw	s0,44(sp)
 30043de:	1800                	addi	s0,sp,48
 30043e0:	fca42e23          	sw	a0,-36(s0)
 30043e4:	fcb42c23          	sw	a1,-40(s0)
    CAN_ASSERT_PARAM(canHandle != NULL);
    CAN_ASSERT_PARAM(IsCANInstance(canHandle->baseAddress));
    unsigned int busy;
    canHandle->baseAddress->IF2_COMMAND_MASK.reg = 0x7F;
 30043e8:	fdc42783          	lw	a5,-36(s0)
 30043ec:	439c                	lw	a5,0(a5)
 30043ee:	07f00713          	li	a4,127
 30043f2:	08e7a223          	sw	a4,132(a5)
    canHandle->baseAddress->IF2_COMMAND_REQUEST.BIT.MessageNumber = objId;
 30043f6:	fdc42783          	lw	a5,-36(s0)
 30043fa:	4398                	lw	a4,0(a5)
 30043fc:	fd842783          	lw	a5,-40(s0)
 3004400:	03f7f793          	andi	a5,a5,63
 3004404:	0ff7f693          	andi	a3,a5,255
 3004408:	08072783          	lw	a5,128(a4)
 300440c:	03f6f693          	andi	a3,a3,63
 3004410:	fc07f793          	andi	a5,a5,-64
 3004414:	8fd5                	or	a5,a5,a3
 3004416:	08f72023          	sw	a5,128(a4)
    do {
        busy = canHandle->baseAddress->IF2_COMMAND_REQUEST.BIT.BUSY;
 300441a:	fdc42783          	lw	a5,-36(s0)
 300441e:	439c                	lw	a5,0(a5)
 3004420:	0807a783          	lw	a5,128(a5)
 3004424:	83bd                	srli	a5,a5,0xf
 3004426:	8b85                	andi	a5,a5,1
 3004428:	9f81                	uxtb	a5
 300442a:	fef42623          	sw	a5,-20(s0)
    } while (busy != 0x00);
 300442e:	fec42783          	lw	a5,-20(s0)
 3004432:	f7e5                	bnez	a5,300441a <WriteFinishClear+0x40>
    return BASE_STATUS_OK;
 3004434:	4781                	li	a5,0
}
 3004436:	853e                	mv	a0,a5
 3004438:	5432                	lw	s0,44(sp)
 300443a:	6145                	addi	sp,sp,48
 300443c:	8082                	ret

0300443e <WriteIrqService>:
  * @param canHandle CAN handle.
  * @param irqIndex Packet object interrupt ID.
  * @retval None.
  */
static void WriteIrqService(CAN_Handle *canHandle, unsigned int irqIndex)
{
 300443e:	1101                	addi	sp,sp,-32
 3004440:	ce06                	sw	ra,28(sp)
 3004442:	cc22                	sw	s0,24(sp)
 3004444:	1000                	addi	s0,sp,32
 3004446:	fea42623          	sw	a0,-20(s0)
 300444a:	feb42423          	sw	a1,-24(s0)
    // DBG_PRINTF("Transmit Successfully!\r\n");
    WriteFinishClear(canHandle, irqIndex);
 300444e:	fe842583          	lw	a1,-24(s0)
 3004452:	fec42503          	lw	a0,-20(s0)
 3004456:	3751                	jal	ra,30043da <WriteFinishClear>
    g_msgObj[irqIndex - 1] = 0;
 3004458:	fe842783          	lw	a5,-24(s0)
 300445c:	17fd                	addi	a5,a5,-1
 300445e:	c1218713          	addi	a4,gp,-1006 # 400051c <g_msgObj>
 3004462:	078a                	slli	a5,a5,0x2
 3004464:	97ba                	add	a5,a5,a4
 3004466:	0007a023          	sw	zero,0(a5)
    if (canHandle->userCallBack.WriteFinishCallBack != NULL) {
 300446a:	fec42783          	lw	a5,-20(s0)
 300446e:	5b9c                	lw	a5,48(a5)
 3004470:	c799                	beqz	a5,300447e <WriteIrqService+0x40>
        canHandle->userCallBack.WriteFinishCallBack(canHandle);
 3004472:	fec42783          	lw	a5,-20(s0)
 3004476:	5b9c                	lw	a5,48(a5)
 3004478:	fec42503          	lw	a0,-20(s0)
 300447c:	9782                	jalr	a5
    }
}
 300447e:	0001                	nop
 3004480:	40f2                	lw	ra,28(sp)
 3004482:	4462                	lw	s0,24(sp)
 3004484:	6105                	addi	sp,sp,32
 3004486:	8082                	ret

03004488 <ReadIrqService>:
  * @param canHandle CAN handle.
  * @param irqIndex Packet object interrupt ID.
  * @retval None.
  */
static void ReadIrqService(CAN_Handle *canHandle, unsigned int irqIndex)
{
 3004488:	1101                	addi	sp,sp,-32
 300448a:	ce06                	sw	ra,28(sp)
 300448c:	cc22                	sw	s0,24(sp)
 300448e:	1000                	addi	s0,sp,32
 3004490:	fea42623          	sw	a0,-20(s0)
 3004494:	feb42423          	sw	a1,-24(s0)
    //DBG_PRINTF("Receive Successfully!\r\n");
    CAN_ReadCallback(canHandle, irqIndex);
 3004498:	fe842583          	lw	a1,-24(s0)
 300449c:	fec42503          	lw	a0,-20(s0)
 30044a0:	3245                	jal	ra,3003e40 <CAN_ReadCallback>
    if (canHandle->userCallBack.ReadFinishCallBack != NULL) {
 30044a2:	fec42783          	lw	a5,-20(s0)
 30044a6:	5bdc                	lw	a5,52(a5)
 30044a8:	c799                	beqz	a5,30044b6 <ReadIrqService+0x2e>
        canHandle->userCallBack.ReadFinishCallBack(canHandle);
 30044aa:	fec42783          	lw	a5,-20(s0)
 30044ae:	5bdc                	lw	a5,52(a5)
 30044b0:	fec42503          	lw	a0,-20(s0)
 30044b4:	9782                	jalr	a5
    }
}
 30044b6:	0001                	nop
 30044b8:	40f2                	lw	ra,28(sp)
 30044ba:	4462                	lw	s0,24(sp)
 30044bc:	6105                	addi	sp,sp,32
 30044be:	8082                	ret

030044c0 <HAL_CAN_IrqHandler>:
  * @brief CAN interrupt service processing function.
  * @param handle CAN handle.
  * @retval None.
  */
void HAL_CAN_IrqHandler(void *handle)
{
 30044c0:	7139                	addi	sp,sp,-64
 30044c2:	de06                	sw	ra,60(sp)
 30044c4:	dc22                	sw	s0,56(sp)
 30044c6:	0080                	addi	s0,sp,64
 30044c8:	fca42623          	sw	a0,-52(s0)
    //DBG_PRINTF("Interrupt!\r\n");
    CAN_ASSERT_PARAM(handle != NULL);
    CAN_Handle *canHandle = (CAN_Handle *)handle;
 30044cc:	fcc42783          	lw	a5,-52(s0)
 30044d0:	fef42623          	sw	a5,-20(s0)
    CAN_ASSERT_PARAM(IsCANInstance(canHandle->baseAddress));
    unsigned int irqIndex;
    unsigned int idLow, idHigh, id;
    irqIndex = canHandle->baseAddress->CAN_INTERRUPT.reg;
 30044d4:	fec42783          	lw	a5,-20(s0)
 30044d8:	439c                	lw	a5,0(a5)
 30044da:	4b9c                	lw	a5,16(a5)
 30044dc:	fef42423          	sw	a5,-24(s0)
    /* Status interrupt ID: 0x8000 */
    if (irqIndex == 0x8000) {
 30044e0:	fe842703          	lw	a4,-24(s0)
 30044e4:	67a1                	lui	a5,0x8
 30044e6:	04f71963          	bne	a4,a5,3004538 <HAL_CAN_IrqHandler+0x78>
        /* Offline status of the CAN bus. */
        unsigned int statusBusoff = canHandle->baseAddress->CAN_STATUS.BIT.Boff;
 30044ea:	fec42783          	lw	a5,-20(s0)
 30044ee:	439c                	lw	a5,0(a5)
 30044f0:	43dc                	lw	a5,4(a5)
 30044f2:	839d                	srli	a5,a5,0x7
 30044f4:	8b85                	andi	a5,a5,1
 30044f6:	9f81                	uxtb	a5
 30044f8:	fcf42c23          	sw	a5,-40(s0)
        if (statusBusoff == BASE_CFG_ENABLE) {  /* true when the bus-off state is displayed. */
 30044fc:	fd842703          	lw	a4,-40(s0)
 3004500:	4785                	li	a5,1
 3004502:	02f71063          	bne	a4,a5,3004522 <HAL_CAN_IrqHandler+0x62>
            canHandle->baseAddress->CAN_CONTROL.BIT.Init = 0x01;
 3004506:	fec42783          	lw	a5,-20(s0)
 300450a:	4398                	lw	a4,0(a5)
 300450c:	431c                	lw	a5,0(a4)
 300450e:	0017e793          	ori	a5,a5,1
 3004512:	c31c                	sw	a5,0(a4)
            __asm__ volatile ("nop");                   /* Hold-off time */
 3004514:	0001                	nop
            canHandle->baseAddress->CAN_CONTROL.BIT.Init = 0x00;
 3004516:	fec42783          	lw	a5,-20(s0)
 300451a:	4398                	lw	a4,0(a5)
 300451c:	431c                	lw	a5,0(a4)
 300451e:	9bf9                	andi	a5,a5,-2
 3004520:	c31c                	sw	a5,0(a4)
        }
        if (canHandle->userCallBack.TransmitErrorCallBack != NULL) {
 3004522:	fec42783          	lw	a5,-20(s0)
 3004526:	5f9c                	lw	a5,56(a5)
 3004528:	cbc1                	beqz	a5,30045b8 <HAL_CAN_IrqHandler+0xf8>
            canHandle->userCallBack.TransmitErrorCallBack(canHandle);
 300452a:	fec42783          	lw	a5,-20(s0)
 300452e:	5f9c                	lw	a5,56(a5)
 3004530:	fec42503          	lw	a0,-20(s0)
 3004534:	9782                	jalr	a5
        }
        if (id & g_allRecvMap) {
            ReadIrqService(canHandle, irqIndex);
        }
    }
    return;
 3004536:	a049                	j	30045b8 <HAL_CAN_IrqHandler+0xf8>
    } else if (irqIndex >= 0x01 && irqIndex <= 0x20) { /* Packet object interrupt ID from 0x01 to 0x20 */
 3004538:	fe842783          	lw	a5,-24(s0)
 300453c:	cfb5                	beqz	a5,30045b8 <HAL_CAN_IrqHandler+0xf8>
 300453e:	fe842703          	lw	a4,-24(s0)
 3004542:	02000793          	li	a5,32
 3004546:	06e7e963          	bltu	a5,a4,30045b8 <HAL_CAN_IrqHandler+0xf8>
        idLow = canHandle->baseAddress->INTERRUPT_PENDING1.BIT.IntPnd16_1;
 300454a:	fec42783          	lw	a5,-20(s0)
 300454e:	439c                	lw	a5,0(a5)
 3004550:	1407a783          	lw	a5,320(a5) # 8140 <RAM_SIZE+0x3140>
 3004554:	9fa1                	uxth	a5
 3004556:	fef42223          	sw	a5,-28(s0)
        idHigh = canHandle->baseAddress->INTERRUPT_PENDING2.BIT.IntPnd32_17;
 300455a:	fec42783          	lw	a5,-20(s0)
 300455e:	439c                	lw	a5,0(a5)
 3004560:	1447a783          	lw	a5,324(a5)
 3004564:	9fa1                	uxth	a5
 3004566:	fef42023          	sw	a5,-32(s0)
        id = idLow;
 300456a:	fe442783          	lw	a5,-28(s0)
 300456e:	fcf42e23          	sw	a5,-36(s0)
        id |= idHigh << 16;          /* High 16 bits ID */
 3004572:	fe042783          	lw	a5,-32(s0)
 3004576:	07c2                	slli	a5,a5,0x10
 3004578:	fdc42703          	lw	a4,-36(s0)
 300457c:	8fd9                	or	a5,a5,a4
 300457e:	fcf42e23          	sw	a5,-36(s0)
        if (id & g_allSendMap) {     /* Write complete */
 3004582:	040007b7          	lui	a5,0x4000
 3004586:	00c7a703          	lw	a4,12(a5) # 400000c <g_allSendMap>
 300458a:	fdc42783          	lw	a5,-36(s0)
 300458e:	8ff9                	and	a5,a5,a4
 3004590:	c791                	beqz	a5,300459c <HAL_CAN_IrqHandler+0xdc>
            WriteIrqService(canHandle, irqIndex);
 3004592:	fe842583          	lw	a1,-24(s0)
 3004596:	fec42503          	lw	a0,-20(s0)
 300459a:	3555                	jal	ra,300443e <WriteIrqService>
        if (id & g_allRecvMap) {
 300459c:	040007b7          	lui	a5,0x4000
 30045a0:	0107a703          	lw	a4,16(a5) # 4000010 <g_allRecvMap>
 30045a4:	fdc42783          	lw	a5,-36(s0)
 30045a8:	8ff9                	and	a5,a5,a4
 30045aa:	c799                	beqz	a5,30045b8 <HAL_CAN_IrqHandler+0xf8>
            ReadIrqService(canHandle, irqIndex);
 30045ac:	fe842583          	lw	a1,-24(s0)
 30045b0:	fec42503          	lw	a0,-20(s0)
 30045b4:	3dd1                	jal	ra,3004488 <ReadIrqService>
    return;
 30045b6:	0001                	nop
 30045b8:	0001                	nop
}
 30045ba:	50f2                	lw	ra,60(sp)
 30045bc:	5462                	lw	s0,56(sp)
 30045be:	6121                	addi	sp,sp,64
 30045c0:	8082                	ret

030045c2 <HAL_CAN_RegisterCallBack>:
  * @param typeID Id of callback function type, @ref CAN_CallBackFunType
  * @param pCallback Pointer of the specified callbcak function, @ref CAN_CallbackType
  * @retval BASE_StatusType: BASE_STATUS_ERROR register error, BASE_STATUS_OK register success.
  */
BASE_StatusType HAL_CAN_RegisterCallBack(CAN_Handle *canHandle, CAN_CallBackFunType typeID, CAN_CallbackType pCallback)
{
 30045c2:	1101                	addi	sp,sp,-32
 30045c4:	ce22                	sw	s0,28(sp)
 30045c6:	1000                	addi	s0,sp,32
 30045c8:	fea42623          	sw	a0,-20(s0)
 30045cc:	feb42423          	sw	a1,-24(s0)
 30045d0:	fec42223          	sw	a2,-28(s0)
    CAN_ASSERT_PARAM(canHandle != NULL);
    CAN_ASSERT_PARAM(IsCANInstance(canHandle->baseAddress));
    switch (typeID) {
 30045d4:	fe842783          	lw	a5,-24(s0)
 30045d8:	4705                	li	a4,1
 30045da:	00e78f63          	beq	a5,a4,30045f8 <HAL_CAN_RegisterCallBack+0x36>
 30045de:	4705                	li	a4,1
 30045e0:	00e7e663          	bltu	a5,a4,30045ec <HAL_CAN_RegisterCallBack+0x2a>
 30045e4:	4709                	li	a4,2
 30045e6:	00e78f63          	beq	a5,a4,3004604 <HAL_CAN_RegisterCallBack+0x42>
 30045ea:	a01d                	j	3004610 <HAL_CAN_RegisterCallBack+0x4e>
        case CAN_WRITE_FINISH:    /* CAN write finish call back. */
            canHandle->userCallBack.WriteFinishCallBack = pCallback;
 30045ec:	fec42783          	lw	a5,-20(s0)
 30045f0:	fe442703          	lw	a4,-28(s0)
 30045f4:	db98                	sw	a4,48(a5)
            break;
 30045f6:	a839                	j	3004614 <HAL_CAN_RegisterCallBack+0x52>
        case CAN_READ_FINISH:    /* CAN read finish call back. */
            canHandle->userCallBack.ReadFinishCallBack = pCallback;
 30045f8:	fec42783          	lw	a5,-20(s0)
 30045fc:	fe442703          	lw	a4,-28(s0)
 3004600:	dbd8                	sw	a4,52(a5)
            break;
 3004602:	a809                	j	3004614 <HAL_CAN_RegisterCallBack+0x52>
        case CAN_TRNS_ERROR:     /* CAN transmit finish call back. */
            canHandle->userCallBack.TransmitErrorCallBack = pCallback;
 3004604:	fec42783          	lw	a5,-20(s0)
 3004608:	fe442703          	lw	a4,-28(s0)
 300460c:	df98                	sw	a4,56(a5)
            break;
 300460e:	a019                	j	3004614 <HAL_CAN_RegisterCallBack+0x52>
        default:
            return BASE_STATUS_ERROR;
 3004610:	4785                	li	a5,1
 3004612:	a011                	j	3004616 <HAL_CAN_RegisterCallBack+0x54>
    }
    return BASE_STATUS_OK;
 3004614:	4781                	li	a5,0
 3004616:	853e                	mv	a0,a5
 3004618:	4472                	lw	s0,28(sp)
 300461a:	6105                	addi	sp,sp,32
 300461c:	8082                	ret

0300461e <DCL_SYSCTRL_CrgWriteProtectionDisable>:
  * @brief Set the write protection for CRG-related registers disable.
  * @param None
  * @retval None.
  */
static inline void DCL_SYSCTRL_CrgWriteProtectionDisable(void)
{
 300461e:	1141                	addi	sp,sp,-16
 3004620:	c622                	sw	s0,12(sp)
 3004622:	0800                	addi	s0,sp,16
    /* Set the corresponding bit without affecting the other bits and set the high 16 bits to EA51 to write to. */
    SYSCTRL0->SC_LOCKEN.reg = (SYSCTRL0->SC_LOCKEN.reg & SC_LOCKEN_CRG_DISABLE_MASK) + SC_LOCKEN_VALID_HIGH_BIT;
 3004624:	101007b7          	lui	a5,0x10100
 3004628:	43f8                	lw	a4,68(a5)
 300462a:	67c1                	lui	a5,0x10
 300462c:	17f9                	addi	a5,a5,-2 # fffe <RAM_SIZE+0xaffe>
 300462e:	00f776b3          	and	a3,a4,a5
 3004632:	101007b7          	lui	a5,0x10100
 3004636:	ea510737          	lui	a4,0xea510
 300463a:	9736                	add	a4,a4,a3
 300463c:	c3f8                	sw	a4,68(a5)
}
 300463e:	0001                	nop
 3004640:	4432                	lw	s0,12(sp)
 3004642:	0141                	addi	sp,sp,16
 3004644:	8082                	ret

03004646 <DCL_SYSCTRL_CrgWriteProtectionEnable>:
  * @brief Set the Set the write protection for CRG-related registers enable.
  * @param None
  * @retval None.
  */
static inline void DCL_SYSCTRL_CrgWriteProtectionEnable(void)
{
 3004646:	1141                	addi	sp,sp,-16
 3004648:	c622                	sw	s0,12(sp)
 300464a:	0800                	addi	s0,sp,16
    /* Set the corresponding bit without affecting the other bits and set the high 16 bits to EA51 to write to. */
    SYSCTRL0->SC_LOCKEN.reg = ((SYSCTRL0->SC_LOCKEN.reg & SC_LOW_BIT_MASK) | SC_LOCKEN_CRG_ENABLE_MASK) +
 300464c:	101007b7          	lui	a5,0x10100
 3004650:	43f8                	lw	a4,68(a5)
 3004652:	67c1                	lui	a5,0x10
 3004654:	17fd                	addi	a5,a5,-1 # ffff <RAM_SIZE+0xafff>
 3004656:	8ff9                	and	a5,a5,a4
 3004658:	0017e693          	ori	a3,a5,1
 300465c:	101007b7          	lui	a5,0x10100
 3004660:	ea510737          	lui	a4,0xea510
 3004664:	9736                	add	a4,a4,a3
 3004666:	c3f8                	sw	a4,68(a5)
                              SC_LOCKEN_VALID_HIGH_BIT;
}
 3004668:	0001                	nop
 300466a:	4432                	lw	s0,12(sp)
 300466c:	0141                	addi	sp,sp,16
 300466e:	8082                	ret

03004670 <IsCrgPllRefClkSelect>:
  * @param clkSelect pll_ref_cksel
  * @retval true
  * @retval false
  */
static inline bool IsCrgPllRefClkSelect(CRG_PllRefClkSelect clkSelect)
{
 3004670:	1101                	addi	sp,sp,-32
 3004672:	ce22                	sw	s0,28(sp)
 3004674:	1000                	addi	s0,sp,32
 3004676:	fea42623          	sw	a0,-20(s0)
    return ((clkSelect == CRG_PLL_REF_CLK_SELECT_HOSC) ||
 300467a:	fec42783          	lw	a5,-20(s0)
 300467e:	c791                	beqz	a5,300468a <IsCrgPllRefClkSelect+0x1a>
 3004680:	fec42703          	lw	a4,-20(s0)
 3004684:	4785                	li	a5,1
 3004686:	00f71463          	bne	a4,a5,300468e <IsCrgPllRefClkSelect+0x1e>
 300468a:	4785                	li	a5,1
 300468c:	a011                	j	3004690 <IsCrgPllRefClkSelect+0x20>
 300468e:	4781                	li	a5,0
 3004690:	8b85                	andi	a5,a5,1
 3004692:	9f81                	uxtb	a5
            (clkSelect == CRG_PLL_REF_CLK_SELECT_XTAL));
}
 3004694:	853e                	mv	a0,a5
 3004696:	4472                	lw	s0,28(sp)
 3004698:	6105                	addi	sp,sp,32
 300469a:	8082                	ret

0300469c <IsCrgPllPreDiv>:
  * @param preDiv pll prediv value
  * @retval true
  * @retval false
  */
static inline bool IsCrgPllPreDiv(CRG_PllPreDiv preDiv)
{
 300469c:	1101                	addi	sp,sp,-32
 300469e:	ce22                	sw	s0,28(sp)
 30046a0:	1000                	addi	s0,sp,32
 30046a2:	fea42623          	sw	a0,-20(s0)
    return ((preDiv >= CRG_PLL_PREDIV_1) &&
 30046a6:	fec42783          	lw	a5,-20(s0)
 30046aa:	0087b793          	sltiu	a5,a5,8
 30046ae:	9f81                	uxtb	a5
            (preDiv <= CRG_PLL_PREDIV_8));
}
 30046b0:	853e                	mv	a0,a5
 30046b2:	4472                	lw	s0,28(sp)
 30046b4:	6105                	addi	sp,sp,32
 30046b6:	8082                	ret

030046b8 <IsCrgPllPostDiv>:
  * @param postDiv  pll_postdiv value
  * @retval true
  * @retval false
  */
static inline bool IsCrgPllPostDiv(CRG_PllPostDiv postDiv)
{
 30046b8:	1101                	addi	sp,sp,-32
 30046ba:	ce22                	sw	s0,28(sp)
 30046bc:	1000                	addi	s0,sp,32
 30046be:	fea42623          	sw	a0,-20(s0)
    return ((postDiv >= CRG_PLL_POSTDIV_1) &&
 30046c2:	fec42783          	lw	a5,-20(s0)
 30046c6:	0087b793          	sltiu	a5,a5,8
 30046ca:	9f81                	uxtb	a5
            (postDiv <= CRG_PLL_POSTDIV_8));
}
 30046cc:	853e                	mv	a0,a5
 30046ce:	4472                	lw	s0,28(sp)
 30046d0:	6105                	addi	sp,sp,32
 30046d2:	8082                	ret

030046d4 <IsCrgPllPostDiv2>:
  * @param postDiv  pll_postdiv2 value
  * @retval true
  * @retval false
  */
static inline bool IsCrgPllPostDiv2(CRG_PllPostDiv2 postDiv)
{
 30046d4:	1101                	addi	sp,sp,-32
 30046d6:	ce22                	sw	s0,28(sp)
 30046d8:	1000                	addi	s0,sp,32
 30046da:	fea42623          	sw	a0,-20(s0)
    return ((postDiv >= CRG_PLL_POSTDIV2_1) &&
 30046de:	fec42783          	lw	a5,-20(s0)
 30046e2:	0087b793          	sltiu	a5,a5,8
 30046e6:	9f81                	uxtb	a5
            (postDiv <= CRG_PLL_POSTDIV2_8_MAX));
}
 30046e8:	853e                	mv	a0,a5
 30046ea:	4472                	lw	s0,28(sp)
 30046ec:	6105                	addi	sp,sp,32
 30046ee:	8082                	ret

030046f0 <IsCrgPllFbDiv>:
  * @param fbDiv  pll fbdiv value
  * @retval true
  * @retval false
  */
static inline bool IsCrgPllFbDiv(unsigned int fbDiv)
{
 30046f0:	1101                	addi	sp,sp,-32
 30046f2:	ce22                	sw	s0,28(sp)
 30046f4:	1000                	addi	s0,sp,32
 30046f6:	fea42623          	sw	a0,-20(s0)
    return (fbDiv <= CRG_PLL_FBDIV_MAX);
 30046fa:	fec42783          	lw	a5,-20(s0)
 30046fe:	0807b793          	sltiu	a5,a5,128
 3004702:	9f81                	uxtb	a5
}
 3004704:	853e                	mv	a0,a5
 3004706:	4472                	lw	s0,28(sp)
 3004708:	6105                	addi	sp,sp,32
 300470a:	8082                	ret

0300470c <IsCrgCoreCkSel>:
  * @param select  core_cksel value
  * @retval true
  * @retval false
  */
static inline bool IsCrgCoreCkSel(CRG_CoreClkSelect select)
{
 300470c:	1101                	addi	sp,sp,-32
 300470e:	ce22                	sw	s0,28(sp)
 3004710:	1000                	addi	s0,sp,32
 3004712:	fea42623          	sw	a0,-20(s0)
    return ((select == CRG_CORE_CLK_SELECT_HOSC) ||
            (select == CRG_CORE_CLK_SELECT_TCXO) ||
 3004716:	fec42783          	lw	a5,-20(s0)
 300471a:	cb99                	beqz	a5,3004730 <IsCrgCoreCkSel+0x24>
    return ((select == CRG_CORE_CLK_SELECT_HOSC) ||
 300471c:	fec42703          	lw	a4,-20(s0)
 3004720:	4785                	li	a5,1
 3004722:	00f70763          	beq	a4,a5,3004730 <IsCrgCoreCkSel+0x24>
            (select == CRG_CORE_CLK_SELECT_TCXO) ||
 3004726:	fec42703          	lw	a4,-20(s0)
 300472a:	4789                	li	a5,2
 300472c:	00f71463          	bne	a4,a5,3004734 <IsCrgCoreCkSel+0x28>
 3004730:	4785                	li	a5,1
 3004732:	a011                	j	3004736 <IsCrgCoreCkSel+0x2a>
 3004734:	4781                	li	a5,0
 3004736:	8b85                	andi	a5,a5,1
 3004738:	9f81                	uxtb	a5
            (select == CRG_CORE_CLK_SELECT_PLL));
}
 300473a:	853e                	mv	a0,a5
 300473c:	4472                	lw	s0,28(sp)
 300473e:	6105                	addi	sp,sp,32
 3004740:	8082                	ret

03004742 <IsCrg1MCkSel>:
  * @param select  1M clock selection
  * @retval true
  * @retval false
  */
static inline bool IsCrg1MCkSel(CRG_1MClkSelect select)
{
 3004742:	1101                	addi	sp,sp,-32
 3004744:	ce22                	sw	s0,28(sp)
 3004746:	1000                	addi	s0,sp,32
 3004748:	fea42623          	sw	a0,-20(s0)
    return ((select == CRG_1M_CLK_SELECT_HOSC) ||
 300474c:	fec42783          	lw	a5,-20(s0)
 3004750:	c791                	beqz	a5,300475c <IsCrg1MCkSel+0x1a>
 3004752:	fec42703          	lw	a4,-20(s0)
 3004756:	4785                	li	a5,1
 3004758:	00f71463          	bne	a4,a5,3004760 <IsCrg1MCkSel+0x1e>
 300475c:	4785                	li	a5,1
 300475e:	a011                	j	3004762 <IsCrg1MCkSel+0x20>
 3004760:	4781                	li	a5,0
 3004762:	8b85                	andi	a5,a5,1
 3004764:	9f81                	uxtb	a5
            (select == CRG_1M_CLK_SELECT_TCXO));
}
 3004766:	853e                	mv	a0,a5
 3004768:	4472                	lw	s0,28(sp)
 300476a:	6105                	addi	sp,sp,32
 300476c:	8082                	ret

0300476e <IsCrg1MCkDiv>:
  * @param div  1M clock ratio
  * @retval true
  * @retval false
  */
static inline bool IsCrg1MCkDiv(unsigned int div)
{
 300476e:	1101                	addi	sp,sp,-32
 3004770:	ce22                	sw	s0,28(sp)
 3004772:	1000                	addi	s0,sp,32
 3004774:	fea42623          	sw	a0,-20(s0)
    return (div <= CRG_1MHZ_CLK_MAX_DIV);
 3004778:	fec42783          	lw	a5,-20(s0)
 300477c:	0407b793          	sltiu	a5,a5,64
 3004780:	9f81                	uxtb	a5
}
 3004782:	853e                	mv	a0,a5
 3004784:	4472                	lw	s0,28(sp)
 3004786:	6105                	addi	sp,sp,32
 3004788:	8082                	ret

0300478a <IsCrgAHBCkSel>:
  * @param select  AHB ip clock select value
  * @retval true
  * @retval false
  */
static inline bool IsCrgAHBCkSel(CRG_AHBClkSelect select)
{
 300478a:	1101                	addi	sp,sp,-32
 300478c:	ce22                	sw	s0,28(sp)
 300478e:	1000                	addi	s0,sp,32
 3004790:	fea42623          	sw	a0,-20(s0)
    return ((select == CRG_AHB_CLK_NO_PREDV) ||
            (select == CRG_AHB_CLK_PREDIV_2) ||
            (select == CRG_AHB_CLK_PREDIV_4) ||
 3004794:	fec42783          	lw	a5,-20(s0)
 3004798:	c385                	beqz	a5,30047b8 <IsCrgAHBCkSel+0x2e>
    return ((select == CRG_AHB_CLK_NO_PREDV) ||
 300479a:	fec42703          	lw	a4,-20(s0)
 300479e:	4785                	li	a5,1
 30047a0:	00f70c63          	beq	a4,a5,30047b8 <IsCrgAHBCkSel+0x2e>
            (select == CRG_AHB_CLK_PREDIV_2) ||
 30047a4:	fec42703          	lw	a4,-20(s0)
 30047a8:	4789                	li	a5,2
 30047aa:	00f70763          	beq	a4,a5,30047b8 <IsCrgAHBCkSel+0x2e>
            (select == CRG_AHB_CLK_PREDIV_4) ||
 30047ae:	fec42703          	lw	a4,-20(s0)
 30047b2:	478d                	li	a5,3
 30047b4:	00f71463          	bne	a4,a5,30047bc <IsCrgAHBCkSel+0x32>
 30047b8:	4785                	li	a5,1
 30047ba:	a011                	j	30047be <IsCrgAHBCkSel+0x34>
 30047bc:	4781                	li	a5,0
 30047be:	8b85                	andi	a5,a5,1
 30047c0:	9f81                	uxtb	a5
            (select == CRG_AHB_CLK_PREDIV_8));
}
 30047c2:	853e                	mv	a0,a5
 30047c4:	4472                	lw	s0,28(sp)
 30047c6:	6105                	addi	sp,sp,32
 30047c8:	8082                	ret

030047ca <IsCrgValidPreDiv>:
  * @param preDiv PLL Previous Divsion
  * @retval true
  * @retval false
  */
static inline bool IsCrgValidPreDiv(unsigned int pllRefFreq, unsigned int preDiv)
{
 30047ca:	7179                	addi	sp,sp,-48
 30047cc:	d622                	sw	s0,44(sp)
 30047ce:	1800                	addi	s0,sp,48
 30047d0:	fca42e23          	sw	a0,-36(s0)
 30047d4:	fcb42c23          	sw	a1,-40(s0)
    unsigned int freq = pllRefFreq;
 30047d8:	fdc42783          	lw	a5,-36(s0)
 30047dc:	fef42623          	sw	a5,-20(s0)
    if (preDiv != 0) {
 30047e0:	fd842783          	lw	a5,-40(s0)
 30047e4:	cb89                	beqz	a5,30047f6 <IsCrgValidPreDiv+0x2c>
        freq /= preDiv;
 30047e6:	fec42703          	lw	a4,-20(s0)
 30047ea:	fd842783          	lw	a5,-40(s0)
 30047ee:	02f757b3          	divu	a5,a4,a5
 30047f2:	fef42623          	sw	a5,-20(s0)
    }
    return (freq >= CRG_CLK_PFD_MIN_FREQ) && (freq <= CRG_CLK_PFD_MAX_FREQ);
 30047f6:	fec42703          	lw	a4,-20(s0)
 30047fa:	003d17b7          	lui	a5,0x3d1
 30047fe:	8ff78793          	addi	a5,a5,-1793 # 3d08ff <FLASH_SIZE+0x3b0903>
 3004802:	00e7fc63          	bgeu	a5,a4,300481a <IsCrgValidPreDiv+0x50>
 3004806:	fec42703          	lw	a4,-20(s0)
 300480a:	007277b7          	lui	a5,0x727
 300480e:	0e078793          	addi	a5,a5,224 # 7270e0 <FLASH_SIZE+0x7070e4>
 3004812:	00e7e463          	bltu	a5,a4,300481a <IsCrgValidPreDiv+0x50>
 3004816:	4785                	li	a5,1
 3004818:	a011                	j	300481c <IsCrgValidPreDiv+0x52>
 300481a:	4781                	li	a5,0
 300481c:	8b85                	andi	a5,a5,1
 300481e:	9f81                	uxtb	a5
}
 3004820:	853e                	mv	a0,a5
 3004822:	5432                	lw	s0,44(sp)
 3004824:	6145                	addi	sp,sp,48
 3004826:	8082                	ret

03004828 <IsCrgValidFdDiv>:
  * @param fdDiv PLL FD Divsion
  * @retval true
  * @retval false
  */
static inline bool IsCrgValidFdDiv(unsigned int clkPfdFreq, unsigned int fdDiv)
{
 3004828:	7179                	addi	sp,sp,-48
 300482a:	d622                	sw	s0,44(sp)
 300482c:	1800                	addi	s0,sp,48
 300482e:	fca42e23          	sw	a0,-36(s0)
 3004832:	fcb42c23          	sw	a1,-40(s0)
    if (clkPfdFreq > 30000000U) {  /* The maximum speed of the external clock source is 30000000U. */
 3004836:	fdc42703          	lw	a4,-36(s0)
 300483a:	01c9c7b7          	lui	a5,0x1c9c
 300483e:	38078793          	addi	a5,a5,896 # 1c9c380 <FLASH_SIZE+0x1c7c384>
 3004842:	00e7f463          	bgeu	a5,a4,300484a <IsCrgValidFdDiv+0x22>
        return false;
 3004846:	4781                	li	a5,0
 3004848:	a08d                	j	30048aa <IsCrgValidFdDiv+0x82>
    } else if (fdDiv > CRG_PLL_FBDIV_MAX) {
 300484a:	fd842703          	lw	a4,-40(s0)
 300484e:	07f00793          	li	a5,127
 3004852:	00e7f463          	bgeu	a5,a4,300485a <IsCrgValidFdDiv+0x32>
        return false;
 3004856:	4781                	li	a5,0
 3004858:	a889                	j	30048aa <IsCrgValidFdDiv+0x82>
    }

    unsigned int freq = (fdDiv > 0x6) ? (clkPfdFreq * fdDiv) : (clkPfdFreq * 0x6); /* 0x0-0x6: divided by 0x6 */
 300485a:	fd842703          	lw	a4,-40(s0)
 300485e:	4799                	li	a5,6
 3004860:	00e7f963          	bgeu	a5,a4,3004872 <IsCrgValidFdDiv+0x4a>
 3004864:	fdc42703          	lw	a4,-36(s0)
 3004868:	fd842783          	lw	a5,-40(s0)
 300486c:	02f707b3          	mul	a5,a4,a5
 3004870:	a031                	j	300487c <IsCrgValidFdDiv+0x54>
 3004872:	fdc42703          	lw	a4,-36(s0)
 3004876:	4799                	li	a5,6
 3004878:	02f707b3          	mul	a5,a4,a5
 300487c:	fef42623          	sw	a5,-20(s0)
    return (freq >= CRG_CLK_VCO_MIN_FREQ) && (freq <= CRG_CLK_VCO_MAX_FREQ);
 3004880:	fec42703          	lw	a4,-20(s0)
 3004884:	05f5e7b7          	lui	a5,0x5f5e
 3004888:	0ff78793          	addi	a5,a5,255 # 5f5e0ff <RAM_END+0x1f560ff>
 300488c:	00e7fc63          	bgeu	a5,a4,30048a4 <IsCrgValidFdDiv+0x7c>
 3004890:	fec42703          	lw	a4,-20(s0)
 3004894:	11e1a7b7          	lui	a5,0x11e1a
 3004898:	30078793          	addi	a5,a5,768 # 11e1a300 <RAM_END+0xde12300>
 300489c:	00e7e463          	bltu	a5,a4,30048a4 <IsCrgValidFdDiv+0x7c>
 30048a0:	4785                	li	a5,1
 30048a2:	a011                	j	30048a6 <IsCrgValidFdDiv+0x7e>
 30048a4:	4781                	li	a5,0
 30048a6:	8b85                	andi	a5,a5,1
 30048a8:	9f81                	uxtb	a5
}
 30048aa:	853e                	mv	a0,a5
 30048ac:	5432                	lw	s0,44(sp)
 30048ae:	6145                	addi	sp,sp,48
 30048b0:	8082                	ret

030048b2 <IsCrgValidPostDiv>:
  * @param postDiv PLL Post Divsion
  * @retval true
  * @retval false
  */
static inline bool IsCrgValidPostDiv(unsigned int clkVcoFreq, unsigned int postDiv)
{
 30048b2:	7179                	addi	sp,sp,-48
 30048b4:	d622                	sw	s0,44(sp)
 30048b6:	1800                	addi	s0,sp,48
 30048b8:	fca42e23          	sw	a0,-36(s0)
 30048bc:	fcb42c23          	sw	a1,-40(s0)
    unsigned int freq = clkVcoFreq;
 30048c0:	fdc42783          	lw	a5,-36(s0)
 30048c4:	fef42623          	sw	a5,-20(s0)
    if (postDiv != 0) {
 30048c8:	fd842783          	lw	a5,-40(s0)
 30048cc:	cb91                	beqz	a5,30048e0 <IsCrgValidPostDiv+0x2e>
        freq /= (postDiv + 1);
 30048ce:	fd842783          	lw	a5,-40(s0)
 30048d2:	0785                	addi	a5,a5,1
 30048d4:	fec42703          	lw	a4,-20(s0)
 30048d8:	02f757b3          	divu	a5,a4,a5
 30048dc:	fef42623          	sw	a5,-20(s0)
    }
    return (freq <= CRG_CLK_TARGET_MAX_FREQ);
 30048e0:	fec42703          	lw	a4,-20(s0)
 30048e4:	08f0d7b7          	lui	a5,0x8f0d
 30048e8:	18178793          	addi	a5,a5,385 # 8f0d181 <RAM_END+0x4f05181>
 30048ec:	00f737b3          	sltu	a5,a4,a5
 30048f0:	9f81                	uxtb	a5
}
 30048f2:	853e                	mv	a0,a5
 30048f4:	5432                	lw	s0,44(sp)
 30048f6:	6145                	addi	sp,sp,48
 30048f8:	8082                	ret

030048fa <IsCrgValidPostDiv2>:
  * @param postDiv2 PLL Post Divsion2
  * @retval true
  * @retval false
  */
static inline bool IsCrgValidPostDiv2(unsigned int clkVcoFreq, unsigned int postDiv2)
{
 30048fa:	7179                	addi	sp,sp,-48
 30048fc:	d622                	sw	s0,44(sp)
 30048fe:	1800                	addi	s0,sp,48
 3004900:	fca42e23          	sw	a0,-36(s0)
 3004904:	fcb42c23          	sw	a1,-40(s0)
    unsigned int freq = clkVcoFreq;
 3004908:	fdc42783          	lw	a5,-36(s0)
 300490c:	fef42623          	sw	a5,-20(s0)
    if (postDiv2 != 0) {
 3004910:	fd842783          	lw	a5,-40(s0)
 3004914:	cb91                	beqz	a5,3004928 <IsCrgValidPostDiv2+0x2e>
        freq /= (postDiv2 + 1);
 3004916:	fd842783          	lw	a5,-40(s0)
 300491a:	0785                	addi	a5,a5,1
 300491c:	fec42703          	lw	a4,-20(s0)
 3004920:	02f757b3          	divu	a5,a4,a5
 3004924:	fef42623          	sw	a5,-20(s0)
    }
    return (freq <= CRG_CLK_PST2_MAX_FREQ);
 3004928:	fec42703          	lw	a4,-20(s0)
 300492c:	05f5e7b7          	lui	a5,0x5f5e
 3004930:	10178793          	addi	a5,a5,257 # 5f5e101 <RAM_END+0x1f56101>
 3004934:	00f737b3          	sltu	a5,a4,a5
 3004938:	9f81                	uxtb	a5
}
 300493a:	853e                	mv	a0,a5
 300493c:	5432                	lw	s0,44(sp)
 300493e:	6145                	addi	sp,sp,48
 3004940:	8082                	ret

03004942 <IsCrgAdcClkModeSelect>:
  * @param adcClkSelect the value of adc clock select
  * @retval true
  * @retval false
  */
static inline bool IsCrgAdcClkModeSelect(CRG_AdcClkSelect adcClkSelect)
{
 3004942:	1101                	addi	sp,sp,-32
 3004944:	ce22                	sw	s0,28(sp)
 3004946:	1000                	addi	s0,sp,32
 3004948:	fea42623          	sw	a0,-20(s0)
    return (adcClkSelect == CRG_ADC_CLK_ASYN_HOSC || \
            adcClkSelect == CRG_ADC_CLK_ASYN_TCXO || \
            adcClkSelect == CRG_ADC_CLK_ASYN_PLL_DIV || \
 300494c:	fec42783          	lw	a5,-20(s0)
 3004950:	c385                	beqz	a5,3004970 <IsCrgAdcClkModeSelect+0x2e>
    return (adcClkSelect == CRG_ADC_CLK_ASYN_HOSC || \
 3004952:	fec42703          	lw	a4,-20(s0)
 3004956:	4785                	li	a5,1
 3004958:	00f70c63          	beq	a4,a5,3004970 <IsCrgAdcClkModeSelect+0x2e>
            adcClkSelect == CRG_ADC_CLK_ASYN_TCXO || \
 300495c:	fec42703          	lw	a4,-20(s0)
 3004960:	4789                	li	a5,2
 3004962:	00f70763          	beq	a4,a5,3004970 <IsCrgAdcClkModeSelect+0x2e>
            adcClkSelect == CRG_ADC_CLK_ASYN_PLL_DIV || \
 3004966:	fec42703          	lw	a4,-20(s0)
 300496a:	478d                	li	a5,3
 300496c:	00f71463          	bne	a4,a5,3004974 <IsCrgAdcClkModeSelect+0x32>
 3004970:	4785                	li	a5,1
 3004972:	a011                	j	3004976 <IsCrgAdcClkModeSelect+0x34>
 3004974:	4781                	li	a5,0
 3004976:	8b85                	andi	a5,a5,1
 3004978:	9f81                	uxtb	a5
            adcClkSelect == CRG_ADC_CLK_SYN_CORE);
}
 300497a:	853e                	mv	a0,a5
 300497c:	4472                	lw	s0,28(sp)
 300497e:	6105                	addi	sp,sp,32
 3004980:	8082                	ret

03004982 <IsCrgAdcClkDiv>:
  * @param div the value of adc clock div
  * @retval true
  * @retval false
  */
static inline bool IsCrgAdcClkDiv(CRG_AdcDiv div)
{
 3004982:	1101                	addi	sp,sp,-32
 3004984:	ce22                	sw	s0,28(sp)
 3004986:	1000                	addi	s0,sp,32
 3004988:	fea42623          	sw	a0,-20(s0)
    return (div == CRG_ADC_DIV_1 || \
            div == CRG_ADC_DIV_2 || \
            div == CRG_ADC_DIV_3 || \
 300498c:	fec42783          	lw	a5,-20(s0)
 3004990:	c385                	beqz	a5,30049b0 <IsCrgAdcClkDiv+0x2e>
    return (div == CRG_ADC_DIV_1 || \
 3004992:	fec42703          	lw	a4,-20(s0)
 3004996:	4785                	li	a5,1
 3004998:	00f70c63          	beq	a4,a5,30049b0 <IsCrgAdcClkDiv+0x2e>
            div == CRG_ADC_DIV_2 || \
 300499c:	fec42703          	lw	a4,-20(s0)
 30049a0:	4789                	li	a5,2
 30049a2:	00f70763          	beq	a4,a5,30049b0 <IsCrgAdcClkDiv+0x2e>
            div == CRG_ADC_DIV_3 || \
 30049a6:	fec42703          	lw	a4,-20(s0)
 30049aa:	478d                	li	a5,3
 30049ac:	00f71463          	bne	a4,a5,30049b4 <IsCrgAdcClkDiv+0x32>
 30049b0:	4785                	li	a5,1
 30049b2:	a011                	j	30049b6 <IsCrgAdcClkDiv+0x34>
 30049b4:	4781                	li	a5,0
 30049b6:	8b85                	andi	a5,a5,1
 30049b8:	9f81                	uxtb	a5
            div == CRG_ADC_DIV_4);
}
 30049ba:	853e                	mv	a0,a5
 30049bc:	4472                	lw	s0,28(sp)
 30049be:	6105                	addi	sp,sp,32
 30049c0:	8082                	ret

030049c2 <DCL_CRG_SetCoreClkSel>:
  * @param clk  Clock register base address
  * @param select  Core clock selection
  * @retval None
  */
static inline void DCL_CRG_SetCoreClkSel(CRG_RegStruct *clk, CRG_CoreClkSelect select)
{
 30049c2:	1101                	addi	sp,sp,-32
 30049c4:	ce06                	sw	ra,28(sp)
 30049c6:	cc22                	sw	s0,24(sp)
 30049c8:	1000                	addi	s0,sp,32
 30049ca:	fea42623          	sw	a0,-20(s0)
 30049ce:	feb42423          	sw	a1,-24(s0)
    CRG_ASSERT_PARAM(IsCRGInstance(clk));
 30049d2:	fec42703          	lw	a4,-20(s0)
 30049d6:	100007b7          	lui	a5,0x10000
 30049da:	00f70a63          	beq	a4,a5,30049ee <DCL_CRG_SetCoreClkSel+0x2c>
 30049de:	69900593          	li	a1,1689
 30049e2:	030127b7          	lui	a5,0x3012
 30049e6:	bc478513          	addi	a0,a5,-1084 # 3011bc4 <g_crgIpMatch+0x32c>
 30049ea:	2d21                	jal	ra,3005002 <AssertErrorLog.trans.2>
 30049ec:	a001                	j	30049ec <DCL_CRG_SetCoreClkSel+0x2a>
    CRG_PARAM_CHECK_NO_RET(IsCrgCoreCkSel(select));
 30049ee:	fe842503          	lw	a0,-24(s0)
 30049f2:	3b29                	jal	ra,300470c <IsCrgCoreCkSel>
 30049f4:	87aa                	mv	a5,a0
 30049f6:	0017c793          	xori	a5,a5,1
 30049fa:	9f81                	uxtb	a5
 30049fc:	cb89                	beqz	a5,3004a0e <DCL_CRG_SetCoreClkSel+0x4c>
 30049fe:	69a00593          	li	a1,1690
 3004a02:	030127b7          	lui	a5,0x3012
 3004a06:	bc478513          	addi	a0,a5,-1084 # 3011bc4 <g_crgIpMatch+0x32c>
 3004a0a:	2be5                	jal	ra,3005002 <AssertErrorLog.trans.2>
 3004a0c:	a839                	j	3004a2a <DCL_CRG_SetCoreClkSel+0x68>
    clk->PERI_CRG64.BIT.clk_pst1_sw_sel = select;
 3004a0e:	fe842783          	lw	a5,-24(s0)
 3004a12:	8b8d                	andi	a5,a5,3
 3004a14:	0ff7f693          	andi	a3,a5,255
 3004a18:	fec42703          	lw	a4,-20(s0)
 3004a1c:	10072783          	lw	a5,256(a4) # ea510100 <RAM_END+0xe6508100>
 3004a20:	8a8d                	andi	a3,a3,3
 3004a22:	9bf1                	andi	a5,a5,-4
 3004a24:	8fd5                	or	a5,a5,a3
 3004a26:	10f72023          	sw	a5,256(a4)
}
 3004a2a:	40f2                	lw	ra,28(sp)
 3004a2c:	4462                	lw	s0,24(sp)
 3004a2e:	6105                	addi	sp,sp,32
 3004a30:	8082                	ret

03004a32 <HAL_CRG_Init>:
  * @param handle CRG Handle
  * @retval BASE_STATUS_ERROR  Parameter Check fail
  * @retval BASE_STATUS_OK     Success
  */
BASE_StatusType HAL_CRG_Init(const CRG_Handle *handle)
{
 3004a32:	7179                	addi	sp,sp,-48
 3004a34:	d606                	sw	ra,44(sp)
 3004a36:	d422                	sw	s0,40(sp)
 3004a38:	1800                	addi	s0,sp,48
 3004a3a:	fca42e23          	sw	a0,-36(s0)
    CRG_ASSERT_PARAM(handle != NULL);
 3004a3e:	fdc42783          	lw	a5,-36(s0)
 3004a42:	eb89                	bnez	a5,3004a54 <HAL_CRG_Init+0x22>
 3004a44:	07c00593          	li	a1,124
 3004a48:	030127b7          	lui	a5,0x3012
 3004a4c:	be078513          	addi	a0,a5,-1056 # 3011be0 <g_crgIpMatch+0x348>
 3004a50:	2b4d                	jal	ra,3005002 <AssertErrorLog.trans.2>
 3004a52:	a001                	j	3004a52 <HAL_CRG_Init+0x20>
    CRG_ASSERT_PARAM(IsCRGInstance(handle->baseAddress));
 3004a54:	fdc42783          	lw	a5,-36(s0)
 3004a58:	4398                	lw	a4,0(a5)
 3004a5a:	100007b7          	lui	a5,0x10000
 3004a5e:	00f70a63          	beq	a4,a5,3004a72 <HAL_CRG_Init+0x40>
 3004a62:	07d00593          	li	a1,125
 3004a66:	030127b7          	lui	a5,0x3012
 3004a6a:	be078513          	addi	a0,a5,-1056 # 3011be0 <g_crgIpMatch+0x348>
 3004a6e:	2b51                	jal	ra,3005002 <AssertErrorLog.trans.2>
 3004a70:	a001                	j	3004a70 <HAL_CRG_Init+0x3e>
    /* Check the validity of PLL-related parameters. */
    CRG_PARAM_CHECK_WITH_RET(IsCrgPllRefClkSelect(handle->pllRefClkSelect), BASE_STATUS_ERROR);
 3004a72:	fdc42783          	lw	a5,-36(s0)
 3004a76:	43dc                	lw	a5,4(a5)
 3004a78:	853e                	mv	a0,a5
 3004a7a:	3edd                	jal	ra,3004670 <IsCrgPllRefClkSelect>
 3004a7c:	87aa                	mv	a5,a0
 3004a7e:	0017c793          	xori	a5,a5,1
 3004a82:	9f81                	uxtb	a5
 3004a84:	cb91                	beqz	a5,3004a98 <HAL_CRG_Init+0x66>
 3004a86:	07f00593          	li	a1,127
 3004a8a:	030127b7          	lui	a5,0x3012
 3004a8e:	be078513          	addi	a0,a5,-1056 # 3011be0 <g_crgIpMatch+0x348>
 3004a92:	2b85                	jal	ra,3005002 <AssertErrorLog.trans.2>
 3004a94:	4785                	li	a5,1
 3004a96:	ac99                	j	3004cec <HAL_CRG_Init+0x2ba>
    CRG_PARAM_CHECK_WITH_RET(IsCrgPllPreDiv(handle->pllPreDiv), BASE_STATUS_ERROR);
 3004a98:	fdc42783          	lw	a5,-36(s0)
 3004a9c:	479c                	lw	a5,8(a5)
 3004a9e:	853e                	mv	a0,a5
 3004aa0:	3ef5                	jal	ra,300469c <IsCrgPllPreDiv>
 3004aa2:	87aa                	mv	a5,a0
 3004aa4:	0017c793          	xori	a5,a5,1
 3004aa8:	9f81                	uxtb	a5
 3004aaa:	cb91                	beqz	a5,3004abe <HAL_CRG_Init+0x8c>
 3004aac:	08000593          	li	a1,128
 3004ab0:	030127b7          	lui	a5,0x3012
 3004ab4:	be078513          	addi	a0,a5,-1056 # 3011be0 <g_crgIpMatch+0x348>
 3004ab8:	23a9                	jal	ra,3005002 <AssertErrorLog.trans.2>
 3004aba:	4785                	li	a5,1
 3004abc:	ac05                	j	3004cec <HAL_CRG_Init+0x2ba>
    CRG_PARAM_CHECK_WITH_RET(IsCrgPllFbDiv(handle->pllFbDiv), BASE_STATUS_ERROR);
 3004abe:	fdc42783          	lw	a5,-36(s0)
 3004ac2:	47dc                	lw	a5,12(a5)
 3004ac4:	853e                	mv	a0,a5
 3004ac6:	312d                	jal	ra,30046f0 <IsCrgPllFbDiv>
 3004ac8:	87aa                	mv	a5,a0
 3004aca:	0017c793          	xori	a5,a5,1
 3004ace:	9f81                	uxtb	a5
 3004ad0:	cb91                	beqz	a5,3004ae4 <HAL_CRG_Init+0xb2>
 3004ad2:	08100593          	li	a1,129
 3004ad6:	030127b7          	lui	a5,0x3012
 3004ada:	be078513          	addi	a0,a5,-1056 # 3011be0 <g_crgIpMatch+0x348>
 3004ade:	2315                	jal	ra,3005002 <AssertErrorLog.trans.2>
 3004ae0:	4785                	li	a5,1
 3004ae2:	a429                	j	3004cec <HAL_CRG_Init+0x2ba>
    CRG_PARAM_CHECK_WITH_RET(IsCrgPllPostDiv(handle->pllPostDiv), BASE_STATUS_ERROR);
 3004ae4:	fdc42783          	lw	a5,-36(s0)
 3004ae8:	4b9c                	lw	a5,16(a5)
 3004aea:	853e                	mv	a0,a5
 3004aec:	36f1                	jal	ra,30046b8 <IsCrgPllPostDiv>
 3004aee:	87aa                	mv	a5,a0
 3004af0:	0017c793          	xori	a5,a5,1
 3004af4:	9f81                	uxtb	a5
 3004af6:	cb91                	beqz	a5,3004b0a <HAL_CRG_Init+0xd8>
 3004af8:	08200593          	li	a1,130
 3004afc:	030127b7          	lui	a5,0x3012
 3004b00:	be078513          	addi	a0,a5,-1056 # 3011be0 <g_crgIpMatch+0x348>
 3004b04:	29fd                	jal	ra,3005002 <AssertErrorLog.trans.2>
 3004b06:	4785                	li	a5,1
 3004b08:	a2d5                	j	3004cec <HAL_CRG_Init+0x2ba>
    CRG_PARAM_CHECK_WITH_RET(IsCrgPllPostDiv2(handle->handleEx.pllPostDiv2), BASE_STATUS_ERROR);
 3004b0a:	fdc42783          	lw	a5,-36(s0)
 3004b0e:	4fdc                	lw	a5,28(a5)
 3004b10:	853e                	mv	a0,a5
 3004b12:	36c9                	jal	ra,30046d4 <IsCrgPllPostDiv2>
 3004b14:	87aa                	mv	a5,a0
 3004b16:	0017c793          	xori	a5,a5,1
 3004b1a:	9f81                	uxtb	a5
 3004b1c:	cb91                	beqz	a5,3004b30 <HAL_CRG_Init+0xfe>
 3004b1e:	08300593          	li	a1,131
 3004b22:	030127b7          	lui	a5,0x3012
 3004b26:	be078513          	addi	a0,a5,-1056 # 3011be0 <g_crgIpMatch+0x348>
 3004b2a:	29e1                	jal	ra,3005002 <AssertErrorLog.trans.2>
 3004b2c:	4785                	li	a5,1
 3004b2e:	aa7d                	j	3004cec <HAL_CRG_Init+0x2ba>
    /* Check the Clock Source and Frequency Divider of the 1 MHz Clock. */
    CRG_PARAM_CHECK_WITH_RET(IsCrg1MCkSel(handle->handleEx.clk1MSelect), BASE_STATUS_ERROR);
 3004b30:	fdc42783          	lw	a5,-36(s0)
 3004b34:	539c                	lw	a5,32(a5)
 3004b36:	853e                	mv	a0,a5
 3004b38:	3129                	jal	ra,3004742 <IsCrg1MCkSel>
 3004b3a:	87aa                	mv	a5,a0
 3004b3c:	0017c793          	xori	a5,a5,1
 3004b40:	9f81                	uxtb	a5
 3004b42:	cb91                	beqz	a5,3004b56 <HAL_CRG_Init+0x124>
 3004b44:	08500593          	li	a1,133
 3004b48:	030127b7          	lui	a5,0x3012
 3004b4c:	be078513          	addi	a0,a5,-1056 # 3011be0 <g_crgIpMatch+0x348>
 3004b50:	294d                	jal	ra,3005002 <AssertErrorLog.trans.2>
 3004b52:	4785                	li	a5,1
 3004b54:	aa61                	j	3004cec <HAL_CRG_Init+0x2ba>
    CRG_PARAM_CHECK_WITH_RET(IsCrg1MCkDiv(handle->handleEx.clk1MDiv), BASE_STATUS_ERROR);
 3004b56:	fdc42783          	lw	a5,-36(s0)
 3004b5a:	53dc                	lw	a5,36(a5)
 3004b5c:	853e                	mv	a0,a5
 3004b5e:	3901                	jal	ra,300476e <IsCrg1MCkDiv>
 3004b60:	87aa                	mv	a5,a0
 3004b62:	0017c793          	xori	a5,a5,1
 3004b66:	9f81                	uxtb	a5
 3004b68:	cb91                	beqz	a5,3004b7c <HAL_CRG_Init+0x14a>
 3004b6a:	08600593          	li	a1,134
 3004b6e:	030127b7          	lui	a5,0x3012
 3004b72:	be078513          	addi	a0,a5,-1056 # 3011be0 <g_crgIpMatch+0x348>
 3004b76:	2171                	jal	ra,3005002 <AssertErrorLog.trans.2>
 3004b78:	4785                	li	a5,1
 3004b7a:	aa8d                	j	3004cec <HAL_CRG_Init+0x2ba>
    CRG_PARAM_CHECK_WITH_RET(IsCrgCoreCkSel(handle->coreClkSelect), BASE_STATUS_ERROR);
 3004b7c:	fdc42783          	lw	a5,-36(s0)
 3004b80:	4f9c                	lw	a5,24(a5)
 3004b82:	853e                	mv	a0,a5
 3004b84:	3661                	jal	ra,300470c <IsCrgCoreCkSel>
 3004b86:	87aa                	mv	a5,a0
 3004b88:	0017c793          	xori	a5,a5,1
 3004b8c:	9f81                	uxtb	a5
 3004b8e:	cb91                	beqz	a5,3004ba2 <HAL_CRG_Init+0x170>
 3004b90:	08700593          	li	a1,135
 3004b94:	030127b7          	lui	a5,0x3012
 3004b98:	be078513          	addi	a0,a5,-1056 # 3011be0 <g_crgIpMatch+0x348>
 3004b9c:	219d                	jal	ra,3005002 <AssertErrorLog.trans.2>
 3004b9e:	4785                	li	a5,1
 3004ba0:	a2b1                	j	3004cec <HAL_CRG_Init+0x2ba>

    *(unsigned int *)CRG_HOSC_CTRL2_ADDR = 0x306E; /* Optimized HOSC temperature drift performance parameter. */
 3004ba2:	100017b7          	lui	a5,0x10001
 3004ba6:	f0478793          	addi	a5,a5,-252 # 10000f04 <RAM_END+0xbff8f04>
 3004baa:	670d                	lui	a4,0x3
 3004bac:	06e70713          	addi	a4,a4,110 # 306e <STACK_SIZE+0x46e>
 3004bb0:	c398                	sw	a4,0(a5)

    CRG_RegStruct *reg = handle->baseAddress;
 3004bb2:	fdc42783          	lw	a5,-36(s0)
 3004bb6:	439c                	lw	a5,0(a5)
 3004bb8:	fef42623          	sw	a5,-20(s0)
    g_crgBaseAddr = (void *)reg;
 3004bbc:	fec42703          	lw	a4,-20(s0)
 3004bc0:	c8e1a923          	sw	a4,-878(gp) # 400059c <g_crgBaseAddr>
    /* Check the validity of the PLL parameter configuration. */
    if (CRG_IsValidPllConfig(handle) != BASE_STATUS_OK) {
 3004bc4:	fdc42503          	lw	a0,-36(s0)
 3004bc8:	031000ef          	jal	ra,30053f8 <CRG_IsValidPllConfig>
 3004bcc:	87aa                	mv	a5,a0
 3004bce:	c399                	beqz	a5,3004bd4 <HAL_CRG_Init+0x1a2>
        return BASE_STATUS_ERROR;
 3004bd0:	4785                	li	a5,1
 3004bd2:	aa29                	j	3004cec <HAL_CRG_Init+0x2ba>
    }
    /* Disable the write protection function of the CRG register. */
    DCL_SYSCTRL_CrgWriteProtectionDisable();
 3004bd4:	34a9                	jal	ra,300461e <DCL_SYSCTRL_CrgWriteProtectionDisable>

    reg->PERI_CRG0.BIT.pll_ref_cksel   = handle->pllRefClkSelect;
 3004bd6:	fdc42783          	lw	a5,-36(s0)
 3004bda:	43dc                	lw	a5,4(a5)
 3004bdc:	8b85                	andi	a5,a5,1
 3004bde:	0ff7f693          	andi	a3,a5,255
 3004be2:	fec42703          	lw	a4,-20(s0)
 3004be6:	431c                	lw	a5,0(a4)
 3004be8:	8a85                	andi	a3,a3,1
 3004bea:	9bf9                	andi	a5,a5,-2
 3004bec:	8fd5                	or	a5,a5,a3
 3004bee:	c31c                	sw	a5,0(a4)
    reg->PERI_CRG1.BIT.pll_prediv      = handle->pllPreDiv;
 3004bf0:	fdc42783          	lw	a5,-36(s0)
 3004bf4:	479c                	lw	a5,8(a5)
 3004bf6:	8bbd                	andi	a5,a5,15
 3004bf8:	0ff7f693          	andi	a3,a5,255
 3004bfc:	fec42703          	lw	a4,-20(s0)
 3004c00:	435c                	lw	a5,4(a4)
 3004c02:	8abd                	andi	a3,a3,15
 3004c04:	9bc1                	andi	a5,a5,-16
 3004c06:	8fd5                	or	a5,a5,a3
 3004c08:	c35c                	sw	a5,4(a4)
    reg->PERI_CRG2.BIT.pll_fbdiv       = handle->pllFbDiv;
 3004c0a:	fdc42783          	lw	a5,-36(s0)
 3004c0e:	47dc                	lw	a5,12(a5)
 3004c10:	0ff7f693          	andi	a3,a5,255
 3004c14:	fec42703          	lw	a4,-20(s0)
 3004c18:	471c                	lw	a5,8(a4)
 3004c1a:	0ff6f693          	andi	a3,a3,255
 3004c1e:	f007f793          	andi	a5,a5,-256
 3004c22:	8fd5                	or	a5,a5,a3
 3004c24:	c71c                	sw	a5,8(a4)
    reg->PERI_CRG3.BIT.pll_postdiv1    = handle->pllPostDiv;
 3004c26:	fdc42783          	lw	a5,-36(s0)
 3004c2a:	4b9c                	lw	a5,16(a5)
 3004c2c:	8bbd                	andi	a5,a5,15
 3004c2e:	0ff7f693          	andi	a3,a5,255
 3004c32:	fec42703          	lw	a4,-20(s0)
 3004c36:	475c                	lw	a5,12(a4)
 3004c38:	8abd                	andi	a3,a3,15
 3004c3a:	9bc1                	andi	a5,a5,-16
 3004c3c:	8fd5                	or	a5,a5,a3
 3004c3e:	c75c                	sw	a5,12(a4)
    reg->PERI_CRG3.BIT.pll_postdiv2    = handle->handleEx.pllPostDiv2;
 3004c40:	fdc42783          	lw	a5,-36(s0)
 3004c44:	4fdc                	lw	a5,28(a5)
 3004c46:	8bbd                	andi	a5,a5,15
 3004c48:	0ff7f693          	andi	a3,a5,255
 3004c4c:	fec42703          	lw	a4,-20(s0)
 3004c50:	475c                	lw	a5,12(a4)
 3004c52:	8abd                	andi	a3,a3,15
 3004c54:	0692                	slli	a3,a3,0x4
 3004c56:	f0f7f793          	andi	a5,a5,-241
 3004c5a:	8fd5                	or	a5,a5,a3
 3004c5c:	c75c                	sw	a5,12(a4)
    reg->PERI_CRG4.BIT.pll_pd          = BASE_CFG_UNSET;
 3004c5e:	fec42703          	lw	a4,-20(s0)
 3004c62:	4b1c                	lw	a5,16(a4)
 3004c64:	9bf9                	andi	a5,a5,-2
 3004c66:	cb1c                	sw	a5,16(a4)

    while (reg->PERI_CRG7.BIT.pll_lock != BASE_CFG_SET) {
 3004c68:	0001                	nop
 3004c6a:	fec42783          	lw	a5,-20(s0)
 3004c6e:	4fdc                	lw	a5,28(a5)
 3004c70:	8b85                	andi	a5,a5,1
 3004c72:	0ff7f713          	andi	a4,a5,255
 3004c76:	4785                	li	a5,1
 3004c78:	fef719e3          	bne	a4,a5,3004c6a <HAL_CRG_Init+0x238>
        ;  /* Wait for PLL to lock */
    }

    DCL_SYSCTRL_CrgWriteProtectionEnable();
 3004c7c:	32e9                	jal	ra,3004646 <DCL_SYSCTRL_CrgWriteProtectionEnable>
    /* Check the 1MHz clock parameter configuration. */
    if (CRG_IsValid1MHzConfig(handle) != BASE_STATUS_OK) {
 3004c7e:	fdc42503          	lw	a0,-36(s0)
 3004c82:	039000ef          	jal	ra,30054ba <CRG_IsValid1MHzConfig>
 3004c86:	87aa                	mv	a5,a0
 3004c88:	c399                	beqz	a5,3004c8e <HAL_CRG_Init+0x25c>
        return BASE_STATUS_ERROR;
 3004c8a:	4785                	li	a5,1
 3004c8c:	a085                	j	3004cec <HAL_CRG_Init+0x2ba>
    }
    while (reg->HOSC_LOCK.BIT.hosc_lock != BASE_CFG_SET) {
 3004c8e:	0001                	nop
 3004c90:	fec42703          	lw	a4,-20(s0)
 3004c94:	6785                	lui	a5,0x1
 3004c96:	97ba                	add	a5,a5,a4
 3004c98:	f107a783          	lw	a5,-240(a5) # f10 <prithd+0x312>
 3004c9c:	8b85                	andi	a5,a5,1
 3004c9e:	0ff7f713          	andi	a4,a5,255
 3004ca2:	4785                	li	a5,1
 3004ca4:	fef716e3          	bne	a4,a5,3004c90 <HAL_CRG_Init+0x25e>
        ; /* Wait for HOSC to lock */
    }
    /* Set the Clock Source and Frequency Divider of the 1 MHz Clock. */
    reg->PERI_CRG67.BIT.clk_1m_div = handle->handleEx.clk1MDiv;
 3004ca8:	fdc42783          	lw	a5,-36(s0)
 3004cac:	53dc                	lw	a5,36(a5)
 3004cae:	03f7f793          	andi	a5,a5,63
 3004cb2:	0ff7f693          	andi	a3,a5,255
 3004cb6:	fec42703          	lw	a4,-20(s0)
 3004cba:	10c72783          	lw	a5,268(a4)
 3004cbe:	03f6f693          	andi	a3,a3,63
 3004cc2:	fc07f793          	andi	a5,a5,-64
 3004cc6:	8fd5                	or	a5,a5,a3
 3004cc8:	10f72623          	sw	a5,268(a4)
    reg->PERI_CRG66.BIT.clk_1m_ini_cksel = handle->handleEx.clk1MSelect;
 3004ccc:	fdc42783          	lw	a5,-36(s0)
 3004cd0:	539c                	lw	a5,32(a5)
 3004cd2:	8b85                	andi	a5,a5,1
 3004cd4:	0ff7f693          	andi	a3,a5,255
 3004cd8:	fec42703          	lw	a4,-20(s0)
 3004cdc:	10872783          	lw	a5,264(a4)
 3004ce0:	8a85                	andi	a3,a3,1
 3004ce2:	9bf9                	andi	a5,a5,-2
 3004ce4:	8fd5                	or	a5,a5,a3
 3004ce6:	10f72423          	sw	a5,264(a4)
    return BASE_STATUS_OK;
 3004cea:	4781                	li	a5,0
}
 3004cec:	853e                	mv	a0,a5
 3004cee:	50b2                	lw	ra,44(sp)
 3004cf0:	5422                	lw	s0,40(sp)
 3004cf2:	6145                	addi	sp,sp,48
 3004cf4:	8082                	ret

03004cf6 <HAL_CRG_SetCoreClockSelect>:
  * @param handle CRG Handle
  * @retval BASE_STATUS_OK  Success
  * @retval BASE_STATUS_ERROR Paramter check fail
  */
BASE_StatusType HAL_CRG_SetCoreClockSelect(CRG_Handle *handle)
{
 3004cf6:	7179                	addi	sp,sp,-48
 3004cf8:	d606                	sw	ra,44(sp)
 3004cfa:	d422                	sw	s0,40(sp)
 3004cfc:	1800                	addi	s0,sp,48
 3004cfe:	fca42e23          	sw	a0,-36(s0)
    CRG_ASSERT_PARAM(handle != 0);
 3004d02:	fdc42783          	lw	a5,-36(s0)
 3004d06:	eb89                	bnez	a5,3004d18 <HAL_CRG_SetCoreClockSelect+0x22>
 3004d08:	10700593          	li	a1,263
 3004d0c:	030127b7          	lui	a5,0x3012
 3004d10:	be078513          	addi	a0,a5,-1056 # 3011be0 <g_crgIpMatch+0x348>
 3004d14:	24fd                	jal	ra,3005002 <AssertErrorLog.trans.2>
 3004d16:	a001                	j	3004d16 <HAL_CRG_SetCoreClockSelect+0x20>
    CRG_ASSERT_PARAM(IsCRGInstance(handle->baseAddress));
 3004d18:	fdc42783          	lw	a5,-36(s0)
 3004d1c:	4398                	lw	a4,0(a5)
 3004d1e:	100007b7          	lui	a5,0x10000
 3004d22:	00f70a63          	beq	a4,a5,3004d36 <HAL_CRG_SetCoreClockSelect+0x40>
 3004d26:	10800593          	li	a1,264
 3004d2a:	030127b7          	lui	a5,0x3012
 3004d2e:	be078513          	addi	a0,a5,-1056 # 3011be0 <g_crgIpMatch+0x348>
 3004d32:	2cc1                	jal	ra,3005002 <AssertErrorLog.trans.2>
 3004d34:	a001                	j	3004d34 <HAL_CRG_SetCoreClockSelect+0x3e>
    CRG_PARAM_CHECK_WITH_RET(IsCrgCoreCkSel(handle->coreClkSelect), BASE_STATUS_ERROR);
 3004d36:	fdc42783          	lw	a5,-36(s0)
 3004d3a:	4f9c                	lw	a5,24(a5)
 3004d3c:	853e                	mv	a0,a5
 3004d3e:	32f9                	jal	ra,300470c <IsCrgCoreCkSel>
 3004d40:	87aa                	mv	a5,a0
 3004d42:	0017c793          	xori	a5,a5,1
 3004d46:	9f81                	uxtb	a5
 3004d48:	cb91                	beqz	a5,3004d5c <HAL_CRG_SetCoreClockSelect+0x66>
 3004d4a:	10900593          	li	a1,265
 3004d4e:	030127b7          	lui	a5,0x3012
 3004d52:	be078513          	addi	a0,a5,-1056 # 3011be0 <g_crgIpMatch+0x348>
 3004d56:	2475                	jal	ra,3005002 <AssertErrorLog.trans.2>
 3004d58:	4785                	li	a5,1
 3004d5a:	a005                	j	3004d7a <HAL_CRG_SetCoreClockSelect+0x84>

    CRG_RegStruct *reg = handle->baseAddress;
 3004d5c:	fdc42783          	lw	a5,-36(s0)
 3004d60:	439c                	lw	a5,0(a5)
 3004d62:	fef42623          	sw	a5,-20(s0)
   /* The write protection of the CRG register needs to be disabled. */
    DCL_SYSCTRL_CrgWriteProtectionDisable();
 3004d66:	3865                	jal	ra,300461e <DCL_SYSCTRL_CrgWriteProtectionDisable>
    DCL_CRG_SetCoreClkSel(reg, handle->coreClkSelect);
 3004d68:	fdc42783          	lw	a5,-36(s0)
 3004d6c:	4f9c                	lw	a5,24(a5)
 3004d6e:	85be                	mv	a1,a5
 3004d70:	fec42503          	lw	a0,-20(s0)
 3004d74:	31b9                	jal	ra,30049c2 <DCL_CRG_SetCoreClkSel>
    DCL_SYSCTRL_CrgWriteProtectionEnable();
 3004d76:	38c1                	jal	ra,3004646 <DCL_SYSCTRL_CrgWriteProtectionEnable>

    return BASE_STATUS_OK;
 3004d78:	4781                	li	a5,0
}
 3004d7a:	853e                	mv	a0,a5
 3004d7c:	50b2                	lw	ra,44(sp)
 3004d7e:	5422                	lw	s0,40(sp)
 3004d80:	6145                	addi	sp,sp,48
 3004d82:	8082                	ret

03004d84 <CRG_GetVcoFreq>:
 * @brief Get PLL Clock Frequence
 * @param None
 * @retval unsigned int PLL clock frequency
 */
static inline unsigned int CRG_GetVcoFreq(void)
{
 3004d84:	1101                	addi	sp,sp,-32
 3004d86:	ce06                	sw	ra,28(sp)
 3004d88:	cc22                	sw	s0,24(sp)
 3004d8a:	1000                	addi	s0,sp,32
    unsigned int freq;
    unsigned int regFbdiv;
    CRG_RegStruct *crg = g_crgBaseAddr;
 3004d8c:	c921a783          	lw	a5,-878(gp) # 400059c <g_crgBaseAddr>
 3004d90:	fef42623          	sw	a5,-20(s0)

    CRG_ASSERT_PARAM(IsCRGInstance(crg));
 3004d94:	fec42703          	lw	a4,-20(s0)
 3004d98:	100007b7          	lui	a5,0x10000
 3004d9c:	00f70a63          	beq	a4,a5,3004db0 <CRG_GetVcoFreq+0x2c>
 3004da0:	11f00593          	li	a1,287
 3004da4:	030127b7          	lui	a5,0x3012
 3004da8:	be078513          	addi	a0,a5,-1056 # 3011be0 <g_crgIpMatch+0x348>
 3004dac:	2c99                	jal	ra,3005002 <AssertErrorLog.trans.2>
 3004dae:	a001                	j	3004dae <CRG_GetVcoFreq+0x2a>
    CRG_ASSERT_PARAM((XTRAIL_FREQ <= 30000000U)); /* The maximum of the external clock source is 30000000U. */

    freq = CRG_GetPllRefIni(crg->PERI_CRG0.BIT.pll_ref_cksel);
 3004db0:	fec42783          	lw	a5,-20(s0)
 3004db4:	439c                	lw	a5,0(a5)
 3004db6:	8b85                	andi	a5,a5,1
 3004db8:	9f81                	uxtb	a5
 3004dba:	853e                	mv	a0,a5
 3004dbc:	750000ef          	jal	ra,300550c <CRG_GetPllRefIni>
 3004dc0:	fea42423          	sw	a0,-24(s0)
    freq /= CRG_GetPreDivValue(crg->PERI_CRG1.BIT.pll_prediv);
 3004dc4:	fec42783          	lw	a5,-20(s0)
 3004dc8:	43dc                	lw	a5,4(a5)
 3004dca:	8bbd                	andi	a5,a5,15
 3004dcc:	9f81                	uxtb	a5
 3004dce:	853e                	mv	a0,a5
 3004dd0:	766000ef          	jal	ra,3005536 <CRG_GetPreDivValue>
 3004dd4:	872a                	mv	a4,a0
 3004dd6:	fe842783          	lw	a5,-24(s0)
 3004dda:	02e7d7b3          	divu	a5,a5,a4
 3004dde:	fef42423          	sw	a5,-24(s0)
    regFbdiv = CRG_GetPllFbDivValue(crg->PERI_CRG2.BIT.pll_fbdiv); /* Get the value of the fbdiv register. */
 3004de2:	fec42783          	lw	a5,-20(s0)
 3004de6:	479c                	lw	a5,8(a5)
 3004de8:	9f81                	uxtb	a5
 3004dea:	853e                	mv	a0,a5
 3004dec:	778000ef          	jal	ra,3005564 <CRG_GetPllFbDivValue>
 3004df0:	fea42223          	sw	a0,-28(s0)
    freq *= (regFbdiv >= 0x06) ? regFbdiv : 0x06; /* 0x0-0x6: divided by 0x6 */
 3004df4:	fe442783          	lw	a5,-28(s0)
 3004df8:	4719                	li	a4,6
 3004dfa:	00e7f363          	bgeu	a5,a4,3004e00 <CRG_GetVcoFreq+0x7c>
 3004dfe:	4799                	li	a5,6
 3004e00:	fe842703          	lw	a4,-24(s0)
 3004e04:	02f707b3          	mul	a5,a4,a5
 3004e08:	fef42423          	sw	a5,-24(s0)
    return freq;
 3004e0c:	fe842783          	lw	a5,-24(s0)
}
 3004e10:	853e                	mv	a0,a5
 3004e12:	40f2                	lw	ra,28(sp)
 3004e14:	4462                	lw	s0,24(sp)
 3004e16:	6105                	addi	sp,sp,32
 3004e18:	8082                	ret

03004e1a <HAL_CRG_GetPllFreq>:
 * @brief Get PLL Clock Frequence
 * @param None
 * @retval unsigned int PLL clock frequency
 */
unsigned int HAL_CRG_GetPllFreq(void)
{
 3004e1a:	1101                	addi	sp,sp,-32
 3004e1c:	ce06                	sw	ra,28(sp)
 3004e1e:	cc22                	sw	s0,24(sp)
 3004e20:	1000                	addi	s0,sp,32
    unsigned int freq;
    unsigned int pllPostDivValue;
    CRG_RegStruct *crg = g_crgBaseAddr;
 3004e22:	c921a783          	lw	a5,-878(gp) # 400059c <g_crgBaseAddr>
 3004e26:	fef42423          	sw	a5,-24(s0)

    CRG_ASSERT_PARAM(IsCRGInstance(crg));
 3004e2a:	fe842703          	lw	a4,-24(s0)
 3004e2e:	100007b7          	lui	a5,0x10000
 3004e32:	00f70a63          	beq	a4,a5,3004e46 <HAL_CRG_GetPllFreq+0x2c>
 3004e36:	13400593          	li	a1,308
 3004e3a:	030127b7          	lui	a5,0x3012
 3004e3e:	be078513          	addi	a0,a5,-1056 # 3011be0 <g_crgIpMatch+0x348>
 3004e42:	22c1                	jal	ra,3005002 <AssertErrorLog.trans.2>
 3004e44:	a001                	j	3004e44 <HAL_CRG_GetPllFreq+0x2a>
    freq = CRG_GetVcoFreq();
 3004e46:	3f3d                	jal	ra,3004d84 <CRG_GetVcoFreq>
 3004e48:	fea42623          	sw	a0,-20(s0)
    pllPostDivValue = CRG_GetPllPostDivValue((CRG_PllPostDiv)crg->PERI_CRG3.BIT.pll_postdiv1);
 3004e4c:	fe842783          	lw	a5,-24(s0)
 3004e50:	47dc                	lw	a5,12(a5)
 3004e52:	8bbd                	andi	a5,a5,15
 3004e54:	9f81                	uxtb	a5
 3004e56:	853e                	mv	a0,a5
 3004e58:	74e000ef          	jal	ra,30055a6 <CRG_GetPllPostDivValue>
 3004e5c:	fea42223          	sw	a0,-28(s0)
    /* Calculate the PLL output clock frequency based on the VCO clock frequency and post-division coefficient. */
    if (pllPostDivValue != 0) {
 3004e60:	fe442783          	lw	a5,-28(s0)
 3004e64:	cb89                	beqz	a5,3004e76 <HAL_CRG_GetPllFreq+0x5c>
        freq /= pllPostDivValue;
 3004e66:	fec42703          	lw	a4,-20(s0)
 3004e6a:	fe442783          	lw	a5,-28(s0)
 3004e6e:	02f757b3          	divu	a5,a4,a5
 3004e72:	fef42623          	sw	a5,-20(s0)
    }
    return freq;
 3004e76:	fec42783          	lw	a5,-20(s0)
}
 3004e7a:	853e                	mv	a0,a5
 3004e7c:	40f2                	lw	ra,28(sp)
 3004e7e:	4462                	lw	s0,24(sp)
 3004e80:	6105                	addi	sp,sp,32
 3004e82:	8082                	ret

03004e84 <HAL_CRG_GetCoreClkFreq>:
 * @brief Get Core Clock Frequence
 * @param None
 * @retval unsigned int  Core clock frequency
 */
unsigned int HAL_CRG_GetCoreClkFreq(void)
{
 3004e84:	1101                	addi	sp,sp,-32
 3004e86:	ce06                	sw	ra,28(sp)
 3004e88:	cc22                	sw	s0,24(sp)
 3004e8a:	1000                	addi	s0,sp,32
    unsigned int freq;
    unsigned int coreClkSelect;
    CRG_RegStruct *crg = g_crgBaseAddr;
 3004e8c:	c921a783          	lw	a5,-878(gp) # 400059c <g_crgBaseAddr>
 3004e90:	fef42423          	sw	a5,-24(s0)

    CRG_ASSERT_PARAM(IsCRGInstance(crg));
 3004e94:	fe842703          	lw	a4,-24(s0)
 3004e98:	100007b7          	lui	a5,0x10000
 3004e9c:	00f70a63          	beq	a4,a5,3004eb0 <HAL_CRG_GetCoreClkFreq+0x2c>
 3004ea0:	14900593          	li	a1,329
 3004ea4:	030127b7          	lui	a5,0x3012
 3004ea8:	be078513          	addi	a0,a5,-1056 # 3011be0 <g_crgIpMatch+0x348>
 3004eac:	2a99                	jal	ra,3005002 <AssertErrorLog.trans.2>
 3004eae:	a001                	j	3004eae <HAL_CRG_GetCoreClkFreq+0x2a>
    coreClkSelect = crg->PERI_CRG64.BIT.clk_pst1_sw_sel;
 3004eb0:	fe842783          	lw	a5,-24(s0)
 3004eb4:	1007a783          	lw	a5,256(a5)
 3004eb8:	8b8d                	andi	a5,a5,3
 3004eba:	9f81                	uxtb	a5
 3004ebc:	fef42223          	sw	a5,-28(s0)
    switch (coreClkSelect) {
 3004ec0:	fe442783          	lw	a5,-28(s0)
 3004ec4:	4705                	li	a4,1
 3004ec6:	02e78063          	beq	a5,a4,3004ee6 <HAL_CRG_GetCoreClkFreq+0x62>
 3004eca:	4705                	li	a4,1
 3004ecc:	00e7e663          	bltu	a5,a4,3004ed8 <HAL_CRG_GetCoreClkFreq+0x54>
 3004ed0:	4709                	li	a4,2
 3004ed2:	02e78163          	beq	a5,a4,3004ef4 <HAL_CRG_GetCoreClkFreq+0x70>
 3004ed6:	a01d                	j	3004efc <HAL_CRG_GetCoreClkFreq+0x78>
        case CRG_CORE_CLK_SELECT_HOSC: /* The clock source is an internal high-speed clock. */
            freq = HOSC_FREQ;
 3004ed8:	017d87b7          	lui	a5,0x17d8
 3004edc:	84078793          	addi	a5,a5,-1984 # 17d7840 <FLASH_SIZE+0x17b7844>
 3004ee0:	fef42623          	sw	a5,-20(s0)
            break;
 3004ee4:	a015                	j	3004f08 <HAL_CRG_GetCoreClkFreq+0x84>

        case CRG_CORE_CLK_SELECT_TCXO: /* The clock source is the external crystal oscillator clock. */
            freq = XTRAIL_FREQ;
 3004ee6:	01c9c7b7          	lui	a5,0x1c9c
 3004eea:	38078793          	addi	a5,a5,896 # 1c9c380 <FLASH_SIZE+0x1c7c384>
 3004eee:	fef42623          	sw	a5,-20(s0)
            break;
 3004ef2:	a819                	j	3004f08 <HAL_CRG_GetCoreClkFreq+0x84>

        case CRG_CORE_CLK_SELECT_PLL: /* The clock source is the PLL. */
            freq = HAL_CRG_GetPllFreq();
 3004ef4:	371d                	jal	ra,3004e1a <HAL_CRG_GetPllFreq>
 3004ef6:	fea42623          	sw	a0,-20(s0)
            break;
 3004efa:	a039                	j	3004f08 <HAL_CRG_GetCoreClkFreq+0x84>

        default:
            freq = LOSC_FREQ;
 3004efc:	67a1                	lui	a5,0x8
 3004efe:	d0078793          	addi	a5,a5,-768 # 7d00 <RAM_SIZE+0x2d00>
 3004f02:	fef42623          	sw	a5,-20(s0)
            break;
 3004f06:	0001                	nop
    }
    return freq;
 3004f08:	fec42783          	lw	a5,-20(s0)
}
 3004f0c:	853e                	mv	a0,a5
 3004f0e:	40f2                	lw	ra,28(sp)
 3004f10:	4462                	lw	s0,24(sp)
 3004f12:	6105                	addi	sp,sp,32
 3004f14:	8082                	ret

03004f16 <HAL_CRG_GetIpFreq>:
 * @brief Get Clock Frequence
 * @param handle CRG Handle
 * @retval Frequece of IP
 */
unsigned int HAL_CRG_GetIpFreq(const void *baseAddress)
{
 3004f16:	7179                	addi	sp,sp,-48
 3004f18:	d606                	sw	ra,44(sp)
 3004f1a:	d422                	sw	s0,40(sp)
 3004f1c:	1800                	addi	s0,sp,48
 3004f1e:	fca42e23          	sw	a0,-36(s0)
    CRG_ASSERT_PARAM(baseAddress != NULL);
 3004f22:	fdc42783          	lw	a5,-36(s0)
 3004f26:	eb89                	bnez	a5,3004f38 <HAL_CRG_GetIpFreq+0x22>
 3004f28:	16600593          	li	a1,358
 3004f2c:	030127b7          	lui	a5,0x3012
 3004f30:	be078513          	addi	a0,a5,-1056 # 3011be0 <g_crgIpMatch+0x348>
 3004f34:	20f9                	jal	ra,3005002 <AssertErrorLog.trans.2>
 3004f36:	a001                	j	3004f36 <HAL_CRG_GetIpFreq+0x20>
    CRG_ASSERT_PARAM(IsCRGInstance(g_crgBaseAddr));
 3004f38:	c921a703          	lw	a4,-878(gp) # 400059c <g_crgBaseAddr>
 3004f3c:	100007b7          	lui	a5,0x10000
 3004f40:	00f70a63          	beq	a4,a5,3004f54 <HAL_CRG_GetIpFreq+0x3e>
 3004f44:	16700593          	li	a1,359
 3004f48:	030127b7          	lui	a5,0x3012
 3004f4c:	be078513          	addi	a0,a5,-1056 # 3011be0 <g_crgIpMatch+0x348>
 3004f50:	284d                	jal	ra,3005002 <AssertErrorLog.trans.2>
 3004f52:	a001                	j	3004f52 <HAL_CRG_GetIpFreq+0x3c>
#ifdef FPGA
    /* Use this function to obtain the clock frequency during the FPGA phase. */
    return CHIP_GetIpFreqHz(baseAddress);
#else
    unsigned int hclk = HAL_CRG_GetCoreClkFreq();
 3004f54:	3f05                	jal	ra,3004e84 <HAL_CRG_GetCoreClkFreq>
 3004f56:	fea42423          	sw	a0,-24(s0)
    unsigned int freq = LOSC_FREQ;
 3004f5a:	67a1                	lui	a5,0x8
 3004f5c:	d0078793          	addi	a5,a5,-768 # 7d00 <RAM_SIZE+0x2d00>
 3004f60:	fef42623          	sw	a5,-20(s0)
    unsigned int coreClkFreq;
    /* Get the CRG type of the target IP. */
    CHIP_CrgIpMatchInfo *p = GetCrgIpMatchInfo(baseAddress);
 3004f64:	fdc42503          	lw	a0,-36(s0)
 3004f68:	2cd9                	jal	ra,300523e <GetCrgIpMatchInfo.trans.39>
 3004f6a:	fea42223          	sw	a0,-28(s0)
    if (p == NULL) {
 3004f6e:	fe442783          	lw	a5,-28(s0)
 3004f72:	e781                	bnez	a5,3004f7a <HAL_CRG_GetIpFreq+0x64>
        return freq;
 3004f74:	fec42783          	lw	a5,-20(s0)
 3004f78:	a041                	j	3004ff8 <HAL_CRG_GetIpFreq+0xe2>
    }
    switch (p->type) {
 3004f7a:	fe442783          	lw	a5,-28(s0)
 3004f7e:	43dc                	lw	a5,4(a5)
 3004f80:	4719                	li	a4,6
 3004f82:	06f76063          	bltu	a4,a5,3004fe2 <HAL_CRG_GetIpFreq+0xcc>
 3004f86:	00279713          	slli	a4,a5,0x2
 3004f8a:	030127b7          	lui	a5,0x3012
 3004f8e:	c1c78793          	addi	a5,a5,-996 # 3011c1c <g_crgIpMatch+0x384>
 3004f92:	97ba                	add	a5,a5,a4
 3004f94:	439c                	lw	a5,0(a5)
 3004f96:	8782                	jr	a5
        case CRG_IP_WITH_CLK_SEL:
            /* Get the clock frequency of the module with the frequency division function. */
            freq = CRG_GetLsIpFreq(p, hclk);
 3004f98:	fe842583          	lw	a1,-24(s0)
 3004f9c:	fe442503          	lw	a0,-28(s0)
 3004fa0:	244d                	jal	ra,3005242 <CRG_GetLsIpFreq>
 3004fa2:	fea42623          	sw	a0,-20(s0)
            break;
 3004fa6:	a83d                	j	3004fe4 <HAL_CRG_GetIpFreq+0xce>

        case CRG_IP_NONE_CLK_SEL:
        case CRG_IP_EFC:
        case CRG_IP_ANA:
            freq = hclk; /* Returns the internal high speed clock frequency. */
 3004fa8:	fe842783          	lw	a5,-24(s0)
 3004fac:	fef42623          	sw	a5,-20(s0)
            break;
 3004fb0:	a815                	j	3004fe4 <HAL_CRG_GetIpFreq+0xce>

        case CRG_IP_CAN:
            freq = CRG_GetPllRefIni(g_crgBaseAddr->PERI_CRG0.BIT.pll_ref_cksel);
 3004fb2:	c921a783          	lw	a5,-878(gp) # 400059c <g_crgBaseAddr>
 3004fb6:	439c                	lw	a5,0(a5)
 3004fb8:	8b85                	andi	a5,a5,1
 3004fba:	9f81                	uxtb	a5
 3004fbc:	853e                	mv	a0,a5
 3004fbe:	23b9                	jal	ra,300550c <CRG_GetPllRefIni>
 3004fc0:	fea42623          	sw	a0,-20(s0)
            break;
 3004fc4:	a005                	j	3004fe4 <HAL_CRG_GetIpFreq+0xce>

        case CRG_IP_ADC:
            /* Get core clock frequence for calculating the ADC clock frequency. */
            coreClkFreq = HAL_CRG_GetCoreClkFreq();
 3004fc6:	3d7d                	jal	ra,3004e84 <HAL_CRG_GetCoreClkFreq>
 3004fc8:	fea42023          	sw	a0,-32(s0)
            freq = CRG_GetAdcIpFreq(p, CRG_GetVcoFreq(), coreClkFreq);
 3004fcc:	3b65                	jal	ra,3004d84 <CRG_GetVcoFreq>
 3004fce:	87aa                	mv	a5,a0
 3004fd0:	fe042603          	lw	a2,-32(s0)
 3004fd4:	85be                	mv	a1,a5
 3004fd6:	fe442503          	lw	a0,-28(s0)
 3004fda:	2601                	jal	ra,30052da <CRG_GetAdcIpFreq>
 3004fdc:	fea42623          	sw	a0,-20(s0)
            break;
 3004fe0:	a011                	j	3004fe4 <HAL_CRG_GetIpFreq+0xce>

        case CRG_IP_IWDG: /* The IWDG clock frequency is an internal low-speed clock. */
        default:
            break;
 3004fe2:	0001                	nop
    }
    if (freq == 0) {
 3004fe4:	fec42783          	lw	a5,-20(s0)
 3004fe8:	e791                	bnez	a5,3004ff4 <HAL_CRG_GetIpFreq+0xde>
        freq = LOSC_FREQ;
 3004fea:	67a1                	lui	a5,0x8
 3004fec:	d0078793          	addi	a5,a5,-768 # 7d00 <RAM_SIZE+0x2d00>
 3004ff0:	fef42623          	sw	a5,-20(s0)
    }
    return freq;
 3004ff4:	fec42783          	lw	a5,-20(s0)
#endif
}
 3004ff8:	853e                	mv	a0,a5
 3004ffa:	50b2                	lw	ra,44(sp)
 3004ffc:	5422                	lw	s0,40(sp)
 3004ffe:	6145                	addi	sp,sp,48
 3005000:	8082                	ret

03005002 <AssertErrorLog.trans.2>:
 3005002:	d51fd06f          	j	3002d52 <AssertErrorLog>

03005006 <HAL_CRG_IpEnableSet>:
  * @param enable enable mask
  * @retval BASE_STATUS_ERROR       Can't find the Match or operation is not support
  * @retval BASE_STATUS_OK          Operation Success
  */
BASE_StatusType HAL_CRG_IpEnableSet(const void *baseAddress, unsigned int enable)
{
 3005006:	7179                	addi	sp,sp,-48
 3005008:	d606                	sw	ra,44(sp)
 300500a:	d422                	sw	s0,40(sp)
 300500c:	1800                	addi	s0,sp,48
 300500e:	fca42e23          	sw	a0,-36(s0)
 3005012:	fcb42c23          	sw	a1,-40(s0)
    CRG_ASSERT_PARAM(baseAddress != NULL);
 3005016:	fdc42783          	lw	a5,-36(s0)
 300501a:	eb89                	bnez	a5,300502c <HAL_CRG_IpEnableSet+0x26>
 300501c:	19e00593          	li	a1,414
 3005020:	030127b7          	lui	a5,0x3012
 3005024:	be078513          	addi	a0,a5,-1056 # 3011be0 <g_crgIpMatch+0x348>
 3005028:	3fe9                	jal	ra,3005002 <AssertErrorLog.trans.2>
 300502a:	a001                	j	300502a <HAL_CRG_IpEnableSet+0x24>
    CRG_ASSERT_PARAM(IsCRGInstance(g_crgBaseAddr));
 300502c:	c921a703          	lw	a4,-878(gp) # 400059c <g_crgBaseAddr>
 3005030:	100007b7          	lui	a5,0x10000
 3005034:	00f70a63          	beq	a4,a5,3005048 <HAL_CRG_IpEnableSet+0x42>
 3005038:	19f00593          	li	a1,415
 300503c:	030127b7          	lui	a5,0x3012
 3005040:	be078513          	addi	a0,a5,-1056 # 3011be0 <g_crgIpMatch+0x348>
 3005044:	3f7d                	jal	ra,3005002 <AssertErrorLog.trans.2>
 3005046:	a001                	j	3005046 <HAL_CRG_IpEnableSet+0x40>
    /* Check the validity of the input parameters. */
    CRG_PARAM_CHECK_WITH_RET((enable == IP_CLK_ENABLE || enable == IP_CLK_DISABLE), BASE_STATUS_ERROR);
 3005048:	fd842703          	lw	a4,-40(s0)
 300504c:	4785                	li	a5,1
 300504e:	00f70e63          	beq	a4,a5,300506a <HAL_CRG_IpEnableSet+0x64>
 3005052:	fd842783          	lw	a5,-40(s0)
 3005056:	cb91                	beqz	a5,300506a <HAL_CRG_IpEnableSet+0x64>
 3005058:	1a100593          	li	a1,417
 300505c:	030127b7          	lui	a5,0x3012
 3005060:	be078513          	addi	a0,a5,-1056 # 3011be0 <g_crgIpMatch+0x348>
 3005064:	3f79                	jal	ra,3005002 <AssertErrorLog.trans.2>
 3005066:	4785                	li	a5,1
 3005068:	a0a5                	j	30050d0 <HAL_CRG_IpEnableSet+0xca>
    /* Get the CRG type of the target IP. */
    CHIP_CrgIpMatchInfo *p = GetCrgIpMatchInfo(baseAddress);
 300506a:	fdc42503          	lw	a0,-36(s0)
 300506e:	2ac1                	jal	ra,300523e <GetCrgIpMatchInfo.trans.39>
 3005070:	fea42623          	sw	a0,-20(s0)
    if ((p == NULL) || (p->type >= CRG_IP_MAX_TYPE)) {
 3005074:	fec42783          	lw	a5,-20(s0)
 3005078:	c799                	beqz	a5,3005086 <HAL_CRG_IpEnableSet+0x80>
 300507a:	fec42783          	lw	a5,-20(s0)
 300507e:	43d8                	lw	a4,4(a5)
 3005080:	4799                	li	a5,6
 3005082:	00e7f463          	bgeu	a5,a4,300508a <HAL_CRG_IpEnableSet+0x84>
        return BASE_STATUS_ERROR;
 3005086:	4785                	li	a5,1
 3005088:	a0a1                	j	30050d0 <HAL_CRG_IpEnableSet+0xca>
    }
    if (g_ipClkProc[p->type].enableSet == NULL) {
 300508a:	fec42783          	lw	a5,-20(s0)
 300508e:	43d4                	lw	a3,4(a5)
 3005090:	040007b7          	lui	a5,0x4000
 3005094:	01478713          	addi	a4,a5,20 # 4000014 <g_ipClkProc>
 3005098:	02400793          	li	a5,36
 300509c:	02f687b3          	mul	a5,a3,a5
 30050a0:	97ba                	add	a5,a5,a4
 30050a2:	479c                	lw	a5,8(a5)
 30050a4:	e399                	bnez	a5,30050aa <HAL_CRG_IpEnableSet+0xa4>
        return BASE_STATUS_ERROR;
 30050a6:	4785                	li	a5,1
 30050a8:	a025                	j	30050d0 <HAL_CRG_IpEnableSet+0xca>
    }
    g_ipClkProc[p->type].enableSet(p, enable);
 30050aa:	fec42783          	lw	a5,-20(s0)
 30050ae:	43d4                	lw	a3,4(a5)
 30050b0:	040007b7          	lui	a5,0x4000
 30050b4:	01478713          	addi	a4,a5,20 # 4000014 <g_ipClkProc>
 30050b8:	02400793          	li	a5,36
 30050bc:	02f687b3          	mul	a5,a3,a5
 30050c0:	97ba                	add	a5,a5,a4
 30050c2:	479c                	lw	a5,8(a5)
 30050c4:	fd842583          	lw	a1,-40(s0)
 30050c8:	fec42503          	lw	a0,-20(s0)
 30050cc:	9782                	jalr	a5
    return BASE_STATUS_OK;
 30050ce:	4781                	li	a5,0
}
 30050d0:	853e                	mv	a0,a5
 30050d2:	50b2                	lw	ra,44(sp)
 30050d4:	5422                	lw	s0,40(sp)
 30050d6:	6145                	addi	sp,sp,48
 30050d8:	8082                	ret

030050da <HAL_CRG_IpClkSelectSet>:
  * @param select clock select, @see CRG_APBLsClkSelect for ip in apb_ls_subsys or CRG_AdcClkSelect for adc
  * @retval BASE_STATUS_OK    success
  * @retval BASE_STATUS_ERROR fail
  */
BASE_StatusType HAL_CRG_IpClkSelectSet(const void *baseAddress, unsigned int select)
{
 30050da:	7179                	addi	sp,sp,-48
 30050dc:	d606                	sw	ra,44(sp)
 30050de:	d422                	sw	s0,40(sp)
 30050e0:	1800                	addi	s0,sp,48
 30050e2:	fca42e23          	sw	a0,-36(s0)
 30050e6:	fcb42c23          	sw	a1,-40(s0)
    CRG_ASSERT_PARAM(baseAddress != NULL);
 30050ea:	fdc42783          	lw	a5,-36(s0)
 30050ee:	eb89                	bnez	a5,3005100 <HAL_CRG_IpClkSelectSet+0x26>
 30050f0:	1cf00593          	li	a1,463
 30050f4:	030127b7          	lui	a5,0x3012
 30050f8:	be078513          	addi	a0,a5,-1056 # 3011be0 <g_crgIpMatch+0x348>
 30050fc:	3719                	jal	ra,3005002 <AssertErrorLog.trans.2>
 30050fe:	a001                	j	30050fe <HAL_CRG_IpClkSelectSet+0x24>
    CRG_ASSERT_PARAM(IsCRGInstance(g_crgBaseAddr));
 3005100:	c921a703          	lw	a4,-878(gp) # 400059c <g_crgBaseAddr>
 3005104:	100007b7          	lui	a5,0x10000
 3005108:	00f70a63          	beq	a4,a5,300511c <HAL_CRG_IpClkSelectSet+0x42>
 300510c:	1d000593          	li	a1,464
 3005110:	030127b7          	lui	a5,0x3012
 3005114:	be078513          	addi	a0,a5,-1056 # 3011be0 <g_crgIpMatch+0x348>
 3005118:	35ed                	jal	ra,3005002 <AssertErrorLog.trans.2>
 300511a:	a001                	j	300511a <HAL_CRG_IpClkSelectSet+0x40>

    CHIP_CrgIpMatchInfo *p = GetCrgIpMatchInfo(baseAddress);
 300511c:	fdc42503          	lw	a0,-36(s0)
 3005120:	2a39                	jal	ra,300523e <GetCrgIpMatchInfo.trans.39>
 3005122:	fea42623          	sw	a0,-20(s0)
    if ((p == NULL) || (p->type >= CRG_IP_MAX_TYPE)) {
 3005126:	fec42783          	lw	a5,-20(s0)
 300512a:	c799                	beqz	a5,3005138 <HAL_CRG_IpClkSelectSet+0x5e>
 300512c:	fec42783          	lw	a5,-20(s0)
 3005130:	43d8                	lw	a4,4(a5)
 3005132:	4799                	li	a5,6
 3005134:	00e7f463          	bgeu	a5,a4,300513c <HAL_CRG_IpClkSelectSet+0x62>
        return BASE_STATUS_ERROR;
 3005138:	4785                	li	a5,1
 300513a:	a0a1                	j	3005182 <HAL_CRG_IpClkSelectSet+0xa8>
    }
    if (g_ipClkProc[p->type].clkSelSet == NULL) {
 300513c:	fec42783          	lw	a5,-20(s0)
 3005140:	43d4                	lw	a3,4(a5)
 3005142:	040007b7          	lui	a5,0x4000
 3005146:	01478713          	addi	a4,a5,20 # 4000014 <g_ipClkProc>
 300514a:	02400793          	li	a5,36
 300514e:	02f687b3          	mul	a5,a3,a5
 3005152:	97ba                	add	a5,a5,a4
 3005154:	47dc                	lw	a5,12(a5)
 3005156:	e399                	bnez	a5,300515c <HAL_CRG_IpClkSelectSet+0x82>
        return BASE_STATUS_ERROR;
 3005158:	4785                	li	a5,1
 300515a:	a025                	j	3005182 <HAL_CRG_IpClkSelectSet+0xa8>
    }
    g_ipClkProc[p->type].clkSelSet(p, select); /* Clock selection of the configuration module. */
 300515c:	fec42783          	lw	a5,-20(s0)
 3005160:	43d4                	lw	a3,4(a5)
 3005162:	040007b7          	lui	a5,0x4000
 3005166:	01478713          	addi	a4,a5,20 # 4000014 <g_ipClkProc>
 300516a:	02400793          	li	a5,36
 300516e:	02f687b3          	mul	a5,a3,a5
 3005172:	97ba                	add	a5,a5,a4
 3005174:	47dc                	lw	a5,12(a5)
 3005176:	fd842583          	lw	a1,-40(s0)
 300517a:	fec42503          	lw	a0,-20(s0)
 300517e:	9782                	jalr	a5
    return BASE_STATUS_OK;
 3005180:	4781                	li	a5,0
}
 3005182:	853e                	mv	a0,a5
 3005184:	50b2                	lw	ra,44(sp)
 3005186:	5422                	lw	s0,40(sp)
 3005188:	6145                	addi	sp,sp,48
 300518a:	8082                	ret

0300518c <HAL_CRG_IpClkDivSet>:
  * @param div set div value
  * @retval BASE_STATUS_OK     Success
  * @retval BASE_STATUS_ERROR  Match Fail or Not support
  */
BASE_StatusType HAL_CRG_IpClkDivSet(const void *baseAddress, unsigned int div)
{
 300518c:	7179                	addi	sp,sp,-48
 300518e:	d606                	sw	ra,44(sp)
 3005190:	d422                	sw	s0,40(sp)
 3005192:	1800                	addi	s0,sp,48
 3005194:	fca42e23          	sw	a0,-36(s0)
 3005198:	fcb42c23          	sw	a1,-40(s0)
    CRG_ASSERT_PARAM(baseAddress != NULL);
 300519c:	fdc42783          	lw	a5,-36(s0)
 30051a0:	eb89                	bnez	a5,30051b2 <HAL_CRG_IpClkDivSet+0x26>
 30051a2:	22e00593          	li	a1,558
 30051a6:	030127b7          	lui	a5,0x3012
 30051aa:	be078513          	addi	a0,a5,-1056 # 3011be0 <g_crgIpMatch+0x348>
 30051ae:	3d91                	jal	ra,3005002 <AssertErrorLog.trans.2>
 30051b0:	a001                	j	30051b0 <HAL_CRG_IpClkDivSet+0x24>
    CRG_ASSERT_PARAM(IsCRGInstance(g_crgBaseAddr));
 30051b2:	c921a703          	lw	a4,-878(gp) # 400059c <g_crgBaseAddr>
 30051b6:	100007b7          	lui	a5,0x10000
 30051ba:	00f70a63          	beq	a4,a5,30051ce <HAL_CRG_IpClkDivSet+0x42>
 30051be:	22f00593          	li	a1,559
 30051c2:	030127b7          	lui	a5,0x3012
 30051c6:	be078513          	addi	a0,a5,-1056 # 3011be0 <g_crgIpMatch+0x348>
 30051ca:	3d25                	jal	ra,3005002 <AssertErrorLog.trans.2>
 30051cc:	a001                	j	30051cc <HAL_CRG_IpClkDivSet+0x40>

    CHIP_CrgIpMatchInfo *p = GetCrgIpMatchInfo(baseAddress);
 30051ce:	fdc42503          	lw	a0,-36(s0)
 30051d2:	20b5                	jal	ra,300523e <GetCrgIpMatchInfo.trans.39>
 30051d4:	fea42623          	sw	a0,-20(s0)
    if ((p == NULL) || (p->type >= CRG_IP_MAX_TYPE)) {
 30051d8:	fec42783          	lw	a5,-20(s0)
 30051dc:	c799                	beqz	a5,30051ea <HAL_CRG_IpClkDivSet+0x5e>
 30051de:	fec42783          	lw	a5,-20(s0)
 30051e2:	43d8                	lw	a4,4(a5)
 30051e4:	4799                	li	a5,6
 30051e6:	00e7f463          	bgeu	a5,a4,30051ee <HAL_CRG_IpClkDivSet+0x62>
        return BASE_STATUS_ERROR;
 30051ea:	4785                	li	a5,1
 30051ec:	a0a1                	j	3005234 <HAL_CRG_IpClkDivSet+0xa8>
    }
    if (g_ipClkProc[p->type].clkDivSet == NULL) {
 30051ee:	fec42783          	lw	a5,-20(s0)
 30051f2:	43d4                	lw	a3,4(a5)
 30051f4:	040007b7          	lui	a5,0x4000
 30051f8:	01478713          	addi	a4,a5,20 # 4000014 <g_ipClkProc>
 30051fc:	02400793          	li	a5,36
 3005200:	02f687b3          	mul	a5,a3,a5
 3005204:	97ba                	add	a5,a5,a4
 3005206:	4b9c                	lw	a5,16(a5)
 3005208:	e399                	bnez	a5,300520e <HAL_CRG_IpClkDivSet+0x82>
        return BASE_STATUS_ERROR;
 300520a:	4785                	li	a5,1
 300520c:	a025                	j	3005234 <HAL_CRG_IpClkDivSet+0xa8>
    }
    g_ipClkProc[p->type].clkDivSet(p, div); /* Configure the clock frequency divider of the module. */
 300520e:	fec42783          	lw	a5,-20(s0)
 3005212:	43d4                	lw	a3,4(a5)
 3005214:	040007b7          	lui	a5,0x4000
 3005218:	01478713          	addi	a4,a5,20 # 4000014 <g_ipClkProc>
 300521c:	02400793          	li	a5,36
 3005220:	02f687b3          	mul	a5,a3,a5
 3005224:	97ba                	add	a5,a5,a4
 3005226:	4b9c                	lw	a5,16(a5)
 3005228:	fd842583          	lw	a1,-40(s0)
 300522c:	fec42503          	lw	a0,-20(s0)
 3005230:	9782                	jalr	a5
    return BASE_STATUS_OK;
 3005232:	4781                	li	a5,0
}
 3005234:	853e                	mv	a0,a5
 3005236:	50b2                	lw	ra,44(sp)
 3005238:	5422                	lw	s0,40(sp)
 300523a:	6145                	addi	sp,sp,48
 300523c:	8082                	ret

0300523e <GetCrgIpMatchInfo.trans.39>:
 300523e:	faffb06f          	j	30011ec <GetCrgIpMatchInfo>

03005242 <CRG_GetLsIpFreq>:
  * @param matchInfo match info
  * @param baseClkRate clock rate
  * @retval Ip Frequence
  */
static unsigned int CRG_GetLsIpFreq(const CHIP_CrgIpMatchInfo *matchInfo, unsigned int baseClkRate)
{
 3005242:	7179                	addi	sp,sp,-48
 3005244:	d606                	sw	ra,44(sp)
 3005246:	d422                	sw	s0,40(sp)
 3005248:	1800                	addi	s0,sp,48
 300524a:	fca42e23          	sw	a0,-36(s0)
 300524e:	fcb42c23          	sw	a1,-40(s0)
    CRG_ASSERT_PARAM(matchInfo != NULL);
 3005252:	fdc42783          	lw	a5,-36(s0)
 3005256:	eb89                	bnez	a5,3005268 <CRG_GetLsIpFreq+0x26>
 3005258:	2af00593          	li	a1,687
 300525c:	030127b7          	lui	a5,0x3012
 3005260:	be078513          	addi	a0,a5,-1056 # 3011be0 <g_crgIpMatch+0x348>
 3005264:	3b79                	jal	ra,3005002 <AssertErrorLog.trans.2>
 3005266:	a001                	j	3005266 <CRG_GetLsIpFreq+0x24>
    CRG_ASSERT_PARAM(g_crgBaseAddr != NULL);
 3005268:	c921a783          	lw	a5,-878(gp) # 400059c <g_crgBaseAddr>
 300526c:	eb89                	bnez	a5,300527e <CRG_GetLsIpFreq+0x3c>
 300526e:	2b000593          	li	a1,688
 3005272:	030127b7          	lui	a5,0x3012
 3005276:	be078513          	addi	a0,a5,-1056 # 3011be0 <g_crgIpMatch+0x348>
 300527a:	3361                	jal	ra,3005002 <AssertErrorLog.trans.2>
 300527c:	a001                	j	300527c <CRG_GetLsIpFreq+0x3a>

    unsigned int clkSel;
    CRG_IpProc *proc;
    
    if (matchInfo->type == CRG_IP_WITH_CLK_SEL) { /* type in legal scope */
 300527e:	fdc42783          	lw	a5,-36(s0)
 3005282:	43dc                	lw	a5,4(a5)
 3005284:	e785                	bnez	a5,30052ac <CRG_GetLsIpFreq+0x6a>
        proc = &g_ipClkProc[matchInfo->type];
 3005286:	fdc42783          	lw	a5,-36(s0)
 300528a:	43d8                	lw	a4,4(a5)
 300528c:	02400793          	li	a5,36
 3005290:	02f70733          	mul	a4,a4,a5
 3005294:	040007b7          	lui	a5,0x4000
 3005298:	01478793          	addi	a5,a5,20 # 4000014 <g_ipClkProc>
 300529c:	97ba                	add	a5,a5,a4
 300529e:	fef42623          	sw	a5,-20(s0)
    } else {
        return 0;
    }

    if (proc->clkSelGet == NULL) {
 30052a2:	fec42783          	lw	a5,-20(s0)
 30052a6:	4fdc                	lw	a5,28(a5)
 30052a8:	e791                	bnez	a5,30052b4 <CRG_GetLsIpFreq+0x72>
 30052aa:	a019                	j	30052b0 <CRG_GetLsIpFreq+0x6e>
        return 0;
 30052ac:	4781                	li	a5,0
 30052ae:	a00d                	j	30052d0 <CRG_GetLsIpFreq+0x8e>
        return 0;
 30052b0:	4781                	li	a5,0
 30052b2:	a839                	j	30052d0 <CRG_GetLsIpFreq+0x8e>
    }
    clkSel = proc->clkSelGet(matchInfo);
 30052b4:	fec42783          	lw	a5,-20(s0)
 30052b8:	4fdc                	lw	a5,28(a5)
 30052ba:	fdc42503          	lw	a0,-36(s0)
 30052be:	9782                	jalr	a5
 30052c0:	fea42423          	sw	a0,-24(s0)
    return (baseClkRate >> clkSel);
 30052c4:	fd842703          	lw	a4,-40(s0)
 30052c8:	fe842783          	lw	a5,-24(s0)
 30052cc:	00f757b3          	srl	a5,a4,a5
}
 30052d0:	853e                	mv	a0,a5
 30052d2:	50b2                	lw	ra,44(sp)
 30052d4:	5422                	lw	s0,40(sp)
 30052d6:	6145                	addi	sp,sp,48
 30052d8:	8082                	ret

030052da <CRG_GetAdcIpFreq>:
  * @param coreClkFreq core clock rate
  * @retval Ip Frequence
  */
static unsigned int CRG_GetAdcIpFreq(const CHIP_CrgIpMatchInfo *matchInfo, unsigned int baseClkRate,
                                     unsigned int coreClkFreq)
{
 30052da:	7139                	addi	sp,sp,-64
 30052dc:	de06                	sw	ra,60(sp)
 30052de:	dc22                	sw	s0,56(sp)
 30052e0:	0080                	addi	s0,sp,64
 30052e2:	fca42623          	sw	a0,-52(s0)
 30052e6:	fcb42423          	sw	a1,-56(s0)
 30052ea:	fcc42223          	sw	a2,-60(s0)
    CRG_ASSERT_PARAM(matchInfo != NULL);
 30052ee:	fcc42783          	lw	a5,-52(s0)
 30052f2:	eb89                	bnez	a5,3005304 <CRG_GetAdcIpFreq+0x2a>
 30052f4:	2cc00593          	li	a1,716
 30052f8:	030127b7          	lui	a5,0x3012
 30052fc:	be078513          	addi	a0,a5,-1056 # 3011be0 <g_crgIpMatch+0x348>
 3005300:	3309                	jal	ra,3005002 <AssertErrorLog.trans.2>
 3005302:	a001                	j	3005302 <CRG_GetAdcIpFreq+0x28>
    CRG_ASSERT_PARAM(g_crgBaseAddr != NULL);
 3005304:	c921a783          	lw	a5,-878(gp) # 400059c <g_crgBaseAddr>
 3005308:	eb89                	bnez	a5,300531a <CRG_GetAdcIpFreq+0x40>
 300530a:	2cd00593          	li	a1,717
 300530e:	030127b7          	lui	a5,0x3012
 3005312:	be078513          	addi	a0,a5,-1056 # 3011be0 <g_crgIpMatch+0x348>
 3005316:	31f5                	jal	ra,3005002 <AssertErrorLog.trans.2>
 3005318:	a001                	j	3005318 <CRG_GetAdcIpFreq+0x3e>
    
    unsigned int clkSel;
    unsigned int clkDiv;
    unsigned int pst2Div;
    unsigned int freq = 0;
 300531a:	fe042623          	sw	zero,-20(s0)
    
    /* Obtains the clock source selection of the ADC. */
    const CRG_IpProc *proc = &g_ipClkProc[matchInfo->type];
 300531e:	fcc42783          	lw	a5,-52(s0)
 3005322:	43d8                	lw	a4,4(a5)
 3005324:	02400793          	li	a5,36
 3005328:	02f70733          	mul	a4,a4,a5
 300532c:	040007b7          	lui	a5,0x4000
 3005330:	01478793          	addi	a5,a5,20 # 4000014 <g_ipClkProc>
 3005334:	97ba                	add	a5,a5,a4
 3005336:	fef42423          	sw	a5,-24(s0)
    if (proc->clkSelGet == NULL) {
 300533a:	fe842783          	lw	a5,-24(s0)
 300533e:	4fdc                	lw	a5,28(a5)
 3005340:	e399                	bnez	a5,3005346 <CRG_GetAdcIpFreq+0x6c>
        return 0;
 3005342:	4781                	li	a5,0
 3005344:	a06d                	j	30053ee <CRG_GetAdcIpFreq+0x114>
    }
    clkSel = proc->clkSelGet(matchInfo);
 3005346:	fe842783          	lw	a5,-24(s0)
 300534a:	4fdc                	lw	a5,28(a5)
 300534c:	fcc42503          	lw	a0,-52(s0)
 3005350:	9782                	jalr	a5
 3005352:	fea42223          	sw	a0,-28(s0)
    /* Calculate the frequency from the ADC's clock source. */
    if (clkSel == CRG_ADC_CLK_SYN_CORE) {
 3005356:	fe442703          	lw	a4,-28(s0)
 300535a:	478d                	li	a5,3
 300535c:	00f71763          	bne	a4,a5,300536a <CRG_GetAdcIpFreq+0x90>
        freq = coreClkFreq;
 3005360:	fc442783          	lw	a5,-60(s0)
 3005364:	fef42623          	sw	a5,-20(s0)
 3005368:	a8b1                	j	30053c4 <CRG_GetAdcIpFreq+0xea>
    } else if (clkSel == CRG_ADC_CLK_ASYN_HOSC) {
 300536a:	fe442783          	lw	a5,-28(s0)
 300536e:	eb81                	bnez	a5,300537e <CRG_GetAdcIpFreq+0xa4>
        freq = HOSC_FREQ;
 3005370:	017d87b7          	lui	a5,0x17d8
 3005374:	84078793          	addi	a5,a5,-1984 # 17d7840 <FLASH_SIZE+0x17b7844>
 3005378:	fef42623          	sw	a5,-20(s0)
 300537c:	a0a1                	j	30053c4 <CRG_GetAdcIpFreq+0xea>
    } else if (clkSel == CRG_ADC_CLK_ASYN_TCXO) {
 300537e:	fe442703          	lw	a4,-28(s0)
 3005382:	4785                	li	a5,1
 3005384:	00f71963          	bne	a4,a5,3005396 <CRG_GetAdcIpFreq+0xbc>
        /* The maximum speed of the external clock source is 30000000U. */
        freq = (XTRAIL_FREQ > 30000000U) ? 0 : XTRAIL_FREQ;
 3005388:	01c9c7b7          	lui	a5,0x1c9c
 300538c:	38078793          	addi	a5,a5,896 # 1c9c380 <FLASH_SIZE+0x1c7c384>
 3005390:	fef42623          	sw	a5,-20(s0)
 3005394:	a805                	j	30053c4 <CRG_GetAdcIpFreq+0xea>
    } else if (clkSel == CRG_ADC_CLK_ASYN_PLL_DIV) {
 3005396:	fe442703          	lw	a4,-28(s0)
 300539a:	4789                	li	a5,2
 300539c:	02f71463          	bne	a4,a5,30053c4 <CRG_GetAdcIpFreq+0xea>
        pst2Div = CRG_GetPllPostDivValue((CRG_PllPostDiv)g_crgBaseAddr->PERI_CRG3.BIT.pll_postdiv2);
 30053a0:	c921a783          	lw	a5,-878(gp) # 400059c <g_crgBaseAddr>
 30053a4:	47dc                	lw	a5,12(a5)
 30053a6:	8391                	srli	a5,a5,0x4
 30053a8:	8bbd                	andi	a5,a5,15
 30053aa:	9f81                	uxtb	a5
 30053ac:	853e                	mv	a0,a5
 30053ae:	2ae5                	jal	ra,30055a6 <CRG_GetPllPostDivValue>
 30053b0:	fea42023          	sw	a0,-32(s0)
        freq = baseClkRate / pst2Div;
 30053b4:	fc842703          	lw	a4,-56(s0)
 30053b8:	fe042783          	lw	a5,-32(s0)
 30053bc:	02f757b3          	divu	a5,a4,a5
 30053c0:	fef42623          	sw	a5,-20(s0)
    }

    /* Obtain the frequency divider based on the ADC clock source. */
    if (proc->clkDivGet == NULL) {
 30053c4:	fe842783          	lw	a5,-24(s0)
 30053c8:	539c                	lw	a5,32(a5)
 30053ca:	e399                	bnez	a5,30053d0 <CRG_GetAdcIpFreq+0xf6>
        return 0;
 30053cc:	4781                	li	a5,0
 30053ce:	a005                	j	30053ee <CRG_GetAdcIpFreq+0x114>
    }
    clkDiv = proc->clkDivGet(matchInfo);
 30053d0:	fe842783          	lw	a5,-24(s0)
 30053d4:	539c                	lw	a5,32(a5)
 30053d6:	fcc42503          	lw	a0,-52(s0)
 30053da:	9782                	jalr	a5
 30053dc:	fca42e23          	sw	a0,-36(s0)
    /* Calculate the clock frequency of the ADC. */
    return (freq / (clkDiv + 1));
 30053e0:	fdc42783          	lw	a5,-36(s0)
 30053e4:	0785                	addi	a5,a5,1
 30053e6:	fec42703          	lw	a4,-20(s0)
 30053ea:	02f757b3          	divu	a5,a4,a5
}
 30053ee:	853e                	mv	a0,a5
 30053f0:	50f2                	lw	ra,60(sp)
 30053f2:	5462                	lw	s0,56(sp)
 30053f4:	6121                	addi	sp,sp,64
 30053f6:	8082                	ret

030053f8 <CRG_IsValidPllConfig>:
 * @param  CRG_Handle CRG handle
  * @retval BASE_STATUS_OK     Check Success
  * @retval BASE_STATUS_ERROR  Check Fail
 */
static BASE_StatusType CRG_IsValidPllConfig(const CRG_Handle *handle)
{
 30053f8:	7179                	addi	sp,sp,-48
 30053fa:	d606                	sw	ra,44(sp)
 30053fc:	d422                	sw	s0,40(sp)
 30053fe:	1800                	addi	s0,sp,48
 3005400:	fca42e23          	sw	a0,-36(s0)
    unsigned int preDiv;
    unsigned int freq;

    freq = CRG_GetPllRefIni(handle->pllRefClkSelect);
 3005404:	fdc42783          	lw	a5,-36(s0)
 3005408:	43dc                	lw	a5,4(a5)
 300540a:	853e                	mv	a0,a5
 300540c:	2201                	jal	ra,300550c <CRG_GetPllRefIni>
 300540e:	fea42623          	sw	a0,-20(s0)
    preDiv = CRG_GetPreDivValue(handle->pllPreDiv);
 3005412:	fdc42783          	lw	a5,-36(s0)
 3005416:	479c                	lw	a5,8(a5)
 3005418:	853e                	mv	a0,a5
 300541a:	2a31                	jal	ra,3005536 <CRG_GetPreDivValue>
 300541c:	fea42423          	sw	a0,-24(s0)
    /* Check the validity of the prescaled clock frequency. */
    if (!IsCrgValidPreDiv(freq, preDiv)) {
 3005420:	fe842583          	lw	a1,-24(s0)
 3005424:	fec42503          	lw	a0,-20(s0)
 3005428:	ba2ff0ef          	jal	ra,30047ca <IsCrgValidPreDiv>
 300542c:	87aa                	mv	a5,a0
 300542e:	0017c793          	xori	a5,a5,1
 3005432:	9f81                	uxtb	a5
 3005434:	c399                	beqz	a5,300543a <CRG_IsValidPllConfig+0x42>
        return BASE_STATUS_ERROR;
 3005436:	4785                	li	a5,1
 3005438:	a8a5                	j	30054b0 <CRG_IsValidPllConfig+0xb8>
    }
    freq /= preDiv;
 300543a:	fec42703          	lw	a4,-20(s0)
 300543e:	fe842783          	lw	a5,-24(s0)
 3005442:	02f757b3          	divu	a5,a4,a5
 3005446:	fef42623          	sw	a5,-20(s0)
    /* Check the validity of the clock frequency after frequency multiplication. */
    if (!IsCrgValidFdDiv(freq, handle->pllFbDiv)) {
 300544a:	fdc42783          	lw	a5,-36(s0)
 300544e:	47dc                	lw	a5,12(a5)
 3005450:	85be                	mv	a1,a5
 3005452:	fec42503          	lw	a0,-20(s0)
 3005456:	bd2ff0ef          	jal	ra,3004828 <IsCrgValidFdDiv>
 300545a:	87aa                	mv	a5,a0
 300545c:	0017c793          	xori	a5,a5,1
 3005460:	9f81                	uxtb	a5
 3005462:	c399                	beqz	a5,3005468 <CRG_IsValidPllConfig+0x70>
        return BASE_STATUS_ERROR;
 3005464:	4785                	li	a5,1
 3005466:	a0a9                	j	30054b0 <CRG_IsValidPllConfig+0xb8>
    }
    freq *= (handle->pllFbDiv > 0x06) ? handle->pllFbDiv : 0x06; /* 0x0-0x6: divided by 0x6 */
 3005468:	fdc42783          	lw	a5,-36(s0)
 300546c:	47dc                	lw	a5,12(a5)
 300546e:	4719                	li	a4,6
 3005470:	00e7f363          	bgeu	a5,a4,3005476 <CRG_IsValidPllConfig+0x7e>
 3005474:	4799                	li	a5,6
 3005476:	fec42703          	lw	a4,-20(s0)
 300547a:	02f707b3          	mul	a5,a4,a5
 300547e:	fef42623          	sw	a5,-20(s0)
    /* Check whether the PLL output frequency is valid. */
    if (IsCrgValidPostDiv(freq, handle->pllPostDiv) && IsCrgValidPostDiv2(freq, handle->handleEx.pllPostDiv2)) {
 3005482:	fdc42783          	lw	a5,-36(s0)
 3005486:	4b9c                	lw	a5,16(a5)
 3005488:	85be                	mv	a1,a5
 300548a:	fec42503          	lw	a0,-20(s0)
 300548e:	c24ff0ef          	jal	ra,30048b2 <IsCrgValidPostDiv>
 3005492:	87aa                	mv	a5,a0
 3005494:	cf89                	beqz	a5,30054ae <CRG_IsValidPllConfig+0xb6>
 3005496:	fdc42783          	lw	a5,-36(s0)
 300549a:	4fdc                	lw	a5,28(a5)
 300549c:	85be                	mv	a1,a5
 300549e:	fec42503          	lw	a0,-20(s0)
 30054a2:	c58ff0ef          	jal	ra,30048fa <IsCrgValidPostDiv2>
 30054a6:	87aa                	mv	a5,a0
 30054a8:	c399                	beqz	a5,30054ae <CRG_IsValidPllConfig+0xb6>
        return BASE_STATUS_OK;
 30054aa:	4781                	li	a5,0
 30054ac:	a011                	j	30054b0 <CRG_IsValidPllConfig+0xb8>
    }
    return BASE_STATUS_ERROR;
 30054ae:	4785                	li	a5,1
}
 30054b0:	853e                	mv	a0,a5
 30054b2:	50b2                	lw	ra,44(sp)
 30054b4:	5422                	lw	s0,40(sp)
 30054b6:	6145                	addi	sp,sp,48
 30054b8:	8082                	ret

030054ba <CRG_IsValid1MHzConfig>:
 * @param  CRG_Handle CRG handle
  * @retval BASE_STATUS_OK     Check Success
  * @retval BASE_STATUS_ERROR  Check Fail
 */
static BASE_StatusType CRG_IsValid1MHzConfig(const CRG_Handle *handle)
{
 30054ba:	7179                	addi	sp,sp,-48
 30054bc:	d622                	sw	s0,44(sp)
 30054be:	1800                	addi	s0,sp,48
 30054c0:	fca42e23          	sw	a0,-36(s0)
    unsigned int freq;
    /* Get the ref frequency of the 1 MHz clock. */
    freq = (handle->handleEx.clk1MSelect == CRG_1M_CLK_SELECT_HOSC) ? HOSC_FREQ : XTRAIL_FREQ;
 30054c4:	fdc42783          	lw	a5,-36(s0)
 30054c8:	539c                	lw	a5,32(a5)
 30054ca:	e791                	bnez	a5,30054d6 <CRG_IsValid1MHzConfig+0x1c>
 30054cc:	017d87b7          	lui	a5,0x17d8
 30054d0:	84078793          	addi	a5,a5,-1984 # 17d7840 <FLASH_SIZE+0x17b7844>
 30054d4:	a029                	j	30054de <CRG_IsValid1MHzConfig+0x24>
 30054d6:	01c9c7b7          	lui	a5,0x1c9c
 30054da:	38078793          	addi	a5,a5,896 # 1c9c380 <FLASH_SIZE+0x1c7c384>
 30054de:	fef42623          	sw	a5,-20(s0)
    /* Check whether the 1MHz output frequency is valid. */
    if ((freq / (handle->handleEx.clk1MDiv + 1)) == CRG_FREQ_1MHz) {
 30054e2:	fdc42783          	lw	a5,-36(s0)
 30054e6:	53dc                	lw	a5,36(a5)
 30054e8:	0785                	addi	a5,a5,1
 30054ea:	fec42703          	lw	a4,-20(s0)
 30054ee:	02f75733          	divu	a4,a4,a5
 30054f2:	000f47b7          	lui	a5,0xf4
 30054f6:	24078793          	addi	a5,a5,576 # f4240 <FLASH_SIZE+0xd4244>
 30054fa:	00f71463          	bne	a4,a5,3005502 <CRG_IsValid1MHzConfig+0x48>
        return BASE_STATUS_OK;
 30054fe:	4781                	li	a5,0
 3005500:	a011                	j	3005504 <CRG_IsValid1MHzConfig+0x4a>
    }
    return BASE_STATUS_ERROR;
 3005502:	4785                	li	a5,1
}
 3005504:	853e                	mv	a0,a5
 3005506:	5432                	lw	s0,44(sp)
 3005508:	6145                	addi	sp,sp,48
 300550a:	8082                	ret

0300550c <CRG_GetPllRefIni>:
 * @brief Get clock frequence
 * @param  crg CRG_RegStruct
 * @retval The frequence fo clock
 */
static inline unsigned int CRG_GetPllRefIni(CRG_PllRefClkSelect pllRefClkSelect)
{
 300550c:	1101                	addi	sp,sp,-32
 300550e:	ce22                	sw	s0,28(sp)
 3005510:	1000                	addi	s0,sp,32
 3005512:	fea42623          	sw	a0,-20(s0)
    /* The maximum speed of the external clock source is 30000000U. */
    if (pllRefClkSelect == CRG_PLL_REF_CLK_SELECT_XTAL && XTRAIL_FREQ > 30000000U) {
        return 0;
    }
    return (pllRefClkSelect == (unsigned int)CRG_PLL_REF_CLK_SELECT_HOSC) ? HOSC_FREQ : XTRAIL_FREQ;
 3005516:	fec42783          	lw	a5,-20(s0)
 300551a:	e791                	bnez	a5,3005526 <CRG_GetPllRefIni+0x1a>
 300551c:	017d87b7          	lui	a5,0x17d8
 3005520:	84078793          	addi	a5,a5,-1984 # 17d7840 <FLASH_SIZE+0x17b7844>
 3005524:	a029                	j	300552e <CRG_GetPllRefIni+0x22>
 3005526:	01c9c7b7          	lui	a5,0x1c9c
 300552a:	38078793          	addi	a5,a5,896 # 1c9c380 <FLASH_SIZE+0x1c7c384>
}
 300552e:	853e                	mv	a0,a5
 3005530:	4472                	lw	s0,28(sp)
 3005532:	6105                	addi	sp,sp,32
 3005534:	8082                	ret

03005536 <CRG_GetPreDivValue>:
 * @brief Get previous division Value before PLL
 * @param  crg CRG_RegStruct
 * @retval Previous Div value
 */
static inline unsigned int CRG_GetPreDivValue(CRG_PllPreDiv pllPredDiv)
{
 3005536:	7179                	addi	sp,sp,-48
 3005538:	d622                	sw	s0,44(sp)
 300553a:	1800                	addi	s0,sp,48
 300553c:	fca42e23          	sw	a0,-36(s0)
    unsigned int preDiv;
    if (pllPredDiv <= CRG_PLL_PREDIV_1) { /* 0 or 1 returns PLL_PREDIV_OUT_1. */
 3005540:	fdc42783          	lw	a5,-36(s0)
 3005544:	e789                	bnez	a5,300554e <CRG_GetPreDivValue+0x18>
        preDiv = PLL_PREDIV_OUT_1;
 3005546:	4785                	li	a5,1
 3005548:	fef42623          	sw	a5,-20(s0)
 300554c:	a031                	j	3005558 <CRG_GetPreDivValue+0x22>
    } else {
        preDiv = pllPredDiv + 1;
 300554e:	fdc42783          	lw	a5,-36(s0)
 3005552:	0785                	addi	a5,a5,1
 3005554:	fef42623          	sw	a5,-20(s0)
    }
    return preDiv;
 3005558:	fec42783          	lw	a5,-20(s0)
}
 300555c:	853e                	mv	a0,a5
 300555e:	5432                	lw	s0,44(sp)
 3005560:	6145                	addi	sp,sp,48
 3005562:	8082                	ret

03005564 <CRG_GetPllFbDivValue>:
 * @brief Get PLL loop divider ratio
 * @param  crg CRG_RegStruct
 * @retval PLL loop divider ratio
 */
static inline unsigned int CRG_GetPllFbDivValue(unsigned int pllFbDiv)
{
 3005564:	7179                	addi	sp,sp,-48
 3005566:	d622                	sw	s0,44(sp)
 3005568:	1800                	addi	s0,sp,48
 300556a:	fca42e23          	sw	a0,-36(s0)
    unsigned int div = pllFbDiv;
 300556e:	fdc42783          	lw	a5,-36(s0)
 3005572:	fef42623          	sw	a5,-20(s0)
    /* Check the validity of the minimum frequency multiplication parameter. */
    if (div < CRG_PLL_FBDIV_MIN) {
 3005576:	fec42703          	lw	a4,-20(s0)
 300557a:	4795                	li	a5,5
 300557c:	00e7e563          	bltu	a5,a4,3005586 <CRG_GetPllFbDivValue+0x22>
        div = CRG_PLL_FBDIV_MIN;
 3005580:	4799                	li	a5,6
 3005582:	fef42623          	sw	a5,-20(s0)
    }
    /* Check the validity of the maximum frequency multiplication parameter. */
    if (div > CRG_PLL_FBDIV_MAX) {
 3005586:	fec42703          	lw	a4,-20(s0)
 300558a:	07f00793          	li	a5,127
 300558e:	00e7f663          	bgeu	a5,a4,300559a <CRG_GetPllFbDivValue+0x36>
        div = CRG_PLL_FBDIV_MAX;
 3005592:	07f00793          	li	a5,127
 3005596:	fef42623          	sw	a5,-20(s0)
    }
    return div;
 300559a:	fec42783          	lw	a5,-20(s0)
}
 300559e:	853e                	mv	a0,a5
 30055a0:	5432                	lw	s0,44(sp)
 30055a2:	6145                	addi	sp,sp,48
 30055a4:	8082                	ret

030055a6 <CRG_GetPllPostDivValue>:
 * @brief Get post division Value after PLL
 * @param  crg CRG_RegStruct
 * @retval Previous Div value
 */
static inline unsigned int CRG_GetPllPostDivValue(unsigned int pllPostDiv)
{
 30055a6:	7179                	addi	sp,sp,-48
 30055a8:	d622                	sw	s0,44(sp)
 30055aa:	1800                	addi	s0,sp,48
 30055ac:	fca42e23          	sw	a0,-36(s0)
    unsigned int div = pllPostDiv;
 30055b0:	fdc42783          	lw	a5,-36(s0)
 30055b4:	fef42623          	sw	a5,-20(s0)
    if (div > CRG_PLL_POSTDIV_8) {
 30055b8:	fec42703          	lw	a4,-20(s0)
 30055bc:	479d                	li	a5,7
 30055be:	00e7f663          	bgeu	a5,a4,30055ca <CRG_GetPllPostDivValue+0x24>
        div = (CRG_PLL_POSTDIV_8 + 1); /* If the postdiv is greater than 8, set this postdiv to 8. */
 30055c2:	47a1                	li	a5,8
 30055c4:	fef42623          	sw	a5,-20(s0)
 30055c8:	a031                	j	30055d4 <CRG_GetPllPostDivValue+0x2e>
    } else {
        div += 1;
 30055ca:	fec42783          	lw	a5,-20(s0)
 30055ce:	0785                	addi	a5,a5,1
 30055d0:	fef42623          	sw	a5,-20(s0)
    }
    return div;
 30055d4:	fec42783          	lw	a5,-20(s0)
}
 30055d8:	853e                	mv	a0,a5
 30055da:	5432                	lw	s0,44(sp)
 30055dc:	6145                	addi	sp,sp,48
 30055de:	8082                	ret

030055e0 <CRG_IpWithClkSelEnableSet>:
 * @param matchInfo IP with Clock select match info
 * @param enable  BASE_CFG_SET or BASE_CFG_UNSET
 * @retval None
 */
static void CRG_IpWithClkSelEnableSet(const CHIP_CrgIpMatchInfo *matchInfo, unsigned int enable)
{
 30055e0:	7179                	addi	sp,sp,-48
 30055e2:	d606                	sw	ra,44(sp)
 30055e4:	d422                	sw	s0,40(sp)
 30055e6:	1800                	addi	s0,sp,48
 30055e8:	fca42e23          	sw	a0,-36(s0)
 30055ec:	fcb42c23          	sw	a1,-40(s0)
    CRG_ASSERT_PARAM(matchInfo != NULL);
 30055f0:	fdc42783          	lw	a5,-36(s0)
 30055f4:	eb89                	bnez	a5,3005606 <CRG_IpWithClkSelEnableSet+0x26>
 30055f6:	36a00593          	li	a1,874
 30055fa:	030127b7          	lui	a5,0x3012
 30055fe:	be078513          	addi	a0,a5,-1056 # 3011be0 <g_crgIpMatch+0x348>
 3005602:	3401                	jal	ra,3005002 <AssertErrorLog.trans.2>
 3005604:	a001                	j	3005604 <CRG_IpWithClkSelEnableSet+0x24>
    CRG_ASSERT_PARAM(g_crgBaseAddr != NULL);
 3005606:	c921a783          	lw	a5,-878(gp) # 400059c <g_crgBaseAddr>
 300560a:	eb89                	bnez	a5,300561c <CRG_IpWithClkSelEnableSet+0x3c>
 300560c:	36b00593          	li	a1,875
 3005610:	030127b7          	lui	a5,0x3012
 3005614:	be078513          	addi	a0,a5,-1056 # 3011be0 <g_crgIpMatch+0x348>
 3005618:	32ed                	jal	ra,3005002 <AssertErrorLog.trans.2>
 300561a:	a001                	j	300561a <CRG_IpWithClkSelEnableSet+0x3a>

    uintptr_t base = (uintptr_t)(void *)g_crgBaseAddr;
 300561c:	c921a783          	lw	a5,-878(gp) # 400059c <g_crgBaseAddr>
 3005620:	fef42623          	sw	a5,-20(s0)
    CRG_IpWithClkSelectCfg *p = (CRG_IpWithClkSelectCfg *)(void *)(base + matchInfo->regOffset);
 3005624:	fdc42783          	lw	a5,-36(s0)
 3005628:	279e                	lhu	a5,8(a5)
 300562a:	873e                	mv	a4,a5
 300562c:	fec42783          	lw	a5,-20(s0)
 3005630:	97ba                	add	a5,a5,a4
 3005632:	fef42423          	sw	a5,-24(s0)
    if ((enable & IP_CLK_ENABLE) == IP_CLK_ENABLE) {
 3005636:	fd842783          	lw	a5,-40(s0)
 300563a:	8b85                	andi	a5,a5,1
 300563c:	cf99                	beqz	a5,300565a <CRG_IpWithClkSelEnableSet+0x7a>
        p->BIT.cken = BASE_CFG_SET;
 300563e:	fe842703          	lw	a4,-24(s0)
 3005642:	431c                	lw	a5,0(a4)
 3005644:	0017e793          	ori	a5,a5,1
 3005648:	c31c                	sw	a5,0(a4)
        p->BIT.srst_req = BASE_CFG_UNSET;   /* Enable with soft reset disable */
 300564a:	fe842703          	lw	a4,-24(s0)
 300564e:	431c                	lw	a5,0(a4)
 3005650:	76c1                	lui	a3,0xffff0
 3005652:	16fd                	addi	a3,a3,-1 # fffeffff <RAM_END+0xfbfe7fff>
 3005654:	8ff5                	and	a5,a5,a3
 3005656:	c31c                	sw	a5,0(a4)
    } else {
        p->BIT.cken = BASE_CFG_UNSET;
        p->BIT.srst_req = BASE_CFG_SET;   /* Enable with soft reset disable */
    }
}
 3005658:	a821                	j	3005670 <CRG_IpWithClkSelEnableSet+0x90>
        p->BIT.cken = BASE_CFG_UNSET;
 300565a:	fe842703          	lw	a4,-24(s0)
 300565e:	431c                	lw	a5,0(a4)
 3005660:	9bf9                	andi	a5,a5,-2
 3005662:	c31c                	sw	a5,0(a4)
        p->BIT.srst_req = BASE_CFG_SET;   /* Enable with soft reset disable */
 3005664:	fe842703          	lw	a4,-24(s0)
 3005668:	431c                	lw	a5,0(a4)
 300566a:	66c1                	lui	a3,0x10
 300566c:	8fd5                	or	a5,a5,a3
 300566e:	c31c                	sw	a5,0(a4)
}
 3005670:	0001                	nop
 3005672:	50b2                	lw	ra,44(sp)
 3005674:	5422                	lw	s0,40(sp)
 3005676:	6145                	addi	sp,sp,48
 3005678:	8082                	ret

0300567a <CRG_IpWithClkSelEnableGet>:
 * @param matchInfo IP with Clock select match info
 * @param unsigned int 0: disable, 1: enable
 * @retval Clock enable status
 */
static unsigned int CRG_IpWithClkSelEnableGet(const CHIP_CrgIpMatchInfo *matchInfo)
{
 300567a:	7179                	addi	sp,sp,-48
 300567c:	d606                	sw	ra,44(sp)
 300567e:	d422                	sw	s0,40(sp)
 3005680:	1800                	addi	s0,sp,48
 3005682:	fca42e23          	sw	a0,-36(s0)
    CRG_ASSERT_PARAM(matchInfo != NULL);
 3005686:	fdc42783          	lw	a5,-36(s0)
 300568a:	eb89                	bnez	a5,300569c <CRG_IpWithClkSelEnableGet+0x22>
 300568c:	38000593          	li	a1,896
 3005690:	030127b7          	lui	a5,0x3012
 3005694:	be078513          	addi	a0,a5,-1056 # 3011be0 <g_crgIpMatch+0x348>
 3005698:	32ad                	jal	ra,3005002 <AssertErrorLog.trans.2>
 300569a:	a001                	j	300569a <CRG_IpWithClkSelEnableGet+0x20>
    CRG_ASSERT_PARAM(g_crgBaseAddr != NULL);
 300569c:	c921a783          	lw	a5,-878(gp) # 400059c <g_crgBaseAddr>
 30056a0:	eb89                	bnez	a5,30056b2 <CRG_IpWithClkSelEnableGet+0x38>
 30056a2:	38100593          	li	a1,897
 30056a6:	030127b7          	lui	a5,0x3012
 30056aa:	be078513          	addi	a0,a5,-1056 # 3011be0 <g_crgIpMatch+0x348>
 30056ae:	3a91                	jal	ra,3005002 <AssertErrorLog.trans.2>
 30056b0:	a001                	j	30056b0 <CRG_IpWithClkSelEnableGet+0x36>
    /* Get Clock enable status or undo for target ip. */
    uintptr_t base = (uintptr_t)(void *)g_crgBaseAddr;
 30056b2:	c921a783          	lw	a5,-878(gp) # 400059c <g_crgBaseAddr>
 30056b6:	fef42623          	sw	a5,-20(s0)
    CRG_IpWithClkSelectCfg *p = (CRG_IpWithClkSelectCfg *)(void *)(base + matchInfo->regOffset);
 30056ba:	fdc42783          	lw	a5,-36(s0)
 30056be:	279e                	lhu	a5,8(a5)
 30056c0:	873e                	mv	a4,a5
 30056c2:	fec42783          	lw	a5,-20(s0)
 30056c6:	97ba                	add	a5,a5,a4
 30056c8:	fef42423          	sw	a5,-24(s0)
    return p->BIT.cken;
 30056cc:	fe842783          	lw	a5,-24(s0)
 30056d0:	439c                	lw	a5,0(a5)
 30056d2:	8b85                	andi	a5,a5,1
 30056d4:	9f81                	uxtb	a5
}
 30056d6:	853e                	mv	a0,a5
 30056d8:	50b2                	lw	ra,44(sp)
 30056da:	5422                	lw	s0,40(sp)
 30056dc:	6145                	addi	sp,sp,48
 30056de:	8082                	ret

030056e0 <CRG_IpWithClkSelResetSet>:
 * @param matchInfo IP with Clock select match info
 * @param reset  BASE_CFG_SET or BASE_CFG_UNSET
 * @retval None
 */
static void CRG_IpWithClkSelResetSet(const CHIP_CrgIpMatchInfo *matchInfo, unsigned int reset)
{
 30056e0:	7179                	addi	sp,sp,-48
 30056e2:	d606                	sw	ra,44(sp)
 30056e4:	d422                	sw	s0,40(sp)
 30056e6:	1800                	addi	s0,sp,48
 30056e8:	fca42e23          	sw	a0,-36(s0)
 30056ec:	fcb42c23          	sw	a1,-40(s0)
    CRG_ASSERT_PARAM(matchInfo != NULL);
 30056f0:	fdc42783          	lw	a5,-36(s0)
 30056f4:	eb89                	bnez	a5,3005706 <CRG_IpWithClkSelResetSet+0x26>
 30056f6:	39000593          	li	a1,912
 30056fa:	030127b7          	lui	a5,0x3012
 30056fe:	be078513          	addi	a0,a5,-1056 # 3011be0 <g_crgIpMatch+0x348>
 3005702:	3201                	jal	ra,3005002 <AssertErrorLog.trans.2>
 3005704:	a001                	j	3005704 <CRG_IpWithClkSelResetSet+0x24>
    CRG_ASSERT_PARAM(g_crgBaseAddr != NULL);
 3005706:	c921a783          	lw	a5,-878(gp) # 400059c <g_crgBaseAddr>
 300570a:	eb89                	bnez	a5,300571c <CRG_IpWithClkSelResetSet+0x3c>
 300570c:	39100593          	li	a1,913
 3005710:	030127b7          	lui	a5,0x3012
 3005714:	be078513          	addi	a0,a5,-1056 # 3011be0 <g_crgIpMatch+0x348>
 3005718:	30ed                	jal	ra,3005002 <AssertErrorLog.trans.2>
 300571a:	a001                	j	300571a <CRG_IpWithClkSelResetSet+0x3a>
    /* Set Clock reset or undo for target ip. */
    uintptr_t base = (uintptr_t)(void *)g_crgBaseAddr;
 300571c:	c921a783          	lw	a5,-878(gp) # 400059c <g_crgBaseAddr>
 3005720:	fef42623          	sw	a5,-20(s0)
    CRG_IpWithClkSelectCfg *p = (CRG_IpWithClkSelectCfg *)(void *)(base + matchInfo->regOffset);
 3005724:	fdc42783          	lw	a5,-36(s0)
 3005728:	279e                	lhu	a5,8(a5)
 300572a:	873e                	mv	a4,a5
 300572c:	fec42783          	lw	a5,-20(s0)
 3005730:	97ba                	add	a5,a5,a4
 3005732:	fef42423          	sw	a5,-24(s0)
    p->BIT.srst_req = (reset & BASE_CFG_SET) ? BASE_CFG_SET : BASE_CFG_UNSET;
 3005736:	fd842783          	lw	a5,-40(s0)
 300573a:	8b85                	andi	a5,a5,1
 300573c:	0ff7f693          	andi	a3,a5,255
 3005740:	fe842703          	lw	a4,-24(s0)
 3005744:	431c                	lw	a5,0(a4)
 3005746:	8a85                	andi	a3,a3,1
 3005748:	06c2                	slli	a3,a3,0x10
 300574a:	7641                	lui	a2,0xffff0
 300574c:	167d                	addi	a2,a2,-1 # fffeffff <RAM_END+0xfbfe7fff>
 300574e:	8ff1                	and	a5,a5,a2
 3005750:	8fd5                	or	a5,a5,a3
 3005752:	c31c                	sw	a5,0(a4)
}
 3005754:	0001                	nop
 3005756:	50b2                	lw	ra,44(sp)
 3005758:	5422                	lw	s0,40(sp)
 300575a:	6145                	addi	sp,sp,48
 300575c:	8082                	ret

0300575e <CRG_IpWithClkSelResetGet>:
 * @param matchInfo IP with Clock select match info
 * @param unsigned int 0: disable, 1: enable
 * @retval Clock reset status
 */
static unsigned int CRG_IpWithClkSelResetGet(const CHIP_CrgIpMatchInfo *matchInfo)
{
 300575e:	7179                	addi	sp,sp,-48
 3005760:	d606                	sw	ra,44(sp)
 3005762:	d422                	sw	s0,40(sp)
 3005764:	1800                	addi	s0,sp,48
 3005766:	fca42e23          	sw	a0,-36(s0)
    CRG_ASSERT_PARAM(matchInfo != NULL);
 300576a:	fdc42783          	lw	a5,-36(s0)
 300576e:	eb89                	bnez	a5,3005780 <CRG_IpWithClkSelResetGet+0x22>
 3005770:	3a000593          	li	a1,928
 3005774:	030127b7          	lui	a5,0x3012
 3005778:	be078513          	addi	a0,a5,-1056 # 3011be0 <g_crgIpMatch+0x348>
 300577c:	2501                	jal	ra,3005d7c <AssertErrorLog.trans.3>
 300577e:	a001                	j	300577e <CRG_IpWithClkSelResetGet+0x20>
    CRG_ASSERT_PARAM(g_crgBaseAddr != NULL);
 3005780:	c921a783          	lw	a5,-878(gp) # 400059c <g_crgBaseAddr>
 3005784:	eb89                	bnez	a5,3005796 <CRG_IpWithClkSelResetGet+0x38>
 3005786:	3a100593          	li	a1,929
 300578a:	030127b7          	lui	a5,0x3012
 300578e:	be078513          	addi	a0,a5,-1056 # 3011be0 <g_crgIpMatch+0x348>
 3005792:	23ed                	jal	ra,3005d7c <AssertErrorLog.trans.3>
 3005794:	a001                	j	3005794 <CRG_IpWithClkSelResetGet+0x36>
    /* Get Clock reset status for target ip. */
    uintptr_t base = (uintptr_t)(void *)g_crgBaseAddr;
 3005796:	c921a783          	lw	a5,-878(gp) # 400059c <g_crgBaseAddr>
 300579a:	fef42623          	sw	a5,-20(s0)
    CRG_IpWithClkSelectCfg *p = (CRG_IpWithClkSelectCfg *)(void *)(base + matchInfo->regOffset);
 300579e:	fdc42783          	lw	a5,-36(s0)
 30057a2:	279e                	lhu	a5,8(a5)
 30057a4:	873e                	mv	a4,a5
 30057a6:	fec42783          	lw	a5,-20(s0)
 30057aa:	97ba                	add	a5,a5,a4
 30057ac:	fef42423          	sw	a5,-24(s0)
    return p->BIT.srst_req;
 30057b0:	fe842783          	lw	a5,-24(s0)
 30057b4:	439c                	lw	a5,0(a5)
 30057b6:	83c1                	srli	a5,a5,0x10
 30057b8:	8b85                	andi	a5,a5,1
 30057ba:	9f81                	uxtb	a5
}
 30057bc:	853e                	mv	a0,a5
 30057be:	50b2                	lw	ra,44(sp)
 30057c0:	5422                	lw	s0,40(sp)
 30057c2:	6145                	addi	sp,sp,48
 30057c4:	8082                	ret

030057c6 <CRG_IpWithClkSelClkSelSet>:
 * @param clkSelect @see CRG_APBLsClkSelect
 * @param unsigned int BASE_CFG_SET or BASE_CFG_UNSET
 * @retval None
 */
static void CRG_IpWithClkSelClkSelSet(const CHIP_CrgIpMatchInfo *matchInfo, unsigned int clkSelect)
{
 30057c6:	7179                	addi	sp,sp,-48
 30057c8:	d606                	sw	ra,44(sp)
 30057ca:	d422                	sw	s0,40(sp)
 30057cc:	1800                	addi	s0,sp,48
 30057ce:	fca42e23          	sw	a0,-36(s0)
 30057d2:	fcb42c23          	sw	a1,-40(s0)
    CRG_ASSERT_PARAM(matchInfo != NULL);
 30057d6:	fdc42783          	lw	a5,-36(s0)
 30057da:	eb89                	bnez	a5,30057ec <CRG_IpWithClkSelClkSelSet+0x26>
 30057dc:	3b100593          	li	a1,945
 30057e0:	030127b7          	lui	a5,0x3012
 30057e4:	be078513          	addi	a0,a5,-1056 # 3011be0 <g_crgIpMatch+0x348>
 30057e8:	2b51                	jal	ra,3005d7c <AssertErrorLog.trans.3>
 30057ea:	a001                	j	30057ea <CRG_IpWithClkSelClkSelSet+0x24>
    CRG_ASSERT_PARAM(g_crgBaseAddr != NULL);
 30057ec:	c921a783          	lw	a5,-878(gp) # 400059c <g_crgBaseAddr>
 30057f0:	eb89                	bnez	a5,3005802 <CRG_IpWithClkSelClkSelSet+0x3c>
 30057f2:	3b200593          	li	a1,946
 30057f6:	030127b7          	lui	a5,0x3012
 30057fa:	be078513          	addi	a0,a5,-1056 # 3011be0 <g_crgIpMatch+0x348>
 30057fe:	2bbd                	jal	ra,3005d7c <AssertErrorLog.trans.3>
 3005800:	a001                	j	3005800 <CRG_IpWithClkSelClkSelSet+0x3a>
    CRG_PARAM_CHECK_NO_RET(IsCrgAHBCkSel(clkSelect));
 3005802:	fd842503          	lw	a0,-40(s0)
 3005806:	f85fe0ef          	jal	ra,300478a <IsCrgAHBCkSel>
 300580a:	87aa                	mv	a5,a0
 300580c:	0017c793          	xori	a5,a5,1
 3005810:	9f81                	uxtb	a5
 3005812:	cb89                	beqz	a5,3005824 <CRG_IpWithClkSelClkSelSet+0x5e>
 3005814:	3b300593          	li	a1,947
 3005818:	030127b7          	lui	a5,0x3012
 300581c:	be078513          	addi	a0,a5,-1056 # 3011be0 <g_crgIpMatch+0x348>
 3005820:	2bb1                	jal	ra,3005d7c <AssertErrorLog.trans.3>
 3005822:	a835                	j	300585e <CRG_IpWithClkSelClkSelSet+0x98>
    /* Set Clock Select for target ip. */
    uintptr_t base = (uintptr_t)(void *)g_crgBaseAddr;
 3005824:	c921a783          	lw	a5,-878(gp) # 400059c <g_crgBaseAddr>
 3005828:	fef42623          	sw	a5,-20(s0)
    CRG_IpWithClkSelectCfg *p = (CRG_IpWithClkSelectCfg *)(void *)(base + matchInfo->regOffset);
 300582c:	fdc42783          	lw	a5,-36(s0)
 3005830:	279e                	lhu	a5,8(a5)
 3005832:	873e                	mv	a4,a5
 3005834:	fec42783          	lw	a5,-20(s0)
 3005838:	97ba                	add	a5,a5,a4
 300583a:	fef42423          	sw	a5,-24(s0)
    p->BIT.cksel = clkSelect;
 300583e:	fd842783          	lw	a5,-40(s0)
 3005842:	8b8d                	andi	a5,a5,3
 3005844:	0ff7f693          	andi	a3,a5,255
 3005848:	fe842703          	lw	a4,-24(s0)
 300584c:	431c                	lw	a5,0(a4)
 300584e:	8a8d                	andi	a3,a3,3
 3005850:	06e2                	slli	a3,a3,0x18
 3005852:	fd000637          	lui	a2,0xfd000
 3005856:	167d                	addi	a2,a2,-1 # fcffffff <RAM_END+0xf8ff7fff>
 3005858:	8ff1                	and	a5,a5,a2
 300585a:	8fd5                	or	a5,a5,a3
 300585c:	c31c                	sw	a5,0(a4)
}
 300585e:	50b2                	lw	ra,44(sp)
 3005860:	5422                	lw	s0,40(sp)
 3005862:	6145                	addi	sp,sp,48
 3005864:	8082                	ret

03005866 <CRG_IpWithClkSelClkSelGet>:
 * @brief Get Clock Select for IP in APB_LS_SUBSYS
 * @param matchInfo IP with Clock select match info
 * @retval Clock Select @see CRG_APBLsClkSelect
 */
static unsigned int CRG_IpWithClkSelClkSelGet(const CHIP_CrgIpMatchInfo *matchInfo)
{
 3005866:	7179                	addi	sp,sp,-48
 3005868:	d606                	sw	ra,44(sp)
 300586a:	d422                	sw	s0,40(sp)
 300586c:	1800                	addi	s0,sp,48
 300586e:	fca42e23          	sw	a0,-36(s0)
    CRG_ASSERT_PARAM(matchInfo != NULL);
 3005872:	fdc42783          	lw	a5,-36(s0)
 3005876:	eb89                	bnez	a5,3005888 <CRG_IpWithClkSelClkSelGet+0x22>
 3005878:	3c100593          	li	a1,961
 300587c:	030127b7          	lui	a5,0x3012
 3005880:	be078513          	addi	a0,a5,-1056 # 3011be0 <g_crgIpMatch+0x348>
 3005884:	29e5                	jal	ra,3005d7c <AssertErrorLog.trans.3>
 3005886:	a001                	j	3005886 <CRG_IpWithClkSelClkSelGet+0x20>
    CRG_ASSERT_PARAM(g_crgBaseAddr != NULL);
 3005888:	c921a783          	lw	a5,-878(gp) # 400059c <g_crgBaseAddr>
 300588c:	eb89                	bnez	a5,300589e <CRG_IpWithClkSelClkSelGet+0x38>
 300588e:	3c200593          	li	a1,962
 3005892:	030127b7          	lui	a5,0x3012
 3005896:	be078513          	addi	a0,a5,-1056 # 3011be0 <g_crgIpMatch+0x348>
 300589a:	21cd                	jal	ra,3005d7c <AssertErrorLog.trans.3>
 300589c:	a001                	j	300589c <CRG_IpWithClkSelClkSelGet+0x36>
    /* Get Clock Select for target ip. */
    uintptr_t base = (uintptr_t)(void *)g_crgBaseAddr;
 300589e:	c921a783          	lw	a5,-878(gp) # 400059c <g_crgBaseAddr>
 30058a2:	fef42623          	sw	a5,-20(s0)
    CRG_IpWithClkSelectCfg *p = (CRG_IpWithClkSelectCfg *)(void *)(base + matchInfo->regOffset);
 30058a6:	fdc42783          	lw	a5,-36(s0)
 30058aa:	279e                	lhu	a5,8(a5)
 30058ac:	873e                	mv	a4,a5
 30058ae:	fec42783          	lw	a5,-20(s0)
 30058b2:	97ba                	add	a5,a5,a4
 30058b4:	fef42423          	sw	a5,-24(s0)
    return p->BIT.cksel;
 30058b8:	fe842783          	lw	a5,-24(s0)
 30058bc:	439c                	lw	a5,0(a5)
 30058be:	83e1                	srli	a5,a5,0x18
 30058c0:	8b8d                	andi	a5,a5,3
 30058c2:	9f81                	uxtb	a5
}
 30058c4:	853e                	mv	a0,a5
 30058c6:	50b2                	lw	ra,44(sp)
 30058c8:	5422                	lw	s0,40(sp)
 30058ca:	6145                	addi	sp,sp,48
 30058cc:	8082                	ret

030058ce <CRG_IpWoClkSelEnableSet>:
 * @param matchInfo IP without Clock select match info
 * @param enable BASE_CFG_SET or BASE_CFG_UNSET
 * @retval None
 */
static void CRG_IpWoClkSelEnableSet(const CHIP_CrgIpMatchInfo *matchInfo, unsigned int enable)
{
 30058ce:	7179                	addi	sp,sp,-48
 30058d0:	d606                	sw	ra,44(sp)
 30058d2:	d422                	sw	s0,40(sp)
 30058d4:	1800                	addi	s0,sp,48
 30058d6:	fca42e23          	sw	a0,-36(s0)
 30058da:	fcb42c23          	sw	a1,-40(s0)
    CRG_ASSERT_PARAM(matchInfo != NULL);
 30058de:	fdc42783          	lw	a5,-36(s0)
 30058e2:	eb89                	bnez	a5,30058f4 <CRG_IpWoClkSelEnableSet+0x26>
 30058e4:	3d100593          	li	a1,977
 30058e8:	030127b7          	lui	a5,0x3012
 30058ec:	be078513          	addi	a0,a5,-1056 # 3011be0 <g_crgIpMatch+0x348>
 30058f0:	2171                	jal	ra,3005d7c <AssertErrorLog.trans.3>
 30058f2:	a001                	j	30058f2 <CRG_IpWoClkSelEnableSet+0x24>
    CRG_ASSERT_PARAM(g_crgBaseAddr != NULL);
 30058f4:	c921a783          	lw	a5,-878(gp) # 400059c <g_crgBaseAddr>
 30058f8:	eb89                	bnez	a5,300590a <CRG_IpWoClkSelEnableSet+0x3c>
 30058fa:	3d200593          	li	a1,978
 30058fe:	030127b7          	lui	a5,0x3012
 3005902:	be078513          	addi	a0,a5,-1056 # 3011be0 <g_crgIpMatch+0x348>
 3005906:	299d                	jal	ra,3005d7c <AssertErrorLog.trans.3>
 3005908:	a001                	j	3005908 <CRG_IpWoClkSelEnableSet+0x3a>

    uintptr_t base = (uintptr_t)(void *)g_crgBaseAddr;
 300590a:	c921a783          	lw	a5,-878(gp) # 400059c <g_crgBaseAddr>
 300590e:	fef42623          	sw	a5,-20(s0)
    CRG_IpWoClkSelectCfg *p = (CRG_IpWoClkSelectCfg *)(void *)(base + matchInfo->regOffset);
 3005912:	fdc42783          	lw	a5,-36(s0)
 3005916:	279e                	lhu	a5,8(a5)
 3005918:	873e                	mv	a4,a5
 300591a:	fec42783          	lw	a5,-20(s0)
 300591e:	97ba                	add	a5,a5,a4
 3005920:	fef42423          	sw	a5,-24(s0)
    CRG_IpWoClkSelectCfg cfg;
    cfg.value = p->value;
 3005924:	fe842783          	lw	a5,-24(s0)
 3005928:	439c                	lw	a5,0(a5)
 300592a:	fef42223          	sw	a5,-28(s0)
    if (enable & IP_CLK_ENABLE) {     /* Set enable of target ip. */
 300592e:	fd842783          	lw	a5,-40(s0)
 3005932:	8b85                	andi	a5,a5,1
 3005934:	c7c1                	beqz	a5,30059bc <CRG_IpWoClkSelEnableSet+0xee>
        cfg.BIT.clkEnMask |= 1 << matchInfo->bitOffset;
 3005936:	fe442783          	lw	a5,-28(s0)
 300593a:	9fa1                	uxth	a5
 300593c:	01079713          	slli	a4,a5,0x10
 3005940:	8741                	srai	a4,a4,0x10
 3005942:	fdc42783          	lw	a5,-36(s0)
 3005946:	27bc                	lbu	a5,10(a5)
 3005948:	86be                	mv	a3,a5
 300594a:	4785                	li	a5,1
 300594c:	00d797b3          	sll	a5,a5,a3
 3005950:	07c2                	slli	a5,a5,0x10
 3005952:	87c1                	srai	a5,a5,0x10
 3005954:	8fd9                	or	a5,a5,a4
 3005956:	07c2                	slli	a5,a5,0x10
 3005958:	87c1                	srai	a5,a5,0x10
 300595a:	01079693          	slli	a3,a5,0x10
 300595e:	82c1                	srli	a3,a3,0x10
 3005960:	fe442783          	lw	a5,-28(s0)
 3005964:	6741                	lui	a4,0x10
 3005966:	177d                	addi	a4,a4,-1 # ffff <RAM_SIZE+0xafff>
 3005968:	8f75                	and	a4,a4,a3
 300596a:	76c1                	lui	a3,0xffff0
 300596c:	8ff5                	and	a5,a5,a3
 300596e:	8fd9                	or	a5,a5,a4
 3005970:	fef42223          	sw	a5,-28(s0)
        cfg.BIT.softResetReq &= ~(1 << matchInfo->bitOffset);
 3005974:	fe442783          	lw	a5,-28(s0)
 3005978:	83c1                	srli	a5,a5,0x10
 300597a:	9fa1                	uxth	a5
 300597c:	01079713          	slli	a4,a5,0x10
 3005980:	8741                	srai	a4,a4,0x10
 3005982:	fdc42783          	lw	a5,-36(s0)
 3005986:	27bc                	lbu	a5,10(a5)
 3005988:	86be                	mv	a3,a5
 300598a:	4785                	li	a5,1
 300598c:	00d797b3          	sll	a5,a5,a3
 3005990:	07c2                	slli	a5,a5,0x10
 3005992:	87c1                	srai	a5,a5,0x10
 3005994:	fff7c793          	not	a5,a5
 3005998:	07c2                	slli	a5,a5,0x10
 300599a:	87c1                	srai	a5,a5,0x10
 300599c:	8ff9                	and	a5,a5,a4
 300599e:	07c2                	slli	a5,a5,0x10
 30059a0:	87c1                	srai	a5,a5,0x10
 30059a2:	01079713          	slli	a4,a5,0x10
 30059a6:	8341                	srli	a4,a4,0x10
 30059a8:	fe442783          	lw	a5,-28(s0)
 30059ac:	0742                	slli	a4,a4,0x10
 30059ae:	66c1                	lui	a3,0x10
 30059b0:	16fd                	addi	a3,a3,-1 # ffff <RAM_SIZE+0xafff>
 30059b2:	8ff5                	and	a5,a5,a3
 30059b4:	8fd9                	or	a5,a5,a4
 30059b6:	fef42223          	sw	a5,-28(s0)
 30059ba:	a059                	j	3005a40 <CRG_IpWoClkSelEnableSet+0x172>
    } else {
        cfg.BIT.clkEnMask &= ~(1 << matchInfo->bitOffset); /* Disable of target ip. */
 30059bc:	fe442783          	lw	a5,-28(s0)
 30059c0:	9fa1                	uxth	a5
 30059c2:	01079713          	slli	a4,a5,0x10
 30059c6:	8741                	srai	a4,a4,0x10
 30059c8:	fdc42783          	lw	a5,-36(s0)
 30059cc:	27bc                	lbu	a5,10(a5)
 30059ce:	86be                	mv	a3,a5
 30059d0:	4785                	li	a5,1
 30059d2:	00d797b3          	sll	a5,a5,a3
 30059d6:	07c2                	slli	a5,a5,0x10
 30059d8:	87c1                	srai	a5,a5,0x10
 30059da:	fff7c793          	not	a5,a5
 30059de:	07c2                	slli	a5,a5,0x10
 30059e0:	87c1                	srai	a5,a5,0x10
 30059e2:	8ff9                	and	a5,a5,a4
 30059e4:	07c2                	slli	a5,a5,0x10
 30059e6:	87c1                	srai	a5,a5,0x10
 30059e8:	01079693          	slli	a3,a5,0x10
 30059ec:	82c1                	srli	a3,a3,0x10
 30059ee:	fe442783          	lw	a5,-28(s0)
 30059f2:	6741                	lui	a4,0x10
 30059f4:	177d                	addi	a4,a4,-1 # ffff <RAM_SIZE+0xafff>
 30059f6:	8f75                	and	a4,a4,a3
 30059f8:	76c1                	lui	a3,0xffff0
 30059fa:	8ff5                	and	a5,a5,a3
 30059fc:	8fd9                	or	a5,a5,a4
 30059fe:	fef42223          	sw	a5,-28(s0)
        cfg.BIT.softResetReq |= (1 << matchInfo->bitOffset);
 3005a02:	fe442783          	lw	a5,-28(s0)
 3005a06:	83c1                	srli	a5,a5,0x10
 3005a08:	9fa1                	uxth	a5
 3005a0a:	01079713          	slli	a4,a5,0x10
 3005a0e:	8741                	srai	a4,a4,0x10
 3005a10:	fdc42783          	lw	a5,-36(s0)
 3005a14:	27bc                	lbu	a5,10(a5)
 3005a16:	86be                	mv	a3,a5
 3005a18:	4785                	li	a5,1
 3005a1a:	00d797b3          	sll	a5,a5,a3
 3005a1e:	07c2                	slli	a5,a5,0x10
 3005a20:	87c1                	srai	a5,a5,0x10
 3005a22:	8fd9                	or	a5,a5,a4
 3005a24:	07c2                	slli	a5,a5,0x10
 3005a26:	87c1                	srai	a5,a5,0x10
 3005a28:	01079713          	slli	a4,a5,0x10
 3005a2c:	8341                	srli	a4,a4,0x10
 3005a2e:	fe442783          	lw	a5,-28(s0)
 3005a32:	0742                	slli	a4,a4,0x10
 3005a34:	66c1                	lui	a3,0x10
 3005a36:	16fd                	addi	a3,a3,-1 # ffff <RAM_SIZE+0xafff>
 3005a38:	8ff5                	and	a5,a5,a3
 3005a3a:	8fd9                	or	a5,a5,a4
 3005a3c:	fef42223          	sw	a5,-28(s0)
    }
    p->value = cfg.value;
 3005a40:	fe442703          	lw	a4,-28(s0)
 3005a44:	fe842783          	lw	a5,-24(s0)
 3005a48:	c398                	sw	a4,0(a5)
}
 3005a4a:	0001                	nop
 3005a4c:	50b2                	lw	ra,44(sp)
 3005a4e:	5422                	lw	s0,40(sp)
 3005a50:	6145                	addi	sp,sp,48
 3005a52:	8082                	ret

03005a54 <CRG_IpWoClkSelEnableGet>:
 * @brief Get Enable status of IP in APB_HS_SUBSYS
 * @param matchInfo IP without Clock select match info
 * @retval Clock Enable status
 */
static unsigned int CRG_IpWoClkSelEnableGet(const CHIP_CrgIpMatchInfo *matchInfo)
{
 3005a54:	7179                	addi	sp,sp,-48
 3005a56:	d606                	sw	ra,44(sp)
 3005a58:	d422                	sw	s0,40(sp)
 3005a5a:	1800                	addi	s0,sp,48
 3005a5c:	fca42e23          	sw	a0,-36(s0)
    CRG_ASSERT_PARAM(matchInfo != NULL);
 3005a60:	fdc42783          	lw	a5,-36(s0)
 3005a64:	eb89                	bnez	a5,3005a76 <CRG_IpWoClkSelEnableGet+0x22>
 3005a66:	3e900593          	li	a1,1001
 3005a6a:	030127b7          	lui	a5,0x3012
 3005a6e:	be078513          	addi	a0,a5,-1056 # 3011be0 <g_crgIpMatch+0x348>
 3005a72:	2629                	jal	ra,3005d7c <AssertErrorLog.trans.3>
 3005a74:	a001                	j	3005a74 <CRG_IpWoClkSelEnableGet+0x20>
    CRG_ASSERT_PARAM(g_crgBaseAddr != NULL);
 3005a76:	c921a783          	lw	a5,-878(gp) # 400059c <g_crgBaseAddr>
 3005a7a:	eb89                	bnez	a5,3005a8c <CRG_IpWoClkSelEnableGet+0x38>
 3005a7c:	3ea00593          	li	a1,1002
 3005a80:	030127b7          	lui	a5,0x3012
 3005a84:	be078513          	addi	a0,a5,-1056 # 3011be0 <g_crgIpMatch+0x348>
 3005a88:	2cd5                	jal	ra,3005d7c <AssertErrorLog.trans.3>
 3005a8a:	a001                	j	3005a8a <CRG_IpWoClkSelEnableGet+0x36>

    uintptr_t base = (uintptr_t)(void *)g_crgBaseAddr;
 3005a8c:	c921a783          	lw	a5,-878(gp) # 400059c <g_crgBaseAddr>
 3005a90:	fef42623          	sw	a5,-20(s0)
    /* Get enable status of target ip. */
    CRG_IpWoClkSelectCfg *p = (CRG_IpWoClkSelectCfg *)(void *)(base + matchInfo->regOffset);
 3005a94:	fdc42783          	lw	a5,-36(s0)
 3005a98:	279e                	lhu	a5,8(a5)
 3005a9a:	873e                	mv	a4,a5
 3005a9c:	fec42783          	lw	a5,-20(s0)
 3005aa0:	97ba                	add	a5,a5,a4
 3005aa2:	fef42423          	sw	a5,-24(s0)
    CRG_IpWoClkSelectCfg cfg;

    cfg.value = p->value;
 3005aa6:	fe842783          	lw	a5,-24(s0)
 3005aaa:	439c                	lw	a5,0(a5)
 3005aac:	fef42223          	sw	a5,-28(s0)
    return (cfg.BIT.clkEnMask & (1 << matchInfo->bitOffset)) == 0 ? false : true;
 3005ab0:	fe442783          	lw	a5,-28(s0)
 3005ab4:	9fa1                	uxth	a5
 3005ab6:	873e                	mv	a4,a5
 3005ab8:	fdc42783          	lw	a5,-36(s0)
 3005abc:	27bc                	lbu	a5,10(a5)
 3005abe:	40f757b3          	sra	a5,a4,a5
 3005ac2:	8b85                	andi	a5,a5,1
 3005ac4:	00f037b3          	snez	a5,a5
 3005ac8:	9f81                	uxtb	a5
}
 3005aca:	853e                	mv	a0,a5
 3005acc:	50b2                	lw	ra,44(sp)
 3005ace:	5422                	lw	s0,40(sp)
 3005ad0:	6145                	addi	sp,sp,48
 3005ad2:	8082                	ret

03005ad4 <CRG_IpWoClkSelResetSet>:
 * @param matchInfo IP without Clock select match info
 * @param reset BASE_CFG_SET or BASE_CFG_UNSET
 * @retval None
 */
static void CRG_IpWoClkSelResetSet(const CHIP_CrgIpMatchInfo *matchInfo, unsigned int reset)
{
 3005ad4:	7179                	addi	sp,sp,-48
 3005ad6:	d606                	sw	ra,44(sp)
 3005ad8:	d422                	sw	s0,40(sp)
 3005ada:	1800                	addi	s0,sp,48
 3005adc:	fca42e23          	sw	a0,-36(s0)
 3005ae0:	fcb42c23          	sw	a1,-40(s0)
    CRG_ASSERT_PARAM(matchInfo != NULL);
 3005ae4:	fdc42783          	lw	a5,-36(s0)
 3005ae8:	eb89                	bnez	a5,3005afa <CRG_IpWoClkSelResetSet+0x26>
 3005aea:	3fd00593          	li	a1,1021
 3005aee:	030127b7          	lui	a5,0x3012
 3005af2:	be078513          	addi	a0,a5,-1056 # 3011be0 <g_crgIpMatch+0x348>
 3005af6:	2459                	jal	ra,3005d7c <AssertErrorLog.trans.3>
 3005af8:	a001                	j	3005af8 <CRG_IpWoClkSelResetSet+0x24>
    CRG_ASSERT_PARAM(g_crgBaseAddr != NULL);
 3005afa:	c921a783          	lw	a5,-878(gp) # 400059c <g_crgBaseAddr>
 3005afe:	eb89                	bnez	a5,3005b10 <CRG_IpWoClkSelResetSet+0x3c>
 3005b00:	3fe00593          	li	a1,1022
 3005b04:	030127b7          	lui	a5,0x3012
 3005b08:	be078513          	addi	a0,a5,-1056 # 3011be0 <g_crgIpMatch+0x348>
 3005b0c:	2c85                	jal	ra,3005d7c <AssertErrorLog.trans.3>
 3005b0e:	a001                	j	3005b0e <CRG_IpWoClkSelResetSet+0x3a>

    uintptr_t base = (uintptr_t)(void *)g_crgBaseAddr;
 3005b10:	c921a783          	lw	a5,-878(gp) # 400059c <g_crgBaseAddr>
 3005b14:	fef42623          	sw	a5,-20(s0)
    CRG_IpWoClkSelectCfg *p = (CRG_IpWoClkSelectCfg *)(void *)(base + matchInfo->regOffset);
 3005b18:	fdc42783          	lw	a5,-36(s0)
 3005b1c:	279e                	lhu	a5,8(a5)
 3005b1e:	873e                	mv	a4,a5
 3005b20:	fec42783          	lw	a5,-20(s0)
 3005b24:	97ba                	add	a5,a5,a4
 3005b26:	fef42423          	sw	a5,-24(s0)
    CRG_IpWoClkSelectCfg cfg;
    cfg.value = p->value;
 3005b2a:	fe842783          	lw	a5,-24(s0)
 3005b2e:	439c                	lw	a5,0(a5)
 3005b30:	fef42223          	sw	a5,-28(s0)
    if (reset & BASE_CFG_SET) {
 3005b34:	fd842783          	lw	a5,-40(s0)
 3005b38:	8b85                	andi	a5,a5,1
 3005b3a:	c3a9                	beqz	a5,3005b7c <CRG_IpWoClkSelResetSet+0xa8>
        cfg.BIT.softResetReq |= 1 << matchInfo->bitOffset; /* reset of target ip. */
 3005b3c:	fe442783          	lw	a5,-28(s0)
 3005b40:	83c1                	srli	a5,a5,0x10
 3005b42:	9fa1                	uxth	a5
 3005b44:	01079713          	slli	a4,a5,0x10
 3005b48:	8741                	srai	a4,a4,0x10
 3005b4a:	fdc42783          	lw	a5,-36(s0)
 3005b4e:	27bc                	lbu	a5,10(a5)
 3005b50:	86be                	mv	a3,a5
 3005b52:	4785                	li	a5,1
 3005b54:	00d797b3          	sll	a5,a5,a3
 3005b58:	07c2                	slli	a5,a5,0x10
 3005b5a:	87c1                	srai	a5,a5,0x10
 3005b5c:	8fd9                	or	a5,a5,a4
 3005b5e:	07c2                	slli	a5,a5,0x10
 3005b60:	87c1                	srai	a5,a5,0x10
 3005b62:	01079713          	slli	a4,a5,0x10
 3005b66:	8341                	srli	a4,a4,0x10
 3005b68:	fe442783          	lw	a5,-28(s0)
 3005b6c:	0742                	slli	a4,a4,0x10
 3005b6e:	66c1                	lui	a3,0x10
 3005b70:	16fd                	addi	a3,a3,-1 # ffff <RAM_SIZE+0xafff>
 3005b72:	8ff5                	and	a5,a5,a3
 3005b74:	8fd9                	or	a5,a5,a4
 3005b76:	fef42223          	sw	a5,-28(s0)
 3005b7a:	a0a1                	j	3005bc2 <CRG_IpWoClkSelResetSet+0xee>
    } else {
        cfg.BIT.softResetReq &= ~(1 << matchInfo->bitOffset);  /* Undo reset of target ip. */
 3005b7c:	fe442783          	lw	a5,-28(s0)
 3005b80:	83c1                	srli	a5,a5,0x10
 3005b82:	9fa1                	uxth	a5
 3005b84:	01079713          	slli	a4,a5,0x10
 3005b88:	8741                	srai	a4,a4,0x10
 3005b8a:	fdc42783          	lw	a5,-36(s0)
 3005b8e:	27bc                	lbu	a5,10(a5)
 3005b90:	86be                	mv	a3,a5
 3005b92:	4785                	li	a5,1
 3005b94:	00d797b3          	sll	a5,a5,a3
 3005b98:	07c2                	slli	a5,a5,0x10
 3005b9a:	87c1                	srai	a5,a5,0x10
 3005b9c:	fff7c793          	not	a5,a5
 3005ba0:	07c2                	slli	a5,a5,0x10
 3005ba2:	87c1                	srai	a5,a5,0x10
 3005ba4:	8ff9                	and	a5,a5,a4
 3005ba6:	07c2                	slli	a5,a5,0x10
 3005ba8:	87c1                	srai	a5,a5,0x10
 3005baa:	01079713          	slli	a4,a5,0x10
 3005bae:	8341                	srli	a4,a4,0x10
 3005bb0:	fe442783          	lw	a5,-28(s0)
 3005bb4:	0742                	slli	a4,a4,0x10
 3005bb6:	66c1                	lui	a3,0x10
 3005bb8:	16fd                	addi	a3,a3,-1 # ffff <RAM_SIZE+0xafff>
 3005bba:	8ff5                	and	a5,a5,a3
 3005bbc:	8fd9                	or	a5,a5,a4
 3005bbe:	fef42223          	sw	a5,-28(s0)
    }
    p->value = cfg.value;
 3005bc2:	fe442703          	lw	a4,-28(s0)
 3005bc6:	fe842783          	lw	a5,-24(s0)
 3005bca:	c398                	sw	a4,0(a5)
}
 3005bcc:	0001                	nop
 3005bce:	50b2                	lw	ra,44(sp)
 3005bd0:	5422                	lw	s0,40(sp)
 3005bd2:	6145                	addi	sp,sp,48
 3005bd4:	8082                	ret

03005bd6 <CRG_IpWoClkSelResetGet>:
 * @brief Get Reset status of IP in APB_HS_SUBSYS
 * @param matchInfo IP without Clock select match info
 * @retval Clock select reset status
 */
static unsigned int CRG_IpWoClkSelResetGet(const CHIP_CrgIpMatchInfo *matchInfo)
{
 3005bd6:	7179                	addi	sp,sp,-48
 3005bd8:	d606                	sw	ra,44(sp)
 3005bda:	d422                	sw	s0,40(sp)
 3005bdc:	1800                	addi	s0,sp,48
 3005bde:	fca42e23          	sw	a0,-36(s0)
    CRG_ASSERT_PARAM(matchInfo != NULL);
 3005be2:	fdc42783          	lw	a5,-36(s0)
 3005be6:	eb89                	bnez	a5,3005bf8 <CRG_IpWoClkSelResetGet+0x22>
 3005be8:	41300593          	li	a1,1043
 3005bec:	030127b7          	lui	a5,0x3012
 3005bf0:	be078513          	addi	a0,a5,-1056 # 3011be0 <g_crgIpMatch+0x348>
 3005bf4:	2261                	jal	ra,3005d7c <AssertErrorLog.trans.3>
 3005bf6:	a001                	j	3005bf6 <CRG_IpWoClkSelResetGet+0x20>
    CRG_ASSERT_PARAM(g_crgBaseAddr != NULL);
 3005bf8:	c921a783          	lw	a5,-878(gp) # 400059c <g_crgBaseAddr>
 3005bfc:	eb89                	bnez	a5,3005c0e <CRG_IpWoClkSelResetGet+0x38>
 3005bfe:	41400593          	li	a1,1044
 3005c02:	030127b7          	lui	a5,0x3012
 3005c06:	be078513          	addi	a0,a5,-1056 # 3011be0 <g_crgIpMatch+0x348>
 3005c0a:	2a8d                	jal	ra,3005d7c <AssertErrorLog.trans.3>
 3005c0c:	a001                	j	3005c0c <CRG_IpWoClkSelResetGet+0x36>

    uintptr_t base = (uintptr_t)(void *)g_crgBaseAddr;
 3005c0e:	c921a783          	lw	a5,-878(gp) # 400059c <g_crgBaseAddr>
 3005c12:	fef42623          	sw	a5,-20(s0)
    /* Get the reset status of target ip. */
    CRG_IpWoClkSelectCfg *p = (CRG_IpWoClkSelectCfg *)(void *)(base + matchInfo->regOffset);
 3005c16:	fdc42783          	lw	a5,-36(s0)
 3005c1a:	279e                	lhu	a5,8(a5)
 3005c1c:	873e                	mv	a4,a5
 3005c1e:	fec42783          	lw	a5,-20(s0)
 3005c22:	97ba                	add	a5,a5,a4
 3005c24:	fef42423          	sw	a5,-24(s0)
    CRG_IpWoClkSelectCfg cfg;
    cfg.value = p->value;
 3005c28:	fe842783          	lw	a5,-24(s0)
 3005c2c:	439c                	lw	a5,0(a5)
 3005c2e:	fef42223          	sw	a5,-28(s0)
    return (cfg.BIT.softResetReq & (1 << matchInfo->bitOffset)) ? BASE_CFG_SET : BASE_CFG_UNSET;
 3005c32:	fe442783          	lw	a5,-28(s0)
 3005c36:	83c1                	srli	a5,a5,0x10
 3005c38:	9fa1                	uxth	a5
 3005c3a:	873e                	mv	a4,a5
 3005c3c:	fdc42783          	lw	a5,-36(s0)
 3005c40:	27bc                	lbu	a5,10(a5)
 3005c42:	40f757b3          	sra	a5,a4,a5
 3005c46:	8b85                	andi	a5,a5,1
 3005c48:	00f037b3          	snez	a5,a5
 3005c4c:	9f81                	uxtb	a5
}
 3005c4e:	853e                	mv	a0,a5
 3005c50:	50b2                	lw	ra,44(sp)
 3005c52:	5422                	lw	s0,40(sp)
 3005c54:	6145                	addi	sp,sp,48
 3005c56:	8082                	ret

03005c58 <CRG_AdcEnableSet>:
 * @param matchInfo ADC match info
 * @param enable IP_CLK_ENABLE
 * @retval None
 */
static void CRG_AdcEnableSet(const CHIP_CrgIpMatchInfo *matchInfo, unsigned int enable)
{
 3005c58:	7179                	addi	sp,sp,-48
 3005c5a:	d606                	sw	ra,44(sp)
 3005c5c:	d422                	sw	s0,40(sp)
 3005c5e:	1800                	addi	s0,sp,48
 3005c60:	fca42e23          	sw	a0,-36(s0)
 3005c64:	fcb42c23          	sw	a1,-40(s0)
    CRG_ASSERT_PARAM(matchInfo != NULL);
 3005c68:	fdc42783          	lw	a5,-36(s0)
 3005c6c:	eb89                	bnez	a5,3005c7e <CRG_AdcEnableSet+0x26>
 3005c6e:	42600593          	li	a1,1062
 3005c72:	030127b7          	lui	a5,0x3012
 3005c76:	be078513          	addi	a0,a5,-1056 # 3011be0 <g_crgIpMatch+0x348>
 3005c7a:	2209                	jal	ra,3005d7c <AssertErrorLog.trans.3>
 3005c7c:	a001                	j	3005c7c <CRG_AdcEnableSet+0x24>
    CRG_ASSERT_PARAM(g_crgBaseAddr != NULL);
 3005c7e:	c921a783          	lw	a5,-878(gp) # 400059c <g_crgBaseAddr>
 3005c82:	eb89                	bnez	a5,3005c94 <CRG_AdcEnableSet+0x3c>
 3005c84:	42700593          	li	a1,1063
 3005c88:	030127b7          	lui	a5,0x3012
 3005c8c:	be078513          	addi	a0,a5,-1056 # 3011be0 <g_crgIpMatch+0x348>
 3005c90:	20f5                	jal	ra,3005d7c <AssertErrorLog.trans.3>
 3005c92:	a001                	j	3005c92 <CRG_AdcEnableSet+0x3a>

    uintptr_t base = (uintptr_t)(void *)g_crgBaseAddr;
 3005c94:	c921a783          	lw	a5,-878(gp) # 400059c <g_crgBaseAddr>
 3005c98:	fef42623          	sw	a5,-20(s0)
    CRG_AdcIpCfg *p = (CRG_AdcIpCfg *)(void *)(base + matchInfo->regOffset);
 3005c9c:	fdc42783          	lw	a5,-36(s0)
 3005ca0:	279e                	lhu	a5,8(a5)
 3005ca2:	873e                	mv	a4,a5
 3005ca4:	fec42783          	lw	a5,-20(s0)
 3005ca8:	97ba                	add	a5,a5,a4
 3005caa:	fef42423          	sw	a5,-24(s0)
    CRG_AdcIpCfg cfg;
    cfg.value[1] = p->value[1];
 3005cae:	fe842783          	lw	a5,-24(s0)
 3005cb2:	43dc                	lw	a5,4(a5)
 3005cb4:	fef42223          	sw	a5,-28(s0)
    if (enable) {     /* Enables and Deassert reset the ADC clock. */
 3005cb8:	fd842783          	lw	a5,-40(s0)
 3005cbc:	cf99                	beqz	a5,3005cda <CRG_AdcEnableSet+0x82>
        cfg.BIT.clk_adc_cken = BASE_CFG_SET;
 3005cbe:	fe442783          	lw	a5,-28(s0)
 3005cc2:	0017e793          	ori	a5,a5,1
 3005cc6:	fef42223          	sw	a5,-28(s0)
        cfg.BIT.adc_srst_req = BASE_CFG_UNSET;
 3005cca:	fe442783          	lw	a5,-28(s0)
 3005cce:	7741                	lui	a4,0xffff0
 3005cd0:	177d                	addi	a4,a4,-1 # fffeffff <RAM_END+0xfbfe7fff>
 3005cd2:	8ff9                	and	a5,a5,a4
 3005cd4:	fef42223          	sw	a5,-28(s0)
 3005cd8:	a829                	j	3005cf2 <CRG_AdcEnableSet+0x9a>
    } else {     /* Disable and reset the ADC clock. */
        cfg.BIT.clk_adc_cken = BASE_CFG_UNSET;
 3005cda:	fe442783          	lw	a5,-28(s0)
 3005cde:	9bf9                	andi	a5,a5,-2
 3005ce0:	fef42223          	sw	a5,-28(s0)
        cfg.BIT.adc_srst_req = BASE_CFG_UNSET;
 3005ce4:	fe442783          	lw	a5,-28(s0)
 3005ce8:	7741                	lui	a4,0xffff0
 3005cea:	177d                	addi	a4,a4,-1 # fffeffff <RAM_END+0xfbfe7fff>
 3005cec:	8ff9                	and	a5,a5,a4
 3005cee:	fef42223          	sw	a5,-28(s0)
    }
    p->value[1] = cfg.value[1];
 3005cf2:	fe442703          	lw	a4,-28(s0)
 3005cf6:	fe842783          	lw	a5,-24(s0)
 3005cfa:	c3d8                	sw	a4,4(a5)
}
 3005cfc:	0001                	nop
 3005cfe:	50b2                	lw	ra,44(sp)
 3005d00:	5422                	lw	s0,40(sp)
 3005d02:	6145                	addi	sp,sp,48
 3005d04:	8082                	ret

03005d06 <CRG_AdcEnableGet>:
 * @brief Get Enable status of ADC
 * @param matchInfo ADC match info
 * @retval Cken of ADC
 */
static unsigned int CRG_AdcEnableGet(const CHIP_CrgIpMatchInfo *matchInfo)
{
 3005d06:	7179                	addi	sp,sp,-48
 3005d08:	d606                	sw	ra,44(sp)
 3005d0a:	d422                	sw	s0,40(sp)
 3005d0c:	1800                	addi	s0,sp,48
 3005d0e:	fca42e23          	sw	a0,-36(s0)
    CRG_ASSERT_PARAM(matchInfo != NULL);
 3005d12:	fdc42783          	lw	a5,-36(s0)
 3005d16:	eb89                	bnez	a5,3005d28 <CRG_AdcEnableGet+0x22>
 3005d18:	43e00593          	li	a1,1086
 3005d1c:	030127b7          	lui	a5,0x3012
 3005d20:	be078513          	addi	a0,a5,-1056 # 3011be0 <g_crgIpMatch+0x348>
 3005d24:	28a1                	jal	ra,3005d7c <AssertErrorLog.trans.3>
 3005d26:	a001                	j	3005d26 <CRG_AdcEnableGet+0x20>
    CRG_ASSERT_PARAM(g_crgBaseAddr != NULL);
 3005d28:	c921a783          	lw	a5,-878(gp) # 400059c <g_crgBaseAddr>
 3005d2c:	eb89                	bnez	a5,3005d3e <CRG_AdcEnableGet+0x38>
 3005d2e:	43f00593          	li	a1,1087
 3005d32:	030127b7          	lui	a5,0x3012
 3005d36:	be078513          	addi	a0,a5,-1056 # 3011be0 <g_crgIpMatch+0x348>
 3005d3a:	2089                	jal	ra,3005d7c <AssertErrorLog.trans.3>
 3005d3c:	a001                	j	3005d3c <CRG_AdcEnableGet+0x36>
    unsigned int enable;
    /* Get the enable status of the ADC clock gating. */
    uintptr_t base = (uintptr_t)(void *)g_crgBaseAddr;
 3005d3e:	c921a783          	lw	a5,-878(gp) # 400059c <g_crgBaseAddr>
 3005d42:	fef42623          	sw	a5,-20(s0)
    CRG_AdcIpCfg *p = (CRG_AdcIpCfg *)(void *)(base + matchInfo->regOffset);
 3005d46:	fdc42783          	lw	a5,-36(s0)
 3005d4a:	279e                	lhu	a5,8(a5)
 3005d4c:	873e                	mv	a4,a5
 3005d4e:	fec42783          	lw	a5,-20(s0)
 3005d52:	97ba                	add	a5,a5,a4
 3005d54:	fef42423          	sw	a5,-24(s0)
    enable = ((p->BIT.clk_adc_cken != 0)) ? IP_CLK_ENABLE : IP_CLK_DISABLE;
 3005d58:	fe842783          	lw	a5,-24(s0)
 3005d5c:	43dc                	lw	a5,4(a5)
 3005d5e:	8b85                	andi	a5,a5,1
 3005d60:	9f81                	uxtb	a5
 3005d62:	c399                	beqz	a5,3005d68 <CRG_AdcEnableGet+0x62>
 3005d64:	4785                	li	a5,1
 3005d66:	a011                	j	3005d6a <CRG_AdcEnableGet+0x64>
 3005d68:	4781                	li	a5,0
 3005d6a:	fef42223          	sw	a5,-28(s0)
    return enable;
 3005d6e:	fe442783          	lw	a5,-28(s0)
}
 3005d72:	853e                	mv	a0,a5
 3005d74:	50b2                	lw	ra,44(sp)
 3005d76:	5422                	lw	s0,40(sp)
 3005d78:	6145                	addi	sp,sp,48
 3005d7a:	8082                	ret

03005d7c <AssertErrorLog.trans.3>:
 3005d7c:	fd7fc06f          	j	3002d52 <AssertErrorLog>

03005d80 <CRG_AdcClkSelectSet>:
 * @param matchInfo ADC match info
 * @param clkSelect @see CRG_AdcClkSelect
 * @retval None
 */
static void CRG_AdcClkSelectSet(const CHIP_CrgIpMatchInfo *matchInfo, unsigned int clkSelect)
{
 3005d80:	7179                	addi	sp,sp,-48
 3005d82:	d606                	sw	ra,44(sp)
 3005d84:	d422                	sw	s0,40(sp)
 3005d86:	1800                	addi	s0,sp,48
 3005d88:	fca42e23          	sw	a0,-36(s0)
 3005d8c:	fcb42c23          	sw	a1,-40(s0)
    CRG_ASSERT_PARAM(matchInfo != NULL);
 3005d90:	fdc42783          	lw	a5,-36(s0)
 3005d94:	eb89                	bnez	a5,3005da6 <CRG_AdcClkSelectSet+0x26>
 3005d96:	45000593          	li	a1,1104
 3005d9a:	030127b7          	lui	a5,0x3012
 3005d9e:	be078513          	addi	a0,a5,-1056 # 3011be0 <g_crgIpMatch+0x348>
 3005da2:	3fe9                	jal	ra,3005d7c <AssertErrorLog.trans.3>
 3005da4:	a001                	j	3005da4 <CRG_AdcClkSelectSet+0x24>
    CRG_ASSERT_PARAM(g_crgBaseAddr != NULL);
 3005da6:	c921a783          	lw	a5,-878(gp) # 400059c <g_crgBaseAddr>
 3005daa:	eb89                	bnez	a5,3005dbc <CRG_AdcClkSelectSet+0x3c>
 3005dac:	45100593          	li	a1,1105
 3005db0:	030127b7          	lui	a5,0x3012
 3005db4:	be078513          	addi	a0,a5,-1056 # 3011be0 <g_crgIpMatch+0x348>
 3005db8:	37d1                	jal	ra,3005d7c <AssertErrorLog.trans.3>
 3005dba:	a001                	j	3005dba <CRG_AdcClkSelectSet+0x3a>
    CRG_ASSERT_PARAM(IsCRGInstance(g_crgBaseAddr));
 3005dbc:	c921a703          	lw	a4,-878(gp) # 400059c <g_crgBaseAddr>
 3005dc0:	100007b7          	lui	a5,0x10000
 3005dc4:	00f70a63          	beq	a4,a5,3005dd8 <CRG_AdcClkSelectSet+0x58>
 3005dc8:	45200593          	li	a1,1106
 3005dcc:	030127b7          	lui	a5,0x3012
 3005dd0:	be078513          	addi	a0,a5,-1056 # 3011be0 <g_crgIpMatch+0x348>
 3005dd4:	3765                	jal	ra,3005d7c <AssertErrorLog.trans.3>
 3005dd6:	a001                	j	3005dd6 <CRG_AdcClkSelectSet+0x56>
    CRG_PARAM_CHECK_NO_RET(IsCrgAdcClkModeSelect(clkSelect));
 3005dd8:	fd842503          	lw	a0,-40(s0)
 3005ddc:	b67fe0ef          	jal	ra,3004942 <IsCrgAdcClkModeSelect>
 3005de0:	87aa                	mv	a5,a0
 3005de2:	0017c793          	xori	a5,a5,1
 3005de6:	9f81                	uxtb	a5
 3005de8:	cb89                	beqz	a5,3005dfa <CRG_AdcClkSelectSet+0x7a>
 3005dea:	45300593          	li	a1,1107
 3005dee:	030127b7          	lui	a5,0x3012
 3005df2:	be078513          	addi	a0,a5,-1056 # 3011be0 <g_crgIpMatch+0x348>
 3005df6:	3759                	jal	ra,3005d7c <AssertErrorLog.trans.3>
 3005df8:	a0bd                	j	3005e66 <CRG_AdcClkSelectSet+0xe6>

    uintptr_t base = (uintptr_t)(void *)g_crgBaseAddr;
 3005dfa:	c921a783          	lw	a5,-878(gp) # 400059c <g_crgBaseAddr>
 3005dfe:	fef42623          	sw	a5,-20(s0)
    CRG_AdcIpCfg *p = (CRG_AdcIpCfg *)(void *)(base + matchInfo->regOffset);
 3005e02:	fdc42783          	lw	a5,-36(s0)
 3005e06:	279e                	lhu	a5,8(a5)
 3005e08:	873e                	mv	a4,a5
 3005e0a:	fec42783          	lw	a5,-20(s0)
 3005e0e:	97ba                	add	a5,a5,a4
 3005e10:	fef42423          	sw	a5,-24(s0)
    if (clkSelect == CRG_ADC_CLK_SYN_CORE) {
 3005e14:	fd842703          	lw	a4,-40(s0)
 3005e18:	478d                	li	a5,3
 3005e1a:	00f71a63          	bne	a4,a5,3005e2e <CRG_AdcClkSelectSet+0xae>
        p->BIT.cfg_adc_ckmode_sel = BASE_CFG_SET; /* use sync clock */
 3005e1e:	fe842703          	lw	a4,-24(s0)
 3005e22:	435c                	lw	a5,4(a4)
 3005e24:	010006b7          	lui	a3,0x1000
 3005e28:	8fd5                	or	a5,a5,a3
 3005e2a:	c35c                	sw	a5,4(a4)
 3005e2c:	a82d                	j	3005e66 <CRG_AdcClkSelectSet+0xe6>
    } else {
        DCL_SYSCTRL_CrgWriteProtectionDisable();
 3005e2e:	ff0fe0ef          	jal	ra,300461e <DCL_SYSCTRL_CrgWriteProtectionDisable>
        g_crgBaseAddr->PERI_CRG64.BIT.clk_pst2_sw_sel = clkSelect; /* write clock selection */
 3005e32:	c921a703          	lw	a4,-878(gp) # 400059c <g_crgBaseAddr>
 3005e36:	fd842783          	lw	a5,-40(s0)
 3005e3a:	8b8d                	andi	a5,a5,3
 3005e3c:	0ff7f693          	andi	a3,a5,255
 3005e40:	10072783          	lw	a5,256(a4)
 3005e44:	8a8d                	andi	a3,a3,3
 3005e46:	0692                	slli	a3,a3,0x4
 3005e48:	fcf7f793          	andi	a5,a5,-49
 3005e4c:	8fd5                	or	a5,a5,a3
 3005e4e:	10f72023          	sw	a5,256(a4)
        DCL_SYSCTRL_CrgWriteProtectionEnable();
 3005e52:	ff4fe0ef          	jal	ra,3004646 <DCL_SYSCTRL_CrgWriteProtectionEnable>
        p->BIT.cfg_adc_ckmode_sel = BASE_CFG_UNSET;
 3005e56:	fe842703          	lw	a4,-24(s0)
 3005e5a:	435c                	lw	a5,4(a4)
 3005e5c:	ff0006b7          	lui	a3,0xff000
 3005e60:	16fd                	addi	a3,a3,-1 # feffffff <RAM_END+0xfaff7fff>
 3005e62:	8ff5                	and	a5,a5,a3
 3005e64:	c35c                	sw	a5,4(a4)
    }
}
 3005e66:	50b2                	lw	ra,44(sp)
 3005e68:	5422                	lw	s0,40(sp)
 3005e6a:	6145                	addi	sp,sp,48
 3005e6c:	8082                	ret

03005e6e <CRG_AdcClkSelectGet>:
 * @brief Get ADC Clock Select
 * @param matchInfo ADC match info
 * @retval Adc Clock select @see CRG_AdcClkSelect
 */
static unsigned int CRG_AdcClkSelectGet(const CHIP_CrgIpMatchInfo *matchInfo)
{
 3005e6e:	7179                	addi	sp,sp,-48
 3005e70:	d606                	sw	ra,44(sp)
 3005e72:	d422                	sw	s0,40(sp)
 3005e74:	1800                	addi	s0,sp,48
 3005e76:	fca42e23          	sw	a0,-36(s0)
    CRG_ASSERT_PARAM(matchInfo != NULL);
 3005e7a:	fdc42783          	lw	a5,-36(s0)
 3005e7e:	eb89                	bnez	a5,3005e90 <CRG_AdcClkSelectGet+0x22>
 3005e80:	46800593          	li	a1,1128
 3005e84:	030127b7          	lui	a5,0x3012
 3005e88:	be078513          	addi	a0,a5,-1056 # 3011be0 <g_crgIpMatch+0x348>
 3005e8c:	3dc5                	jal	ra,3005d7c <AssertErrorLog.trans.3>
 3005e8e:	a001                	j	3005e8e <CRG_AdcClkSelectGet+0x20>
    CRG_ASSERT_PARAM(g_crgBaseAddr != NULL);
 3005e90:	c921a783          	lw	a5,-878(gp) # 400059c <g_crgBaseAddr>
 3005e94:	eb89                	bnez	a5,3005ea6 <CRG_AdcClkSelectGet+0x38>
 3005e96:	46900593          	li	a1,1129
 3005e9a:	030127b7          	lui	a5,0x3012
 3005e9e:	be078513          	addi	a0,a5,-1056 # 3011be0 <g_crgIpMatch+0x348>
 3005ea2:	3de9                	jal	ra,3005d7c <AssertErrorLog.trans.3>
 3005ea4:	a001                	j	3005ea4 <CRG_AdcClkSelectGet+0x36>

    uintptr_t base = (uintptr_t)(void *)g_crgBaseAddr;
 3005ea6:	c921a783          	lw	a5,-878(gp) # 400059c <g_crgBaseAddr>
 3005eaa:	fef42623          	sw	a5,-20(s0)
    CRG_AdcIpCfg *p = (CRG_AdcIpCfg *)(void *)(base + matchInfo->regOffset);
 3005eae:	fdc42783          	lw	a5,-36(s0)
 3005eb2:	279e                	lhu	a5,8(a5)
 3005eb4:	873e                	mv	a4,a5
 3005eb6:	fec42783          	lw	a5,-20(s0)
 3005eba:	97ba                	add	a5,a5,a4
 3005ebc:	fef42423          	sw	a5,-24(s0)
    if (p->BIT.cfg_adc_ckmode_sel == BASE_CFG_SET) {
 3005ec0:	fe842783          	lw	a5,-24(s0)
 3005ec4:	43dc                	lw	a5,4(a5)
 3005ec6:	83e1                	srli	a5,a5,0x18
 3005ec8:	8b85                	andi	a5,a5,1
 3005eca:	0ff7f713          	andi	a4,a5,255
 3005ece:	4785                	li	a5,1
 3005ed0:	00f71463          	bne	a4,a5,3005ed8 <CRG_AdcClkSelectGet+0x6a>
        return CRG_ADC_CLK_SYN_CORE;                        /* Synchronous clock signal */
 3005ed4:	478d                	li	a5,3
 3005ed6:	a801                	j	3005ee6 <CRG_AdcClkSelectGet+0x78>
    }
    return g_crgBaseAddr->PERI_CRG64.BIT.clk_pst2_sw_sel;  /* asynchronous clock signal */
 3005ed8:	c921a783          	lw	a5,-878(gp) # 400059c <g_crgBaseAddr>
 3005edc:	1007a783          	lw	a5,256(a5)
 3005ee0:	8391                	srli	a5,a5,0x4
 3005ee2:	8b8d                	andi	a5,a5,3
 3005ee4:	9f81                	uxtb	a5
}
 3005ee6:	853e                	mv	a0,a5
 3005ee8:	50b2                	lw	ra,44(sp)
 3005eea:	5422                	lw	s0,40(sp)
 3005eec:	6145                	addi	sp,sp,48
 3005eee:	8082                	ret

03005ef0 <CRG_AdcDivSet>:
 * @param matchInfo ADC match info
 * @param div Adc clock division
 * @retval None
 */
static void CRG_AdcDivSet(const CHIP_CrgIpMatchInfo *matchInfo, unsigned int div)
{
 3005ef0:	7179                	addi	sp,sp,-48
 3005ef2:	d606                	sw	ra,44(sp)
 3005ef4:	d422                	sw	s0,40(sp)
 3005ef6:	1800                	addi	s0,sp,48
 3005ef8:	fca42e23          	sw	a0,-36(s0)
 3005efc:	fcb42c23          	sw	a1,-40(s0)
    CRG_ASSERT_PARAM(matchInfo != NULL);
 3005f00:	fdc42783          	lw	a5,-36(s0)
 3005f04:	eb89                	bnez	a5,3005f16 <CRG_AdcDivSet+0x26>
 3005f06:	47b00593          	li	a1,1147
 3005f0a:	030127b7          	lui	a5,0x3012
 3005f0e:	be078513          	addi	a0,a5,-1056 # 3011be0 <g_crgIpMatch+0x348>
 3005f12:	35ad                	jal	ra,3005d7c <AssertErrorLog.trans.3>
 3005f14:	a001                	j	3005f14 <CRG_AdcDivSet+0x24>
    CRG_ASSERT_PARAM(g_crgBaseAddr != NULL);
 3005f16:	c921a783          	lw	a5,-878(gp) # 400059c <g_crgBaseAddr>
 3005f1a:	eb89                	bnez	a5,3005f2c <CRG_AdcDivSet+0x3c>
 3005f1c:	47c00593          	li	a1,1148
 3005f20:	030127b7          	lui	a5,0x3012
 3005f24:	be078513          	addi	a0,a5,-1056 # 3011be0 <g_crgIpMatch+0x348>
 3005f28:	3d91                	jal	ra,3005d7c <AssertErrorLog.trans.3>
 3005f2a:	a001                	j	3005f2a <CRG_AdcDivSet+0x3a>
    CRG_PARAM_CHECK_NO_RET(IsCrgAdcClkDiv(div));
 3005f2c:	fd842503          	lw	a0,-40(s0)
 3005f30:	a53fe0ef          	jal	ra,3004982 <IsCrgAdcClkDiv>
 3005f34:	87aa                	mv	a5,a0
 3005f36:	0017c793          	xori	a5,a5,1
 3005f3a:	9f81                	uxtb	a5
 3005f3c:	cb89                	beqz	a5,3005f4e <CRG_AdcDivSet+0x5e>
 3005f3e:	47d00593          	li	a1,1149
 3005f42:	030127b7          	lui	a5,0x3012
 3005f46:	be078513          	addi	a0,a5,-1056 # 3011be0 <g_crgIpMatch+0x348>
 3005f4a:	3d0d                	jal	ra,3005d7c <AssertErrorLog.trans.3>
 3005f4c:	a0b5                	j	3005fb8 <CRG_AdcDivSet+0xc8>

    uintptr_t base = (uintptr_t)(void *)g_crgBaseAddr;
 3005f4e:	c921a783          	lw	a5,-878(gp) # 400059c <g_crgBaseAddr>
 3005f52:	fef42623          	sw	a5,-20(s0)
    CRG_AdcIpCfg *p = (CRG_AdcIpCfg *)(void *)(base + matchInfo->regOffset);
 3005f56:	fdc42783          	lw	a5,-36(s0)
 3005f5a:	279e                	lhu	a5,8(a5)
 3005f5c:	873e                	mv	a4,a5
 3005f5e:	fec42783          	lw	a5,-20(s0)
 3005f62:	97ba                	add	a5,a5,a4
 3005f64:	fef42423          	sw	a5,-24(s0)
    unsigned int clkMode = p->BIT.cfg_adc_ckmode_sel;
 3005f68:	fe842783          	lw	a5,-24(s0)
 3005f6c:	43dc                	lw	a5,4(a5)
 3005f6e:	83e1                	srli	a5,a5,0x18
 3005f70:	8b85                	andi	a5,a5,1
 3005f72:	9f81                	uxtb	a5
 3005f74:	fef42223          	sw	a5,-28(s0)
    if (clkMode == CRG_ADC_CLK_SYNCHRONOUS) {
 3005f78:	fe442703          	lw	a4,-28(s0)
 3005f7c:	4785                	li	a5,1
 3005f7e:	02f71163          	bne	a4,a5,3005fa0 <CRG_AdcDivSet+0xb0>
        p->BIT.clk_adc_div1 = div; /* write div to I1 */
 3005f82:	fd842783          	lw	a5,-40(s0)
 3005f86:	8b8d                	andi	a5,a5,3
 3005f88:	0ff7f693          	andi	a3,a5,255
 3005f8c:	fe842703          	lw	a4,-24(s0)
 3005f90:	431c                	lw	a5,0(a4)
 3005f92:	8a8d                	andi	a3,a3,3
 3005f94:	06a2                	slli	a3,a3,0x8
 3005f96:	cff7f793          	andi	a5,a5,-769
 3005f9a:	8fd5                	or	a5,a5,a3
 3005f9c:	c31c                	sw	a5,0(a4)
 3005f9e:	a829                	j	3005fb8 <CRG_AdcDivSet+0xc8>
    } else {
        p->BIT.clk_adc_div0 = div; /* write div to I0 */
 3005fa0:	fd842783          	lw	a5,-40(s0)
 3005fa4:	8b8d                	andi	a5,a5,3
 3005fa6:	0ff7f693          	andi	a3,a5,255
 3005faa:	fe842703          	lw	a4,-24(s0)
 3005fae:	431c                	lw	a5,0(a4)
 3005fb0:	8a8d                	andi	a3,a3,3
 3005fb2:	9bf1                	andi	a5,a5,-4
 3005fb4:	8fd5                	or	a5,a5,a3
 3005fb6:	c31c                	sw	a5,0(a4)
    }
}
 3005fb8:	50b2                	lw	ra,44(sp)
 3005fba:	5422                	lw	s0,40(sp)
 3005fbc:	6145                	addi	sp,sp,48
 3005fbe:	8082                	ret

03005fc0 <CRG_AdcDivGet>:
 * @brief  Get ADC clock division
 * @param matchInfo  ADC match info
 * @retval Adc clock division
 */
static unsigned int CRG_AdcDivGet(const CHIP_CrgIpMatchInfo *matchInfo)
{
 3005fc0:	7179                	addi	sp,sp,-48
 3005fc2:	d606                	sw	ra,44(sp)
 3005fc4:	d422                	sw	s0,40(sp)
 3005fc6:	1800                	addi	s0,sp,48
 3005fc8:	fca42e23          	sw	a0,-36(s0)
    CRG_ASSERT_PARAM(matchInfo != NULL);
 3005fcc:	fdc42783          	lw	a5,-36(s0)
 3005fd0:	eb89                	bnez	a5,3005fe2 <CRG_AdcDivGet+0x22>
 3005fd2:	49000593          	li	a1,1168
 3005fd6:	030127b7          	lui	a5,0x3012
 3005fda:	be078513          	addi	a0,a5,-1056 # 3011be0 <g_crgIpMatch+0x348>
 3005fde:	3b79                	jal	ra,3005d7c <AssertErrorLog.trans.3>
 3005fe0:	a001                	j	3005fe0 <CRG_AdcDivGet+0x20>
    CRG_ASSERT_PARAM(g_crgBaseAddr != NULL);
 3005fe2:	c921a783          	lw	a5,-878(gp) # 400059c <g_crgBaseAddr>
 3005fe6:	eb89                	bnez	a5,3005ff8 <CRG_AdcDivGet+0x38>
 3005fe8:	49100593          	li	a1,1169
 3005fec:	030127b7          	lui	a5,0x3012
 3005ff0:	be078513          	addi	a0,a5,-1056 # 3011be0 <g_crgIpMatch+0x348>
 3005ff4:	3361                	jal	ra,3005d7c <AssertErrorLog.trans.3>
 3005ff6:	a001                	j	3005ff6 <CRG_AdcDivGet+0x36>

    uintptr_t base = (uintptr_t)(void *)g_crgBaseAddr;
 3005ff8:	c921a783          	lw	a5,-878(gp) # 400059c <g_crgBaseAddr>
 3005ffc:	fef42623          	sw	a5,-20(s0)
    CRG_AdcIpCfg *p = (CRG_AdcIpCfg *)(void *)(base + matchInfo->regOffset);
 3006000:	fdc42783          	lw	a5,-36(s0)
 3006004:	279e                	lhu	a5,8(a5)
 3006006:	873e                	mv	a4,a5
 3006008:	fec42783          	lw	a5,-20(s0)
 300600c:	97ba                	add	a5,a5,a4
 300600e:	fef42423          	sw	a5,-24(s0)

    unsigned int clkMode = p->BIT.cfg_adc_ckmode_sel;
 3006012:	fe842783          	lw	a5,-24(s0)
 3006016:	43dc                	lw	a5,4(a5)
 3006018:	83e1                	srli	a5,a5,0x18
 300601a:	8b85                	andi	a5,a5,1
 300601c:	9f81                	uxtb	a5
 300601e:	fef42223          	sw	a5,-28(s0)

    if (clkMode == CRG_ADC_CLK_SYNCHRONOUS) {
 3006022:	fe442703          	lw	a4,-28(s0)
 3006026:	4785                	li	a5,1
 3006028:	00f71963          	bne	a4,a5,300603a <CRG_AdcDivGet+0x7a>
        return p->BIT.clk_adc_div1; /* return div value I1 */
 300602c:	fe842783          	lw	a5,-24(s0)
 3006030:	439c                	lw	a5,0(a5)
 3006032:	83a1                	srli	a5,a5,0x8
 3006034:	8b8d                	andi	a5,a5,3
 3006036:	9f81                	uxtb	a5
 3006038:	a031                	j	3006044 <CRG_AdcDivGet+0x84>
    }
    return p->BIT.clk_adc_div0; /* return div valye I0 */
 300603a:	fe842783          	lw	a5,-24(s0)
 300603e:	439c                	lw	a5,0(a5)
 3006040:	8b8d                	andi	a5,a5,3
 3006042:	9f81                	uxtb	a5
}
 3006044:	853e                	mv	a0,a5
 3006046:	50b2                	lw	ra,44(sp)
 3006048:	5422                	lw	s0,40(sp)
 300604a:	6145                	addi	sp,sp,48
 300604c:	8082                	ret

0300604e <CRG_EfcEnableSet>:
 * @brief Enable Clock of EFC
 * @param matchInfo EFC match Info
 * @param enable IP_CLK_ENABLE or IP_CRG_DISABLE
 */
static void CRG_EfcEnableSet(const CHIP_CrgIpMatchInfo *matchInfo, unsigned int enable)
{
 300604e:	7179                	addi	sp,sp,-48
 3006050:	d606                	sw	ra,44(sp)
 3006052:	d422                	sw	s0,40(sp)
 3006054:	1800                	addi	s0,sp,48
 3006056:	fca42e23          	sw	a0,-36(s0)
 300605a:	fcb42c23          	sw	a1,-40(s0)
    CRG_ASSERT_PARAM(matchInfo != NULL);
 300605e:	fdc42783          	lw	a5,-36(s0)
 3006062:	eb89                	bnez	a5,3006074 <CRG_EfcEnableSet+0x26>
 3006064:	4a500593          	li	a1,1189
 3006068:	030127b7          	lui	a5,0x3012
 300606c:	be078513          	addi	a0,a5,-1056 # 3011be0 <g_crgIpMatch+0x348>
 3006070:	3331                	jal	ra,3005d7c <AssertErrorLog.trans.3>
 3006072:	a001                	j	3006072 <CRG_EfcEnableSet+0x24>
    CRG_ASSERT_PARAM(g_crgBaseAddr != NULL);
 3006074:	c921a783          	lw	a5,-878(gp) # 400059c <g_crgBaseAddr>
 3006078:	eb89                	bnez	a5,300608a <CRG_EfcEnableSet+0x3c>
 300607a:	4a600593          	li	a1,1190
 300607e:	030127b7          	lui	a5,0x3012
 3006082:	be078513          	addi	a0,a5,-1056 # 3011be0 <g_crgIpMatch+0x348>
 3006086:	39dd                	jal	ra,3005d7c <AssertErrorLog.trans.3>
 3006088:	a001                	j	3006088 <CRG_EfcEnableSet+0x3a>
    /* Enables or disables EFC clock gating. */
    uintptr_t base = (uintptr_t)(void *)g_crgBaseAddr;
 300608a:	c921a783          	lw	a5,-878(gp) # 400059c <g_crgBaseAddr>
 300608e:	fef42623          	sw	a5,-20(s0)
    CRG_EfcIpCfg *p = (CRG_EfcIpCfg *)(void *)(base + matchInfo->regOffset);
 3006092:	fdc42783          	lw	a5,-36(s0)
 3006096:	279e                	lhu	a5,8(a5)
 3006098:	873e                	mv	a4,a5
 300609a:	fec42783          	lw	a5,-20(s0)
 300609e:	97ba                	add	a5,a5,a4
 30060a0:	fef42423          	sw	a5,-24(s0)
    p->BIT.eflash_cken = (enable & IP_CLK_ENABLE) ? BASE_CFG_SET : BASE_CFG_UNSET;
 30060a4:	fd842783          	lw	a5,-40(s0)
 30060a8:	8b85                	andi	a5,a5,1
 30060aa:	0ff7f693          	andi	a3,a5,255
 30060ae:	fe842703          	lw	a4,-24(s0)
 30060b2:	431c                	lw	a5,0(a4)
 30060b4:	8a85                	andi	a3,a3,1
 30060b6:	9bf9                	andi	a5,a5,-2
 30060b8:	8fd5                	or	a5,a5,a3
 30060ba:	c31c                	sw	a5,0(a4)
}
 30060bc:	0001                	nop
 30060be:	50b2                	lw	ra,44(sp)
 30060c0:	5422                	lw	s0,40(sp)
 30060c2:	6145                	addi	sp,sp,48
 30060c4:	8082                	ret

030060c6 <CRG_EfcEnableGet>:
 * @brief Disable Clock of EFC
 * @param matchInfo EFC match Info
 * @return unsigned int IP_CLK_ENABLE or IP_CRG_DISABLE
 */
static unsigned int CRG_EfcEnableGet(const CHIP_CrgIpMatchInfo *matchInfo)
{
 30060c6:	7179                	addi	sp,sp,-48
 30060c8:	d606                	sw	ra,44(sp)
 30060ca:	d422                	sw	s0,40(sp)
 30060cc:	1800                	addi	s0,sp,48
 30060ce:	fca42e23          	sw	a0,-36(s0)
    CRG_ASSERT_PARAM(matchInfo != NULL);
 30060d2:	fdc42783          	lw	a5,-36(s0)
 30060d6:	eb89                	bnez	a5,30060e8 <CRG_EfcEnableGet+0x22>
 30060d8:	4b400593          	li	a1,1204
 30060dc:	030127b7          	lui	a5,0x3012
 30060e0:	be078513          	addi	a0,a5,-1056 # 3011be0 <g_crgIpMatch+0x348>
 30060e4:	3961                	jal	ra,3005d7c <AssertErrorLog.trans.3>
 30060e6:	a001                	j	30060e6 <CRG_EfcEnableGet+0x20>
    CRG_ASSERT_PARAM(g_crgBaseAddr != NULL);
 30060e8:	c921a783          	lw	a5,-878(gp) # 400059c <g_crgBaseAddr>
 30060ec:	eb89                	bnez	a5,30060fe <CRG_EfcEnableGet+0x38>
 30060ee:	4b500593          	li	a1,1205
 30060f2:	030127b7          	lui	a5,0x3012
 30060f6:	be078513          	addi	a0,a5,-1056 # 3011be0 <g_crgIpMatch+0x348>
 30060fa:	3149                	jal	ra,3005d7c <AssertErrorLog.trans.3>
 30060fc:	a001                	j	30060fc <CRG_EfcEnableGet+0x36>
    /* Get the value of the EFC register in the CRG. */
    uintptr_t base = (uintptr_t)(void *)g_crgBaseAddr;
 30060fe:	c921a783          	lw	a5,-878(gp) # 400059c <g_crgBaseAddr>
 3006102:	fef42623          	sw	a5,-20(s0)
    CRG_EfcIpCfg *p = (CRG_EfcIpCfg *)(void *)(base + matchInfo->regOffset);
 3006106:	fdc42783          	lw	a5,-36(s0)
 300610a:	279e                	lhu	a5,8(a5)
 300610c:	873e                	mv	a4,a5
 300610e:	fec42783          	lw	a5,-20(s0)
 3006112:	97ba                	add	a5,a5,a4
 3006114:	fef42423          	sw	a5,-24(s0)
    return p->BIT.eflash_cken;
 3006118:	fe842783          	lw	a5,-24(s0)
 300611c:	439c                	lw	a5,0(a5)
 300611e:	8b85                	andi	a5,a5,1
 3006120:	9f81                	uxtb	a5
}
 3006122:	853e                	mv	a0,a5
 3006124:	50b2                	lw	ra,44(sp)
 3006126:	5422                	lw	s0,40(sp)
 3006128:	6145                	addi	sp,sp,48
 300612a:	8082                	ret

0300612c <CRG_AnaEnableSet>:
 * @brief Enable Clock of ANA
 * @param matchInfo ANA match Info
 * @param enable IP_CLK_ENABLE or IP_CRG_DISABLE
 */
static void CRG_AnaEnableSet(const CHIP_CrgIpMatchInfo *matchInfo, unsigned int enable)
{
 300612c:	7179                	addi	sp,sp,-48
 300612e:	d606                	sw	ra,44(sp)
 3006130:	d422                	sw	s0,40(sp)
 3006132:	1800                	addi	s0,sp,48
 3006134:	fca42e23          	sw	a0,-36(s0)
 3006138:	fcb42c23          	sw	a1,-40(s0)
    CRG_ASSERT_PARAM(matchInfo != NULL);
 300613c:	fdc42783          	lw	a5,-36(s0)
 3006140:	eb89                	bnez	a5,3006152 <CRG_AnaEnableSet+0x26>
 3006142:	4c400593          	li	a1,1220
 3006146:	030127b7          	lui	a5,0x3012
 300614a:	be078513          	addi	a0,a5,-1056 # 3011be0 <g_crgIpMatch+0x348>
 300614e:	313d                	jal	ra,3005d7c <AssertErrorLog.trans.3>
 3006150:	a001                	j	3006150 <CRG_AnaEnableSet+0x24>
    CRG_ASSERT_PARAM(g_crgBaseAddr != NULL);
 3006152:	c921a783          	lw	a5,-878(gp) # 400059c <g_crgBaseAddr>
 3006156:	eb89                	bnez	a5,3006168 <CRG_AnaEnableSet+0x3c>
 3006158:	4c500593          	li	a1,1221
 300615c:	030127b7          	lui	a5,0x3012
 3006160:	be078513          	addi	a0,a5,-1056 # 3011be0 <g_crgIpMatch+0x348>
 3006164:	3921                	jal	ra,3005d7c <AssertErrorLog.trans.3>
 3006166:	a001                	j	3006166 <CRG_AnaEnableSet+0x3a>
    CRG_PARAM_CHECK_NO_RET(enable == IP_CLK_ENABLE || enable == IP_CLK_DISABLE);
 3006168:	fd842703          	lw	a4,-40(s0)
 300616c:	4785                	li	a5,1
 300616e:	00f70d63          	beq	a4,a5,3006188 <CRG_AnaEnableSet+0x5c>
 3006172:	fd842783          	lw	a5,-40(s0)
 3006176:	cb89                	beqz	a5,3006188 <CRG_AnaEnableSet+0x5c>
 3006178:	4c600593          	li	a1,1222
 300617c:	030127b7          	lui	a5,0x3012
 3006180:	be078513          	addi	a0,a5,-1056 # 3011be0 <g_crgIpMatch+0x348>
 3006184:	3ee5                	jal	ra,3005d7c <AssertErrorLog.trans.3>
 3006186:	a209                	j	3006288 <CRG_AnaEnableSet+0x15c>

    /* Get the value of the ANA IP register in the CRG. */
    uintptr_t base = (uintptr_t)(void *)g_crgBaseAddr;
 3006188:	c921a783          	lw	a5,-878(gp) # 400059c <g_crgBaseAddr>
 300618c:	fef42623          	sw	a5,-20(s0)
    CRG_AnaIpCfg *p = (CRG_AnaIpCfg *)(void *)(base + matchInfo->regOffset + matchInfo->bitOffset);
 3006190:	fdc42783          	lw	a5,-36(s0)
 3006194:	279e                	lhu	a5,8(a5)
 3006196:	873e                	mv	a4,a5
 3006198:	fec42783          	lw	a5,-20(s0)
 300619c:	97ba                	add	a5,a5,a4
 300619e:	fdc42703          	lw	a4,-36(s0)
 30061a2:	2738                	lbu	a4,10(a4)
 30061a4:	97ba                	add	a5,a5,a4
 30061a6:	fef42423          	sw	a5,-24(s0)

    if ((enable == IP_CLK_ENABLE) && (p->BIT.ip_srst_req == BASE_CFG_SET)) {
 30061aa:	fd842703          	lw	a4,-40(s0)
 30061ae:	4785                	li	a5,1
 30061b0:	02f71b63          	bne	a4,a5,30061e6 <CRG_AnaEnableSet+0xba>
 30061b4:	fe842783          	lw	a5,-24(s0)
 30061b8:	439c                	lw	a5,0(a5)
 30061ba:	83c1                	srli	a5,a5,0x10
 30061bc:	8b85                	andi	a5,a5,1
 30061be:	0ff7f713          	andi	a4,a5,255
 30061c2:	4785                	li	a5,1
 30061c4:	02f71163          	bne	a4,a5,30061e6 <CRG_AnaEnableSet+0xba>
        p->BIT.ip_srst_req = BASE_CFG_UNSET;
 30061c8:	fe842703          	lw	a4,-24(s0)
 30061cc:	431c                	lw	a5,0(a4)
 30061ce:	76c1                	lui	a3,0xffff0
 30061d0:	16fd                	addi	a3,a3,-1 # fffeffff <RAM_END+0xfbfe7fff>
 30061d2:	8ff5                	and	a5,a5,a3
 30061d4:	c31c                	sw	a5,0(a4)
        g_anaEnableFlag++; /* count enable analog IP number */
 30061d6:	c961c783          	lbu	a5,-874(gp) # 40005a0 <g_anaEnableFlag>
 30061da:	0785                	addi	a5,a5,1
 30061dc:	0ff7f713          	andi	a4,a5,255
 30061e0:	c8e18b23          	sb	a4,-874(gp) # 40005a0 <g_anaEnableFlag>
 30061e4:	a81d                	j	300621a <CRG_AnaEnableSet+0xee>
    } else if ((enable == IP_CLK_DISABLE) && (p->BIT.ip_srst_req == BASE_CFG_UNSET)) {
 30061e6:	fd842783          	lw	a5,-40(s0)
 30061ea:	eb85                	bnez	a5,300621a <CRG_AnaEnableSet+0xee>
 30061ec:	fe842783          	lw	a5,-24(s0)
 30061f0:	439c                	lw	a5,0(a5)
 30061f2:	83c1                	srli	a5,a5,0x10
 30061f4:	8b85                	andi	a5,a5,1
 30061f6:	9f81                	uxtb	a5
 30061f8:	e38d                	bnez	a5,300621a <CRG_AnaEnableSet+0xee>
        p->BIT.ip_srst_req = BASE_CFG_SET;
 30061fa:	fe842703          	lw	a4,-24(s0)
 30061fe:	431c                	lw	a5,0(a4)
 3006200:	66c1                	lui	a3,0x10
 3006202:	8fd5                	or	a5,a5,a3
 3006204:	c31c                	sw	a5,0(a4)
        if (g_anaEnableFlag > 0) {
 3006206:	c961c783          	lbu	a5,-874(gp) # 40005a0 <g_anaEnableFlag>
 300620a:	cb81                	beqz	a5,300621a <CRG_AnaEnableSet+0xee>
            g_anaEnableFlag--; /* Decreasing the count to enable the analog IP number. */
 300620c:	c961c783          	lbu	a5,-874(gp) # 40005a0 <g_anaEnableFlag>
 3006210:	17fd                	addi	a5,a5,-1
 3006212:	0ff7f713          	andi	a4,a5,255
 3006216:	c8e18b23          	sb	a4,-874(gp) # 40005a0 <g_anaEnableFlag>
        }
    }

    if ((g_anaEnableFlag == 0) && (enable == IP_CLK_DISABLE)) { /* all analog clock disable */
 300621a:	c961c783          	lbu	a5,-874(gp) # 40005a0 <g_anaEnableFlag>
 300621e:	eb85                	bnez	a5,300624e <CRG_AnaEnableSet+0x122>
 3006220:	fd842783          	lw	a5,-40(s0)
 3006224:	e78d                	bnez	a5,300624e <CRG_AnaEnableSet+0x122>
        CRG->PERI_CRG660.BIT.clk_ana_cken = BASE_CFG_UNSET;
 3006226:	10000737          	lui	a4,0x10000
 300622a:	6785                	lui	a5,0x1
 300622c:	973e                	add	a4,a4,a5
 300622e:	a5072783          	lw	a5,-1456(a4) # ffffa50 <RAM_END+0xbff7a50>
 3006232:	9bf9                	andi	a5,a5,-2
 3006234:	a4f72823          	sw	a5,-1456(a4)
        CRG->PERI_CRG660.BIT.ana_srst_req = BASE_CFG_SET;
 3006238:	10000737          	lui	a4,0x10000
 300623c:	6785                	lui	a5,0x1
 300623e:	973e                	add	a4,a4,a5
 3006240:	a5072783          	lw	a5,-1456(a4) # ffffa50 <RAM_END+0xbff7a50>
 3006244:	66c1                	lui	a3,0x10
 3006246:	8fd5                	or	a5,a5,a3
 3006248:	a4f72823          	sw	a5,-1456(a4)
 300624c:	a835                	j	3006288 <CRG_AnaEnableSet+0x15c>
    } else if ((g_anaEnableFlag > 0) && (enable == IP_CLK_ENABLE)) {  /* all analog clock enable */
 300624e:	c961c783          	lbu	a5,-874(gp) # 40005a0 <g_anaEnableFlag>
 3006252:	cb9d                	beqz	a5,3006288 <CRG_AnaEnableSet+0x15c>
 3006254:	fd842703          	lw	a4,-40(s0)
 3006258:	4785                	li	a5,1
 300625a:	02f71763          	bne	a4,a5,3006288 <CRG_AnaEnableSet+0x15c>
        CRG->PERI_CRG660.BIT.ana_srst_req = BASE_CFG_UNSET;
 300625e:	10000737          	lui	a4,0x10000
 3006262:	6785                	lui	a5,0x1
 3006264:	973e                	add	a4,a4,a5
 3006266:	a5072783          	lw	a5,-1456(a4) # ffffa50 <RAM_END+0xbff7a50>
 300626a:	76c1                	lui	a3,0xffff0
 300626c:	16fd                	addi	a3,a3,-1 # fffeffff <RAM_END+0xfbfe7fff>
 300626e:	8ff5                	and	a5,a5,a3
 3006270:	a4f72823          	sw	a5,-1456(a4)
        CRG->PERI_CRG660.BIT.clk_ana_cken = BASE_CFG_SET;
 3006274:	10000737          	lui	a4,0x10000
 3006278:	6785                	lui	a5,0x1
 300627a:	973e                	add	a4,a4,a5
 300627c:	a5072783          	lw	a5,-1456(a4) # ffffa50 <RAM_END+0xbff7a50>
 3006280:	0017e793          	ori	a5,a5,1
 3006284:	a4f72823          	sw	a5,-1456(a4)
    }
}
 3006288:	50b2                	lw	ra,44(sp)
 300628a:	5422                	lw	s0,40(sp)
 300628c:	6145                	addi	sp,sp,48
 300628e:	8082                	ret

03006290 <CRG_AnaEnableGet>:
 * @brief Get Clock of ANA
 * @param matchInfo ANA match Info
 * @return unsigned int IP_CLK_ENABLE or IP_CRG_DISABLE
 */
static unsigned int CRG_AnaEnableGet(const CHIP_CrgIpMatchInfo *matchInfo)
{
 3006290:	7179                	addi	sp,sp,-48
 3006292:	d606                	sw	ra,44(sp)
 3006294:	d422                	sw	s0,40(sp)
 3006296:	1800                	addi	s0,sp,48
 3006298:	fca42e23          	sw	a0,-36(s0)
    CRG_ASSERT_PARAM(matchInfo != NULL);
 300629c:	fdc42783          	lw	a5,-36(s0)
 30062a0:	eb89                	bnez	a5,30062b2 <CRG_AnaEnableGet+0x22>
 30062a2:	4e600593          	li	a1,1254
 30062a6:	030127b7          	lui	a5,0x3012
 30062aa:	be078513          	addi	a0,a5,-1056 # 3011be0 <g_crgIpMatch+0x348>
 30062ae:	34f9                	jal	ra,3005d7c <AssertErrorLog.trans.3>
 30062b0:	a001                	j	30062b0 <CRG_AnaEnableGet+0x20>
    CRG_ASSERT_PARAM(g_crgBaseAddr != NULL);
 30062b2:	c921a783          	lw	a5,-878(gp) # 400059c <g_crgBaseAddr>
 30062b6:	eb89                	bnez	a5,30062c8 <CRG_AnaEnableGet+0x38>
 30062b8:	4e700593          	li	a1,1255
 30062bc:	030127b7          	lui	a5,0x3012
 30062c0:	be078513          	addi	a0,a5,-1056 # 3011be0 <g_crgIpMatch+0x348>
 30062c4:	3c65                	jal	ra,3005d7c <AssertErrorLog.trans.3>
 30062c6:	a001                	j	30062c6 <CRG_AnaEnableGet+0x36>

    /* Get the value of the ANA IP register in the CRG. */
    uintptr_t base = (uintptr_t)(void *)g_crgBaseAddr;
 30062c8:	c921a783          	lw	a5,-878(gp) # 400059c <g_crgBaseAddr>
 30062cc:	fef42623          	sw	a5,-20(s0)
    CRG_AnaIpCfg *p = (CRG_AnaIpCfg *)(void *)(base + matchInfo->regOffset + matchInfo->bitOffset);
 30062d0:	fdc42783          	lw	a5,-36(s0)
 30062d4:	279e                	lhu	a5,8(a5)
 30062d6:	873e                	mv	a4,a5
 30062d8:	fec42783          	lw	a5,-20(s0)
 30062dc:	97ba                	add	a5,a5,a4
 30062de:	fdc42703          	lw	a4,-36(s0)
 30062e2:	2738                	lbu	a4,10(a4)
 30062e4:	97ba                	add	a5,a5,a4
 30062e6:	fef42423          	sw	a5,-24(s0)
    /* The clock is enabled based on the IP reset status. */
    return (p->BIT.ip_srst_req) ? BASE_CFG_UNSET : BASE_CFG_SET;
 30062ea:	fe842783          	lw	a5,-24(s0)
 30062ee:	439c                	lw	a5,0(a5)
 30062f0:	83c1                	srli	a5,a5,0x10
 30062f2:	8b85                	andi	a5,a5,1
 30062f4:	9f81                	uxtb	a5
 30062f6:	0017c793          	xori	a5,a5,1
 30062fa:	9f81                	uxtb	a5
}
 30062fc:	853e                	mv	a0,a5
 30062fe:	50b2                	lw	ra,44(sp)
 3006300:	5422                	lw	s0,40(sp)
 3006302:	6145                	addi	sp,sp,48
 3006304:	8082                	ret

03006306 <DBG_PrintCh>:
 * @brief   Write a character to the UART port.
 * @param   ch The int promotion of the character to be written.
 * @retval  None.
 */
static void DBG_PrintCh(unsigned int ch)
{
 3006306:	1101                	addi	sp,sp,-32
 3006308:	ce22                	sw	s0,28(sp)
 300630a:	1000                	addi	s0,sp,32
 300630c:	fea42623          	sw	a0,-20(s0)
    while (DBG_PRINTF_UART_PORT->UART_FR.BIT.txff == 1) {
 3006310:	0001                	nop
 3006312:	140027b7          	lui	a5,0x14002
 3006316:	4f9c                	lw	a5,24(a5)
 3006318:	8395                	srli	a5,a5,0x5
 300631a:	8b85                	andi	a5,a5,1
 300631c:	0ff7f713          	andi	a4,a5,255
 3006320:	4785                	li	a5,1
 3006322:	fef708e3          	beq	a4,a5,3006312 <DBG_PrintCh+0xc>
        ;
    }
    DBG_PRINTF_UART_PORT->UART_DR.BIT.data = (unsigned char)ch;
 3006326:	14002737          	lui	a4,0x14002
 300632a:	fec42783          	lw	a5,-20(s0)
 300632e:	0ff7f693          	andi	a3,a5,255
 3006332:	431c                	lw	a5,0(a4)
 3006334:	0ff6f693          	andi	a3,a3,255
 3006338:	f007f793          	andi	a5,a5,-256
 300633c:	8fd5                	or	a5,a5,a3
 300633e:	c31c                	sw	a5,0(a4)
}
 3006340:	0001                	nop
 3006342:	4472                	lw	s0,28(sp)
 3006344:	6105                	addi	sp,sp,32
 3006346:	8082                	ret

03006348 <DBG_PrintStr>:
 * @param   str The string to be printed.
 * @retval  int If succeeded, the total number of characters printed is returned.
 *              If the input parameter is wrong, a BASE_STATUS_ERROR is returned.
 */
static int DBG_PrintStr(const char *str)
{
 3006348:	7179                	addi	sp,sp,-48
 300634a:	d606                	sw	ra,44(sp)
 300634c:	d422                	sw	s0,40(sp)
 300634e:	1800                	addi	s0,sp,48
 3006350:	fca42e23          	sw	a0,-36(s0)
    DEBUG_ASSERT_PARAM(str != NULL);
    int cnt = 0;
 3006354:	fe042623          	sw	zero,-20(s0)
    while (*str != '\0') {
 3006358:	a00d                	j	300637a <DBG_PrintStr+0x32>
        DBG_PrintCh(*str);
 300635a:	fdc42783          	lw	a5,-36(s0)
 300635e:	00078783          	lb	a5,0(a5) # 14002000 <RAM_END+0xfffa000>
 3006362:	853e                	mv	a0,a5
 3006364:	374d                	jal	ra,3006306 <DBG_PrintCh>
        str++;
 3006366:	fdc42783          	lw	a5,-36(s0)
 300636a:	0785                	addi	a5,a5,1
 300636c:	fcf42e23          	sw	a5,-36(s0)
        cnt++;
 3006370:	fec42783          	lw	a5,-20(s0)
 3006374:	0785                	addi	a5,a5,1
 3006376:	fef42623          	sw	a5,-20(s0)
    while (*str != '\0') {
 300637a:	fdc42783          	lw	a5,-36(s0)
 300637e:	00078783          	lb	a5,0(a5)
 3006382:	ffe1                	bnez	a5,300635a <DBG_PrintStr+0x12>
    }
    return cnt;
 3006384:	fec42783          	lw	a5,-20(s0)
}
 3006388:	853e                	mv	a0,a5
 300638a:	50b2                	lw	ra,44(sp)
 300638c:	5422                	lw	s0,40(sp)
 300638e:	6145                	addi	sp,sp,48
 3006390:	8082                	ret

03006392 <DBG_Pow>:
 * @param   base Base value.
 * @param   exponent Exponent value.
 * @retval  unsigned long The result of raising base to the power exponent.
 */
static unsigned long DBG_Pow(unsigned int base, unsigned int exponent)
{
 3006392:	7179                	addi	sp,sp,-48
 3006394:	d622                	sw	s0,44(sp)
 3006396:	1800                	addi	s0,sp,48
 3006398:	fca42e23          	sw	a0,-36(s0)
 300639c:	fcb42c23          	sw	a1,-40(s0)
    unsigned long ret = 1;
 30063a0:	4785                	li	a5,1
 30063a2:	fef42623          	sw	a5,-20(s0)
    while (exponent--) {
 30063a6:	a809                	j	30063b8 <DBG_Pow+0x26>
        ret *= base;
 30063a8:	fec42703          	lw	a4,-20(s0)
 30063ac:	fdc42783          	lw	a5,-36(s0)
 30063b0:	02f707b3          	mul	a5,a4,a5
 30063b4:	fef42623          	sw	a5,-20(s0)
    while (exponent--) {
 30063b8:	fd842783          	lw	a5,-40(s0)
 30063bc:	fff78713          	addi	a4,a5,-1
 30063c0:	fce42c23          	sw	a4,-40(s0)
 30063c4:	f3f5                	bnez	a5,30063a8 <DBG_Pow+0x16>
    }
    return ret; /* ret = base ^ exponent */
 30063c6:	fec42783          	lw	a5,-20(s0)
}
 30063ca:	853e                	mv	a0,a5
 30063cc:	5432                	lw	s0,44(sp)
 30063ce:	6145                	addi	sp,sp,48
 30063d0:	8082                	ret

030063d2 <DBG_CountDigits>:
 * @param   num The number to be counted.
 * @param   base The number base of num.
 * @retval  unsigned int The number of digits.
 */
static unsigned int DBG_CountDigits(int num, NumBase base)
{
 30063d2:	7179                	addi	sp,sp,-48
 30063d4:	d622                	sw	s0,44(sp)
 30063d6:	1800                	addi	s0,sp,48
 30063d8:	fca42e23          	sw	a0,-36(s0)
 30063dc:	fcb42c23          	sw	a1,-40(s0)
    unsigned int cnt = 0;
 30063e0:	fe042623          	sw	zero,-20(s0)
    if (base == 0) {
 30063e4:	fd842783          	lw	a5,-40(s0)
 30063e8:	e78d                	bnez	a5,3006412 <DBG_CountDigits+0x40>
        return 0;
 30063ea:	4781                	li	a5,0
 30063ec:	a099                	j	3006432 <DBG_CountDigits+0x60>
    }
    while (num != 0) {
        cnt++;
 30063ee:	fec42783          	lw	a5,-20(s0)
 30063f2:	0785                	addi	a5,a5,1
 30063f4:	fef42623          	sw	a5,-20(s0)
        if (cnt > MAX_DIV_TIMES) {
 30063f8:	fec42703          	lw	a4,-20(s0)
 30063fc:	47fd                	li	a5,31
 30063fe:	00e7ee63          	bltu	a5,a4,300641a <DBG_CountDigits+0x48>
            break;
        }
        num /= base;
 3006402:	fdc42703          	lw	a4,-36(s0)
 3006406:	fd842783          	lw	a5,-40(s0)
 300640a:	02f757b3          	divu	a5,a4,a5
 300640e:	fcf42e23          	sw	a5,-36(s0)
    while (num != 0) {
 3006412:	fdc42783          	lw	a5,-36(s0)
 3006416:	ffe1                	bnez	a5,30063ee <DBG_CountDigits+0x1c>
 3006418:	a011                	j	300641c <DBG_CountDigits+0x4a>
            break;
 300641a:	0001                	nop
    }
    cnt = (cnt == 0) ? 1 : cnt;
 300641c:	fec42783          	lw	a5,-20(s0)
 3006420:	c781                	beqz	a5,3006428 <DBG_CountDigits+0x56>
 3006422:	fec42783          	lw	a5,-20(s0)
 3006426:	a011                	j	300642a <DBG_CountDigits+0x58>
 3006428:	4785                	li	a5,1
 300642a:	fef42623          	sw	a5,-20(s0)
    return cnt;
 300642e:	fec42783          	lw	a5,-20(s0)
}
 3006432:	853e                	mv	a0,a5
 3006434:	5432                	lw	s0,44(sp)
 3006436:	6145                	addi	sp,sp,48
 3006438:	8082                	ret

0300643a <DBG_PutUnsignedNum>:
 * @param   num The unsigned number to be printed.
 * @param   base The number base of num.
 * @param   digits The digits of num.
 */
static void DBG_PutUnsignedNum(unsigned int num, NumBase base, unsigned int digits)
{
 300643a:	7179                	addi	sp,sp,-48
 300643c:	d606                	sw	ra,44(sp)
 300643e:	d422                	sw	s0,40(sp)
 3006440:	1800                	addi	s0,sp,48
 3006442:	fca42e23          	sw	a0,-36(s0)
 3006446:	fcb42c23          	sw	a1,-40(s0)
 300644a:	fcc42a23          	sw	a2,-44(s0)
    unsigned char ch;
    while (digits != 0) {
 300644e:	a069                	j	30064d8 <DBG_PutUnsignedNum+0x9e>
        ch = num / DBG_Pow(base, digits - 1);
 3006450:	fd442783          	lw	a5,-44(s0)
 3006454:	17fd                	addi	a5,a5,-1
 3006456:	85be                	mv	a1,a5
 3006458:	fd842503          	lw	a0,-40(s0)
 300645c:	3f1d                	jal	ra,3006392 <DBG_Pow>
 300645e:	872a                	mv	a4,a0
 3006460:	fdc42783          	lw	a5,-36(s0)
 3006464:	02e7d7b3          	divu	a5,a5,a4
 3006468:	fef407a3          	sb	a5,-17(s0)
        num %= DBG_Pow(base, digits - 1);
 300646c:	fd442783          	lw	a5,-44(s0)
 3006470:	17fd                	addi	a5,a5,-1
 3006472:	85be                	mv	a1,a5
 3006474:	fd842503          	lw	a0,-40(s0)
 3006478:	3f29                	jal	ra,3006392 <DBG_Pow>
 300647a:	872a                	mv	a4,a0
 300647c:	fdc42783          	lw	a5,-36(s0)
 3006480:	02e7f7b3          	remu	a5,a5,a4
 3006484:	fcf42e23          	sw	a5,-36(s0)
        if (base == DECIMAL) {
 3006488:	fd842703          	lw	a4,-40(s0)
 300648c:	47a9                	li	a5,10
 300648e:	00f71963          	bne	a4,a5,30064a0 <DBG_PutUnsignedNum+0x66>
            DBG_PrintCh(ch + '0');
 3006492:	fef44783          	lbu	a5,-17(s0)
 3006496:	03078793          	addi	a5,a5,48
 300649a:	853e                	mv	a0,a5
 300649c:	35ad                	jal	ra,3006306 <DBG_PrintCh>
 300649e:	a805                	j	30064ce <DBG_PutUnsignedNum+0x94>
        } else if (base == HEXADECIMAL) {
 30064a0:	fd842703          	lw	a4,-40(s0)
 30064a4:	47c1                	li	a5,16
 30064a6:	02f71d63          	bne	a4,a5,30064e0 <DBG_PutUnsignedNum+0xa6>
            if (ch < DECIMAL_BASE) {
 30064aa:	fef44703          	lbu	a4,-17(s0)
 30064ae:	47a5                	li	a5,9
 30064b0:	00e7e963          	bltu	a5,a4,30064c2 <DBG_PutUnsignedNum+0x88>
                DBG_PrintCh(ch + '0');
 30064b4:	fef44783          	lbu	a5,-17(s0)
 30064b8:	03078793          	addi	a5,a5,48
 30064bc:	853e                	mv	a0,a5
 30064be:	35a1                	jal	ra,3006306 <DBG_PrintCh>
 30064c0:	a039                	j	30064ce <DBG_PutUnsignedNum+0x94>
            } else {
                DBG_PrintCh(ch - DECIMAL_BASE + 'A');
 30064c2:	fef44783          	lbu	a5,-17(s0)
 30064c6:	03778793          	addi	a5,a5,55
 30064ca:	853e                	mv	a0,a5
 30064cc:	3d2d                	jal	ra,3006306 <DBG_PrintCh>
            }
        } else {
            break;
        }
        digits--;
 30064ce:	fd442783          	lw	a5,-44(s0)
 30064d2:	17fd                	addi	a5,a5,-1
 30064d4:	fcf42a23          	sw	a5,-44(s0)
    while (digits != 0) {
 30064d8:	fd442783          	lw	a5,-44(s0)
 30064dc:	fbb5                	bnez	a5,3006450 <DBG_PutUnsignedNum+0x16>
    }
}
 30064de:	a011                	j	30064e2 <DBG_PutUnsignedNum+0xa8>
            break;
 30064e0:	0001                	nop
}
 30064e2:	0001                	nop
 30064e4:	50b2                	lw	ra,44(sp)
 30064e6:	5422                	lw	s0,40(sp)
 30064e8:	6145                	addi	sp,sp,48
 30064ea:	8082                	ret

030064ec <DBG_PrintInt>:
 * @brief   Print decimal number through UART port.
 * @param   intNum The decimal number to be printed.
 * @retval  unsigned int The total number of characters printed.
 */
static unsigned int DBG_PrintInt(int intNum)
{
 30064ec:	7179                	addi	sp,sp,-48
 30064ee:	d606                	sw	ra,44(sp)
 30064f0:	d422                	sw	s0,40(sp)
 30064f2:	1800                	addi	s0,sp,48
 30064f4:	fca42e23          	sw	a0,-36(s0)
    unsigned int cnt;
    if (intNum == 0) {
 30064f8:	fdc42783          	lw	a5,-36(s0)
 30064fc:	e791                	bnez	a5,3006508 <DBG_PrintInt+0x1c>
        DBG_PrintCh('0');
 30064fe:	03000513          	li	a0,48
 3006502:	3511                	jal	ra,3006306 <DBG_PrintCh>
        return 1;
 3006504:	4785                	li	a5,1
 3006506:	a82d                	j	3006540 <DBG_PrintInt+0x54>
    }
    if (intNum < 0) {
 3006508:	fdc42783          	lw	a5,-36(s0)
 300650c:	0007db63          	bgez	a5,3006522 <DBG_PrintInt+0x36>
        DBG_PrintCh('-');
 3006510:	02d00513          	li	a0,45
 3006514:	3bcd                	jal	ra,3006306 <DBG_PrintCh>
        intNum = -intNum;
 3006516:	fdc42783          	lw	a5,-36(s0)
 300651a:	40f007b3          	neg	a5,a5
 300651e:	fcf42e23          	sw	a5,-36(s0)
    }
    cnt = DBG_CountDigits(intNum, DECIMAL);
 3006522:	45a9                	li	a1,10
 3006524:	fdc42503          	lw	a0,-36(s0)
 3006528:	356d                	jal	ra,30063d2 <DBG_CountDigits>
 300652a:	fea42623          	sw	a0,-20(s0)
    DBG_PutUnsignedNum(intNum, DECIMAL, cnt);
 300652e:	fdc42783          	lw	a5,-36(s0)
 3006532:	fec42603          	lw	a2,-20(s0)
 3006536:	45a9                	li	a1,10
 3006538:	853e                	mv	a0,a5
 300653a:	3701                	jal	ra,300643a <DBG_PutUnsignedNum>
    return cnt;
 300653c:	fec42783          	lw	a5,-20(s0)
}
 3006540:	853e                	mv	a0,a5
 3006542:	50b2                	lw	ra,44(sp)
 3006544:	5422                	lw	s0,40(sp)
 3006546:	6145                	addi	sp,sp,48
 3006548:	8082                	ret

0300654a <DBG_PrintHex>:
 * @brief   Print hexadecimal number through UART port.
 * @param   hexNum The hexadecimal number to be printed.
 * @retval  unsigned int The total number of characters printed.
 */
static unsigned int DBG_PrintHex(unsigned int hexNum)
{
 300654a:	7179                	addi	sp,sp,-48
 300654c:	d606                	sw	ra,44(sp)
 300654e:	d422                	sw	s0,40(sp)
 3006550:	1800                	addi	s0,sp,48
 3006552:	fca42e23          	sw	a0,-36(s0)
    unsigned int cnt;
    if (hexNum == 0) {
 3006556:	fdc42783          	lw	a5,-36(s0)
 300655a:	e791                	bnez	a5,3006566 <DBG_PrintHex+0x1c>
        DBG_PrintCh('0');
 300655c:	03000513          	li	a0,48
 3006560:	335d                	jal	ra,3006306 <DBG_PrintCh>
        return 1;
 3006562:	4785                	li	a5,1
 3006564:	a005                	j	3006584 <DBG_PrintHex+0x3a>
    }
    cnt = DBG_CountDigits(hexNum, HEXADECIMAL);
 3006566:	fdc42783          	lw	a5,-36(s0)
 300656a:	45c1                	li	a1,16
 300656c:	853e                	mv	a0,a5
 300656e:	3595                	jal	ra,30063d2 <DBG_CountDigits>
 3006570:	fea42623          	sw	a0,-20(s0)
    DBG_PutUnsignedNum(hexNum, HEXADECIMAL, cnt);
 3006574:	fec42603          	lw	a2,-20(s0)
 3006578:	45c1                	li	a1,16
 300657a:	fdc42503          	lw	a0,-36(s0)
 300657e:	3d75                	jal	ra,300643a <DBG_PutUnsignedNum>
    return cnt;
 3006580:	fec42783          	lw	a5,-20(s0)
}
 3006584:	853e                	mv	a0,a5
 3006586:	50b2                	lw	ra,44(sp)
 3006588:	5422                	lw	s0,40(sp)
 300658a:	6145                	addi	sp,sp,48
 300658c:	8082                	ret

0300658e <DBG_PrintFlt>:
 * @brief   Print floating-point number through UART port.
 * @param   fltNum The floating-point number to be printed.
 * @retval  unsigned int The total number of characters printed.
 */
static unsigned int DBG_PrintFlt(float fltNum, unsigned int precision)
{
 300658e:	7139                	addi	sp,sp,-64
 3006590:	de06                	sw	ra,60(sp)
 3006592:	dc22                	sw	s0,56(sp)
 3006594:	0080                	addi	s0,sp,64
 3006596:	fca42627          	fsw	fa0,-52(s0)
 300659a:	fca42423          	sw	a0,-56(s0)
    unsigned int cnt = 0;
 300659e:	fe042623          	sw	zero,-20(s0)
    unsigned int floatScale;

    if (fltNum < 0) {
 30065a2:	fcc42787          	flw	fa5,-52(s0)
 30065a6:	f0000753          	fmv.w.x	fa4,zero
 30065aa:	a0e797d3          	flt.s	a5,fa5,fa4
 30065ae:	cf99                	beqz	a5,30065cc <DBG_PrintFlt+0x3e>
        DBG_PrintCh('-');
 30065b0:	02d00513          	li	a0,45
 30065b4:	3b89                	jal	ra,3006306 <DBG_PrintCh>
        cnt += 1;
 30065b6:	fec42783          	lw	a5,-20(s0)
 30065ba:	0785                	addi	a5,a5,1
 30065bc:	fef42623          	sw	a5,-20(s0)
        fltNum = -fltNum;
 30065c0:	fcc42787          	flw	fa5,-52(s0)
 30065c4:	20f797d3          	fneg.s	fa5,fa5
 30065c8:	fcf42627          	fsw	fa5,-52(s0)
    }
    int integerVal = (int)fltNum;
 30065cc:	fcc42787          	flw	fa5,-52(s0)
 30065d0:	c00797d3          	fcvt.w.s	a5,fa5,rtz
 30065d4:	fef42023          	sw	a5,-32(s0)
    floatScale = DBG_Pow(10, (precision + 1)); /* 10: decimal */
 30065d8:	fc842783          	lw	a5,-56(s0)
 30065dc:	0785                	addi	a5,a5,1
 30065de:	85be                	mv	a1,a5
 30065e0:	4529                	li	a0,10
 30065e2:	3b45                	jal	ra,3006392 <DBG_Pow>
 30065e4:	fca42e23          	sw	a0,-36(s0)
    int floatVal = (long)(floatScale * (fltNum - integerVal));
 30065e8:	fdc42783          	lw	a5,-36(s0)
 30065ec:	d017f753          	fcvt.s.wu	fa4,a5
 30065f0:	fe042783          	lw	a5,-32(s0)
 30065f4:	d007f7d3          	fcvt.s.w	fa5,a5
 30065f8:	fcc42687          	flw	fa3,-52(s0)
 30065fc:	08f6f7d3          	fsub.s	fa5,fa3,fa5
 3006600:	10f777d3          	fmul.s	fa5,fa4,fa5
 3006604:	c00797d3          	fcvt.w.s	a5,fa5,rtz
 3006608:	fef42423          	sw	a5,-24(s0)
    /* Half-adjust: round up or round down */
    if (floatVal % DECIMAL_BASE >= HALF_ADJUST_BOUNDARY) {
 300660c:	fe842703          	lw	a4,-24(s0)
 3006610:	47a9                	li	a5,10
 3006612:	02f77733          	remu	a4,a4,a5
 3006616:	4791                	li	a5,4
 3006618:	00e7fb63          	bgeu	a5,a4,300662e <DBG_PrintFlt+0xa0>
        floatVal = floatVal / DECIMAL_BASE + 1;
 300661c:	fe842703          	lw	a4,-24(s0)
 3006620:	47a9                	li	a5,10
 3006622:	02f757b3          	divu	a5,a4,a5
 3006626:	0785                	addi	a5,a5,1
 3006628:	fef42423          	sw	a5,-24(s0)
 300662c:	a801                	j	300663c <DBG_PrintFlt+0xae>
    } else {
        floatVal = floatVal / DECIMAL_BASE;
 300662e:	fe842703          	lw	a4,-24(s0)
 3006632:	47a9                	li	a5,10
 3006634:	02f757b3          	divu	a5,a4,a5
 3006638:	fef42423          	sw	a5,-24(s0)
    }
    cnt += DBG_PrintInt(integerVal);
 300663c:	fe042503          	lw	a0,-32(s0)
 3006640:	3575                	jal	ra,30064ec <DBG_PrintInt>
 3006642:	872a                	mv	a4,a0
 3006644:	fec42783          	lw	a5,-20(s0)
 3006648:	97ba                	add	a5,a5,a4
 300664a:	fef42623          	sw	a5,-20(s0)
    DBG_PrintCh('.');
 300664e:	02e00513          	li	a0,46
 3006652:	3955                	jal	ra,3006306 <DBG_PrintCh>
    cnt += 1;
 3006654:	fec42783          	lw	a5,-20(s0)
 3006658:	0785                	addi	a5,a5,1
 300665a:	fef42623          	sw	a5,-20(s0)
    /* Pad 0 in float part */
    unsigned int fltCnt = DBG_CountDigits(floatVal, DECIMAL);
 300665e:	45a9                	li	a1,10
 3006660:	fe842503          	lw	a0,-24(s0)
 3006664:	33bd                	jal	ra,30063d2 <DBG_CountDigits>
 3006666:	fca42c23          	sw	a0,-40(s0)
    if (precision > fltCnt) {
 300666a:	fc842703          	lw	a4,-56(s0)
 300666e:	fd842783          	lw	a5,-40(s0)
 3006672:	02e7f763          	bgeu	a5,a4,30066a0 <DBG_PrintFlt+0x112>
        for (unsigned int i = 0; i < precision - fltCnt; i++) {
 3006676:	fe042223          	sw	zero,-28(s0)
 300667a:	a809                	j	300668c <DBG_PrintFlt+0xfe>
            DBG_PrintCh('0'); /* add '0' */
 300667c:	03000513          	li	a0,48
 3006680:	3159                	jal	ra,3006306 <DBG_PrintCh>
        for (unsigned int i = 0; i < precision - fltCnt; i++) {
 3006682:	fe442783          	lw	a5,-28(s0)
 3006686:	0785                	addi	a5,a5,1
 3006688:	fef42223          	sw	a5,-28(s0)
 300668c:	fc842703          	lw	a4,-56(s0)
 3006690:	fd842783          	lw	a5,-40(s0)
 3006694:	40f707b3          	sub	a5,a4,a5
 3006698:	fe442703          	lw	a4,-28(s0)
 300669c:	fef760e3          	bltu	a4,a5,300667c <DBG_PrintFlt+0xee>
        }
    }
    DBG_PutUnsignedNum(floatVal, DECIMAL, fltCnt); /* print unsigned number */
 30066a0:	fe842783          	lw	a5,-24(s0)
 30066a4:	fd842603          	lw	a2,-40(s0)
 30066a8:	45a9                	li	a1,10
 30066aa:	853e                	mv	a0,a5
 30066ac:	3379                	jal	ra,300643a <DBG_PutUnsignedNum>
    cnt += precision;
 30066ae:	fec42703          	lw	a4,-20(s0)
 30066b2:	fc842783          	lw	a5,-56(s0)
 30066b6:	97ba                	add	a5,a5,a4
 30066b8:	fef42623          	sw	a5,-20(s0)
    return cnt;
 30066bc:	fec42783          	lw	a5,-20(s0)
}
 30066c0:	853e                	mv	a0,a5
 30066c2:	50f2                	lw	ra,60(sp)
 30066c4:	5462                	lw	s0,56(sp)
 30066c6:	6121                	addi	sp,sp,64
 30066c8:	8082                	ret

030066ca <ParseSpecifier>:
 * @param   ch The format specifier.
 * @param   paramList The pointer of the variable parameter list.
 * @retval  unsigned int The total number of characters printed.
 */
static unsigned int ParseSpecifier(const char ch, va_list *paramList)
{
 30066ca:	7139                	addi	sp,sp,-64
 30066cc:	de06                	sw	ra,60(sp)
 30066ce:	dc22                	sw	s0,56(sp)
 30066d0:	0080                	addi	s0,sp,64
 30066d2:	87aa                	mv	a5,a0
 30066d4:	fcb42423          	sw	a1,-56(s0)
 30066d8:	fcf407a3          	sb	a5,-49(s0)
    unsigned int cnt = 0;
 30066dc:	fe042623          	sw	zero,-20(s0)
    unsigned int tmpCnt;
    char chVal = 0;
 30066e0:	fe0405a3          	sb	zero,-21(s0)
    const char *strVal = NULL;
 30066e4:	fe042223          	sw	zero,-28(s0)
    int intVal = 0;
 30066e8:	fe042023          	sw	zero,-32(s0)
    unsigned int unsignedVal = 0;
 30066ec:	fc042e23          	sw	zero,-36(s0)
    unsigned int hexVal = 0;
 30066f0:	fc042c23          	sw	zero,-40(s0)
    float fltVal = 0;
 30066f4:	fc042a23          	sw	zero,-44(s0)
    switch (ch) {
 30066f8:	fcf40783          	lb	a5,-49(s0)
 30066fc:	fa878793          	addi	a5,a5,-88
 3006700:	02000713          	li	a4,32
 3006704:	14f76063          	bltu	a4,a5,3006844 <ParseSpecifier+0x17a>
 3006708:	00279713          	slli	a4,a5,0x2
 300670c:	030127b7          	lui	a5,0x3012
 3006710:	c3878793          	addi	a5,a5,-968 # 3011c38 <g_crgIpMatch+0x3a0>
 3006714:	97ba                	add	a5,a5,a4
 3006716:	439c                	lw	a5,0(a5)
 3006718:	8782                	jr	a5
        case 'c': /* Character format data. */
            chVal = VA_ARG(*paramList, int); /* Use type int because of byte alignment */
 300671a:	fc842783          	lw	a5,-56(s0)
 300671e:	439c                	lw	a5,0(a5)
 3006720:	00478693          	addi	a3,a5,4
 3006724:	fc842703          	lw	a4,-56(s0)
 3006728:	c314                	sw	a3,0(a4)
 300672a:	439c                	lw	a5,0(a5)
 300672c:	fef405a3          	sb	a5,-21(s0)
            DBG_PrintCh(chVal);
 3006730:	feb40783          	lb	a5,-21(s0)
 3006734:	853e                	mv	a0,a5
 3006736:	3ec1                	jal	ra,3006306 <DBG_PrintCh>
            cnt += 1;
 3006738:	fec42783          	lw	a5,-20(s0)
 300673c:	0785                	addi	a5,a5,1
 300673e:	fef42623          	sw	a5,-20(s0)
            break;
 3006742:	aa19                	j	3006858 <ParseSpecifier+0x18e>
        case 's': /* String format data. */
            strVal = VA_ARG(*paramList, const char *);
 3006744:	fc842783          	lw	a5,-56(s0)
 3006748:	439c                	lw	a5,0(a5)
 300674a:	00478693          	addi	a3,a5,4
 300674e:	fc842703          	lw	a4,-56(s0)
 3006752:	c314                	sw	a3,0(a4)
 3006754:	439c                	lw	a5,0(a5)
 3006756:	fef42223          	sw	a5,-28(s0)
            cnt += DBG_PrintStr(strVal);
 300675a:	fe442503          	lw	a0,-28(s0)
 300675e:	36ed                	jal	ra,3006348 <DBG_PrintStr>
 3006760:	87aa                	mv	a5,a0
 3006762:	873e                	mv	a4,a5
 3006764:	fec42783          	lw	a5,-20(s0)
 3006768:	97ba                	add	a5,a5,a4
 300676a:	fef42623          	sw	a5,-20(s0)
            break;
 300676e:	a0ed                	j	3006858 <ParseSpecifier+0x18e>
        case 'd': /* Integer decimal data. */
            intVal = VA_ARG(*paramList, int);
 3006770:	fc842783          	lw	a5,-56(s0)
 3006774:	439c                	lw	a5,0(a5)
 3006776:	00478693          	addi	a3,a5,4
 300677a:	fc842703          	lw	a4,-56(s0)
 300677e:	c314                	sw	a3,0(a4)
 3006780:	439c                	lw	a5,0(a5)
 3006782:	fef42023          	sw	a5,-32(s0)
            cnt += DBG_PrintInt(intVal);
 3006786:	fe042503          	lw	a0,-32(s0)
 300678a:	338d                	jal	ra,30064ec <DBG_PrintInt>
 300678c:	872a                	mv	a4,a0
 300678e:	fec42783          	lw	a5,-20(s0)
 3006792:	97ba                	add	a5,a5,a4
 3006794:	fef42623          	sw	a5,-20(s0)
            break;
 3006798:	a0c1                	j	3006858 <ParseSpecifier+0x18e>
        case 'u': /* Unsigned decimal data. */
            unsignedVal = VA_ARG(*paramList, unsigned int);
 300679a:	fc842783          	lw	a5,-56(s0)
 300679e:	439c                	lw	a5,0(a5)
 30067a0:	00478693          	addi	a3,a5,4
 30067a4:	fc842703          	lw	a4,-56(s0)
 30067a8:	c314                	sw	a3,0(a4)
 30067aa:	439c                	lw	a5,0(a5)
 30067ac:	fcf42e23          	sw	a5,-36(s0)
            tmpCnt = DBG_CountDigits(unsignedVal, DECIMAL);
 30067b0:	fdc42783          	lw	a5,-36(s0)
 30067b4:	45a9                	li	a1,10
 30067b6:	853e                	mv	a0,a5
 30067b8:	3929                	jal	ra,30063d2 <DBG_CountDigits>
 30067ba:	fca42823          	sw	a0,-48(s0)
            DBG_PutUnsignedNum(unsignedVal, DECIMAL, tmpCnt);
 30067be:	fd042603          	lw	a2,-48(s0)
 30067c2:	45a9                	li	a1,10
 30067c4:	fdc42503          	lw	a0,-36(s0)
 30067c8:	398d                	jal	ra,300643a <DBG_PutUnsignedNum>
            cnt += tmpCnt;
 30067ca:	fec42703          	lw	a4,-20(s0)
 30067ce:	fd042783          	lw	a5,-48(s0)
 30067d2:	97ba                	add	a5,a5,a4
 30067d4:	fef42623          	sw	a5,-20(s0)
            break;
 30067d8:	a041                	j	3006858 <ParseSpecifier+0x18e>
        case 'x': /* Hexadecimal data. */
        case 'X':
        case 'p': /* Address data. */
            hexVal = VA_ARG(*paramList, unsigned int);
 30067da:	fc842783          	lw	a5,-56(s0)
 30067de:	439c                	lw	a5,0(a5)
 30067e0:	00478693          	addi	a3,a5,4
 30067e4:	fc842703          	lw	a4,-56(s0)
 30067e8:	c314                	sw	a3,0(a4)
 30067ea:	439c                	lw	a5,0(a5)
 30067ec:	fcf42c23          	sw	a5,-40(s0)
            cnt += DBG_PrintHex(hexVal);
 30067f0:	fd842503          	lw	a0,-40(s0)
 30067f4:	3b99                	jal	ra,300654a <DBG_PrintHex>
 30067f6:	872a                	mv	a4,a0
 30067f8:	fec42783          	lw	a5,-20(s0)
 30067fc:	97ba                	add	a5,a5,a4
 30067fe:	fef42623          	sw	a5,-20(s0)
            break;
 3006802:	a899                	j	3006858 <ParseSpecifier+0x18e>
        case 'f': /* Floating-point data. */
            fltVal = VA_ARG(*paramList, double);
 3006804:	fc842783          	lw	a5,-56(s0)
 3006808:	439c                	lw	a5,0(a5)
 300680a:	079d                	addi	a5,a5,7
 300680c:	9be1                	andi	a5,a5,-8
 300680e:	00878693          	addi	a3,a5,8
 3006812:	fc842703          	lw	a4,-56(s0)
 3006816:	c314                	sw	a3,0(a4)
 3006818:	0047a803          	lw	a6,4(a5)
 300681c:	439c                	lw	a5,0(a5)
 300681e:	853e                	mv	a0,a5
 3006820:	85c2                	mv	a1,a6
 3006822:	0c50a0ef          	jal	ra,30110e6 <__truncdfsf2>
 3006826:	20a507d3          	fmv.s	fa5,fa0
 300682a:	fcf42a27          	fsw	fa5,-44(s0)
            cnt += DBG_PrintFlt(fltVal, 5); /* default precision: 5 */
 300682e:	4515                	li	a0,5
 3006830:	fd442507          	flw	fa0,-44(s0)
 3006834:	3ba9                	jal	ra,300658e <DBG_PrintFlt>
 3006836:	872a                	mv	a4,a0
 3006838:	fec42783          	lw	a5,-20(s0)
 300683c:	97ba                	add	a5,a5,a4
 300683e:	fef42623          	sw	a5,-20(s0)
            break;
 3006842:	a819                	j	3006858 <ParseSpecifier+0x18e>
        default:
            DBG_PrintCh(ch);
 3006844:	fcf40783          	lb	a5,-49(s0)
 3006848:	853e                	mv	a0,a5
 300684a:	3c75                	jal	ra,3006306 <DBG_PrintCh>
            cnt += 1;
 300684c:	fec42783          	lw	a5,-20(s0)
 3006850:	0785                	addi	a5,a5,1
 3006852:	fef42623          	sw	a5,-20(s0)
            break;
 3006856:	0001                	nop
    }
    return cnt;
 3006858:	fec42783          	lw	a5,-20(s0)
}
 300685c:	853e                	mv	a0,a5
 300685e:	50f2                	lw	ra,60(sp)
 3006860:	5462                	lw	s0,56(sp)
 3006862:	6121                	addi	sp,sp,64
 3006864:	8082                	ret

03006866 <DBG_PrintIntWithField>:
 * @param   intNum The decimal number to be printed.
 * @param   fieldWidth Field width.
 * @retval  unsigned int The total number of characters printed.
 */
static unsigned int DBG_PrintIntWithField(int intNum, int fieldWidth)
{
 3006866:	7139                	addi	sp,sp,-64
 3006868:	de06                	sw	ra,60(sp)
 300686a:	dc22                	sw	s0,56(sp)
 300686c:	0080                	addi	s0,sp,64
 300686e:	fca42623          	sw	a0,-52(s0)
 3006872:	fcb42423          	sw	a1,-56(s0)
    int zeroCnt = 0;
 3006876:	fc042e23          	sw	zero,-36(s0)
    int digitsCnt = 0;
 300687a:	fe042623          	sw	zero,-20(s0)
    unsigned int cnt = 0;
 300687e:	fe042423          	sw	zero,-24(s0)

    if (intNum == 0) {
 3006882:	fcc42783          	lw	a5,-52(s0)
 3006886:	e791                	bnez	a5,3006892 <DBG_PrintIntWithField+0x2c>
        DBG_PrintCh('0');
 3006888:	03000513          	li	a0,48
 300688c:	3cad                	jal	ra,3006306 <DBG_PrintCh>
        return 1;
 300688e:	4785                	li	a5,1
 3006890:	a0dd                	j	3006976 <DBG_PrintIntWithField+0x110>
    }
    if (intNum < 0) {
 3006892:	fcc42783          	lw	a5,-52(s0)
 3006896:	0607dd63          	bgez	a5,3006910 <DBG_PrintIntWithField+0xaa>
        DBG_PrintCh('-'); /* add symbol */
 300689a:	02d00513          	li	a0,45
 300689e:	34a5                	jal	ra,3006306 <DBG_PrintCh>
        cnt++;
 30068a0:	fe842783          	lw	a5,-24(s0)
 30068a4:	0785                	addi	a5,a5,1
 30068a6:	fef42423          	sw	a5,-24(s0)
        intNum = -intNum;
 30068aa:	fcc42783          	lw	a5,-52(s0)
 30068ae:	40f007b3          	neg	a5,a5
 30068b2:	fcf42623          	sw	a5,-52(s0)
        digitsCnt = DBG_CountDigits(intNum, DECIMAL); /* get int value's width */
 30068b6:	45a9                	li	a1,10
 30068b8:	fcc42503          	lw	a0,-52(s0)
 30068bc:	3e19                	jal	ra,30063d2 <DBG_CountDigits>
 30068be:	87aa                	mv	a5,a0
 30068c0:	fef42623          	sw	a5,-20(s0)
        zeroCnt = fieldWidth - digitsCnt;
 30068c4:	fc842703          	lw	a4,-56(s0)
 30068c8:	fec42783          	lw	a5,-20(s0)
 30068cc:	40f707b3          	sub	a5,a4,a5
 30068d0:	fcf42e23          	sw	a5,-36(s0)
        for (int i = 0; i < zeroCnt; i++) {
 30068d4:	fe042223          	sw	zero,-28(s0)
 30068d8:	a831                	j	30068f4 <DBG_PrintIntWithField+0x8e>
            DBG_PrintCh('0'); /* add '0' */
 30068da:	03000513          	li	a0,48
 30068de:	3425                	jal	ra,3006306 <DBG_PrintCh>
            cnt++;
 30068e0:	fe842783          	lw	a5,-24(s0)
 30068e4:	0785                	addi	a5,a5,1
 30068e6:	fef42423          	sw	a5,-24(s0)
        for (int i = 0; i < zeroCnt; i++) {
 30068ea:	fe442783          	lw	a5,-28(s0)
 30068ee:	0785                	addi	a5,a5,1
 30068f0:	fef42223          	sw	a5,-28(s0)
 30068f4:	fe442703          	lw	a4,-28(s0)
 30068f8:	fdc42783          	lw	a5,-36(s0)
 30068fc:	fcf74fe3          	blt	a4,a5,30068da <DBG_PrintIntWithField+0x74>
        }
        cnt += digitsCnt;
 3006900:	fec42783          	lw	a5,-20(s0)
 3006904:	fe842703          	lw	a4,-24(s0)
 3006908:	97ba                	add	a5,a5,a4
 300690a:	fef42423          	sw	a5,-24(s0)
 300690e:	a891                	j	3006962 <DBG_PrintIntWithField+0xfc>
    } else {
        digitsCnt = DBG_CountDigits(intNum, DECIMAL); /* get int value's width */
 3006910:	45a9                	li	a1,10
 3006912:	fcc42503          	lw	a0,-52(s0)
 3006916:	3c75                	jal	ra,30063d2 <DBG_CountDigits>
 3006918:	87aa                	mv	a5,a0
 300691a:	fef42623          	sw	a5,-20(s0)
        cnt = digitsCnt;
 300691e:	fec42783          	lw	a5,-20(s0)
 3006922:	fef42423          	sw	a5,-24(s0)
        zeroCnt = fieldWidth - digitsCnt;
 3006926:	fc842703          	lw	a4,-56(s0)
 300692a:	fec42783          	lw	a5,-20(s0)
 300692e:	40f707b3          	sub	a5,a4,a5
 3006932:	fcf42e23          	sw	a5,-36(s0)
        for (int i = 0; i < zeroCnt; i++) {
 3006936:	fe042023          	sw	zero,-32(s0)
 300693a:	a831                	j	3006956 <DBG_PrintIntWithField+0xf0>
            DBG_PrintCh('0'); /* add '0' */
 300693c:	03000513          	li	a0,48
 3006940:	32d9                	jal	ra,3006306 <DBG_PrintCh>
            cnt++;
 3006942:	fe842783          	lw	a5,-24(s0)
 3006946:	0785                	addi	a5,a5,1
 3006948:	fef42423          	sw	a5,-24(s0)
        for (int i = 0; i < zeroCnt; i++) {
 300694c:	fe042783          	lw	a5,-32(s0)
 3006950:	0785                	addi	a5,a5,1
 3006952:	fef42023          	sw	a5,-32(s0)
 3006956:	fe042703          	lw	a4,-32(s0)
 300695a:	fdc42783          	lw	a5,-36(s0)
 300695e:	fcf74fe3          	blt	a4,a5,300693c <DBG_PrintIntWithField+0xd6>
        }
    }
    DBG_PutUnsignedNum(intNum, DECIMAL, digitsCnt);
 3006962:	fcc42783          	lw	a5,-52(s0)
 3006966:	fec42703          	lw	a4,-20(s0)
 300696a:	863a                	mv	a2,a4
 300696c:	45a9                	li	a1,10
 300696e:	853e                	mv	a0,a5
 3006970:	34e9                	jal	ra,300643a <DBG_PutUnsignedNum>
    return cnt;
 3006972:	fe842783          	lw	a5,-24(s0)
}
 3006976:	853e                	mv	a0,a5
 3006978:	50f2                	lw	ra,60(sp)
 300697a:	5462                	lw	s0,56(sp)
 300697c:	6121                	addi	sp,sp,64
 300697e:	8082                	ret

03006980 <DBG_Atoi>:

static int DBG_Atoi(const char **s)
{
 3006980:	7179                	addi	sp,sp,-48
 3006982:	d622                	sw	s0,44(sp)
 3006984:	1800                	addi	s0,sp,48
 3006986:	fca42e23          	sw	a0,-36(s0)
    int i, c;

    for (i = 0; '0' <= (c = **s) && c <= '9'; ++*s) {
 300698a:	fe042623          	sw	zero,-20(s0)
 300698e:	a02d                	j	30069b8 <DBG_Atoi+0x38>
        i = i * 10  + c - '0'; /* 10: decimal */
 3006990:	fec42703          	lw	a4,-20(s0)
 3006994:	47a9                	li	a5,10
 3006996:	02f70733          	mul	a4,a4,a5
 300699a:	fe842783          	lw	a5,-24(s0)
 300699e:	97ba                	add	a5,a5,a4
 30069a0:	fd078793          	addi	a5,a5,-48
 30069a4:	fef42623          	sw	a5,-20(s0)
    for (i = 0; '0' <= (c = **s) && c <= '9'; ++*s) {
 30069a8:	fdc42783          	lw	a5,-36(s0)
 30069ac:	439c                	lw	a5,0(a5)
 30069ae:	00178713          	addi	a4,a5,1
 30069b2:	fdc42783          	lw	a5,-36(s0)
 30069b6:	c398                	sw	a4,0(a5)
 30069b8:	fdc42783          	lw	a5,-36(s0)
 30069bc:	439c                	lw	a5,0(a5)
 30069be:	00078783          	lb	a5,0(a5)
 30069c2:	fef42423          	sw	a5,-24(s0)
 30069c6:	fe842703          	lw	a4,-24(s0)
 30069ca:	02f00793          	li	a5,47
 30069ce:	00e7d863          	bge	a5,a4,30069de <DBG_Atoi+0x5e>
 30069d2:	fe842703          	lw	a4,-24(s0)
 30069d6:	03900793          	li	a5,57
 30069da:	fae7dbe3          	bge	a5,a4,3006990 <DBG_Atoi+0x10>
    }
    return i;
 30069de:	fec42783          	lw	a5,-20(s0)
}
 30069e2:	853e                	mv	a0,a5
 30069e4:	5432                	lw	s0,44(sp)
 30069e6:	6145                	addi	sp,sp,48
 30069e8:	8082                	ret

030069ea <DBG_UartPrintf>:
 * @param   ...     Variable parameter list.
 * @retval  int     If succeeded, the total number of characters printed is returned.
 *                  If the input parameter is wrong, return BASE_STATUS_ERROR.
 */
int DBG_UartPrintf(const char *format, ...)
{
 30069ea:	711d                	addi	sp,sp,-96
 30069ec:	de06                	sw	ra,60(sp)
 30069ee:	dc22                	sw	s0,56(sp)
 30069f0:	0080                	addi	s0,sp,64
 30069f2:	fca42623          	sw	a0,-52(s0)
 30069f6:	c04c                	sw	a1,4(s0)
 30069f8:	c410                	sw	a2,8(s0)
 30069fa:	c454                	sw	a3,12(s0)
 30069fc:	c818                	sw	a4,16(s0)
 30069fe:	c85c                	sw	a5,20(s0)
 3006a00:	01042c23          	sw	a6,24(s0)
 3006a04:	01142e23          	sw	a7,28(s0)
    DEBUG_ASSERT_PARAM(format != NULL);
    int cnt = 0;
 3006a08:	fe042623          	sw	zero,-20(s0)
    int fieldWidth = 0;
 3006a0c:	fe042423          	sw	zero,-24(s0)
    int floatPrecision = 0;
 3006a10:	fe042223          	sw	zero,-28(s0)
    float fltVal = 0;
 3006a14:	fe042023          	sw	zero,-32(s0)
    int intVal = 0;
 3006a18:	fc042e23          	sw	zero,-36(s0)
    va_list paramList;
    VA_START(paramList, format);
 3006a1c:	02040793          	addi	a5,s0,32
 3006a20:	1791                	addi	a5,a5,-28
 3006a22:	fcf42c23          	sw	a5,-40(s0)

    while (*format != '\0') {
 3006a26:	aa09                	j	3006b38 <DBG_UartPrintf+0x14e>
        if (*format != '%') {
 3006a28:	fcc42783          	lw	a5,-52(s0)
 3006a2c:	00078703          	lb	a4,0(a5)
 3006a30:	02500793          	li	a5,37
 3006a34:	00f70e63          	beq	a4,a5,3006a50 <DBG_UartPrintf+0x66>
            DBG_PrintCh(*format);
 3006a38:	fcc42783          	lw	a5,-52(s0)
 3006a3c:	00078783          	lb	a5,0(a5)
 3006a40:	853e                	mv	a0,a5
 3006a42:	30d1                	jal	ra,3006306 <DBG_PrintCh>
            cnt += 1;
 3006a44:	fec42783          	lw	a5,-20(s0)
 3006a48:	0785                	addi	a5,a5,1
 3006a4a:	fef42623          	sw	a5,-20(s0)
 3006a4e:	a0c5                	j	3006b2e <DBG_UartPrintf+0x144>
        } else {
            format++;
 3006a50:	fcc42783          	lw	a5,-52(s0)
 3006a54:	0785                	addi	a5,a5,1
 3006a56:	fcf42623          	sw	a5,-52(s0)
            if (*format == '0') {
 3006a5a:	fcc42783          	lw	a5,-52(s0)
 3006a5e:	00078703          	lb	a4,0(a5)
 3006a62:	03000793          	li	a5,48
 3006a66:	04f71263          	bne	a4,a5,3006aaa <DBG_UartPrintf+0xc0>
                format++;
 3006a6a:	fcc42783          	lw	a5,-52(s0)
 3006a6e:	0785                	addi	a5,a5,1
 3006a70:	fcf42623          	sw	a5,-52(s0)
                fieldWidth = DBG_Atoi(&format);
 3006a74:	fcc40793          	addi	a5,s0,-52
 3006a78:	853e                	mv	a0,a5
 3006a7a:	3719                	jal	ra,3006980 <DBG_Atoi>
 3006a7c:	fea42423          	sw	a0,-24(s0)
                intVal = VA_ARG(paramList, int);
 3006a80:	fd842783          	lw	a5,-40(s0)
 3006a84:	00478713          	addi	a4,a5,4
 3006a88:	fce42c23          	sw	a4,-40(s0)
 3006a8c:	439c                	lw	a5,0(a5)
 3006a8e:	fcf42e23          	sw	a5,-36(s0)
                cnt += DBG_PrintIntWithField(intVal, fieldWidth);
 3006a92:	fe842583          	lw	a1,-24(s0)
 3006a96:	fdc42503          	lw	a0,-36(s0)
 3006a9a:	33f1                	jal	ra,3006866 <DBG_PrintIntWithField>
 3006a9c:	872a                	mv	a4,a0
 3006a9e:	fec42783          	lw	a5,-20(s0)
 3006aa2:	97ba                	add	a5,a5,a4
 3006aa4:	fef42623          	sw	a5,-20(s0)
 3006aa8:	a059                	j	3006b2e <DBG_UartPrintf+0x144>
            } else if (*format == '.') {
 3006aaa:	fcc42783          	lw	a5,-52(s0)
 3006aae:	00078703          	lb	a4,0(a5)
 3006ab2:	02e00793          	li	a5,46
 3006ab6:	04f71d63          	bne	a4,a5,3006b10 <DBG_UartPrintf+0x126>
                format++;
 3006aba:	fcc42783          	lw	a5,-52(s0)
 3006abe:	0785                	addi	a5,a5,1
 3006ac0:	fcf42623          	sw	a5,-52(s0)
                floatPrecision = DBG_Atoi(&format);
 3006ac4:	fcc40793          	addi	a5,s0,-52
 3006ac8:	853e                	mv	a0,a5
 3006aca:	3d5d                	jal	ra,3006980 <DBG_Atoi>
 3006acc:	fea42223          	sw	a0,-28(s0)
                fltVal = VA_ARG(paramList, double);
 3006ad0:	fd842783          	lw	a5,-40(s0)
 3006ad4:	079d                	addi	a5,a5,7
 3006ad6:	9be1                	andi	a5,a5,-8
 3006ad8:	00878713          	addi	a4,a5,8
 3006adc:	fce42c23          	sw	a4,-40(s0)
 3006ae0:	0047a803          	lw	a6,4(a5)
 3006ae4:	439c                	lw	a5,0(a5)
 3006ae6:	853e                	mv	a0,a5
 3006ae8:	85c2                	mv	a1,a6
 3006aea:	5fc0a0ef          	jal	ra,30110e6 <__truncdfsf2>
 3006aee:	20a507d3          	fmv.s	fa5,fa0
 3006af2:	fef42027          	fsw	fa5,-32(s0)
                cnt += DBG_PrintFlt(fltVal, floatPrecision);
 3006af6:	fe442783          	lw	a5,-28(s0)
 3006afa:	853e                	mv	a0,a5
 3006afc:	fe042507          	flw	fa0,-32(s0)
 3006b00:	3479                	jal	ra,300658e <DBG_PrintFlt>
 3006b02:	872a                	mv	a4,a0
 3006b04:	fec42783          	lw	a5,-20(s0)
 3006b08:	97ba                	add	a5,a5,a4
 3006b0a:	fef42623          	sw	a5,-20(s0)
 3006b0e:	a005                	j	3006b2e <DBG_UartPrintf+0x144>
            } else {
                cnt += ParseSpecifier(*format, &paramList);
 3006b10:	fcc42783          	lw	a5,-52(s0)
 3006b14:	00078783          	lb	a5,0(a5)
 3006b18:	fd840713          	addi	a4,s0,-40
 3006b1c:	85ba                	mv	a1,a4
 3006b1e:	853e                	mv	a0,a5
 3006b20:	366d                	jal	ra,30066ca <ParseSpecifier>
 3006b22:	872a                	mv	a4,a0
 3006b24:	fec42783          	lw	a5,-20(s0)
 3006b28:	97ba                	add	a5,a5,a4
 3006b2a:	fef42623          	sw	a5,-20(s0)
            }
        }
        format++;
 3006b2e:	fcc42783          	lw	a5,-52(s0)
 3006b32:	0785                	addi	a5,a5,1
 3006b34:	fcf42623          	sw	a5,-52(s0)
    while (*format != '\0') {
 3006b38:	fcc42783          	lw	a5,-52(s0)
 3006b3c:	00078783          	lb	a5,0(a5)
 3006b40:	ee0794e3          	bnez	a5,3006a28 <DBG_UartPrintf+0x3e>
    }
    VA_END(paramList);
    return cnt;
 3006b44:	fec42783          	lw	a5,-20(s0)
}
 3006b48:	853e                	mv	a0,a5
 3006b4a:	50f2                	lw	ra,60(sp)
 3006b4c:	5462                	lw	s0,56(sp)
 3006b4e:	6125                	addi	sp,sp,96
 3006b50:	8082                	ret

03006b52 <IsGpioValue>:
  * @brief Check gpio value parameter.
  * @param value Value of @ref GPIO_Value
  * @retval Bool.
  */
static inline bool IsGpioValue(GPIO_Value value)
{
 3006b52:	1101                	addi	sp,sp,-32
 3006b54:	ce22                	sw	s0,28(sp)
 3006b56:	1000                	addi	s0,sp,32
 3006b58:	fea42623          	sw	a0,-20(s0)
    return (value == GPIO_LOW_LEVEL || value == GPIO_HIGH_LEVEL);
 3006b5c:	fec42783          	lw	a5,-20(s0)
 3006b60:	c791                	beqz	a5,3006b6c <IsGpioValue+0x1a>
 3006b62:	fec42703          	lw	a4,-20(s0)
 3006b66:	4785                	li	a5,1
 3006b68:	00f71463          	bne	a4,a5,3006b70 <IsGpioValue+0x1e>
 3006b6c:	4785                	li	a5,1
 3006b6e:	a011                	j	3006b72 <IsGpioValue+0x20>
 3006b70:	4781                	li	a5,0
 3006b72:	8b85                	andi	a5,a5,1
 3006b74:	9f81                	uxtb	a5
}
 3006b76:	853e                	mv	a0,a5
 3006b78:	4472                	lw	s0,28(sp)
 3006b7a:	6105                	addi	sp,sp,32
 3006b7c:	8082                	ret

03006b7e <IsGpioDirection>:
  * @brief Check gpio direction parameter.
  * @param dir Value of @ref GPIO_Direction.
  * @retval Bool.
  */
static inline bool IsGpioDirection(GPIO_Direction dir)
{
 3006b7e:	1101                	addi	sp,sp,-32
 3006b80:	ce22                	sw	s0,28(sp)
 3006b82:	1000                	addi	s0,sp,32
 3006b84:	fea42623          	sw	a0,-20(s0)
    return (dir == GPIO_INPUT_MODE || dir == GPIO_OUTPUT_MODE);
 3006b88:	fec42783          	lw	a5,-20(s0)
 3006b8c:	c791                	beqz	a5,3006b98 <IsGpioDirection+0x1a>
 3006b8e:	fec42703          	lw	a4,-20(s0)
 3006b92:	4785                	li	a5,1
 3006b94:	00f71463          	bne	a4,a5,3006b9c <IsGpioDirection+0x1e>
 3006b98:	4785                	li	a5,1
 3006b9a:	a011                	j	3006b9e <IsGpioDirection+0x20>
 3006b9c:	4781                	li	a5,0
 3006b9e:	8b85                	andi	a5,a5,1
 3006ba0:	9f81                	uxtb	a5
}
 3006ba2:	853e                	mv	a0,a5
 3006ba4:	4472                	lw	s0,28(sp)
 3006ba6:	6105                	addi	sp,sp,32
 3006ba8:	8082                	ret

03006baa <IsGpioPins>:
  * @brief Check gpio pins parameter.
  * @param pins OR logical combination of pin.
  * @retval Bool.
  */
static inline bool IsGpioPins(unsigned int pins)
{
 3006baa:	1101                	addi	sp,sp,-32
 3006bac:	ce22                	sw	s0,28(sp)
 3006bae:	1000                	addi	s0,sp,32
 3006bb0:	fea42623          	sw	a0,-20(s0)
    return ((pins & GPIO_PIN_MASK) != BASE_CFG_UNSET) && ((pins & ~GPIO_PIN_MASK) == BASE_CFG_UNSET);
 3006bb4:	fec42783          	lw	a5,-20(s0)
 3006bb8:	0ff7f793          	andi	a5,a5,255
 3006bbc:	cb81                	beqz	a5,3006bcc <IsGpioPins+0x22>
 3006bbe:	fec42783          	lw	a5,-20(s0)
 3006bc2:	f007f793          	andi	a5,a5,-256
 3006bc6:	e399                	bnez	a5,3006bcc <IsGpioPins+0x22>
 3006bc8:	4785                	li	a5,1
 3006bca:	a011                	j	3006bce <IsGpioPins+0x24>
 3006bcc:	4781                	li	a5,0
 3006bce:	8b85                	andi	a5,a5,1
 3006bd0:	9f81                	uxtb	a5
}
 3006bd2:	853e                	mv	a0,a5
 3006bd4:	4472                	lw	s0,28(sp)
 3006bd6:	6105                	addi	sp,sp,32
 3006bd8:	8082                	ret

03006bda <IsGpioPin>:
  * @brief Check gpio pin parameter.
  * @param pin Value of @ref GPIO_PIN.
  * @retval Bool.
  */
static inline bool IsGpioPin(GPIO_PIN pin)
{
 3006bda:	1101                	addi	sp,sp,-32
 3006bdc:	ce22                	sw	s0,28(sp)
 3006bde:	1000                	addi	s0,sp,32
 3006be0:	fea42623          	sw	a0,-20(s0)
    /* Check whether gpio pin */
    return (pin == GPIO_PIN_0 || pin == GPIO_PIN_1 || \
            pin == GPIO_PIN_2 || pin == GPIO_PIN_3 || \
            pin == GPIO_PIN_4 || pin == GPIO_PIN_5 || \
            pin == GPIO_PIN_6 || pin == GPIO_PIN_7 || \
 3006be4:	fec42703          	lw	a4,-20(s0)
 3006be8:	4785                	li	a5,1
 3006bea:	04f70e63          	beq	a4,a5,3006c46 <IsGpioPin+0x6c>
    return (pin == GPIO_PIN_0 || pin == GPIO_PIN_1 || \
 3006bee:	fec42703          	lw	a4,-20(s0)
 3006bf2:	4789                	li	a5,2
 3006bf4:	04f70963          	beq	a4,a5,3006c46 <IsGpioPin+0x6c>
 3006bf8:	fec42703          	lw	a4,-20(s0)
 3006bfc:	4791                	li	a5,4
 3006bfe:	04f70463          	beq	a4,a5,3006c46 <IsGpioPin+0x6c>
            pin == GPIO_PIN_2 || pin == GPIO_PIN_3 || \
 3006c02:	fec42703          	lw	a4,-20(s0)
 3006c06:	47a1                	li	a5,8
 3006c08:	02f70f63          	beq	a4,a5,3006c46 <IsGpioPin+0x6c>
 3006c0c:	fec42703          	lw	a4,-20(s0)
 3006c10:	47c1                	li	a5,16
 3006c12:	02f70a63          	beq	a4,a5,3006c46 <IsGpioPin+0x6c>
            pin == GPIO_PIN_4 || pin == GPIO_PIN_5 || \
 3006c16:	fec42703          	lw	a4,-20(s0)
 3006c1a:	02000793          	li	a5,32
 3006c1e:	02f70463          	beq	a4,a5,3006c46 <IsGpioPin+0x6c>
 3006c22:	fec42703          	lw	a4,-20(s0)
 3006c26:	04000793          	li	a5,64
 3006c2a:	00f70e63          	beq	a4,a5,3006c46 <IsGpioPin+0x6c>
            pin == GPIO_PIN_6 || pin == GPIO_PIN_7 || \
 3006c2e:	fec42703          	lw	a4,-20(s0)
 3006c32:	08000793          	li	a5,128
 3006c36:	00f70863          	beq	a4,a5,3006c46 <IsGpioPin+0x6c>
 3006c3a:	fec42703          	lw	a4,-20(s0)
 3006c3e:	0ff00793          	li	a5,255
 3006c42:	00f71463          	bne	a4,a5,3006c4a <IsGpioPin+0x70>
 3006c46:	4785                	li	a5,1
 3006c48:	a011                	j	3006c4c <IsGpioPin+0x72>
 3006c4a:	4781                	li	a5,0
 3006c4c:	8b85                	andi	a5,a5,1
 3006c4e:	9f81                	uxtb	a5
            pin == GPIO_PIN_ALL);
}
 3006c50:	853e                	mv	a0,a5
 3006c52:	4472                	lw	s0,28(sp)
 3006c54:	6105                	addi	sp,sp,32
 3006c56:	8082                	ret

03006c58 <IsGpioITMode>:
  * @brief Check gpio interrupt mode parameter.
  * @param mode Value of @ref GPIO_InterruptMode.
  * @retval Bool.
  */
static inline bool IsGpioITMode(GPIO_InterruptMode mode)
{
 3006c58:	1101                	addi	sp,sp,-32
 3006c5a:	ce22                	sw	s0,28(sp)
 3006c5c:	1000                	addi	s0,sp,32
 3006c5e:	fea42623          	sw	a0,-20(s0)
    /* Check whether gpio interrupt mode */
    return (mode == GPIO_INT_TYPE_HIGH_LEVEL || \
            mode == GPIO_INT_TYPE_LOW_LEVEL || \
            mode == GPIO_INT_TYPE_RISE_EDGE || \
            mode == GPIO_INT_TYPE_FALL_EDGE || \
            mode == GPIO_INT_TYPE_BOTH_EDGE || \
 3006c62:	fec42703          	lw	a4,-20(s0)
 3006c66:	478d                	li	a5,3
 3006c68:	02f70963          	beq	a4,a5,3006c9a <IsGpioITMode+0x42>
    return (mode == GPIO_INT_TYPE_HIGH_LEVEL || \
 3006c6c:	fec42703          	lw	a4,-20(s0)
 3006c70:	4789                	li	a5,2
 3006c72:	02f70463          	beq	a4,a5,3006c9a <IsGpioITMode+0x42>
            mode == GPIO_INT_TYPE_LOW_LEVEL || \
 3006c76:	fec42703          	lw	a4,-20(s0)
 3006c7a:	4785                	li	a5,1
 3006c7c:	00f70f63          	beq	a4,a5,3006c9a <IsGpioITMode+0x42>
            mode == GPIO_INT_TYPE_RISE_EDGE || \
 3006c80:	fec42783          	lw	a5,-20(s0)
 3006c84:	cb99                	beqz	a5,3006c9a <IsGpioITMode+0x42>
            mode == GPIO_INT_TYPE_FALL_EDGE || \
 3006c86:	fec42703          	lw	a4,-20(s0)
 3006c8a:	4791                	li	a5,4
 3006c8c:	00f70763          	beq	a4,a5,3006c9a <IsGpioITMode+0x42>
            mode == GPIO_INT_TYPE_BOTH_EDGE || \
 3006c90:	fec42703          	lw	a4,-20(s0)
 3006c94:	4795                	li	a5,5
 3006c96:	00f71463          	bne	a4,a5,3006c9e <IsGpioITMode+0x46>
 3006c9a:	4785                	li	a5,1
 3006c9c:	a011                	j	3006ca0 <IsGpioITMode+0x48>
 3006c9e:	4781                	li	a5,0
 3006ca0:	8b85                	andi	a5,a5,1
 3006ca2:	9f81                	uxtb	a5
            mode == GPIO_INT_TYPE_NONE);
}
 3006ca4:	853e                	mv	a0,a5
 3006ca6:	4472                	lw	s0,28(sp)
 3006ca8:	6105                	addi	sp,sp,32
 3006caa:	8082                	ret

03006cac <DCL_GPIO_SetValue>:
  * @param pins OR logical combination of pin.
  * @param value Value of @ref GPIO_Value.
  * @retval None.
  */
static inline void DCL_GPIO_SetValue(GPIO_RegStruct *gpiox, unsigned int pins, GPIO_Value value)
{
 3006cac:	1101                	addi	sp,sp,-32
 3006cae:	ce06                	sw	ra,28(sp)
 3006cb0:	cc22                	sw	s0,24(sp)
 3006cb2:	1000                	addi	s0,sp,32
 3006cb4:	fea42623          	sw	a0,-20(s0)
 3006cb8:	feb42423          	sw	a1,-24(s0)
 3006cbc:	fec42223          	sw	a2,-28(s0)
    GPIO_ASSERT_PARAM(IsGPIOInstance(gpiox));
 3006cc0:	fec42703          	lw	a4,-20(s0)
 3006cc4:	145007b7          	lui	a5,0x14500
 3006cc8:	04f70863          	beq	a4,a5,3006d18 <DCL_GPIO_SetValue+0x6c>
 3006ccc:	fec42703          	lw	a4,-20(s0)
 3006cd0:	145017b7          	lui	a5,0x14501
 3006cd4:	04f70263          	beq	a4,a5,3006d18 <DCL_GPIO_SetValue+0x6c>
 3006cd8:	fec42703          	lw	a4,-20(s0)
 3006cdc:	145027b7          	lui	a5,0x14502
 3006ce0:	02f70c63          	beq	a4,a5,3006d18 <DCL_GPIO_SetValue+0x6c>
 3006ce4:	fec42703          	lw	a4,-20(s0)
 3006ce8:	145037b7          	lui	a5,0x14503
 3006cec:	02f70663          	beq	a4,a5,3006d18 <DCL_GPIO_SetValue+0x6c>
 3006cf0:	fec42703          	lw	a4,-20(s0)
 3006cf4:	145047b7          	lui	a5,0x14504
 3006cf8:	02f70063          	beq	a4,a5,3006d18 <DCL_GPIO_SetValue+0x6c>
 3006cfc:	fec42703          	lw	a4,-20(s0)
 3006d00:	145057b7          	lui	a5,0x14505
 3006d04:	00f70a63          	beq	a4,a5,3006d18 <DCL_GPIO_SetValue+0x6c>
 3006d08:	18e00593          	li	a1,398
 3006d0c:	030127b7          	lui	a5,0x3012
 3006d10:	cbc78513          	addi	a0,a5,-836 # 3011cbc <g_crgIpMatch+0x424>
 3006d14:	2d51                	jal	ra,30073a8 <AssertErrorLog.trans.4>
 3006d16:	a001                	j	3006d16 <DCL_GPIO_SetValue+0x6a>
    GPIO_PARAM_CHECK_NO_RET(IsGpioPins(pins));
 3006d18:	fe842503          	lw	a0,-24(s0)
 3006d1c:	3579                	jal	ra,3006baa <IsGpioPins>
 3006d1e:	87aa                	mv	a5,a0
 3006d20:	0017c793          	xori	a5,a5,1
 3006d24:	9f81                	uxtb	a5
 3006d26:	cb89                	beqz	a5,3006d38 <DCL_GPIO_SetValue+0x8c>
 3006d28:	18f00593          	li	a1,399
 3006d2c:	030127b7          	lui	a5,0x3012
 3006d30:	cbc78513          	addi	a0,a5,-836 # 3011cbc <g_crgIpMatch+0x424>
 3006d34:	2d95                	jal	ra,30073a8 <AssertErrorLog.trans.4>
 3006d36:	a089                	j	3006d78 <DCL_GPIO_SetValue+0xcc>
    GPIO_PARAM_CHECK_NO_RET(IsGpioValue(value));
 3006d38:	fe442503          	lw	a0,-28(s0)
 3006d3c:	3d19                	jal	ra,3006b52 <IsGpioValue>
 3006d3e:	87aa                	mv	a5,a0
 3006d40:	0017c793          	xori	a5,a5,1
 3006d44:	9f81                	uxtb	a5
 3006d46:	cb89                	beqz	a5,3006d58 <DCL_GPIO_SetValue+0xac>
 3006d48:	19000593          	li	a1,400
 3006d4c:	030127b7          	lui	a5,0x3012
 3006d50:	cbc78513          	addi	a0,a5,-836 # 3011cbc <g_crgIpMatch+0x424>
 3006d54:	2d91                	jal	ra,30073a8 <AssertErrorLog.trans.4>
 3006d56:	a00d                	j	3006d78 <DCL_GPIO_SetValue+0xcc>
    gpiox->GPIO_DATA[pins].reg = (value == GPIO_HIGH_LEVEL ? pins : BASE_CFG_UNSET); /* Set GPIO pin level */
 3006d58:	fe442703          	lw	a4,-28(s0)
 3006d5c:	4785                	li	a5,1
 3006d5e:	00f71563          	bne	a4,a5,3006d68 <DCL_GPIO_SetValue+0xbc>
 3006d62:	fe842783          	lw	a5,-24(s0)
 3006d66:	a011                	j	3006d6a <DCL_GPIO_SetValue+0xbe>
 3006d68:	4781                	li	a5,0
 3006d6a:	fec42683          	lw	a3,-20(s0)
 3006d6e:	fe842703          	lw	a4,-24(s0)
 3006d72:	070a                	slli	a4,a4,0x2
 3006d74:	9736                	add	a4,a4,a3
 3006d76:	c31c                	sw	a5,0(a4)
}
 3006d78:	40f2                	lw	ra,28(sp)
 3006d7a:	4462                	lw	s0,24(sp)
 3006d7c:	6105                	addi	sp,sp,32
 3006d7e:	8082                	ret

03006d80 <DCL_GPIO_SetDirection>:
  * @param pins OR logical combination of pin.
  * @param dir Value of @ref GPIO_Direction.
  * @retval None.
  */
static inline void DCL_GPIO_SetDirection(GPIO_RegStruct *gpiox, unsigned int pins, GPIO_Direction dir)
{
 3006d80:	1101                	addi	sp,sp,-32
 3006d82:	ce06                	sw	ra,28(sp)
 3006d84:	cc22                	sw	s0,24(sp)
 3006d86:	1000                	addi	s0,sp,32
 3006d88:	fea42623          	sw	a0,-20(s0)
 3006d8c:	feb42423          	sw	a1,-24(s0)
 3006d90:	fec42223          	sw	a2,-28(s0)
    /* param check */
    GPIO_ASSERT_PARAM(IsGPIOInstance(gpiox));
 3006d94:	fec42703          	lw	a4,-20(s0)
 3006d98:	145007b7          	lui	a5,0x14500
 3006d9c:	04f70863          	beq	a4,a5,3006dec <DCL_GPIO_SetDirection+0x6c>
 3006da0:	fec42703          	lw	a4,-20(s0)
 3006da4:	145017b7          	lui	a5,0x14501
 3006da8:	04f70263          	beq	a4,a5,3006dec <DCL_GPIO_SetDirection+0x6c>
 3006dac:	fec42703          	lw	a4,-20(s0)
 3006db0:	145027b7          	lui	a5,0x14502
 3006db4:	02f70c63          	beq	a4,a5,3006dec <DCL_GPIO_SetDirection+0x6c>
 3006db8:	fec42703          	lw	a4,-20(s0)
 3006dbc:	145037b7          	lui	a5,0x14503
 3006dc0:	02f70663          	beq	a4,a5,3006dec <DCL_GPIO_SetDirection+0x6c>
 3006dc4:	fec42703          	lw	a4,-20(s0)
 3006dc8:	145047b7          	lui	a5,0x14504
 3006dcc:	02f70063          	beq	a4,a5,3006dec <DCL_GPIO_SetDirection+0x6c>
 3006dd0:	fec42703          	lw	a4,-20(s0)
 3006dd4:	145057b7          	lui	a5,0x14505
 3006dd8:	00f70a63          	beq	a4,a5,3006dec <DCL_GPIO_SetDirection+0x6c>
 3006ddc:	1b700593          	li	a1,439
 3006de0:	030127b7          	lui	a5,0x3012
 3006de4:	cbc78513          	addi	a0,a5,-836 # 3011cbc <g_crgIpMatch+0x424>
 3006de8:	23c1                	jal	ra,30073a8 <AssertErrorLog.trans.4>
 3006dea:	a001                	j	3006dea <DCL_GPIO_SetDirection+0x6a>
    GPIO_PARAM_CHECK_NO_RET(IsGpioPins(pins));
 3006dec:	fe842503          	lw	a0,-24(s0)
 3006df0:	3b6d                	jal	ra,3006baa <IsGpioPins>
 3006df2:	87aa                	mv	a5,a0
 3006df4:	0017c793          	xori	a5,a5,1
 3006df8:	9f81                	uxtb	a5
 3006dfa:	cb89                	beqz	a5,3006e0c <DCL_GPIO_SetDirection+0x8c>
 3006dfc:	1b800593          	li	a1,440
 3006e00:	030127b7          	lui	a5,0x3012
 3006e04:	cbc78513          	addi	a0,a5,-836 # 3011cbc <g_crgIpMatch+0x424>
 3006e08:	2345                	jal	ra,30073a8 <AssertErrorLog.trans.4>
 3006e0a:	a095                	j	3006e6e <DCL_GPIO_SetDirection+0xee>
    GPIO_PARAM_CHECK_NO_RET(IsGpioDirection(dir));
 3006e0c:	fe442503          	lw	a0,-28(s0)
 3006e10:	33bd                	jal	ra,3006b7e <IsGpioDirection>
 3006e12:	87aa                	mv	a5,a0
 3006e14:	0017c793          	xori	a5,a5,1
 3006e18:	9f81                	uxtb	a5
 3006e1a:	cb89                	beqz	a5,3006e2c <DCL_GPIO_SetDirection+0xac>
 3006e1c:	1b900593          	li	a1,441
 3006e20:	030127b7          	lui	a5,0x3012
 3006e24:	cbc78513          	addi	a0,a5,-836 # 3011cbc <g_crgIpMatch+0x424>
 3006e28:	2341                	jal	ra,30073a8 <AssertErrorLog.trans.4>
 3006e2a:	a091                	j	3006e6e <DCL_GPIO_SetDirection+0xee>
    if (dir == GPIO_INPUT_MODE) { /* Set GPIO pin direction */
 3006e2c:	fe442783          	lw	a5,-28(s0)
 3006e30:	ef99                	bnez	a5,3006e4e <DCL_GPIO_SetDirection+0xce>
        gpiox->GPIO_DIR.reg &= ~pins;
 3006e32:	fec42783          	lw	a5,-20(s0)
 3006e36:	4007a703          	lw	a4,1024(a5)
 3006e3a:	fe842783          	lw	a5,-24(s0)
 3006e3e:	fff7c793          	not	a5,a5
 3006e42:	8f7d                	and	a4,a4,a5
 3006e44:	fec42783          	lw	a5,-20(s0)
 3006e48:	40e7a023          	sw	a4,1024(a5)
 3006e4c:	a00d                	j	3006e6e <DCL_GPIO_SetDirection+0xee>
    } else if (dir == GPIO_OUTPUT_MODE) {
 3006e4e:	fe442703          	lw	a4,-28(s0)
 3006e52:	4785                	li	a5,1
 3006e54:	00f71d63          	bne	a4,a5,3006e6e <DCL_GPIO_SetDirection+0xee>
        gpiox->GPIO_DIR.reg |= pins;
 3006e58:	fec42783          	lw	a5,-20(s0)
 3006e5c:	4007a703          	lw	a4,1024(a5)
 3006e60:	fe842783          	lw	a5,-24(s0)
 3006e64:	8f5d                	or	a4,a4,a5
 3006e66:	fec42783          	lw	a5,-20(s0)
 3006e6a:	40e7a023          	sw	a4,1024(a5)
    }
}
 3006e6e:	40f2                	lw	ra,28(sp)
 3006e70:	4462                	lw	s0,24(sp)
 3006e72:	6105                	addi	sp,sp,32
 3006e74:	8082                	ret

03006e76 <DCL_GPIO_ClearIrq>:
  * @param gpiox Value of @ref GPIO_RegStruct.
  * @param pins OR logical combination of pin.
  * @retval None.
  */
static inline void DCL_GPIO_ClearIrq(GPIO_RegStruct *gpiox, unsigned int pins)
{
 3006e76:	1101                	addi	sp,sp,-32
 3006e78:	ce06                	sw	ra,28(sp)
 3006e7a:	cc22                	sw	s0,24(sp)
 3006e7c:	1000                	addi	s0,sp,32
 3006e7e:	fea42623          	sw	a0,-20(s0)
 3006e82:	feb42423          	sw	a1,-24(s0)
    GPIO_ASSERT_PARAM(IsGPIOInstance(gpiox));
 3006e86:	fec42703          	lw	a4,-20(s0)
 3006e8a:	145007b7          	lui	a5,0x14500
 3006e8e:	04f70863          	beq	a4,a5,3006ede <DCL_GPIO_ClearIrq+0x68>
 3006e92:	fec42703          	lw	a4,-20(s0)
 3006e96:	145017b7          	lui	a5,0x14501
 3006e9a:	04f70263          	beq	a4,a5,3006ede <DCL_GPIO_ClearIrq+0x68>
 3006e9e:	fec42703          	lw	a4,-20(s0)
 3006ea2:	145027b7          	lui	a5,0x14502
 3006ea6:	02f70c63          	beq	a4,a5,3006ede <DCL_GPIO_ClearIrq+0x68>
 3006eaa:	fec42703          	lw	a4,-20(s0)
 3006eae:	145037b7          	lui	a5,0x14503
 3006eb2:	02f70663          	beq	a4,a5,3006ede <DCL_GPIO_ClearIrq+0x68>
 3006eb6:	fec42703          	lw	a4,-20(s0)
 3006eba:	145047b7          	lui	a5,0x14504
 3006ebe:	02f70063          	beq	a4,a5,3006ede <DCL_GPIO_ClearIrq+0x68>
 3006ec2:	fec42703          	lw	a4,-20(s0)
 3006ec6:	145057b7          	lui	a5,0x14505
 3006eca:	00f70a63          	beq	a4,a5,3006ede <DCL_GPIO_ClearIrq+0x68>
 3006ece:	25c00593          	li	a1,604
 3006ed2:	030127b7          	lui	a5,0x3012
 3006ed6:	cbc78513          	addi	a0,a5,-836 # 3011cbc <g_crgIpMatch+0x424>
 3006eda:	21f9                	jal	ra,30073a8 <AssertErrorLog.trans.4>
 3006edc:	a001                	j	3006edc <DCL_GPIO_ClearIrq+0x66>
    GPIO_PARAM_CHECK_NO_RET(IsGpioPins(pins));
 3006ede:	fe842503          	lw	a0,-24(s0)
 3006ee2:	31e1                	jal	ra,3006baa <IsGpioPins>
 3006ee4:	87aa                	mv	a5,a0
 3006ee6:	0017c793          	xori	a5,a5,1
 3006eea:	9f81                	uxtb	a5
 3006eec:	cb89                	beqz	a5,3006efe <DCL_GPIO_ClearIrq+0x88>
 3006eee:	25d00593          	li	a1,605
 3006ef2:	030127b7          	lui	a5,0x3012
 3006ef6:	cbc78513          	addi	a0,a5,-836 # 3011cbc <g_crgIpMatch+0x424>
 3006efa:	217d                	jal	ra,30073a8 <AssertErrorLog.trans.4>
 3006efc:	a821                	j	3006f14 <DCL_GPIO_ClearIrq+0x9e>
    gpiox->GPIO_IC.reg |= pins;
 3006efe:	fec42783          	lw	a5,-20(s0)
 3006f02:	41c7a703          	lw	a4,1052(a5)
 3006f06:	fe842783          	lw	a5,-24(s0)
 3006f0a:	8f5d                	or	a4,a4,a5
 3006f0c:	fec42783          	lw	a5,-20(s0)
 3006f10:	40e7ae23          	sw	a4,1052(a5)
}
 3006f14:	40f2                	lw	ra,28(sp)
 3006f16:	4462                	lw	s0,24(sp)
 3006f18:	6105                	addi	sp,sp,32
 3006f1a:	8082                	ret

03006f1c <DCL_GPIO_EnableIrq>:
  * @param gpiox Value of @ref GPIO_RegStruct.
  * @param pins OR logical combination of pins.
  * @retval None.
  */
static inline void DCL_GPIO_EnableIrq(GPIO_RegStruct *gpiox, unsigned int pins)
{
 3006f1c:	1101                	addi	sp,sp,-32
 3006f1e:	ce06                	sw	ra,28(sp)
 3006f20:	cc22                	sw	s0,24(sp)
 3006f22:	1000                	addi	s0,sp,32
 3006f24:	fea42623          	sw	a0,-20(s0)
 3006f28:	feb42423          	sw	a1,-24(s0)
    GPIO_ASSERT_PARAM(IsGPIOInstance(gpiox));
 3006f2c:	fec42703          	lw	a4,-20(s0)
 3006f30:	145007b7          	lui	a5,0x14500
 3006f34:	04f70863          	beq	a4,a5,3006f84 <DCL_GPIO_EnableIrq+0x68>
 3006f38:	fec42703          	lw	a4,-20(s0)
 3006f3c:	145017b7          	lui	a5,0x14501
 3006f40:	04f70263          	beq	a4,a5,3006f84 <DCL_GPIO_EnableIrq+0x68>
 3006f44:	fec42703          	lw	a4,-20(s0)
 3006f48:	145027b7          	lui	a5,0x14502
 3006f4c:	02f70c63          	beq	a4,a5,3006f84 <DCL_GPIO_EnableIrq+0x68>
 3006f50:	fec42703          	lw	a4,-20(s0)
 3006f54:	145037b7          	lui	a5,0x14503
 3006f58:	02f70663          	beq	a4,a5,3006f84 <DCL_GPIO_EnableIrq+0x68>
 3006f5c:	fec42703          	lw	a4,-20(s0)
 3006f60:	145047b7          	lui	a5,0x14504
 3006f64:	02f70063          	beq	a4,a5,3006f84 <DCL_GPIO_EnableIrq+0x68>
 3006f68:	fec42703          	lw	a4,-20(s0)
 3006f6c:	145057b7          	lui	a5,0x14505
 3006f70:	00f70a63          	beq	a4,a5,3006f84 <DCL_GPIO_EnableIrq+0x68>
 3006f74:	26900593          	li	a1,617
 3006f78:	030127b7          	lui	a5,0x3012
 3006f7c:	cbc78513          	addi	a0,a5,-836 # 3011cbc <g_crgIpMatch+0x424>
 3006f80:	2125                	jal	ra,30073a8 <AssertErrorLog.trans.4>
 3006f82:	a001                	j	3006f82 <DCL_GPIO_EnableIrq+0x66>
    GPIO_PARAM_CHECK_NO_RET(IsGpioPins(pins));
 3006f84:	fe842503          	lw	a0,-24(s0)
 3006f88:	310d                	jal	ra,3006baa <IsGpioPins>
 3006f8a:	87aa                	mv	a5,a0
 3006f8c:	0017c793          	xori	a5,a5,1
 3006f90:	9f81                	uxtb	a5
 3006f92:	cb89                	beqz	a5,3006fa4 <DCL_GPIO_EnableIrq+0x88>
 3006f94:	26a00593          	li	a1,618
 3006f98:	030127b7          	lui	a5,0x3012
 3006f9c:	cbc78513          	addi	a0,a5,-836 # 3011cbc <g_crgIpMatch+0x424>
 3006fa0:	2121                	jal	ra,30073a8 <AssertErrorLog.trans.4>
 3006fa2:	a00d                	j	3006fc4 <DCL_GPIO_EnableIrq+0xa8>
    /* must clear interrupt first, prevents interrupts triggered by previous output mode. */
    DCL_GPIO_ClearIrq(gpiox, pins);
 3006fa4:	fe842583          	lw	a1,-24(s0)
 3006fa8:	fec42503          	lw	a0,-20(s0)
 3006fac:	35e9                	jal	ra,3006e76 <DCL_GPIO_ClearIrq>
    gpiox->GPIO_IE.reg |= pins;
 3006fae:	fec42783          	lw	a5,-20(s0)
 3006fb2:	4107a703          	lw	a4,1040(a5)
 3006fb6:	fe842783          	lw	a5,-24(s0)
 3006fba:	8f5d                	or	a4,a4,a5
 3006fbc:	fec42783          	lw	a5,-20(s0)
 3006fc0:	40e7a823          	sw	a4,1040(a5)
}
 3006fc4:	40f2                	lw	ra,28(sp)
 3006fc6:	4462                	lw	s0,24(sp)
 3006fc8:	6105                	addi	sp,sp,32
 3006fca:	8082                	ret

03006fcc <DCL_GPIO_DisableIrq>:
  * @param gpiox Value of @ref GPIO_RegStruct.
  * @param pins OR logical combination of pin.
  * @retval None.
  */
static inline void DCL_GPIO_DisableIrq(GPIO_RegStruct *gpiox, unsigned int pins)
{
 3006fcc:	1101                	addi	sp,sp,-32
 3006fce:	ce06                	sw	ra,28(sp)
 3006fd0:	cc22                	sw	s0,24(sp)
 3006fd2:	1000                	addi	s0,sp,32
 3006fd4:	fea42623          	sw	a0,-20(s0)
 3006fd8:	feb42423          	sw	a1,-24(s0)
    GPIO_ASSERT_PARAM(IsGPIOInstance(gpiox));
 3006fdc:	fec42703          	lw	a4,-20(s0)
 3006fe0:	145007b7          	lui	a5,0x14500
 3006fe4:	04f70863          	beq	a4,a5,3007034 <DCL_GPIO_DisableIrq+0x68>
 3006fe8:	fec42703          	lw	a4,-20(s0)
 3006fec:	145017b7          	lui	a5,0x14501
 3006ff0:	04f70263          	beq	a4,a5,3007034 <DCL_GPIO_DisableIrq+0x68>
 3006ff4:	fec42703          	lw	a4,-20(s0)
 3006ff8:	145027b7          	lui	a5,0x14502
 3006ffc:	02f70c63          	beq	a4,a5,3007034 <DCL_GPIO_DisableIrq+0x68>
 3007000:	fec42703          	lw	a4,-20(s0)
 3007004:	145037b7          	lui	a5,0x14503
 3007008:	02f70663          	beq	a4,a5,3007034 <DCL_GPIO_DisableIrq+0x68>
 300700c:	fec42703          	lw	a4,-20(s0)
 3007010:	145047b7          	lui	a5,0x14504
 3007014:	02f70063          	beq	a4,a5,3007034 <DCL_GPIO_DisableIrq+0x68>
 3007018:	fec42703          	lw	a4,-20(s0)
 300701c:	145057b7          	lui	a5,0x14505
 3007020:	00f70a63          	beq	a4,a5,3007034 <DCL_GPIO_DisableIrq+0x68>
 3007024:	27800593          	li	a1,632
 3007028:	030127b7          	lui	a5,0x3012
 300702c:	cbc78513          	addi	a0,a5,-836 # 3011cbc <g_crgIpMatch+0x424>
 3007030:	2ea5                	jal	ra,30073a8 <AssertErrorLog.trans.4>
 3007032:	a001                	j	3007032 <DCL_GPIO_DisableIrq+0x66>
    GPIO_PARAM_CHECK_NO_RET(IsGpioPins(pins));
 3007034:	fe842503          	lw	a0,-24(s0)
 3007038:	3e8d                	jal	ra,3006baa <IsGpioPins>
 300703a:	87aa                	mv	a5,a0
 300703c:	0017c793          	xori	a5,a5,1
 3007040:	9f81                	uxtb	a5
 3007042:	cb89                	beqz	a5,3007054 <DCL_GPIO_DisableIrq+0x88>
 3007044:	27900593          	li	a1,633
 3007048:	030127b7          	lui	a5,0x3012
 300704c:	cbc78513          	addi	a0,a5,-836 # 3011cbc <g_crgIpMatch+0x424>
 3007050:	2ea1                	jal	ra,30073a8 <AssertErrorLog.trans.4>
 3007052:	a831                	j	300706e <DCL_GPIO_DisableIrq+0xa2>
    gpiox->GPIO_IE.reg &= ~pins;
 3007054:	fec42783          	lw	a5,-20(s0)
 3007058:	4107a703          	lw	a4,1040(a5)
 300705c:	fe842783          	lw	a5,-24(s0)
 3007060:	fff7c793          	not	a5,a5
 3007064:	8f7d                	and	a4,a4,a5
 3007066:	fec42783          	lw	a5,-20(s0)
 300706a:	40e7a823          	sw	a4,1040(a5)
}
 300706e:	40f2                	lw	ra,28(sp)
 3007070:	4462                	lw	s0,24(sp)
 3007072:	6105                	addi	sp,sp,32
 3007074:	8082                	ret

03007076 <DCL_GPIO_GetMIS>:
  * @brief Getting all values of GPIO MIS register.
  * @param gpiox Value of @ref GPIO_RegStruct.
  * @retval unsigned int All values of GPIO MIS register.
  */
static inline unsigned int DCL_GPIO_GetMIS(const GPIO_RegStruct *gpiox)
{
 3007076:	1101                	addi	sp,sp,-32
 3007078:	ce06                	sw	ra,28(sp)
 300707a:	cc22                	sw	s0,24(sp)
 300707c:	1000                	addi	s0,sp,32
 300707e:	fea42623          	sw	a0,-20(s0)
    GPIO_ASSERT_PARAM(IsGPIOInstance(gpiox));
 3007082:	fec42703          	lw	a4,-20(s0)
 3007086:	145007b7          	lui	a5,0x14500
 300708a:	04f70863          	beq	a4,a5,30070da <DCL_GPIO_GetMIS+0x64>
 300708e:	fec42703          	lw	a4,-20(s0)
 3007092:	145017b7          	lui	a5,0x14501
 3007096:	04f70263          	beq	a4,a5,30070da <DCL_GPIO_GetMIS+0x64>
 300709a:	fec42703          	lw	a4,-20(s0)
 300709e:	145027b7          	lui	a5,0x14502
 30070a2:	02f70c63          	beq	a4,a5,30070da <DCL_GPIO_GetMIS+0x64>
 30070a6:	fec42703          	lw	a4,-20(s0)
 30070aa:	145037b7          	lui	a5,0x14503
 30070ae:	02f70663          	beq	a4,a5,30070da <DCL_GPIO_GetMIS+0x64>
 30070b2:	fec42703          	lw	a4,-20(s0)
 30070b6:	145047b7          	lui	a5,0x14504
 30070ba:	02f70063          	beq	a4,a5,30070da <DCL_GPIO_GetMIS+0x64>
 30070be:	fec42703          	lw	a4,-20(s0)
 30070c2:	145057b7          	lui	a5,0x14505
 30070c6:	00f70a63          	beq	a4,a5,30070da <DCL_GPIO_GetMIS+0x64>
 30070ca:	29a00593          	li	a1,666
 30070ce:	030127b7          	lui	a5,0x3012
 30070d2:	cbc78513          	addi	a0,a5,-836 # 3011cbc <g_crgIpMatch+0x424>
 30070d6:	2cc9                	jal	ra,30073a8 <AssertErrorLog.trans.4>
 30070d8:	a001                	j	30070d8 <DCL_GPIO_GetMIS+0x62>
    return gpiox->GPIO_MIS.reg & GPIO_PIN_MASK;
 30070da:	fec42783          	lw	a5,-20(s0)
 30070de:	4187a783          	lw	a5,1048(a5)
 30070e2:	0ff7f793          	andi	a5,a5,255
}
 30070e6:	853e                	mv	a0,a5
 30070e8:	40f2                	lw	ra,28(sp)
 30070ea:	4462                	lw	s0,24(sp)
 30070ec:	6105                	addi	sp,sp,32
 30070ee:	8082                	ret

030070f0 <HAL_GPIO_Init>:
  * @brief Initializing GPIO register values.
  * @param handle Value of @ref GPIO_Handle.
  * @retval None.
  */
void HAL_GPIO_Init(GPIO_Handle *handle)
{
 30070f0:	7179                	addi	sp,sp,-48
 30070f2:	d606                	sw	ra,44(sp)
 30070f4:	d422                	sw	s0,40(sp)
 30070f6:	1800                	addi	s0,sp,48
 30070f8:	fca42e23          	sw	a0,-36(s0)
    GPIO_ASSERT_PARAM(handle != NULL);
 30070fc:	fdc42783          	lw	a5,-36(s0)
 3007100:	eb89                	bnez	a5,3007112 <HAL_GPIO_Init+0x22>
 3007102:	02b00593          	li	a1,43
 3007106:	030127b7          	lui	a5,0x3012
 300710a:	cdc78513          	addi	a0,a5,-804 # 3011cdc <g_crgIpMatch+0x444>
 300710e:	2c69                	jal	ra,30073a8 <AssertErrorLog.trans.4>
 3007110:	a001                	j	3007110 <HAL_GPIO_Init+0x20>
    GPIO_ASSERT_PARAM(IsGPIOInstance(handle->baseAddress));
 3007112:	fdc42783          	lw	a5,-36(s0)
 3007116:	4398                	lw	a4,0(a5)
 3007118:	145007b7          	lui	a5,0x14500
 300711c:	04f70d63          	beq	a4,a5,3007176 <HAL_GPIO_Init+0x86>
 3007120:	fdc42783          	lw	a5,-36(s0)
 3007124:	4398                	lw	a4,0(a5)
 3007126:	145017b7          	lui	a5,0x14501
 300712a:	04f70663          	beq	a4,a5,3007176 <HAL_GPIO_Init+0x86>
 300712e:	fdc42783          	lw	a5,-36(s0)
 3007132:	4398                	lw	a4,0(a5)
 3007134:	145027b7          	lui	a5,0x14502
 3007138:	02f70f63          	beq	a4,a5,3007176 <HAL_GPIO_Init+0x86>
 300713c:	fdc42783          	lw	a5,-36(s0)
 3007140:	4398                	lw	a4,0(a5)
 3007142:	145037b7          	lui	a5,0x14503
 3007146:	02f70863          	beq	a4,a5,3007176 <HAL_GPIO_Init+0x86>
 300714a:	fdc42783          	lw	a5,-36(s0)
 300714e:	4398                	lw	a4,0(a5)
 3007150:	145047b7          	lui	a5,0x14504
 3007154:	02f70163          	beq	a4,a5,3007176 <HAL_GPIO_Init+0x86>
 3007158:	fdc42783          	lw	a5,-36(s0)
 300715c:	4398                	lw	a4,0(a5)
 300715e:	145057b7          	lui	a5,0x14505
 3007162:	00f70a63          	beq	a4,a5,3007176 <HAL_GPIO_Init+0x86>
 3007166:	02c00593          	li	a1,44
 300716a:	030127b7          	lui	a5,0x3012
 300716e:	cdc78513          	addi	a0,a5,-804 # 3011cdc <g_crgIpMatch+0x444>
 3007172:	2c1d                	jal	ra,30073a8 <AssertErrorLog.trans.4>
 3007174:	a001                	j	3007174 <HAL_GPIO_Init+0x84>
    GPIO_PARAM_CHECK_NO_RET(IsGpioPins(handle->pins));
 3007176:	fdc42783          	lw	a5,-36(s0)
 300717a:	43dc                	lw	a5,4(a5)
 300717c:	853e                	mv	a0,a5
 300717e:	3435                	jal	ra,3006baa <IsGpioPins>
 3007180:	87aa                	mv	a5,a0
 3007182:	0017c793          	xori	a5,a5,1
 3007186:	9f81                	uxtb	a5
 3007188:	cb89                	beqz	a5,300719a <HAL_GPIO_Init+0xaa>
 300718a:	02d00593          	li	a1,45
 300718e:	030127b7          	lui	a5,0x3012
 3007192:	cdc78513          	addi	a0,a5,-804 # 3011cdc <g_crgIpMatch+0x444>
 3007196:	2c09                	jal	ra,30073a8 <AssertErrorLog.trans.4>
 3007198:	a81d                	j	30071ce <HAL_GPIO_Init+0xde>

    /* Register GPIO callback ID */
    for (unsigned int i = 0; i < GPIO_PIN_NUM; i++) {
 300719a:	fe042623          	sw	zero,-20(s0)
 300719e:	a01d                	j	30071c4 <HAL_GPIO_Init+0xd4>
        handle->userCallBack.GPIO_CallbackFuncs[i].pin = (1 << i);
 30071a0:	4705                	li	a4,1
 30071a2:	fec42783          	lw	a5,-20(s0)
 30071a6:	00f717b3          	sll	a5,a4,a5
 30071aa:	86be                	mv	a3,a5
 30071ac:	fdc42703          	lw	a4,-36(s0)
 30071b0:	fec42783          	lw	a5,-20(s0)
 30071b4:	078e                	slli	a5,a5,0x3
 30071b6:	97ba                	add	a5,a5,a4
 30071b8:	c794                	sw	a3,8(a5)
    for (unsigned int i = 0; i < GPIO_PIN_NUM; i++) {
 30071ba:	fec42783          	lw	a5,-20(s0)
 30071be:	0785                	addi	a5,a5,1
 30071c0:	fef42623          	sw	a5,-20(s0)
 30071c4:	fec42703          	lw	a4,-20(s0)
 30071c8:	479d                	li	a5,7
 30071ca:	fce7fbe3          	bgeu	a5,a4,30071a0 <HAL_GPIO_Init+0xb0>
    }
}
 30071ce:	50b2                	lw	ra,44(sp)
 30071d0:	5422                	lw	s0,40(sp)
 30071d2:	6145                	addi	sp,sp,48
 30071d4:	8082                	ret

030071d6 <HAL_GPIO_SetDirection>:
  * @param pins OR logical combination of pin.
  * @param dir GPIO pin direction.
  * @retval None.
  */
void HAL_GPIO_SetDirection(GPIO_Handle *handle, unsigned int pins, GPIO_Direction dir)
{
 30071d6:	1101                	addi	sp,sp,-32
 30071d8:	ce06                	sw	ra,28(sp)
 30071da:	cc22                	sw	s0,24(sp)
 30071dc:	1000                	addi	s0,sp,32
 30071de:	fea42623          	sw	a0,-20(s0)
 30071e2:	feb42423          	sw	a1,-24(s0)
 30071e6:	fec42223          	sw	a2,-28(s0)
    GPIO_ASSERT_PARAM(handle != NULL);
 30071ea:	fec42783          	lw	a5,-20(s0)
 30071ee:	eb89                	bnez	a5,3007200 <HAL_GPIO_SetDirection+0x2a>
 30071f0:	04f00593          	li	a1,79
 30071f4:	030127b7          	lui	a5,0x3012
 30071f8:	cdc78513          	addi	a0,a5,-804 # 3011cdc <g_crgIpMatch+0x444>
 30071fc:	2275                	jal	ra,30073a8 <AssertErrorLog.trans.4>
 30071fe:	a001                	j	30071fe <HAL_GPIO_SetDirection+0x28>
    GPIO_ASSERT_PARAM(IsGPIOInstance(handle->baseAddress));
 3007200:	fec42783          	lw	a5,-20(s0)
 3007204:	4398                	lw	a4,0(a5)
 3007206:	145007b7          	lui	a5,0x14500
 300720a:	04f70d63          	beq	a4,a5,3007264 <HAL_GPIO_SetDirection+0x8e>
 300720e:	fec42783          	lw	a5,-20(s0)
 3007212:	4398                	lw	a4,0(a5)
 3007214:	145017b7          	lui	a5,0x14501
 3007218:	04f70663          	beq	a4,a5,3007264 <HAL_GPIO_SetDirection+0x8e>
 300721c:	fec42783          	lw	a5,-20(s0)
 3007220:	4398                	lw	a4,0(a5)
 3007222:	145027b7          	lui	a5,0x14502
 3007226:	02f70f63          	beq	a4,a5,3007264 <HAL_GPIO_SetDirection+0x8e>
 300722a:	fec42783          	lw	a5,-20(s0)
 300722e:	4398                	lw	a4,0(a5)
 3007230:	145037b7          	lui	a5,0x14503
 3007234:	02f70863          	beq	a4,a5,3007264 <HAL_GPIO_SetDirection+0x8e>
 3007238:	fec42783          	lw	a5,-20(s0)
 300723c:	4398                	lw	a4,0(a5)
 300723e:	145047b7          	lui	a5,0x14504
 3007242:	02f70163          	beq	a4,a5,3007264 <HAL_GPIO_SetDirection+0x8e>
 3007246:	fec42783          	lw	a5,-20(s0)
 300724a:	4398                	lw	a4,0(a5)
 300724c:	145057b7          	lui	a5,0x14505
 3007250:	00f70a63          	beq	a4,a5,3007264 <HAL_GPIO_SetDirection+0x8e>
 3007254:	05000593          	li	a1,80
 3007258:	030127b7          	lui	a5,0x3012
 300725c:	cdc78513          	addi	a0,a5,-804 # 3011cdc <g_crgIpMatch+0x444>
 3007260:	22a1                	jal	ra,30073a8 <AssertErrorLog.trans.4>
 3007262:	a001                	j	3007262 <HAL_GPIO_SetDirection+0x8c>
    GPIO_PARAM_CHECK_NO_RET(IsGpioPins(pins));
 3007264:	fe842503          	lw	a0,-24(s0)
 3007268:	3289                	jal	ra,3006baa <IsGpioPins>
 300726a:	87aa                	mv	a5,a0
 300726c:	0017c793          	xori	a5,a5,1
 3007270:	9f81                	uxtb	a5
 3007272:	cb89                	beqz	a5,3007284 <HAL_GPIO_SetDirection+0xae>
 3007274:	05100593          	li	a1,81
 3007278:	030127b7          	lui	a5,0x3012
 300727c:	cdc78513          	addi	a0,a5,-804 # 3011cdc <g_crgIpMatch+0x444>
 3007280:	2225                	jal	ra,30073a8 <AssertErrorLog.trans.4>
 3007282:	a815                	j	30072b6 <HAL_GPIO_SetDirection+0xe0>
    GPIO_PARAM_CHECK_NO_RET(IsGpioDirection(dir));
 3007284:	fe442503          	lw	a0,-28(s0)
 3007288:	38dd                	jal	ra,3006b7e <IsGpioDirection>
 300728a:	87aa                	mv	a5,a0
 300728c:	0017c793          	xori	a5,a5,1
 3007290:	9f81                	uxtb	a5
 3007292:	cb89                	beqz	a5,30072a4 <HAL_GPIO_SetDirection+0xce>
 3007294:	05200593          	li	a1,82
 3007298:	030127b7          	lui	a5,0x3012
 300729c:	cdc78513          	addi	a0,a5,-804 # 3011cdc <g_crgIpMatch+0x444>
 30072a0:	2221                	jal	ra,30073a8 <AssertErrorLog.trans.4>
 30072a2:	a811                	j	30072b6 <HAL_GPIO_SetDirection+0xe0>
    DCL_GPIO_SetDirection(handle->baseAddress, pins, dir);
 30072a4:	fec42783          	lw	a5,-20(s0)
 30072a8:	439c                	lw	a5,0(a5)
 30072aa:	fe442603          	lw	a2,-28(s0)
 30072ae:	fe842583          	lw	a1,-24(s0)
 30072b2:	853e                	mv	a0,a5
 30072b4:	34f1                	jal	ra,3006d80 <DCL_GPIO_SetDirection>
}
 30072b6:	40f2                	lw	ra,28(sp)
 30072b8:	4462                	lw	s0,24(sp)
 30072ba:	6105                	addi	sp,sp,32
 30072bc:	8082                	ret

030072be <HAL_GPIO_SetValue>:
  * @param pins OR logical combination of pin.
  * @param value Value of @ref GPIO_Value.
  * @retval None.
  */
void HAL_GPIO_SetValue(GPIO_Handle *handle, unsigned int pins, GPIO_Value value)
{
 30072be:	1101                	addi	sp,sp,-32
 30072c0:	ce06                	sw	ra,28(sp)
 30072c2:	cc22                	sw	s0,24(sp)
 30072c4:	1000                	addi	s0,sp,32
 30072c6:	fea42623          	sw	a0,-20(s0)
 30072ca:	feb42423          	sw	a1,-24(s0)
 30072ce:	fec42223          	sw	a2,-28(s0)
    GPIO_ASSERT_PARAM(handle != NULL);
 30072d2:	fec42783          	lw	a5,-20(s0)
 30072d6:	eb89                	bnez	a5,30072e8 <HAL_GPIO_SetValue+0x2a>
 30072d8:	05f00593          	li	a1,95
 30072dc:	030127b7          	lui	a5,0x3012
 30072e0:	cdc78513          	addi	a0,a5,-804 # 3011cdc <g_crgIpMatch+0x444>
 30072e4:	20d1                	jal	ra,30073a8 <AssertErrorLog.trans.4>
 30072e6:	a001                	j	30072e6 <HAL_GPIO_SetValue+0x28>
    GPIO_ASSERT_PARAM(IsGPIOInstance(handle->baseAddress));
 30072e8:	fec42783          	lw	a5,-20(s0)
 30072ec:	4398                	lw	a4,0(a5)
 30072ee:	145007b7          	lui	a5,0x14500
 30072f2:	04f70d63          	beq	a4,a5,300734c <HAL_GPIO_SetValue+0x8e>
 30072f6:	fec42783          	lw	a5,-20(s0)
 30072fa:	4398                	lw	a4,0(a5)
 30072fc:	145017b7          	lui	a5,0x14501
 3007300:	04f70663          	beq	a4,a5,300734c <HAL_GPIO_SetValue+0x8e>
 3007304:	fec42783          	lw	a5,-20(s0)
 3007308:	4398                	lw	a4,0(a5)
 300730a:	145027b7          	lui	a5,0x14502
 300730e:	02f70f63          	beq	a4,a5,300734c <HAL_GPIO_SetValue+0x8e>
 3007312:	fec42783          	lw	a5,-20(s0)
 3007316:	4398                	lw	a4,0(a5)
 3007318:	145037b7          	lui	a5,0x14503
 300731c:	02f70863          	beq	a4,a5,300734c <HAL_GPIO_SetValue+0x8e>
 3007320:	fec42783          	lw	a5,-20(s0)
 3007324:	4398                	lw	a4,0(a5)
 3007326:	145047b7          	lui	a5,0x14504
 300732a:	02f70163          	beq	a4,a5,300734c <HAL_GPIO_SetValue+0x8e>
 300732e:	fec42783          	lw	a5,-20(s0)
 3007332:	4398                	lw	a4,0(a5)
 3007334:	145057b7          	lui	a5,0x14505
 3007338:	00f70a63          	beq	a4,a5,300734c <HAL_GPIO_SetValue+0x8e>
 300733c:	06000593          	li	a1,96
 3007340:	030127b7          	lui	a5,0x3012
 3007344:	cdc78513          	addi	a0,a5,-804 # 3011cdc <g_crgIpMatch+0x444>
 3007348:	2085                	jal	ra,30073a8 <AssertErrorLog.trans.4>
 300734a:	a001                	j	300734a <HAL_GPIO_SetValue+0x8c>
    GPIO_PARAM_CHECK_NO_RET(IsGpioPins(pins));
 300734c:	fe842503          	lw	a0,-24(s0)
 3007350:	38a9                	jal	ra,3006baa <IsGpioPins>
 3007352:	87aa                	mv	a5,a0
 3007354:	0017c793          	xori	a5,a5,1
 3007358:	9f81                	uxtb	a5
 300735a:	cb89                	beqz	a5,300736c <HAL_GPIO_SetValue+0xae>
 300735c:	06100593          	li	a1,97
 3007360:	030127b7          	lui	a5,0x3012
 3007364:	cdc78513          	addi	a0,a5,-804 # 3011cdc <g_crgIpMatch+0x444>
 3007368:	2081                	jal	ra,30073a8 <AssertErrorLog.trans.4>
 300736a:	a81d                	j	30073a0 <HAL_GPIO_SetValue+0xe2>
    GPIO_PARAM_CHECK_NO_RET(IsGpioValue(value));
 300736c:	fe442503          	lw	a0,-28(s0)
 3007370:	fe2ff0ef          	jal	ra,3006b52 <IsGpioValue>
 3007374:	87aa                	mv	a5,a0
 3007376:	0017c793          	xori	a5,a5,1
 300737a:	9f81                	uxtb	a5
 300737c:	cb89                	beqz	a5,300738e <HAL_GPIO_SetValue+0xd0>
 300737e:	06200593          	li	a1,98
 3007382:	030127b7          	lui	a5,0x3012
 3007386:	cdc78513          	addi	a0,a5,-804 # 3011cdc <g_crgIpMatch+0x444>
 300738a:	2839                	jal	ra,30073a8 <AssertErrorLog.trans.4>
 300738c:	a811                	j	30073a0 <HAL_GPIO_SetValue+0xe2>
    DCL_GPIO_SetValue(handle->baseAddress, pins, value);
 300738e:	fec42783          	lw	a5,-20(s0)
 3007392:	439c                	lw	a5,0(a5)
 3007394:	fe442603          	lw	a2,-28(s0)
 3007398:	fe842583          	lw	a1,-24(s0)
 300739c:	853e                	mv	a0,a5
 300739e:	3239                	jal	ra,3006cac <DCL_GPIO_SetValue>
}
 30073a0:	40f2                	lw	ra,28(sp)
 30073a2:	4462                	lw	s0,24(sp)
 30073a4:	6105                	addi	sp,sp,32
 30073a6:	8082                	ret

030073a8 <AssertErrorLog.trans.4>:
 30073a8:	9abfb06f          	j	3002d52 <AssertErrorLog>

030073ac <GPIO_SetLevelIrqType>:
  * @param pins OR logical combination of pin.
  * @param mode Value of @ref GPIO_InterruptMode.
  * @retval None.
  */
static void GPIO_SetLevelIrqType(GPIO_Handle *handle, unsigned int pins, GPIO_InterruptMode mode)
{
 30073ac:	1101                	addi	sp,sp,-32
 30073ae:	ce22                	sw	s0,28(sp)
 30073b0:	1000                	addi	s0,sp,32
 30073b2:	fea42623          	sw	a0,-20(s0)
 30073b6:	feb42423          	sw	a1,-24(s0)
 30073ba:	fec42223          	sw	a2,-28(s0)
    handle->baseAddress->GPIO_IBE.reg &= ~pins; /* Disable edge detection */
 30073be:	fec42783          	lw	a5,-20(s0)
 30073c2:	439c                	lw	a5,0(a5)
 30073c4:	4087a683          	lw	a3,1032(a5)
 30073c8:	fe842783          	lw	a5,-24(s0)
 30073cc:	fff7c713          	not	a4,a5
 30073d0:	fec42783          	lw	a5,-20(s0)
 30073d4:	439c                	lw	a5,0(a5)
 30073d6:	8f75                	and	a4,a4,a3
 30073d8:	40e7a423          	sw	a4,1032(a5)
    handle->baseAddress->GPIO_IS.reg |= pins; /* Enable level detection */
 30073dc:	fec42783          	lw	a5,-20(s0)
 30073e0:	439c                	lw	a5,0(a5)
 30073e2:	4047a683          	lw	a3,1028(a5)
 30073e6:	fec42783          	lw	a5,-20(s0)
 30073ea:	439c                	lw	a5,0(a5)
 30073ec:	fe842703          	lw	a4,-24(s0)
 30073f0:	8f55                	or	a4,a4,a3
 30073f2:	40e7a223          	sw	a4,1028(a5)
    if (mode == GPIO_INT_TYPE_HIGH_LEVEL) {
 30073f6:	fe442703          	lw	a4,-28(s0)
 30073fa:	478d                	li	a5,3
 30073fc:	02f71063          	bne	a4,a5,300741c <GPIO_SetLevelIrqType+0x70>
        handle->baseAddress->GPIO_IEV.reg |= pins;
 3007400:	fec42783          	lw	a5,-20(s0)
 3007404:	439c                	lw	a5,0(a5)
 3007406:	40c7a683          	lw	a3,1036(a5)
 300740a:	fec42783          	lw	a5,-20(s0)
 300740e:	439c                	lw	a5,0(a5)
 3007410:	fe842703          	lw	a4,-24(s0)
 3007414:	8f55                	or	a4,a4,a3
 3007416:	40e7a623          	sw	a4,1036(a5)
    } else {
        handle->baseAddress->GPIO_IEV.reg &= ~pins;
    }
}
 300741a:	a005                	j	300743a <GPIO_SetLevelIrqType+0x8e>
        handle->baseAddress->GPIO_IEV.reg &= ~pins;
 300741c:	fec42783          	lw	a5,-20(s0)
 3007420:	439c                	lw	a5,0(a5)
 3007422:	40c7a683          	lw	a3,1036(a5)
 3007426:	fe842783          	lw	a5,-24(s0)
 300742a:	fff7c713          	not	a4,a5
 300742e:	fec42783          	lw	a5,-20(s0)
 3007432:	439c                	lw	a5,0(a5)
 3007434:	8f75                	and	a4,a4,a3
 3007436:	40e7a623          	sw	a4,1036(a5)
}
 300743a:	0001                	nop
 300743c:	4472                	lw	s0,28(sp)
 300743e:	6105                	addi	sp,sp,32
 3007440:	8082                	ret

03007442 <GPIO_SetEdgeIrqType>:
  * @param pins OR logical combination of pin.
  * @param mode Value of @ref GPIO_InterruptMode.
  * @retval None.
  */
static void GPIO_SetEdgeIrqType(GPIO_Handle *handle, unsigned int pins, GPIO_InterruptMode mode)
{
 3007442:	1101                	addi	sp,sp,-32
 3007444:	ce22                	sw	s0,28(sp)
 3007446:	1000                	addi	s0,sp,32
 3007448:	fea42623          	sw	a0,-20(s0)
 300744c:	feb42423          	sw	a1,-24(s0)
 3007450:	fec42223          	sw	a2,-28(s0)
    handle->baseAddress->GPIO_IS.reg &= ~pins; /* Disable level detection. */
 3007454:	fec42783          	lw	a5,-20(s0)
 3007458:	439c                	lw	a5,0(a5)
 300745a:	4047a683          	lw	a3,1028(a5)
 300745e:	fe842783          	lw	a5,-24(s0)
 3007462:	fff7c713          	not	a4,a5
 3007466:	fec42783          	lw	a5,-20(s0)
 300746a:	439c                	lw	a5,0(a5)
 300746c:	8f75                	and	a4,a4,a3
 300746e:	40e7a223          	sw	a4,1028(a5)
    handle->baseAddress->GPIO_IBE.reg &= ~pins; /* Clear detection on both edges. */
 3007472:	fec42783          	lw	a5,-20(s0)
 3007476:	439c                	lw	a5,0(a5)
 3007478:	4087a683          	lw	a3,1032(a5)
 300747c:	fe842783          	lw	a5,-24(s0)
 3007480:	fff7c713          	not	a4,a5
 3007484:	fec42783          	lw	a5,-20(s0)
 3007488:	439c                	lw	a5,0(a5)
 300748a:	8f75                	and	a4,a4,a3
 300748c:	40e7a423          	sw	a4,1032(a5)
    if (mode == GPIO_INT_TYPE_RISE_EDGE) {
 3007490:	fe442703          	lw	a4,-28(s0)
 3007494:	4785                	li	a5,1
 3007496:	02f71063          	bne	a4,a5,30074b6 <GPIO_SetEdgeIrqType+0x74>
        handle->baseAddress->GPIO_IEV.reg |= pins;
 300749a:	fec42783          	lw	a5,-20(s0)
 300749e:	439c                	lw	a5,0(a5)
 30074a0:	40c7a683          	lw	a3,1036(a5)
 30074a4:	fec42783          	lw	a5,-20(s0)
 30074a8:	439c                	lw	a5,0(a5)
 30074aa:	fe842703          	lw	a4,-24(s0)
 30074ae:	8f55                	or	a4,a4,a3
 30074b0:	40e7a623          	sw	a4,1036(a5)
    } else {
        handle->baseAddress->GPIO_IEV.reg &= ~pins;
    }
}
 30074b4:	a005                	j	30074d4 <GPIO_SetEdgeIrqType+0x92>
        handle->baseAddress->GPIO_IEV.reg &= ~pins;
 30074b6:	fec42783          	lw	a5,-20(s0)
 30074ba:	439c                	lw	a5,0(a5)
 30074bc:	40c7a683          	lw	a3,1036(a5)
 30074c0:	fe842783          	lw	a5,-24(s0)
 30074c4:	fff7c713          	not	a4,a5
 30074c8:	fec42783          	lw	a5,-20(s0)
 30074cc:	439c                	lw	a5,0(a5)
 30074ce:	8f75                	and	a4,a4,a3
 30074d0:	40e7a623          	sw	a4,1036(a5)
}
 30074d4:	0001                	nop
 30074d6:	4472                	lw	s0,28(sp)
 30074d8:	6105                	addi	sp,sp,32
 30074da:	8082                	ret

030074dc <HAL_GPIO_SetIrqType>:
  * @param pins OR logical combination of pin.
  * @param mode Value of @ref GPIO_InterruptMode.
  * @retval Value of @ref BASE_StatusType.
  */
BASE_StatusType HAL_GPIO_SetIrqType(GPIO_Handle *handle, unsigned int pins, GPIO_InterruptMode mode)
{
 30074dc:	1101                	addi	sp,sp,-32
 30074de:	ce06                	sw	ra,28(sp)
 30074e0:	cc22                	sw	s0,24(sp)
 30074e2:	1000                	addi	s0,sp,32
 30074e4:	fea42623          	sw	a0,-20(s0)
 30074e8:	feb42423          	sw	a1,-24(s0)
 30074ec:	fec42223          	sw	a2,-28(s0)
    GPIO_ASSERT_PARAM(handle != NULL);
 30074f0:	fec42783          	lw	a5,-20(s0)
 30074f4:	eb89                	bnez	a5,3007506 <HAL_GPIO_SetIrqType+0x2a>
 30074f6:	0ef00593          	li	a1,239
 30074fa:	030127b7          	lui	a5,0x3012
 30074fe:	cdc78513          	addi	a0,a5,-804 # 3011cdc <g_crgIpMatch+0x444>
 3007502:	355d                	jal	ra,30073a8 <AssertErrorLog.trans.4>
 3007504:	a001                	j	3007504 <HAL_GPIO_SetIrqType+0x28>
    GPIO_ASSERT_PARAM(IsGPIOInstance(handle->baseAddress));
 3007506:	fec42783          	lw	a5,-20(s0)
 300750a:	4398                	lw	a4,0(a5)
 300750c:	145007b7          	lui	a5,0x14500
 3007510:	04f70d63          	beq	a4,a5,300756a <HAL_GPIO_SetIrqType+0x8e>
 3007514:	fec42783          	lw	a5,-20(s0)
 3007518:	4398                	lw	a4,0(a5)
 300751a:	145017b7          	lui	a5,0x14501
 300751e:	04f70663          	beq	a4,a5,300756a <HAL_GPIO_SetIrqType+0x8e>
 3007522:	fec42783          	lw	a5,-20(s0)
 3007526:	4398                	lw	a4,0(a5)
 3007528:	145027b7          	lui	a5,0x14502
 300752c:	02f70f63          	beq	a4,a5,300756a <HAL_GPIO_SetIrqType+0x8e>
 3007530:	fec42783          	lw	a5,-20(s0)
 3007534:	4398                	lw	a4,0(a5)
 3007536:	145037b7          	lui	a5,0x14503
 300753a:	02f70863          	beq	a4,a5,300756a <HAL_GPIO_SetIrqType+0x8e>
 300753e:	fec42783          	lw	a5,-20(s0)
 3007542:	4398                	lw	a4,0(a5)
 3007544:	145047b7          	lui	a5,0x14504
 3007548:	02f70163          	beq	a4,a5,300756a <HAL_GPIO_SetIrqType+0x8e>
 300754c:	fec42783          	lw	a5,-20(s0)
 3007550:	4398                	lw	a4,0(a5)
 3007552:	145057b7          	lui	a5,0x14505
 3007556:	00f70a63          	beq	a4,a5,300756a <HAL_GPIO_SetIrqType+0x8e>
 300755a:	0f000593          	li	a1,240
 300755e:	030127b7          	lui	a5,0x3012
 3007562:	cdc78513          	addi	a0,a5,-804 # 3011cdc <g_crgIpMatch+0x444>
 3007566:	3589                	jal	ra,30073a8 <AssertErrorLog.trans.4>
 3007568:	a001                	j	3007568 <HAL_GPIO_SetIrqType+0x8c>
    GPIO_PARAM_CHECK_WITH_RET(IsGpioPins(pins), BASE_STATUS_ERROR);
 300756a:	fe842503          	lw	a0,-24(s0)
 300756e:	e3cff0ef          	jal	ra,3006baa <IsGpioPins>
 3007572:	87aa                	mv	a5,a0
 3007574:	0017c793          	xori	a5,a5,1
 3007578:	9f81                	uxtb	a5
 300757a:	cb91                	beqz	a5,300758e <HAL_GPIO_SetIrqType+0xb2>
 300757c:	0f100593          	li	a1,241
 3007580:	030127b7          	lui	a5,0x3012
 3007584:	cdc78513          	addi	a0,a5,-804 # 3011cdc <g_crgIpMatch+0x444>
 3007588:	3505                	jal	ra,30073a8 <AssertErrorLog.trans.4>
 300758a:	4785                	li	a5,1
 300758c:	aa89                	j	30076de <HAL_GPIO_SetIrqType+0x202>
    GPIO_PARAM_CHECK_WITH_RET(IsGpioITMode(mode), BASE_STATUS_ERROR);
 300758e:	fe442503          	lw	a0,-28(s0)
 3007592:	ec6ff0ef          	jal	ra,3006c58 <IsGpioITMode>
 3007596:	87aa                	mv	a5,a0
 3007598:	0017c793          	xori	a5,a5,1
 300759c:	9f81                	uxtb	a5
 300759e:	cb91                	beqz	a5,30075b2 <HAL_GPIO_SetIrqType+0xd6>
 30075a0:	0f200593          	li	a1,242
 30075a4:	030127b7          	lui	a5,0x3012
 30075a8:	cdc78513          	addi	a0,a5,-804 # 3011cdc <g_crgIpMatch+0x444>
 30075ac:	3bf5                	jal	ra,30073a8 <AssertErrorLog.trans.4>
 30075ae:	4785                	li	a5,1
 30075b0:	a23d                	j	30076de <HAL_GPIO_SetIrqType+0x202>

    /* It must be disabled to avoid triggering interrupts during configuration. */
    DCL_GPIO_DisableIrq(handle->baseAddress, pins);
 30075b2:	fec42783          	lw	a5,-20(s0)
 30075b6:	439c                	lw	a5,0(a5)
 30075b8:	fe842583          	lw	a1,-24(s0)
 30075bc:	853e                	mv	a0,a5
 30075be:	3439                	jal	ra,3006fcc <DCL_GPIO_DisableIrq>

    if ((mode == GPIO_INT_TYPE_HIGH_LEVEL) || (mode == GPIO_INT_TYPE_LOW_LEVEL)) {
 30075c0:	fe442703          	lw	a4,-28(s0)
 30075c4:	478d                	li	a5,3
 30075c6:	00f70763          	beq	a4,a5,30075d4 <HAL_GPIO_SetIrqType+0xf8>
 30075ca:	fe442703          	lw	a4,-28(s0)
 30075ce:	4789                	li	a5,2
 30075d0:	00f71a63          	bne	a4,a5,30075e4 <HAL_GPIO_SetIrqType+0x108>
        GPIO_SetLevelIrqType(handle, pins, mode);
 30075d4:	fe442603          	lw	a2,-28(s0)
 30075d8:	fe842583          	lw	a1,-24(s0)
 30075dc:	fec42503          	lw	a0,-20(s0)
 30075e0:	33f1                	jal	ra,30073ac <GPIO_SetLevelIrqType>
 30075e2:	a0f5                	j	30076ce <HAL_GPIO_SetIrqType+0x1f2>
    } else if (mode == GPIO_INT_TYPE_BOTH_EDGE) {
 30075e4:	fe442703          	lw	a4,-28(s0)
 30075e8:	4791                	li	a5,4
 30075ea:	04f71e63          	bne	a4,a5,3007646 <HAL_GPIO_SetIrqType+0x16a>
        handle->baseAddress->GPIO_IEV.reg &= ~pins;
 30075ee:	fec42783          	lw	a5,-20(s0)
 30075f2:	439c                	lw	a5,0(a5)
 30075f4:	40c7a683          	lw	a3,1036(a5)
 30075f8:	fe842783          	lw	a5,-24(s0)
 30075fc:	fff7c713          	not	a4,a5
 3007600:	fec42783          	lw	a5,-20(s0)
 3007604:	439c                	lw	a5,0(a5)
 3007606:	8f75                	and	a4,a4,a3
 3007608:	40e7a623          	sw	a4,1036(a5)
        handle->baseAddress->GPIO_IS.reg &= ~pins;
 300760c:	fec42783          	lw	a5,-20(s0)
 3007610:	439c                	lw	a5,0(a5)
 3007612:	4047a683          	lw	a3,1028(a5)
 3007616:	fe842783          	lw	a5,-24(s0)
 300761a:	fff7c713          	not	a4,a5
 300761e:	fec42783          	lw	a5,-20(s0)
 3007622:	439c                	lw	a5,0(a5)
 3007624:	8f75                	and	a4,a4,a3
 3007626:	40e7a223          	sw	a4,1028(a5)
        handle->baseAddress->GPIO_IBE.reg |= pins;
 300762a:	fec42783          	lw	a5,-20(s0)
 300762e:	439c                	lw	a5,0(a5)
 3007630:	4087a683          	lw	a3,1032(a5)
 3007634:	fec42783          	lw	a5,-20(s0)
 3007638:	439c                	lw	a5,0(a5)
 300763a:	fe842703          	lw	a4,-24(s0)
 300763e:	8f55                	or	a4,a4,a3
 3007640:	40e7a423          	sw	a4,1032(a5)
 3007644:	a069                	j	30076ce <HAL_GPIO_SetIrqType+0x1f2>
    } else if ((mode == GPIO_INT_TYPE_RISE_EDGE) || (mode == GPIO_INT_TYPE_FALL_EDGE)) {
 3007646:	fe442703          	lw	a4,-28(s0)
 300764a:	4785                	li	a5,1
 300764c:	00f70563          	beq	a4,a5,3007656 <HAL_GPIO_SetIrqType+0x17a>
 3007650:	fe442783          	lw	a5,-28(s0)
 3007654:	eb89                	bnez	a5,3007666 <HAL_GPIO_SetIrqType+0x18a>
        GPIO_SetEdgeIrqType(handle, pins, mode);
 3007656:	fe442603          	lw	a2,-28(s0)
 300765a:	fe842583          	lw	a1,-24(s0)
 300765e:	fec42503          	lw	a0,-20(s0)
 3007662:	33c5                	jal	ra,3007442 <GPIO_SetEdgeIrqType>
 3007664:	a0ad                	j	30076ce <HAL_GPIO_SetIrqType+0x1f2>
    } else if (mode == GPIO_INT_TYPE_NONE) {
 3007666:	fe442703          	lw	a4,-28(s0)
 300766a:	4795                	li	a5,5
 300766c:	06f71163          	bne	a4,a5,30076ce <HAL_GPIO_SetIrqType+0x1f2>
        /* No interruptMode: disable everything. */
        handle->baseAddress->GPIO_IEV.reg &= ~pins;
 3007670:	fec42783          	lw	a5,-20(s0)
 3007674:	439c                	lw	a5,0(a5)
 3007676:	40c7a683          	lw	a3,1036(a5)
 300767a:	fe842783          	lw	a5,-24(s0)
 300767e:	fff7c713          	not	a4,a5
 3007682:	fec42783          	lw	a5,-20(s0)
 3007686:	439c                	lw	a5,0(a5)
 3007688:	8f75                	and	a4,a4,a3
 300768a:	40e7a623          	sw	a4,1036(a5)
        handle->baseAddress->GPIO_IS.reg &= ~pins;
 300768e:	fec42783          	lw	a5,-20(s0)
 3007692:	439c                	lw	a5,0(a5)
 3007694:	4047a683          	lw	a3,1028(a5)
 3007698:	fe842783          	lw	a5,-24(s0)
 300769c:	fff7c713          	not	a4,a5
 30076a0:	fec42783          	lw	a5,-20(s0)
 30076a4:	439c                	lw	a5,0(a5)
 30076a6:	8f75                	and	a4,a4,a3
 30076a8:	40e7a223          	sw	a4,1028(a5)
        handle->baseAddress->GPIO_IBE.reg &= ~pins;
 30076ac:	fec42783          	lw	a5,-20(s0)
 30076b0:	439c                	lw	a5,0(a5)
 30076b2:	4087a683          	lw	a3,1032(a5)
 30076b6:	fe842783          	lw	a5,-24(s0)
 30076ba:	fff7c713          	not	a4,a5
 30076be:	fec42783          	lw	a5,-20(s0)
 30076c2:	439c                	lw	a5,0(a5)
 30076c4:	8f75                	and	a4,a4,a3
 30076c6:	40e7a423          	sw	a4,1032(a5)
        return BASE_STATUS_ERROR;
 30076ca:	4785                	li	a5,1
 30076cc:	a809                	j	30076de <HAL_GPIO_SetIrqType+0x202>
    }

    DCL_GPIO_EnableIrq(handle->baseAddress, pins);
 30076ce:	fec42783          	lw	a5,-20(s0)
 30076d2:	439c                	lw	a5,0(a5)
 30076d4:	fe842583          	lw	a1,-24(s0)
 30076d8:	853e                	mv	a0,a5
 30076da:	3089                	jal	ra,3006f1c <DCL_GPIO_EnableIrq>
    return BASE_STATUS_OK;
 30076dc:	4781                	li	a5,0
}
 30076de:	853e                	mv	a0,a5
 30076e0:	40f2                	lw	ra,28(sp)
 30076e2:	4462                	lw	s0,24(sp)
 30076e4:	6105                	addi	sp,sp,32
 30076e6:	8082                	ret

030076e8 <GPIO_ExcuteCallBack>:
  * @param handle Value of @ref GPIO_Handle.
  * @param pin Value of @ref GPIO_PIN.
  * @retval None.
  */
static void GPIO_ExcuteCallBack(GPIO_Handle *handle, GPIO_PIN pin)
{
 30076e8:	7179                	addi	sp,sp,-48
 30076ea:	d606                	sw	ra,44(sp)
 30076ec:	d422                	sw	s0,40(sp)
 30076ee:	1800                	addi	s0,sp,48
 30076f0:	fca42e23          	sw	a0,-36(s0)
 30076f4:	fcb42c23          	sw	a1,-40(s0)
    GPIO_ASSERT_PARAM(handle != NULL);
 30076f8:	fdc42783          	lw	a5,-36(s0)
 30076fc:	eb89                	bnez	a5,300770e <GPIO_ExcuteCallBack+0x26>
 30076fe:	11300593          	li	a1,275
 3007702:	030127b7          	lui	a5,0x3012
 3007706:	cdc78513          	addi	a0,a5,-804 # 3011cdc <g_crgIpMatch+0x444>
 300770a:	3979                	jal	ra,30073a8 <AssertErrorLog.trans.4>
 300770c:	a001                	j	300770c <GPIO_ExcuteCallBack+0x24>
    GPIO_ASSERT_PARAM(IsGPIOInstance(handle->baseAddress));
 300770e:	fdc42783          	lw	a5,-36(s0)
 3007712:	4398                	lw	a4,0(a5)
 3007714:	145007b7          	lui	a5,0x14500
 3007718:	04f70d63          	beq	a4,a5,3007772 <GPIO_ExcuteCallBack+0x8a>
 300771c:	fdc42783          	lw	a5,-36(s0)
 3007720:	4398                	lw	a4,0(a5)
 3007722:	145017b7          	lui	a5,0x14501
 3007726:	04f70663          	beq	a4,a5,3007772 <GPIO_ExcuteCallBack+0x8a>
 300772a:	fdc42783          	lw	a5,-36(s0)
 300772e:	4398                	lw	a4,0(a5)
 3007730:	145027b7          	lui	a5,0x14502
 3007734:	02f70f63          	beq	a4,a5,3007772 <GPIO_ExcuteCallBack+0x8a>
 3007738:	fdc42783          	lw	a5,-36(s0)
 300773c:	4398                	lw	a4,0(a5)
 300773e:	145037b7          	lui	a5,0x14503
 3007742:	02f70863          	beq	a4,a5,3007772 <GPIO_ExcuteCallBack+0x8a>
 3007746:	fdc42783          	lw	a5,-36(s0)
 300774a:	4398                	lw	a4,0(a5)
 300774c:	145047b7          	lui	a5,0x14504
 3007750:	02f70163          	beq	a4,a5,3007772 <GPIO_ExcuteCallBack+0x8a>
 3007754:	fdc42783          	lw	a5,-36(s0)
 3007758:	4398                	lw	a4,0(a5)
 300775a:	145057b7          	lui	a5,0x14505
 300775e:	00f70a63          	beq	a4,a5,3007772 <GPIO_ExcuteCallBack+0x8a>
 3007762:	11400593          	li	a1,276
 3007766:	030127b7          	lui	a5,0x3012
 300776a:	cdc78513          	addi	a0,a5,-804 # 3011cdc <g_crgIpMatch+0x444>
 300776e:	392d                	jal	ra,30073a8 <AssertErrorLog.trans.4>
 3007770:	a001                	j	3007770 <GPIO_ExcuteCallBack+0x88>
    GPIO_PARAM_CHECK_NO_RET(IsGpioPins(pin));
 3007772:	fd842503          	lw	a0,-40(s0)
 3007776:	c34ff0ef          	jal	ra,3006baa <IsGpioPins>
 300777a:	87aa                	mv	a5,a0
 300777c:	0017c793          	xori	a5,a5,1
 3007780:	9f81                	uxtb	a5
 3007782:	cb89                	beqz	a5,3007794 <GPIO_ExcuteCallBack+0xac>
 3007784:	11500593          	li	a1,277
 3007788:	030127b7          	lui	a5,0x3012
 300778c:	cdc78513          	addi	a0,a5,-804 # 3011cdc <g_crgIpMatch+0x444>
 3007790:	3921                	jal	ra,30073a8 <AssertErrorLog.trans.4>
 3007792:	a899                	j	30077e8 <GPIO_ExcuteCallBack+0x100>
    for (unsigned int i = 0; i < GPIO_PIN_NUM; i++) {
 3007794:	fe042623          	sw	zero,-20(s0)
 3007798:	a099                	j	30077de <GPIO_ExcuteCallBack+0xf6>
        if (handle->userCallBack.GPIO_CallbackFuncs[i].pin == pin) {
 300779a:	fdc42703          	lw	a4,-36(s0)
 300779e:	fec42783          	lw	a5,-20(s0)
 30077a2:	078e                	slli	a5,a5,0x3
 30077a4:	97ba                	add	a5,a5,a4
 30077a6:	479c                	lw	a5,8(a5)
 30077a8:	fd842703          	lw	a4,-40(s0)
 30077ac:	02f71463          	bne	a4,a5,30077d4 <GPIO_ExcuteCallBack+0xec>
            if (handle->userCallBack.GPIO_CallbackFuncs[i].callbackFunc != NULL) {
 30077b0:	fdc42703          	lw	a4,-36(s0)
 30077b4:	fec42783          	lw	a5,-20(s0)
 30077b8:	078e                	slli	a5,a5,0x3
 30077ba:	97ba                	add	a5,a5,a4
 30077bc:	47dc                	lw	a5,12(a5)
 30077be:	cb99                	beqz	a5,30077d4 <GPIO_ExcuteCallBack+0xec>
                handle->userCallBack.GPIO_CallbackFuncs[i].callbackFunc(handle);
 30077c0:	fdc42703          	lw	a4,-36(s0)
 30077c4:	fec42783          	lw	a5,-20(s0)
 30077c8:	078e                	slli	a5,a5,0x3
 30077ca:	97ba                	add	a5,a5,a4
 30077cc:	47dc                	lw	a5,12(a5)
 30077ce:	fdc42503          	lw	a0,-36(s0)
 30077d2:	9782                	jalr	a5
    for (unsigned int i = 0; i < GPIO_PIN_NUM; i++) {
 30077d4:	fec42783          	lw	a5,-20(s0)
 30077d8:	0785                	addi	a5,a5,1
 30077da:	fef42623          	sw	a5,-20(s0)
 30077de:	fec42703          	lw	a4,-20(s0)
 30077e2:	479d                	li	a5,7
 30077e4:	fae7fbe3          	bgeu	a5,a4,300779a <GPIO_ExcuteCallBack+0xb2>
            }
        }
    }
}
 30077e8:	50b2                	lw	ra,44(sp)
 30077ea:	5422                	lw	s0,40(sp)
 30077ec:	6145                	addi	sp,sp,48
 30077ee:	8082                	ret

030077f0 <HAL_GPIO_IrqHandler>:
  * @brief Handle GPIO interrupt request.
  * @param handle Interrupt parameter.
  * @retval None.
  */
void HAL_GPIO_IrqHandler(void *handle)
{
 30077f0:	7179                	addi	sp,sp,-48
 30077f2:	d606                	sw	ra,44(sp)
 30077f4:	d422                	sw	s0,40(sp)
 30077f6:	1800                	addi	s0,sp,48
 30077f8:	fca42e23          	sw	a0,-36(s0)
    GPIO_Handle *gpioHandle = (GPIO_Handle *)handle;
 30077fc:	fdc42783          	lw	a5,-36(s0)
 3007800:	fef42423          	sw	a5,-24(s0)
    GPIO_ASSERT_PARAM(gpioHandle != NULL);
 3007804:	fe842783          	lw	a5,-24(s0)
 3007808:	eb89                	bnez	a5,300781a <HAL_GPIO_IrqHandler+0x2a>
 300780a:	12700593          	li	a1,295
 300780e:	030127b7          	lui	a5,0x3012
 3007812:	cdc78513          	addi	a0,a5,-804 # 3011cdc <g_crgIpMatch+0x444>
 3007816:	3e49                	jal	ra,30073a8 <AssertErrorLog.trans.4>
 3007818:	a001                	j	3007818 <HAL_GPIO_IrqHandler+0x28>
    GPIO_ASSERT_PARAM(IsGPIOInstance(gpioHandle->baseAddress));
 300781a:	fe842783          	lw	a5,-24(s0)
 300781e:	4398                	lw	a4,0(a5)
 3007820:	145007b7          	lui	a5,0x14500
 3007824:	04f70d63          	beq	a4,a5,300787e <HAL_GPIO_IrqHandler+0x8e>
 3007828:	fe842783          	lw	a5,-24(s0)
 300782c:	4398                	lw	a4,0(a5)
 300782e:	145017b7          	lui	a5,0x14501
 3007832:	04f70663          	beq	a4,a5,300787e <HAL_GPIO_IrqHandler+0x8e>
 3007836:	fe842783          	lw	a5,-24(s0)
 300783a:	4398                	lw	a4,0(a5)
 300783c:	145027b7          	lui	a5,0x14502
 3007840:	02f70f63          	beq	a4,a5,300787e <HAL_GPIO_IrqHandler+0x8e>
 3007844:	fe842783          	lw	a5,-24(s0)
 3007848:	4398                	lw	a4,0(a5)
 300784a:	145037b7          	lui	a5,0x14503
 300784e:	02f70863          	beq	a4,a5,300787e <HAL_GPIO_IrqHandler+0x8e>
 3007852:	fe842783          	lw	a5,-24(s0)
 3007856:	4398                	lw	a4,0(a5)
 3007858:	145047b7          	lui	a5,0x14504
 300785c:	02f70163          	beq	a4,a5,300787e <HAL_GPIO_IrqHandler+0x8e>
 3007860:	fe842783          	lw	a5,-24(s0)
 3007864:	4398                	lw	a4,0(a5)
 3007866:	145057b7          	lui	a5,0x14505
 300786a:	00f70a63          	beq	a4,a5,300787e <HAL_GPIO_IrqHandler+0x8e>
 300786e:	12800593          	li	a1,296
 3007872:	030127b7          	lui	a5,0x3012
 3007876:	cdc78513          	addi	a0,a5,-804 # 3011cdc <g_crgIpMatch+0x444>
 300787a:	363d                	jal	ra,30073a8 <AssertErrorLog.trans.4>
 300787c:	a001                	j	300787c <HAL_GPIO_IrqHandler+0x8c>
    unsigned int position = 0x00000000U;
 300787e:	fe042623          	sw	zero,-20(s0)
    unsigned int pinCurrent = 0x00000000U;
 3007882:	fe042223          	sw	zero,-28(s0)
    unsigned int mis = DCL_GPIO_GetMIS(gpioHandle->baseAddress); /* Queries the masked GPIO interrupt status. */
 3007886:	fe842783          	lw	a5,-24(s0)
 300788a:	439c                	lw	a5,0(a5)
 300788c:	853e                	mv	a0,a5
 300788e:	fe8ff0ef          	jal	ra,3007076 <DCL_GPIO_GetMIS>
 3007892:	fea42023          	sw	a0,-32(s0)

    /* Determine which pin sets the callback function. */
    while ((mis >> position) != BASE_CFG_UNSET) {
 3007896:	a0b1                	j	30078e2 <HAL_GPIO_IrqHandler+0xf2>
        pinCurrent = mis & (1 << position);
 3007898:	4705                	li	a4,1
 300789a:	fec42783          	lw	a5,-20(s0)
 300789e:	00f717b3          	sll	a5,a4,a5
 30078a2:	873e                	mv	a4,a5
 30078a4:	fe042783          	lw	a5,-32(s0)
 30078a8:	8ff9                	and	a5,a5,a4
 30078aa:	fef42223          	sw	a5,-28(s0)
        if (pinCurrent) {
 30078ae:	fe442783          	lw	a5,-28(s0)
 30078b2:	c39d                	beqz	a5,30078d8 <HAL_GPIO_IrqHandler+0xe8>
            gpioHandle->pins = pinCurrent;
 30078b4:	fe842783          	lw	a5,-24(s0)
 30078b8:	fe442703          	lw	a4,-28(s0)
 30078bc:	c3d8                	sw	a4,4(a5)
            DCL_GPIO_ClearIrq(gpioHandle->baseAddress, pinCurrent);
 30078be:	fe842783          	lw	a5,-24(s0)
 30078c2:	439c                	lw	a5,0(a5)
 30078c4:	fe442583          	lw	a1,-28(s0)
 30078c8:	853e                	mv	a0,a5
 30078ca:	dacff0ef          	jal	ra,3006e76 <DCL_GPIO_ClearIrq>
            GPIO_ExcuteCallBack(gpioHandle, pinCurrent);
 30078ce:	fe442583          	lw	a1,-28(s0)
 30078d2:	fe842503          	lw	a0,-24(s0)
 30078d6:	3d09                	jal	ra,30076e8 <GPIO_ExcuteCallBack>
        }
        position++;
 30078d8:	fec42783          	lw	a5,-20(s0)
 30078dc:	0785                	addi	a5,a5,1
 30078de:	fef42623          	sw	a5,-20(s0)
    while ((mis >> position) != BASE_CFG_UNSET) {
 30078e2:	fe042703          	lw	a4,-32(s0)
 30078e6:	fec42783          	lw	a5,-20(s0)
 30078ea:	00f757b3          	srl	a5,a4,a5
 30078ee:	f7cd                	bnez	a5,3007898 <HAL_GPIO_IrqHandler+0xa8>
    }
}
 30078f0:	0001                	nop
 30078f2:	50b2                	lw	ra,44(sp)
 30078f4:	5422                	lw	s0,40(sp)
 30078f6:	6145                	addi	sp,sp,48
 30078f8:	8082                	ret

030078fa <HAL_GPIO_RegisterCallBack>:
  * @param pin Value of @ref GPIO_PIN.
  * @param pCallback Value of @ref GPIO_CallbackType.
  * @retval None.
  */
void HAL_GPIO_RegisterCallBack(GPIO_Handle *handle, GPIO_PIN pin, GPIO_CallbackType pCallback)
{
 30078fa:	7179                	addi	sp,sp,-48
 30078fc:	d606                	sw	ra,44(sp)
 30078fe:	d422                	sw	s0,40(sp)
 3007900:	1800                	addi	s0,sp,48
 3007902:	fca42e23          	sw	a0,-36(s0)
 3007906:	fcb42c23          	sw	a1,-40(s0)
 300790a:	fcc42a23          	sw	a2,-44(s0)
    GPIO_ASSERT_PARAM(handle != NULL);
 300790e:	fdc42783          	lw	a5,-36(s0)
 3007912:	eb89                	bnez	a5,3007924 <HAL_GPIO_RegisterCallBack+0x2a>
 3007914:	14200593          	li	a1,322
 3007918:	030127b7          	lui	a5,0x3012
 300791c:	cdc78513          	addi	a0,a5,-804 # 3011cdc <g_crgIpMatch+0x444>
 3007920:	3461                	jal	ra,30073a8 <AssertErrorLog.trans.4>
 3007922:	a001                	j	3007922 <HAL_GPIO_RegisterCallBack+0x28>
    GPIO_ASSERT_PARAM(IsGPIOInstance(handle->baseAddress));
 3007924:	fdc42783          	lw	a5,-36(s0)
 3007928:	4398                	lw	a4,0(a5)
 300792a:	145007b7          	lui	a5,0x14500
 300792e:	04f70d63          	beq	a4,a5,3007988 <HAL_GPIO_RegisterCallBack+0x8e>
 3007932:	fdc42783          	lw	a5,-36(s0)
 3007936:	4398                	lw	a4,0(a5)
 3007938:	145017b7          	lui	a5,0x14501
 300793c:	04f70663          	beq	a4,a5,3007988 <HAL_GPIO_RegisterCallBack+0x8e>
 3007940:	fdc42783          	lw	a5,-36(s0)
 3007944:	4398                	lw	a4,0(a5)
 3007946:	145027b7          	lui	a5,0x14502
 300794a:	02f70f63          	beq	a4,a5,3007988 <HAL_GPIO_RegisterCallBack+0x8e>
 300794e:	fdc42783          	lw	a5,-36(s0)
 3007952:	4398                	lw	a4,0(a5)
 3007954:	145037b7          	lui	a5,0x14503
 3007958:	02f70863          	beq	a4,a5,3007988 <HAL_GPIO_RegisterCallBack+0x8e>
 300795c:	fdc42783          	lw	a5,-36(s0)
 3007960:	4398                	lw	a4,0(a5)
 3007962:	145047b7          	lui	a5,0x14504
 3007966:	02f70163          	beq	a4,a5,3007988 <HAL_GPIO_RegisterCallBack+0x8e>
 300796a:	fdc42783          	lw	a5,-36(s0)
 300796e:	4398                	lw	a4,0(a5)
 3007970:	145057b7          	lui	a5,0x14505
 3007974:	00f70a63          	beq	a4,a5,3007988 <HAL_GPIO_RegisterCallBack+0x8e>
 3007978:	14300593          	li	a1,323
 300797c:	030127b7          	lui	a5,0x3012
 3007980:	cdc78513          	addi	a0,a5,-804 # 3011cdc <g_crgIpMatch+0x444>
 3007984:	3415                	jal	ra,30073a8 <AssertErrorLog.trans.4>
 3007986:	a001                	j	3007986 <HAL_GPIO_RegisterCallBack+0x8c>
    GPIO_PARAM_CHECK_NO_RET(IsGpioPin(pin));
 3007988:	fd842503          	lw	a0,-40(s0)
 300798c:	a4eff0ef          	jal	ra,3006bda <IsGpioPin>
 3007990:	87aa                	mv	a5,a0
 3007992:	0017c793          	xori	a5,a5,1
 3007996:	9f81                	uxtb	a5
 3007998:	cb89                	beqz	a5,30079aa <HAL_GPIO_RegisterCallBack+0xb0>
 300799a:	14400593          	li	a1,324
 300799e:	030127b7          	lui	a5,0x3012
 30079a2:	cdc78513          	addi	a0,a5,-804 # 3011cdc <g_crgIpMatch+0x444>
 30079a6:	3409                	jal	ra,30073a8 <AssertErrorLog.trans.4>
 30079a8:	a091                	j	30079ec <HAL_GPIO_RegisterCallBack+0xf2>
    for (unsigned int i = 0; i < GPIO_PIN_NUM; i++) {
 30079aa:	fe042623          	sw	zero,-20(s0)
 30079ae:	a815                	j	30079e2 <HAL_GPIO_RegisterCallBack+0xe8>
        if (handle->userCallBack.GPIO_CallbackFuncs[i].pin == pin) {
 30079b0:	fdc42703          	lw	a4,-36(s0)
 30079b4:	fec42783          	lw	a5,-20(s0)
 30079b8:	078e                	slli	a5,a5,0x3
 30079ba:	97ba                	add	a5,a5,a4
 30079bc:	479c                	lw	a5,8(a5)
 30079be:	fd842703          	lw	a4,-40(s0)
 30079c2:	00f71b63          	bne	a4,a5,30079d8 <HAL_GPIO_RegisterCallBack+0xde>
            handle->userCallBack.GPIO_CallbackFuncs[i].callbackFunc = pCallback;
 30079c6:	fdc42703          	lw	a4,-36(s0)
 30079ca:	fec42783          	lw	a5,-20(s0)
 30079ce:	078e                	slli	a5,a5,0x3
 30079d0:	97ba                	add	a5,a5,a4
 30079d2:	fd442703          	lw	a4,-44(s0)
 30079d6:	c7d8                	sw	a4,12(a5)
    for (unsigned int i = 0; i < GPIO_PIN_NUM; i++) {
 30079d8:	fec42783          	lw	a5,-20(s0)
 30079dc:	0785                	addi	a5,a5,1
 30079de:	fef42623          	sw	a5,-20(s0)
 30079e2:	fec42703          	lw	a4,-20(s0)
 30079e6:	479d                	li	a5,7
 30079e8:	fce7f4e3          	bgeu	a5,a4,30079b0 <HAL_GPIO_RegisterCallBack+0xb6>
        }
    }
 30079ec:	50b2                	lw	ra,44(sp)
 30079ee:	5422                	lw	s0,40(sp)
 30079f0:	6145                	addi	sp,sp,48
 30079f2:	8082                	ret

030079f4 <IsGptPwmNum>:
  * @param num    Pwm number, only valid if keep equ 0
  * @retval true
  * @retval false
  */
static inline bool IsGptPwmNum(unsigned int num)
{
 30079f4:	1101                	addi	sp,sp,-32
 30079f6:	ce22                	sw	s0,28(sp)
 30079f8:	1000                	addi	s0,sp,32
 30079fa:	fea42623          	sw	a0,-20(s0)
    return ((num) <= GPT_PWM_MAX_NUM);
 30079fe:	fec42783          	lw	a5,-20(s0)
 3007a02:	4007b793          	sltiu	a5,a5,1024
 3007a06:	9f81                	uxtb	a5
}
 3007a08:	853e                	mv	a0,a5
 3007a0a:	4472                	lw	s0,28(sp)
 3007a0c:	6105                	addi	sp,sp,32
 3007a0e:	8082                	ret

03007a10 <IsGptDiv>:
  * @param div  division factor of GPT
  * @retval true
  * @retval false
  */
static inline bool IsGptDiv(unsigned int div)
{
 3007a10:	1101                	addi	sp,sp,-32
 3007a12:	ce22                	sw	s0,28(sp)
 3007a14:	1000                	addi	s0,sp,32
 3007a16:	fea42623          	sw	a0,-20(s0)
    return (div <= GPT_PWM_DIV_FACTOR_MAX_VALUE);
 3007a1a:	fec42703          	lw	a4,-20(s0)
 3007a1e:	6785                	lui	a5,0x1
 3007a20:	00f737b3          	sltu	a5,a4,a5
 3007a24:	9f81                	uxtb	a5
}
 3007a26:	853e                	mv	a0,a5
 3007a28:	4472                	lw	s0,28(sp)
 3007a2a:	6105                	addi	sp,sp,32
 3007a2c:	8082                	ret

03007a2e <IsGptPeriod>:
  * @param period  Period of GPT
  * @retval true
  * @retval false
  */
static inline bool IsGptPeriod(unsigned int period)
{
 3007a2e:	1101                	addi	sp,sp,-32
 3007a30:	ce22                	sw	s0,28(sp)
 3007a32:	1000                	addi	s0,sp,32
 3007a34:	fea42623          	sw	a0,-20(s0)
    return ((period >= GPT_PWM_PERIOD_MIN_VALUE) && (period <= GPT_PWM_PERIOD_MAX_VALUE));
 3007a38:	fec42703          	lw	a4,-20(s0)
 3007a3c:	4785                	li	a5,1
 3007a3e:	00e7f963          	bgeu	a5,a4,3007a50 <IsGptPeriod+0x22>
 3007a42:	fec42703          	lw	a4,-20(s0)
 3007a46:	67c1                	lui	a5,0x10
 3007a48:	00f77463          	bgeu	a4,a5,3007a50 <IsGptPeriod+0x22>
 3007a4c:	4785                	li	a5,1
 3007a4e:	a011                	j	3007a52 <IsGptPeriod+0x24>
 3007a50:	4781                	li	a5,0
 3007a52:	8b85                	andi	a5,a5,1
 3007a54:	9f81                	uxtb	a5
}
 3007a56:	853e                	mv	a0,a5
 3007a58:	4472                	lw	s0,28(sp)
 3007a5a:	6105                	addi	sp,sp,32
 3007a5c:	8082                	ret

03007a5e <IsGptRefDot>:
  * @param  value  value of GPT ref dot
  * @retval true
  * @retval false
  */
static inline bool IsGptRefDot(unsigned int value)
{
 3007a5e:	1101                	addi	sp,sp,-32
 3007a60:	ce22                	sw	s0,28(sp)
 3007a62:	1000                	addi	s0,sp,32
 3007a64:	fea42623          	sw	a0,-20(s0)
    return (value <= GPT_TC_PRD_MAX_VALUE);
 3007a68:	fec42703          	lw	a4,-20(s0)
 3007a6c:	67c1                	lui	a5,0x10
 3007a6e:	00f737b3          	sltu	a5,a4,a5
 3007a72:	9f81                	uxtb	a5
}
 3007a74:	853e                	mv	a0,a5
 3007a76:	4472                	lw	s0,28(sp)
 3007a78:	6105                	addi	sp,sp,32
 3007a7a:	8082                	ret

03007a7c <IsGptAction>:
  * @param period  Period of GPT
  * @retval true
  * @retval false
  */
static inline bool IsGptAction(unsigned int action)
{
 3007a7c:	1101                	addi	sp,sp,-32
 3007a7e:	ce22                	sw	s0,28(sp)
 3007a80:	1000                	addi	s0,sp,32
 3007a82:	fea42623          	sw	a0,-20(s0)
    return (action <= GPT_ACTION_OUTPUT_FLIP);
 3007a86:	fec42783          	lw	a5,-20(s0)
 3007a8a:	0047b793          	sltiu	a5,a5,4
 3007a8e:	9f81                	uxtb	a5
}
 3007a90:	853e                	mv	a0,a5
 3007a92:	4472                	lw	s0,28(sp)
 3007a94:	6105                	addi	sp,sp,32
 3007a96:	8082                	ret

03007a98 <GPT_GetKeepState>:
 * @param   handle   GPT Handle
 * @retval  keep   0: Outputs a fixed number of square waves
 *                 1: Output continuous square wave
 */
static unsigned int GPT_GetKeepState(GPT_Handle *handle)
{
 3007a98:	7179                	addi	sp,sp,-48
 3007a9a:	d622                	sw	s0,44(sp)
 3007a9c:	1800                	addi	s0,sp,48
 3007a9e:	fca42e23          	sw	a0,-36(s0)
    GPT_PWM0_CFG_REG pwm0Cfg;
    pwm0Cfg.reg = handle->baseAddress->GPT_PWM0_CFG.reg;
 3007aa2:	fdc42783          	lw	a5,-36(s0)
 3007aa6:	439c                	lw	a5,0(a5)
 3007aa8:	4007a783          	lw	a5,1024(a5) # 10400 <RAM_SIZE+0xb400>
 3007aac:	fef42623          	sw	a5,-20(s0)
    return pwm0Cfg.BIT.rg_pwm0_keep;
 3007ab0:	fec42783          	lw	a5,-20(s0)
 3007ab4:	83fd                	srli	a5,a5,0x1f
 3007ab6:	9f81                	uxtb	a5
}
 3007ab8:	853e                	mv	a0,a5
 3007aba:	5432                	lw	s0,44(sp)
 3007abc:	6145                	addi	sp,sp,48
 3007abe:	8082                	ret

03007ac0 <HAL_GPT_Init>:
 * @param   handle   GPT Handle.
 * @retval  BASE_STATUS_OK   Success
 * @retval  BASE_STATUS_ERROR Paramter check fail
 */
BASE_StatusType HAL_GPT_Init(GPT_Handle *handle)
{
 3007ac0:	1101                	addi	sp,sp,-32
 3007ac2:	ce06                	sw	ra,28(sp)
 3007ac4:	cc22                	sw	s0,24(sp)
 3007ac6:	1000                	addi	s0,sp,32
 3007ac8:	fea42623          	sw	a0,-20(s0)
    GPT_ASSERT_PARAM(handle != NULL);
 3007acc:	fec42783          	lw	a5,-20(s0)
 3007ad0:	eb89                	bnez	a5,3007ae2 <HAL_GPT_Init+0x22>
 3007ad2:	03500593          	li	a1,53
 3007ad6:	030127b7          	lui	a5,0x3012
 3007ada:	cf878513          	addi	a0,a5,-776 # 3011cf8 <g_crgIpMatch+0x460>
 3007ade:	30e9                	jal	ra,30073a8 <AssertErrorLog.trans.4>
 3007ae0:	a001                	j	3007ae0 <HAL_GPT_Init+0x20>
    GPT_ASSERT_PARAM(IsGPTInstance(handle->baseAddress));
 3007ae2:	fec42783          	lw	a5,-20(s0)
 3007ae6:	4398                	lw	a4,0(a5)
 3007ae8:	147007b7          	lui	a5,0x14700
 3007aec:	02f70f63          	beq	a4,a5,3007b2a <HAL_GPT_Init+0x6a>
 3007af0:	fec42783          	lw	a5,-20(s0)
 3007af4:	4398                	lw	a4,0(a5)
 3007af6:	147017b7          	lui	a5,0x14701
 3007afa:	02f70863          	beq	a4,a5,3007b2a <HAL_GPT_Init+0x6a>
 3007afe:	fec42783          	lw	a5,-20(s0)
 3007b02:	4398                	lw	a4,0(a5)
 3007b04:	147027b7          	lui	a5,0x14702
 3007b08:	02f70163          	beq	a4,a5,3007b2a <HAL_GPT_Init+0x6a>
 3007b0c:	fec42783          	lw	a5,-20(s0)
 3007b10:	4398                	lw	a4,0(a5)
 3007b12:	147037b7          	lui	a5,0x14703
 3007b16:	00f70a63          	beq	a4,a5,3007b2a <HAL_GPT_Init+0x6a>
 3007b1a:	03600593          	li	a1,54
 3007b1e:	030127b7          	lui	a5,0x3012
 3007b22:	cf878513          	addi	a0,a5,-776 # 3011cf8 <g_crgIpMatch+0x460>
 3007b26:	23fd                	jal	ra,3008114 <AssertErrorLog.trans.5>
 3007b28:	a001                	j	3007b28 <HAL_GPT_Init+0x68>

    HAL_GPT_Stop(handle);
 3007b2a:	fec42503          	lw	a0,-20(s0)
 3007b2e:	207d                	jal	ra,3007bdc <HAL_GPT_Stop>
    if (HAL_GPT_Config(handle) == BASE_STATUS_ERROR) {
 3007b30:	fec42503          	lw	a0,-20(s0)
 3007b34:	2a15                	jal	ra,3007c68 <HAL_GPT_Config>
 3007b36:	872a                	mv	a4,a0
 3007b38:	4785                	li	a5,1
 3007b3a:	00f71463          	bne	a4,a5,3007b42 <HAL_GPT_Init+0x82>
        return BASE_STATUS_ERROR;
 3007b3e:	4785                	li	a5,1
 3007b40:	a011                	j	3007b44 <HAL_GPT_Init+0x84>
    }
    return BASE_STATUS_OK;
 3007b42:	4781                	li	a5,0
}
 3007b44:	853e                	mv	a0,a5
 3007b46:	40f2                	lw	ra,28(sp)
 3007b48:	4462                	lw	s0,24(sp)
 3007b4a:	6105                	addi	sp,sp,32
 3007b4c:	8082                	ret

03007b4e <HAL_GPT_Start>:
 * @brief   Start GPT
 * @param   handle   GPT Handle.
 * @retval  None
 */
void HAL_GPT_Start(GPT_Handle *handle)
{
 3007b4e:	7179                	addi	sp,sp,-48
 3007b50:	d606                	sw	ra,44(sp)
 3007b52:	d422                	sw	s0,40(sp)
 3007b54:	1800                	addi	s0,sp,48
 3007b56:	fca42e23          	sw	a0,-36(s0)
    GPT_ASSERT_PARAM(handle != NULL);
 3007b5a:	fdc42783          	lw	a5,-36(s0)
 3007b5e:	eb89                	bnez	a5,3007b70 <HAL_GPT_Start+0x22>
 3007b60:	04600593          	li	a1,70
 3007b64:	030127b7          	lui	a5,0x3012
 3007b68:	cf878513          	addi	a0,a5,-776 # 3011cf8 <g_crgIpMatch+0x460>
 3007b6c:	2365                	jal	ra,3008114 <AssertErrorLog.trans.5>
 3007b6e:	a001                	j	3007b6e <HAL_GPT_Start+0x20>
    GPT_ASSERT_PARAM(IsGPTInstance(handle->baseAddress));
 3007b70:	fdc42783          	lw	a5,-36(s0)
 3007b74:	4398                	lw	a4,0(a5)
 3007b76:	147007b7          	lui	a5,0x14700
 3007b7a:	02f70f63          	beq	a4,a5,3007bb8 <HAL_GPT_Start+0x6a>
 3007b7e:	fdc42783          	lw	a5,-36(s0)
 3007b82:	4398                	lw	a4,0(a5)
 3007b84:	147017b7          	lui	a5,0x14701
 3007b88:	02f70863          	beq	a4,a5,3007bb8 <HAL_GPT_Start+0x6a>
 3007b8c:	fdc42783          	lw	a5,-36(s0)
 3007b90:	4398                	lw	a4,0(a5)
 3007b92:	147027b7          	lui	a5,0x14702
 3007b96:	02f70163          	beq	a4,a5,3007bb8 <HAL_GPT_Start+0x6a>
 3007b9a:	fdc42783          	lw	a5,-36(s0)
 3007b9e:	4398                	lw	a4,0(a5)
 3007ba0:	147037b7          	lui	a5,0x14703
 3007ba4:	00f70a63          	beq	a4,a5,3007bb8 <HAL_GPT_Start+0x6a>
 3007ba8:	04700593          	li	a1,71
 3007bac:	030127b7          	lui	a5,0x3012
 3007bb0:	cf878513          	addi	a0,a5,-776 # 3011cf8 <g_crgIpMatch+0x460>
 3007bb4:	2385                	jal	ra,3008114 <AssertErrorLog.trans.5>
 3007bb6:	a001                	j	3007bb6 <HAL_GPT_Start+0x68>
    /* Enables the GPT to output PWM waves according to the configuration. */
    GPT_EN_REG gptEn;
    gptEn.BIT.rg_gpt_en = BASE_CFG_SET;
 3007bb8:	fec42783          	lw	a5,-20(s0)
 3007bbc:	0017e793          	ori	a5,a5,1
 3007bc0:	fef42623          	sw	a5,-20(s0)
    handle->baseAddress->GPT_EN.reg = gptEn.reg;
 3007bc4:	fdc42783          	lw	a5,-36(s0)
 3007bc8:	439c                	lw	a5,0(a5)
 3007bca:	fec42703          	lw	a4,-20(s0)
 3007bce:	40e7a623          	sw	a4,1036(a5)
}
 3007bd2:	0001                	nop
 3007bd4:	50b2                	lw	ra,44(sp)
 3007bd6:	5422                	lw	s0,40(sp)
 3007bd8:	6145                	addi	sp,sp,48
 3007bda:	8082                	ret

03007bdc <HAL_GPT_Stop>:
 * @brief   Stop GPT
 * @param   handle   GPT Handle.
 * @retval  None
 */
void HAL_GPT_Stop(GPT_Handle *handle)
{
 3007bdc:	7179                	addi	sp,sp,-48
 3007bde:	d606                	sw	ra,44(sp)
 3007be0:	d422                	sw	s0,40(sp)
 3007be2:	1800                	addi	s0,sp,48
 3007be4:	fca42e23          	sw	a0,-36(s0)
    GPT_ASSERT_PARAM(handle != NULL);
 3007be8:	fdc42783          	lw	a5,-36(s0)
 3007bec:	eb89                	bnez	a5,3007bfe <HAL_GPT_Stop+0x22>
 3007bee:	05500593          	li	a1,85
 3007bf2:	030127b7          	lui	a5,0x3012
 3007bf6:	cf878513          	addi	a0,a5,-776 # 3011cf8 <g_crgIpMatch+0x460>
 3007bfa:	2b29                	jal	ra,3008114 <AssertErrorLog.trans.5>
 3007bfc:	a001                	j	3007bfc <HAL_GPT_Stop+0x20>
    GPT_ASSERT_PARAM(IsGPTInstance(handle->baseAddress));
 3007bfe:	fdc42783          	lw	a5,-36(s0)
 3007c02:	4398                	lw	a4,0(a5)
 3007c04:	147007b7          	lui	a5,0x14700
 3007c08:	02f70f63          	beq	a4,a5,3007c46 <HAL_GPT_Stop+0x6a>
 3007c0c:	fdc42783          	lw	a5,-36(s0)
 3007c10:	4398                	lw	a4,0(a5)
 3007c12:	147017b7          	lui	a5,0x14701
 3007c16:	02f70863          	beq	a4,a5,3007c46 <HAL_GPT_Stop+0x6a>
 3007c1a:	fdc42783          	lw	a5,-36(s0)
 3007c1e:	4398                	lw	a4,0(a5)
 3007c20:	147027b7          	lui	a5,0x14702
 3007c24:	02f70163          	beq	a4,a5,3007c46 <HAL_GPT_Stop+0x6a>
 3007c28:	fdc42783          	lw	a5,-36(s0)
 3007c2c:	4398                	lw	a4,0(a5)
 3007c2e:	147037b7          	lui	a5,0x14703
 3007c32:	00f70a63          	beq	a4,a5,3007c46 <HAL_GPT_Stop+0x6a>
 3007c36:	05600593          	li	a1,86
 3007c3a:	030127b7          	lui	a5,0x3012
 3007c3e:	cf878513          	addi	a0,a5,-776 # 3011cf8 <g_crgIpMatch+0x460>
 3007c42:	29c9                	jal	ra,3008114 <AssertErrorLog.trans.5>
 3007c44:	a001                	j	3007c44 <HAL_GPT_Stop+0x68>
     /* Disable the GPT to output PWM waves. */
    GPT_EN_REG gptEn;
    gptEn.BIT.rg_gpt_en = BASE_CFG_UNSET;
 3007c46:	fec42783          	lw	a5,-20(s0)
 3007c4a:	9bf9                	andi	a5,a5,-2
 3007c4c:	fef42623          	sw	a5,-20(s0)
    handle->baseAddress->GPT_EN.reg = gptEn.reg;
 3007c50:	fdc42783          	lw	a5,-36(s0)
 3007c54:	439c                	lw	a5,0(a5)
 3007c56:	fec42703          	lw	a4,-20(s0)
 3007c5a:	40e7a623          	sw	a4,1036(a5)
}
 3007c5e:	0001                	nop
 3007c60:	50b2                	lw	ra,44(sp)
 3007c62:	5422                	lw	s0,40(sp)
 3007c64:	6145                	addi	sp,sp,48
 3007c66:	8082                	ret

03007c68 <HAL_GPT_Config>:
 * @param   handle   GPT Handle.
 * @retval  BASE_STATUS_OK
 * @retval  BASE_STATUS_ERROR
 */
BASE_StatusType HAL_GPT_Config(GPT_Handle *handle)
{
 3007c68:	7179                	addi	sp,sp,-48
 3007c6a:	d606                	sw	ra,44(sp)
 3007c6c:	d422                	sw	s0,40(sp)
 3007c6e:	1800                	addi	s0,sp,48
 3007c70:	fca42e23          	sw	a0,-36(s0)
    GPT_ASSERT_PARAM(handle != NULL);
 3007c74:	fdc42783          	lw	a5,-36(s0)
 3007c78:	eb89                	bnez	a5,3007c8a <HAL_GPT_Config+0x22>
 3007c7a:	06500593          	li	a1,101
 3007c7e:	030127b7          	lui	a5,0x3012
 3007c82:	cf878513          	addi	a0,a5,-776 # 3011cf8 <g_crgIpMatch+0x460>
 3007c86:	2179                	jal	ra,3008114 <AssertErrorLog.trans.5>
 3007c88:	a001                	j	3007c88 <HAL_GPT_Config+0x20>
    GPT_ASSERT_PARAM(IsGPTInstance(handle->baseAddress));
 3007c8a:	fdc42783          	lw	a5,-36(s0)
 3007c8e:	4398                	lw	a4,0(a5)
 3007c90:	147007b7          	lui	a5,0x14700
 3007c94:	02f70f63          	beq	a4,a5,3007cd2 <HAL_GPT_Config+0x6a>
 3007c98:	fdc42783          	lw	a5,-36(s0)
 3007c9c:	4398                	lw	a4,0(a5)
 3007c9e:	147017b7          	lui	a5,0x14701
 3007ca2:	02f70863          	beq	a4,a5,3007cd2 <HAL_GPT_Config+0x6a>
 3007ca6:	fdc42783          	lw	a5,-36(s0)
 3007caa:	4398                	lw	a4,0(a5)
 3007cac:	147027b7          	lui	a5,0x14702
 3007cb0:	02f70163          	beq	a4,a5,3007cd2 <HAL_GPT_Config+0x6a>
 3007cb4:	fdc42783          	lw	a5,-36(s0)
 3007cb8:	4398                	lw	a4,0(a5)
 3007cba:	147037b7          	lui	a5,0x14703
 3007cbe:	00f70a63          	beq	a4,a5,3007cd2 <HAL_GPT_Config+0x6a>
 3007cc2:	06600593          	li	a1,102
 3007cc6:	030127b7          	lui	a5,0x3012
 3007cca:	cf878513          	addi	a0,a5,-776 # 3011cf8 <g_crgIpMatch+0x460>
 3007cce:	2199                	jal	ra,3008114 <AssertErrorLog.trans.5>
 3007cd0:	a001                	j	3007cd0 <HAL_GPT_Config+0x68>
    GPT_PARAM_CHECK_WITH_RET(IsGptPeriod(handle->period), BASE_STATUS_ERROR);
 3007cd2:	fdc42783          	lw	a5,-36(s0)
 3007cd6:	4fdc                	lw	a5,28(a5)
 3007cd8:	853e                	mv	a0,a5
 3007cda:	3b91                	jal	ra,3007a2e <IsGptPeriod>
 3007cdc:	87aa                	mv	a5,a0
 3007cde:	0017c793          	xori	a5,a5,1
 3007ce2:	9f81                	uxtb	a5
 3007ce4:	cb91                	beqz	a5,3007cf8 <HAL_GPT_Config+0x90>
 3007ce6:	06700593          	li	a1,103
 3007cea:	030127b7          	lui	a5,0x3012
 3007cee:	cf878513          	addi	a0,a5,-776 # 3011cf8 <g_crgIpMatch+0x460>
 3007cf2:	210d                	jal	ra,3008114 <AssertErrorLog.trans.5>
 3007cf4:	4785                	li	a5,1
 3007cf6:	ac95                	j	3007f6a <HAL_GPT_Config+0x302>
    GPT_PARAM_CHECK_WITH_RET(IsGptDiv(handle->clockDiv), BASE_STATUS_ERROR);
 3007cf8:	fdc42783          	lw	a5,-36(s0)
 3007cfc:	479c                	lw	a5,8(a5)
 3007cfe:	853e                	mv	a0,a5
 3007d00:	3b01                	jal	ra,3007a10 <IsGptDiv>
 3007d02:	87aa                	mv	a5,a0
 3007d04:	0017c793          	xori	a5,a5,1
 3007d08:	9f81                	uxtb	a5
 3007d0a:	cb91                	beqz	a5,3007d1e <HAL_GPT_Config+0xb6>
 3007d0c:	06800593          	li	a1,104
 3007d10:	030127b7          	lui	a5,0x3012
 3007d14:	cf878513          	addi	a0,a5,-776 # 3011cf8 <g_crgIpMatch+0x460>
 3007d18:	2ef5                	jal	ra,3008114 <AssertErrorLog.trans.5>
 3007d1a:	4785                	li	a5,1
 3007d1c:	a4b9                	j	3007f6a <HAL_GPT_Config+0x302>
    GPT_PARAM_CHECK_WITH_RET(IsGptRefDot(handle->refA0.refdot), BASE_STATUS_ERROR);
 3007d1e:	fdc42783          	lw	a5,-36(s0)
 3007d22:	47dc                	lw	a5,12(a5)
 3007d24:	853e                	mv	a0,a5
 3007d26:	3b25                	jal	ra,3007a5e <IsGptRefDot>
 3007d28:	87aa                	mv	a5,a0
 3007d2a:	0017c793          	xori	a5,a5,1
 3007d2e:	9f81                	uxtb	a5
 3007d30:	cb91                	beqz	a5,3007d44 <HAL_GPT_Config+0xdc>
 3007d32:	06900593          	li	a1,105
 3007d36:	030127b7          	lui	a5,0x3012
 3007d3a:	cf878513          	addi	a0,a5,-776 # 3011cf8 <g_crgIpMatch+0x460>
 3007d3e:	2ed9                	jal	ra,3008114 <AssertErrorLog.trans.5>
 3007d40:	4785                	li	a5,1
 3007d42:	a425                	j	3007f6a <HAL_GPT_Config+0x302>
    GPT_PARAM_CHECK_WITH_RET(IsGptRefDot(handle->refB0.refdot), BASE_STATUS_ERROR);
 3007d44:	fdc42783          	lw	a5,-36(s0)
 3007d48:	4bdc                	lw	a5,20(a5)
 3007d4a:	853e                	mv	a0,a5
 3007d4c:	3b09                	jal	ra,3007a5e <IsGptRefDot>
 3007d4e:	87aa                	mv	a5,a0
 3007d50:	0017c793          	xori	a5,a5,1
 3007d54:	9f81                	uxtb	a5
 3007d56:	cb91                	beqz	a5,3007d6a <HAL_GPT_Config+0x102>
 3007d58:	06a00593          	li	a1,106
 3007d5c:	030127b7          	lui	a5,0x3012
 3007d60:	cf878513          	addi	a0,a5,-776 # 3011cf8 <g_crgIpMatch+0x460>
 3007d64:	2e45                	jal	ra,3008114 <AssertErrorLog.trans.5>
 3007d66:	4785                	li	a5,1
 3007d68:	a409                	j	3007f6a <HAL_GPT_Config+0x302>
    GPT_PARAM_CHECK_WITH_RET(handle->refA0.refdot <= handle->refB0.refdot, BASE_STATUS_ERROR);
 3007d6a:	fdc42783          	lw	a5,-36(s0)
 3007d6e:	47d8                	lw	a4,12(a5)
 3007d70:	fdc42783          	lw	a5,-36(s0)
 3007d74:	4bdc                	lw	a5,20(a5)
 3007d76:	00e7fb63          	bgeu	a5,a4,3007d8c <HAL_GPT_Config+0x124>
 3007d7a:	06b00593          	li	a1,107
 3007d7e:	030127b7          	lui	a5,0x3012
 3007d82:	cf878513          	addi	a0,a5,-776 # 3011cf8 <g_crgIpMatch+0x460>
 3007d86:	2679                	jal	ra,3008114 <AssertErrorLog.trans.5>
 3007d88:	4785                	li	a5,1
 3007d8a:	a2c5                	j	3007f6a <HAL_GPT_Config+0x302>
    GPT_PARAM_CHECK_WITH_RET(handle->refB0.refdot <= handle->period, BASE_STATUS_ERROR);
 3007d8c:	fdc42783          	lw	a5,-36(s0)
 3007d90:	4bd8                	lw	a4,20(a5)
 3007d92:	fdc42783          	lw	a5,-36(s0)
 3007d96:	4fdc                	lw	a5,28(a5)
 3007d98:	00e7fb63          	bgeu	a5,a4,3007dae <HAL_GPT_Config+0x146>
 3007d9c:	06c00593          	li	a1,108
 3007da0:	030127b7          	lui	a5,0x3012
 3007da4:	cf878513          	addi	a0,a5,-776 # 3011cf8 <g_crgIpMatch+0x460>
 3007da8:	26b5                	jal	ra,3008114 <AssertErrorLog.trans.5>
 3007daa:	4785                	li	a5,1
 3007dac:	aa7d                	j	3007f6a <HAL_GPT_Config+0x302>
    GPT_PARAM_CHECK_WITH_RET(IsGptAction(handle->refA0.refAction), BASE_STATUS_ERROR);
 3007dae:	fdc42783          	lw	a5,-36(s0)
 3007db2:	4b9c                	lw	a5,16(a5)
 3007db4:	853e                	mv	a0,a5
 3007db6:	31d9                	jal	ra,3007a7c <IsGptAction>
 3007db8:	87aa                	mv	a5,a0
 3007dba:	0017c793          	xori	a5,a5,1
 3007dbe:	9f81                	uxtb	a5
 3007dc0:	cb91                	beqz	a5,3007dd4 <HAL_GPT_Config+0x16c>
 3007dc2:	06d00593          	li	a1,109
 3007dc6:	030127b7          	lui	a5,0x3012
 3007dca:	cf878513          	addi	a0,a5,-776 # 3011cf8 <g_crgIpMatch+0x460>
 3007dce:	2699                	jal	ra,3008114 <AssertErrorLog.trans.5>
 3007dd0:	4785                	li	a5,1
 3007dd2:	aa61                	j	3007f6a <HAL_GPT_Config+0x302>
    GPT_PARAM_CHECK_WITH_RET(IsGptAction(handle->refB0.refAction), BASE_STATUS_ERROR);
 3007dd4:	fdc42783          	lw	a5,-36(s0)
 3007dd8:	4f9c                	lw	a5,24(a5)
 3007dda:	853e                	mv	a0,a5
 3007ddc:	3145                	jal	ra,3007a7c <IsGptAction>
 3007dde:	87aa                	mv	a5,a0
 3007de0:	0017c793          	xori	a5,a5,1
 3007de4:	9f81                	uxtb	a5
 3007de6:	cb91                	beqz	a5,3007dfa <HAL_GPT_Config+0x192>
 3007de8:	06e00593          	li	a1,110
 3007dec:	030127b7          	lui	a5,0x3012
 3007df0:	cf878513          	addi	a0,a5,-776 # 3011cf8 <g_crgIpMatch+0x460>
 3007df4:	2605                	jal	ra,3008114 <AssertErrorLog.trans.5>
 3007df6:	4785                	li	a5,1
 3007df8:	aa8d                	j	3007f6a <HAL_GPT_Config+0x302>
    GPT_PARAM_CHECK_WITH_RET(IsGptPwmNum(handle->pwmNum), BASE_STATUS_ERROR);
 3007dfa:	fdc42783          	lw	a5,-36(s0)
 3007dfe:	539c                	lw	a5,32(a5)
 3007e00:	853e                	mv	a0,a5
 3007e02:	3ecd                	jal	ra,30079f4 <IsGptPwmNum>
 3007e04:	87aa                	mv	a5,a0
 3007e06:	0017c793          	xori	a5,a5,1
 3007e0a:	9f81                	uxtb	a5
 3007e0c:	cb91                	beqz	a5,3007e20 <HAL_GPT_Config+0x1b8>
 3007e0e:	06f00593          	li	a1,111
 3007e12:	030127b7          	lui	a5,0x3012
 3007e16:	cf878513          	addi	a0,a5,-776 # 3011cf8 <g_crgIpMatch+0x460>
 3007e1a:	2ced                	jal	ra,3008114 <AssertErrorLog.trans.5>
 3007e1c:	4785                	li	a5,1
 3007e1e:	a2b1                	j	3007f6a <HAL_GPT_Config+0x302>

    GPT_RegStruct *gptReg;
    gptReg = handle->baseAddress;
 3007e20:	fdc42783          	lw	a5,-36(s0)
 3007e24:	439c                	lw	a5,0(a5)
 3007e26:	fef42623          	sw	a5,-20(s0)
    /* Configure whether to enable cache loading. */
    gptReg->GPT_BUF_LOAD_EN.BIT.rg_buf_load_en = handle->bufLoad;
 3007e2a:	fdc42783          	lw	a5,-36(s0)
 3007e2e:	0257c683          	lbu	a3,37(a5)
 3007e32:	fec42703          	lw	a4,-20(s0)
 3007e36:	50072783          	lw	a5,1280(a4) # 14002500 <RAM_END+0xfffa500>
 3007e3a:	8a85                	andi	a3,a3,1
 3007e3c:	9bf9                	andi	a5,a5,-2
 3007e3e:	8fd5                	or	a5,a5,a3
 3007e40:	50f72023          	sw	a5,1280(a4)
    
    /* Configuring the Cycle and Frequency Divider */
    gptReg->GPT_TC_DIV.reg = handle->clockDiv;
 3007e44:	fdc42783          	lw	a5,-36(s0)
 3007e48:	4798                	lw	a4,8(a5)
 3007e4a:	fec42783          	lw	a5,-20(s0)
 3007e4e:	cb98                	sw	a4,16(a5)
    gptReg->GPT_TC_PRD.reg = handle->period;
 3007e50:	fdc42783          	lw	a5,-36(s0)
 3007e54:	4fd8                	lw	a4,28(a5)
 3007e56:	fec42783          	lw	a5,-20(s0)
 3007e5a:	cbd8                	sw	a4,20(a5)
    /* Set the count reference point and the corresponding reference action. */
    gptReg->GPT_TC_REFA0.reg = handle->refA0.refdot;
 3007e5c:	fdc42783          	lw	a5,-36(s0)
 3007e60:	47d8                	lw	a4,12(a5)
 3007e62:	fec42783          	lw	a5,-20(s0)
 3007e66:	cf98                	sw	a4,24(a5)
    gptReg->GPT_PG_ACT0.BIT.rg_pg_act0_refa0 = handle->refA0.refAction;
 3007e68:	fdc42783          	lw	a5,-36(s0)
 3007e6c:	4b9c                	lw	a5,16(a5)
 3007e6e:	8b8d                	andi	a5,a5,3
 3007e70:	0ff7f693          	andi	a3,a5,255
 3007e74:	fec42703          	lw	a4,-20(s0)
 3007e78:	10072783          	lw	a5,256(a4)
 3007e7c:	8a8d                	andi	a3,a3,3
 3007e7e:	9bf1                	andi	a5,a5,-4
 3007e80:	8fd5                	or	a5,a5,a3
 3007e82:	10f72023          	sw	a5,256(a4)
    gptReg->GPT_TC_REFB0.reg = handle->refB0.refdot;
 3007e86:	fdc42783          	lw	a5,-36(s0)
 3007e8a:	4bd8                	lw	a4,20(a5)
 3007e8c:	fec42783          	lw	a5,-20(s0)
 3007e90:	cfd8                	sw	a4,28(a5)
    gptReg->GPT_PG_ACT0.BIT.rg_pg_act0_refb0 = handle->refB0.refAction;
 3007e92:	fdc42783          	lw	a5,-36(s0)
 3007e96:	4f9c                	lw	a5,24(a5)
 3007e98:	8b8d                	andi	a5,a5,3
 3007e9a:	0ff7f693          	andi	a3,a5,255
 3007e9e:	fec42703          	lw	a4,-20(s0)
 3007ea2:	10072783          	lw	a5,256(a4)
 3007ea6:	8a8d                	andi	a3,a3,3
 3007ea8:	0692                	slli	a3,a3,0x4
 3007eaa:	fcf7f793          	andi	a5,a5,-49
 3007eae:	8fd5                	or	a5,a5,a3
 3007eb0:	10f72023          	sw	a5,256(a4)
    
    /* Sets the PWM output mode: outputs infinite PWM waves and outputs fixed number PWM. */
    gptReg->GPT_PWM0_CFG.BIT.rg_pwm0_keep = handle->pwmKeep;
 3007eb4:	fdc42783          	lw	a5,-36(s0)
 3007eb8:	0247c683          	lbu	a3,36(a5)
 3007ebc:	fec42703          	lw	a4,-20(s0)
 3007ec0:	40072783          	lw	a5,1024(a4)
 3007ec4:	06fe                	slli	a3,a3,0x1f
 3007ec6:	80000637          	lui	a2,0x80000
 3007eca:	fff64613          	not	a2,a2
 3007ece:	8ff1                	and	a5,a5,a2
 3007ed0:	8fd5                	or	a5,a5,a3
 3007ed2:	40f72023          	sw	a5,1024(a4)
    /* Sets the number of output PWM wavelengths. This parameter is valid only when outputs fixed number PWM. */
    gptReg->GPT_PWM0_CFG.BIT.rg_pwm0_num = handle->pwmNum;
 3007ed6:	fdc42783          	lw	a5,-36(s0)
 3007eda:	539c                	lw	a5,32(a5)
 3007edc:	3ff7f793          	andi	a5,a5,1023
 3007ee0:	01079693          	slli	a3,a5,0x10
 3007ee4:	82c1                	srli	a3,a3,0x10
 3007ee6:	fec42703          	lw	a4,-20(s0)
 3007eea:	40072783          	lw	a5,1024(a4)
 3007eee:	3ff6f693          	andi	a3,a3,1023
 3007ef2:	c007f793          	andi	a5,a5,-1024
 3007ef6:	8fd5                	or	a5,a5,a3
 3007ef8:	40f72023          	sw	a5,1024(a4)
    
    /* Sets the GPT output completion interrupt and periodic interrupt. */
    gptReg->GPT_INT_EN.BIT.rg_prd_int_en = handle->handleEx.periodIntEnable;
 3007efc:	fdc42783          	lw	a5,-36(s0)
 3007f00:	0307c683          	lbu	a3,48(a5)
 3007f04:	fec42703          	lw	a4,-20(s0)
 3007f08:	20072783          	lw	a5,512(a4)
 3007f0c:	8a85                	andi	a3,a3,1
 3007f0e:	9bf9                	andi	a5,a5,-2
 3007f10:	8fd5                	or	a5,a5,a3
 3007f12:	20f72023          	sw	a5,512(a4)
    gptReg->GPT_INT_EN.BIT.rg_pwm0_int_en = handle->handleEx.outputFinIntEnable;
 3007f16:	fdc42783          	lw	a5,-36(s0)
 3007f1a:	0317c683          	lbu	a3,49(a5)
 3007f1e:	fec42703          	lw	a4,-20(s0)
 3007f22:	20072783          	lw	a5,512(a4)
 3007f26:	8a85                	andi	a3,a3,1
 3007f28:	0692                	slli	a3,a3,0x4
 3007f2a:	9bbd                	andi	a5,a5,-17
 3007f2c:	8fd5                	or	a5,a5,a3
 3007f2e:	20f72023          	sw	a5,512(a4)

    /* ADC Trigger Sampling Configuration */
    gptReg->GPT_SOCDR_EN.BIT.rg_soc_pwm0_en = handle->triggleAdcOutFinish;
 3007f32:	fdc42783          	lw	a5,-36(s0)
 3007f36:	0277c683          	lbu	a3,39(a5)
 3007f3a:	fec42703          	lw	a4,-20(s0)
 3007f3e:	30072783          	lw	a5,768(a4)
 3007f42:	8a85                	andi	a3,a3,1
 3007f44:	0686                	slli	a3,a3,0x1
 3007f46:	9bf5                	andi	a5,a5,-3
 3007f48:	8fd5                	or	a5,a5,a3
 3007f4a:	30f72023          	sw	a5,768(a4)
    gptReg->GPT_SOCDR_EN.BIT.rg_soc_prd_en = handle->triggleAdcPeriod;
 3007f4e:	fdc42783          	lw	a5,-36(s0)
 3007f52:	0267c683          	lbu	a3,38(a5)
 3007f56:	fec42703          	lw	a4,-20(s0)
 3007f5a:	30072783          	lw	a5,768(a4)
 3007f5e:	8a85                	andi	a3,a3,1
 3007f60:	9bf9                	andi	a5,a5,-2
 3007f62:	8fd5                	or	a5,a5,a3
 3007f64:	30f72023          	sw	a5,768(a4)
    return BASE_STATUS_OK;
 3007f68:	4781                	li	a5,0
}
 3007f6a:	853e                	mv	a0,a5
 3007f6c:	50b2                	lw	ra,44(sp)
 3007f6e:	5422                	lw	s0,40(sp)
 3007f70:	6145                	addi	sp,sp,48
 3007f72:	8082                	ret

03007f74 <HAL_GPT_GetConfig>:
 * @param   handle   GPT Handle.
 * @retval  BASE_STATUS_OK    Success
 * @retval  BASE_STATUS_ERROR Fail
 */
BASE_StatusType HAL_GPT_GetConfig(GPT_Handle *handle)
{
 3007f74:	7179                	addi	sp,sp,-48
 3007f76:	d606                	sw	ra,44(sp)
 3007f78:	d422                	sw	s0,40(sp)
 3007f7a:	1800                	addi	s0,sp,48
 3007f7c:	fca42e23          	sw	a0,-36(s0)
    GPT_ASSERT_PARAM(handle != NULL);
 3007f80:	fdc42783          	lw	a5,-36(s0)
 3007f84:	eb89                	bnez	a5,3007f96 <HAL_GPT_GetConfig+0x22>
 3007f86:	09600593          	li	a1,150
 3007f8a:	030127b7          	lui	a5,0x3012
 3007f8e:	cf878513          	addi	a0,a5,-776 # 3011cf8 <g_crgIpMatch+0x460>
 3007f92:	2249                	jal	ra,3008114 <AssertErrorLog.trans.5>
 3007f94:	a001                	j	3007f94 <HAL_GPT_GetConfig+0x20>
    GPT_ASSERT_PARAM(IsGPTInstance(handle->baseAddress));
 3007f96:	fdc42783          	lw	a5,-36(s0)
 3007f9a:	4398                	lw	a4,0(a5)
 3007f9c:	147007b7          	lui	a5,0x14700
 3007fa0:	02f70f63          	beq	a4,a5,3007fde <HAL_GPT_GetConfig+0x6a>
 3007fa4:	fdc42783          	lw	a5,-36(s0)
 3007fa8:	4398                	lw	a4,0(a5)
 3007faa:	147017b7          	lui	a5,0x14701
 3007fae:	02f70863          	beq	a4,a5,3007fde <HAL_GPT_GetConfig+0x6a>
 3007fb2:	fdc42783          	lw	a5,-36(s0)
 3007fb6:	4398                	lw	a4,0(a5)
 3007fb8:	147027b7          	lui	a5,0x14702
 3007fbc:	02f70163          	beq	a4,a5,3007fde <HAL_GPT_GetConfig+0x6a>
 3007fc0:	fdc42783          	lw	a5,-36(s0)
 3007fc4:	4398                	lw	a4,0(a5)
 3007fc6:	147037b7          	lui	a5,0x14703
 3007fca:	00f70a63          	beq	a4,a5,3007fde <HAL_GPT_GetConfig+0x6a>
 3007fce:	09700593          	li	a1,151
 3007fd2:	030127b7          	lui	a5,0x3012
 3007fd6:	cf878513          	addi	a0,a5,-776 # 3011cf8 <g_crgIpMatch+0x460>
 3007fda:	2a2d                	jal	ra,3008114 <AssertErrorLog.trans.5>
 3007fdc:	a001                	j	3007fdc <HAL_GPT_GetConfig+0x68>

    GPT_RegStruct *gptReg = handle->baseAddress;
 3007fde:	fdc42783          	lw	a5,-36(s0)
 3007fe2:	439c                	lw	a5,0(a5)
 3007fe4:	fef42623          	sw	a5,-20(s0)
    /* Obtains the configuration parameters of the PWM wavelength. */
    handle->clockDiv        =   gptReg->GPT_TC_DIV.reg;
 3007fe8:	fec42783          	lw	a5,-20(s0)
 3007fec:	4b98                	lw	a4,16(a5)
 3007fee:	fdc42783          	lw	a5,-36(s0)
 3007ff2:	c798                	sw	a4,8(a5)
    handle->period          =   gptReg->GPT_TC_PRD.reg;
 3007ff4:	fec42783          	lw	a5,-20(s0)
 3007ff8:	4bd8                	lw	a4,20(a5)
 3007ffa:	fdc42783          	lw	a5,-36(s0)
 3007ffe:	cfd8                	sw	a4,28(a5)
    handle->refA0.refdot    =   gptReg->GPT_TC_REFA0.reg;
 3008000:	fec42783          	lw	a5,-20(s0)
 3008004:	4f98                	lw	a4,24(a5)
 3008006:	fdc42783          	lw	a5,-36(s0)
 300800a:	c7d8                	sw	a4,12(a5)
    handle->refB0.refdot    =   gptReg->GPT_TC_REFB0.reg;
 300800c:	fec42783          	lw	a5,-20(s0)
 3008010:	4fd8                	lw	a4,28(a5)
 3008012:	fdc42783          	lw	a5,-36(s0)
 3008016:	cbd8                	sw	a4,20(a5)
    handle->refA0.refAction =   gptReg->GPT_PG_ACT0.BIT.rg_pg_act0_refa0;
 3008018:	fec42783          	lw	a5,-20(s0)
 300801c:	1007a783          	lw	a5,256(a5)
 3008020:	8b8d                	andi	a5,a5,3
 3008022:	9f81                	uxtb	a5
 3008024:	873e                	mv	a4,a5
 3008026:	fdc42783          	lw	a5,-36(s0)
 300802a:	cb98                	sw	a4,16(a5)
    handle->refB0.refAction =   gptReg->GPT_PG_ACT0.BIT.rg_pg_act0_refb0;
 300802c:	fec42783          	lw	a5,-20(s0)
 3008030:	1007a783          	lw	a5,256(a5)
 3008034:	8391                	srli	a5,a5,0x4
 3008036:	8b8d                	andi	a5,a5,3
 3008038:	9f81                	uxtb	a5
 300803a:	873e                	mv	a4,a5
 300803c:	fdc42783          	lw	a5,-36(s0)
 3008040:	cf98                	sw	a4,24(a5)
    /* Obtains the cache loading status. */
    handle->bufLoad         =   gptReg->GPT_BUF_LOAD_EN.BIT.rg_buf_load_en;
 3008042:	fec42783          	lw	a5,-20(s0)
 3008046:	5007a783          	lw	a5,1280(a5)
 300804a:	8b85                	andi	a5,a5,1
 300804c:	9f81                	uxtb	a5
 300804e:	00f037b3          	snez	a5,a5
 3008052:	0ff7f713          	andi	a4,a5,255
 3008056:	fdc42783          	lw	a5,-36(s0)
 300805a:	02e782a3          	sb	a4,37(a5)

    /* Obtaining the Interrupt Status */
    handle->handleEx.periodIntEnable    =  gptReg->GPT_INT_EN.BIT.rg_prd_int_en;
 300805e:	fec42783          	lw	a5,-20(s0)
 3008062:	2007a783          	lw	a5,512(a5)
 3008066:	8b85                	andi	a5,a5,1
 3008068:	9f81                	uxtb	a5
 300806a:	00f037b3          	snez	a5,a5
 300806e:	0ff7f713          	andi	a4,a5,255
 3008072:	fdc42783          	lw	a5,-36(s0)
 3008076:	02e78823          	sb	a4,48(a5)
    handle->handleEx.outputFinIntEnable =  gptReg->GPT_INT_EN.BIT.rg_pwm0_int_en;
 300807a:	fec42783          	lw	a5,-20(s0)
 300807e:	2007a783          	lw	a5,512(a5)
 3008082:	8391                	srli	a5,a5,0x4
 3008084:	8b85                	andi	a5,a5,1
 3008086:	9f81                	uxtb	a5
 3008088:	00f037b3          	snez	a5,a5
 300808c:	0ff7f713          	andi	a4,a5,255
 3008090:	fdc42783          	lw	a5,-36(s0)
 3008094:	02e788a3          	sb	a4,49(a5)

    /* Obtains ADC configuration parameters. */
    handle->triggleAdcOutFinish         =  gptReg->GPT_SOCDR_EN.BIT.rg_soc_pwm0_en;
 3008098:	fec42783          	lw	a5,-20(s0)
 300809c:	3007a783          	lw	a5,768(a5)
 30080a0:	8385                	srli	a5,a5,0x1
 30080a2:	8b85                	andi	a5,a5,1
 30080a4:	9f81                	uxtb	a5
 30080a6:	00f037b3          	snez	a5,a5
 30080aa:	0ff7f713          	andi	a4,a5,255
 30080ae:	fdc42783          	lw	a5,-36(s0)
 30080b2:	02e783a3          	sb	a4,39(a5)
    handle->triggleAdcPeriod            =  gptReg->GPT_SOCDR_EN.BIT.rg_soc_prd_en;
 30080b6:	fec42783          	lw	a5,-20(s0)
 30080ba:	3007a783          	lw	a5,768(a5)
 30080be:	8b85                	andi	a5,a5,1
 30080c0:	9f81                	uxtb	a5
 30080c2:	00f037b3          	snez	a5,a5
 30080c6:	0ff7f713          	andi	a4,a5,255
 30080ca:	fdc42783          	lw	a5,-36(s0)
 30080ce:	02e78323          	sb	a4,38(a5)
    
    /* Obtains the PWM output mode. */
    GPT_PWM0_CFG_REG pwm0Cfg;
    pwm0Cfg.reg              =   gptReg->GPT_PWM0_CFG.reg;
 30080d2:	fec42783          	lw	a5,-20(s0)
 30080d6:	4007a783          	lw	a5,1024(a5)
 30080da:	fef42423          	sw	a5,-24(s0)
    handle->pwmKeep          =   GPT_GetKeepState(handle);
 30080de:	fdc42503          	lw	a0,-36(s0)
 30080e2:	3a5d                	jal	ra,3007a98 <GPT_GetKeepState>
 30080e4:	87aa                	mv	a5,a0
 30080e6:	00f037b3          	snez	a5,a5
 30080ea:	0ff7f713          	andi	a4,a5,255
 30080ee:	fdc42783          	lw	a5,-36(s0)
 30080f2:	02e78223          	sb	a4,36(a5)
    handle->pwmNum           =   pwm0Cfg.BIT.rg_pwm0_num;
 30080f6:	fe842783          	lw	a5,-24(s0)
 30080fa:	3ff7f793          	andi	a5,a5,1023
 30080fe:	9fa1                	uxth	a5
 3008100:	873e                	mv	a4,a5
 3008102:	fdc42783          	lw	a5,-36(s0)
 3008106:	d398                	sw	a4,32(a5)
    return BASE_STATUS_OK;
 3008108:	4781                	li	a5,0
}
 300810a:	853e                	mv	a0,a5
 300810c:	50b2                	lw	ra,44(sp)
 300810e:	5422                	lw	s0,40(sp)
 3008110:	6145                	addi	sp,sp,48
 3008112:	8082                	ret

03008114 <AssertErrorLog.trans.5>:
 3008114:	c3ffa06f          	j	3002d52 <AssertErrorLog>

03008118 <IsI2cFunctionMode>:
  * @param functionMode I2C function mode type.
  * @retval true
  * @retval false
  */
static inline bool IsI2cFunctionMode(I2C_ModeSelectType functionMode)
{
 3008118:	1101                	addi	sp,sp,-32
 300811a:	ce22                	sw	s0,28(sp)
 300811c:	1000                	addi	s0,sp,32
 300811e:	fea42623          	sw	a0,-20(s0)
    return (functionMode == I2C_MODE_SELECT_NONE ||
            functionMode == I2C_MODE_SELECT_MASTER_ONLY ||
            functionMode == I2C_MODE_SELECT_SLAVE_ONLY ||
 3008122:	fec42783          	lw	a5,-20(s0)
 3008126:	c385                	beqz	a5,3008146 <IsI2cFunctionMode+0x2e>
    return (functionMode == I2C_MODE_SELECT_NONE ||
 3008128:	fec42703          	lw	a4,-20(s0)
 300812c:	4785                	li	a5,1
 300812e:	00f70c63          	beq	a4,a5,3008146 <IsI2cFunctionMode+0x2e>
            functionMode == I2C_MODE_SELECT_MASTER_ONLY ||
 3008132:	fec42703          	lw	a4,-20(s0)
 3008136:	4789                	li	a5,2
 3008138:	00f70763          	beq	a4,a5,3008146 <IsI2cFunctionMode+0x2e>
            functionMode == I2C_MODE_SELECT_SLAVE_ONLY ||
 300813c:	fec42703          	lw	a4,-20(s0)
 3008140:	478d                	li	a5,3
 3008142:	00f71463          	bne	a4,a5,300814a <IsI2cFunctionMode+0x32>
 3008146:	4785                	li	a5,1
 3008148:	a011                	j	300814c <IsI2cFunctionMode+0x34>
 300814a:	4781                	li	a5,0
 300814c:	8b85                	andi	a5,a5,1
 300814e:	9f81                	uxtb	a5
            functionMode == I2C_MODE_SELECT_MASTER_SLAVE);
}
 3008150:	853e                	mv	a0,a5
 3008152:	4472                	lw	s0,28(sp)
 3008154:	6105                	addi	sp,sp,32
 3008156:	8082                	ret

03008158 <IsI2cAddressMode>:
  * @param addrMode I2C instance
  * @retval true
  * @retval false
  */
static inline bool IsI2cAddressMode(I2C_AddressMode addrMode)
{
 3008158:	1101                	addi	sp,sp,-32
 300815a:	ce22                	sw	s0,28(sp)
 300815c:	1000                	addi	s0,sp,32
 300815e:	fea42623          	sw	a0,-20(s0)
    return (addrMode == I2C_7_BITS ||
 3008162:	fec42783          	lw	a5,-20(s0)
 3008166:	c791                	beqz	a5,3008172 <IsI2cAddressMode+0x1a>
 3008168:	fec42703          	lw	a4,-20(s0)
 300816c:	4785                	li	a5,1
 300816e:	00f71463          	bne	a4,a5,3008176 <IsI2cAddressMode+0x1e>
 3008172:	4785                	li	a5,1
 3008174:	a011                	j	3008178 <IsI2cAddressMode+0x20>
 3008176:	4781                	li	a5,0
 3008178:	8b85                	andi	a5,a5,1
 300817a:	9f81                	uxtb	a5
            addrMode == I2C_10_BITS);
}
 300817c:	853e                	mv	a0,a5
 300817e:	4472                	lw	s0,28(sp)
 3008180:	6105                	addi	sp,sp,32
 3008182:	8082                	ret

03008184 <IsI2cSdaHoldTime>:
  * @param sdaHoldTime I2C instance
  * @retval true
  * @retval false
  */
static inline bool IsI2cSdaHoldTime(unsigned int sdaHoldTime)
{
 3008184:	1101                	addi	sp,sp,-32
 3008186:	ce22                	sw	s0,28(sp)
 3008188:	1000                	addi	s0,sp,32
 300818a:	fea42623          	sw	a0,-20(s0)
    return (sdaHoldTime <= 0xFFFF); /* SdaHoldTime value is 0 to 0xFFFF */
 300818e:	fec42703          	lw	a4,-20(s0)
 3008192:	67c1                	lui	a5,0x10
 3008194:	00f737b3          	sltu	a5,a4,a5
 3008198:	9f81                	uxtb	a5
}
 300819a:	853e                	mv	a0,a5
 300819c:	4472                	lw	s0,28(sp)
 300819e:	6105                	addi	sp,sp,32
 30081a0:	8082                	ret

030081a2 <IsI2cGeneralCallMode>:
  * @param generalCallMode I2C general call mode.
  * @retval true
  * @retval false
  */
static inline bool IsI2cGeneralCallMode(unsigned int generalCallMode)
{
 30081a2:	1101                	addi	sp,sp,-32
 30081a4:	ce22                	sw	s0,28(sp)
 30081a6:	1000                	addi	s0,sp,32
 30081a8:	fea42623          	sw	a0,-20(s0)
    return (generalCallMode == BASE_CFG_ENABLE ||
 30081ac:	fec42703          	lw	a4,-20(s0)
 30081b0:	4785                	li	a5,1
 30081b2:	00f70563          	beq	a4,a5,30081bc <IsI2cGeneralCallMode+0x1a>
 30081b6:	fec42783          	lw	a5,-20(s0)
 30081ba:	e399                	bnez	a5,30081c0 <IsI2cGeneralCallMode+0x1e>
 30081bc:	4785                	li	a5,1
 30081be:	a011                	j	30081c2 <IsI2cGeneralCallMode+0x20>
 30081c0:	4781                	li	a5,0
 30081c2:	8b85                	andi	a5,a5,1
 30081c4:	9f81                	uxtb	a5
            generalCallMode == BASE_CFG_DISABLE);
}
 30081c6:	853e                	mv	a0,a5
 30081c8:	4472                	lw	s0,28(sp)
 30081ca:	6105                	addi	sp,sp,32
 30081cc:	8082                	ret

030081ce <IsI2cOwnAddressOrMask>:
  * @param ownAddress I2C own address.
  * @retval true
  * @retval false
  */
static inline bool IsI2cOwnAddressOrMask(unsigned int ownAddress)
{
 30081ce:	1101                	addi	sp,sp,-32
 30081d0:	ce22                	sw	s0,28(sp)
 30081d2:	1000                	addi	s0,sp,32
 30081d4:	fea42623          	sw	a0,-20(s0)
    return (ownAddress <= XMBUS_OWN_ADDRESS_MASK); /* Own address value is 0 to 0x3FF */
 30081d8:	fec42783          	lw	a5,-20(s0)
 30081dc:	4007b793          	sltiu	a5,a5,1024
 30081e0:	9f81                	uxtb	a5
}
 30081e2:	853e                	mv	a0,a5
 30081e4:	4472                	lw	s0,28(sp)
 30081e6:	6105                	addi	sp,sp,32
 30081e8:	8082                	ret

030081ea <IsXMBusAddressOrMask>:
  * @param xmbusAddress XMBus address.
  * @retval true
  * @retval false
  */
static inline bool IsXMBusAddressOrMask(unsigned int xmbusAddress)
{
 30081ea:	1101                	addi	sp,sp,-32
 30081ec:	ce22                	sw	s0,28(sp)
 30081ee:	1000                	addi	s0,sp,32
 30081f0:	fea42623          	sw	a0,-20(s0)
    return (xmbusAddress <= XMBUS_OWN_ADDRESS_MASK); /* XMBus address value is 0 to 0x3FF */
 30081f4:	fec42783          	lw	a5,-20(s0)
 30081f8:	4007b793          	sltiu	a5,a5,1024
 30081fc:	9f81                	uxtb	a5
}
 30081fe:	853e                	mv	a0,a5
 3008200:	4472                	lw	s0,28(sp)
 3008202:	6105                	addi	sp,sp,32
 3008204:	8082                	ret

03008206 <IsXMBusAddressEnable>:
  * @param xmbusAddress XMBus address.
  * @retval true
  * @retval false
  */
static inline bool IsXMBusAddressEnable(unsigned int slaveOwnXmbAddressEnable)
{
 3008206:	1101                	addi	sp,sp,-32
 3008208:	ce22                	sw	s0,28(sp)
 300820a:	1000                	addi	s0,sp,32
 300820c:	fea42623          	sw	a0,-20(s0)
    return (slaveOwnXmbAddressEnable == BASE_CFG_ENABLE || slaveOwnXmbAddressEnable == BASE_CFG_DISABLE);
 3008210:	fec42703          	lw	a4,-20(s0)
 3008214:	4785                	li	a5,1
 3008216:	00f70563          	beq	a4,a5,3008220 <IsXMBusAddressEnable+0x1a>
 300821a:	fec42783          	lw	a5,-20(s0)
 300821e:	e399                	bnez	a5,3008224 <IsXMBusAddressEnable+0x1e>
 3008220:	4785                	li	a5,1
 3008222:	a011                	j	3008226 <IsXMBusAddressEnable+0x20>
 3008224:	4781                	li	a5,0
 3008226:	8b85                	andi	a5,a5,1
 3008228:	9f81                	uxtb	a5
}
 300822a:	853e                	mv	a0,a5
 300822c:	4472                	lw	s0,28(sp)
 300822e:	6105                	addi	sp,sp,32
 3008230:	8082                	ret

03008232 <IsI2cSpikeFilterTime>:
  * @param spikeFilterTime I2C SDA and SCL Glitch Filtering Time.
  * @retval true
  * @retval false
  */
static inline bool IsI2cSpikeFilterTime(unsigned int spikeFilterTime)
{
 3008232:	1101                	addi	sp,sp,-32
 3008234:	ce22                	sw	s0,28(sp)
 3008236:	1000                	addi	s0,sp,32
 3008238:	fea42623          	sw	a0,-20(s0)
    return (spikeFilterTime <= 0xF); /* The spikeFilterTime value is 0 to 0xF */
 300823c:	fec42783          	lw	a5,-20(s0)
 3008240:	0107b793          	sltiu	a5,a5,16
 3008244:	9f81                	uxtb	a5
}
 3008246:	853e                	mv	a0,a5
 3008248:	4472                	lw	s0,28(sp)
 300824a:	6105                	addi	sp,sp,32
 300824c:	8082                	ret

0300824e <IsI2cFreq>:
  * @param freq I2C freq
  * @retval true
  * @retval false
  */
static inline bool IsI2cFreq(unsigned int freq)
{
 300824e:	1101                	addi	sp,sp,-32
 3008250:	ce22                	sw	s0,28(sp)
 3008252:	1000                	addi	s0,sp,32
 3008254:	fea42623          	sw	a0,-20(s0)
    return (freq > 0);
 3008258:	fec42783          	lw	a5,-20(s0)
 300825c:	00f037b3          	snez	a5,a5
 3008260:	9f81                	uxtb	a5
}
 3008262:	853e                	mv	a0,a5
 3008264:	4472                	lw	s0,28(sp)
 3008266:	6105                	addi	sp,sp,32
 3008268:	8082                	ret

0300826a <IsI2cIgnoreAckFlag>:
  * @param ignoreAckFlag I2C ignore ack flag.
  * @retval true
  * @retval false
  */
static inline bool IsI2cIgnoreAckFlag(unsigned int ignoreAckFlag)
{
 300826a:	1101                	addi	sp,sp,-32
 300826c:	ce22                	sw	s0,28(sp)
 300826e:	1000                	addi	s0,sp,32
 3008270:	fea42623          	sw	a0,-20(s0)
    return (ignoreAckFlag == I2C_IGNORE_NAK_ENABLE ||
 3008274:	fec42703          	lw	a4,-20(s0)
 3008278:	4785                	li	a5,1
 300827a:	00f70563          	beq	a4,a5,3008284 <IsI2cIgnoreAckFlag+0x1a>
 300827e:	fec42783          	lw	a5,-20(s0)
 3008282:	e399                	bnez	a5,3008288 <IsI2cIgnoreAckFlag+0x1e>
 3008284:	4785                	li	a5,1
 3008286:	a011                	j	300828a <IsI2cIgnoreAckFlag+0x20>
 3008288:	4781                	li	a5,0
 300828a:	8b85                	andi	a5,a5,1
 300828c:	9f81                	uxtb	a5
            ignoreAckFlag == I2C_IGNORE_NAK_DISABLE);
}
 300828e:	853e                	mv	a0,a5
 3008290:	4472                	lw	s0,28(sp)
 3008292:	6105                	addi	sp,sp,32
 3008294:	8082                	ret

03008296 <IsI2cTxWaterMark>:
  * @param txWaterMark I2C tx water mark.
  * @retval true
  * @retval false
  */
static inline bool IsI2cTxWaterMark(unsigned int txWaterMark)
{
 3008296:	1101                	addi	sp,sp,-32
 3008298:	ce22                	sw	s0,28(sp)
 300829a:	1000                	addi	s0,sp,32
 300829c:	fea42623          	sw	a0,-20(s0)
    return (txWaterMark <= 0xF); /* The txWaterMark value is 0 to 0xF */
 30082a0:	fec42783          	lw	a5,-20(s0)
 30082a4:	0107b793          	sltiu	a5,a5,16
 30082a8:	9f81                	uxtb	a5
}
 30082aa:	853e                	mv	a0,a5
 30082ac:	4472                	lw	s0,28(sp)
 30082ae:	6105                	addi	sp,sp,32
 30082b0:	8082                	ret

030082b2 <IsI2cRxWaterMark>:
  * @param rxWaterMark I2C rx water mark.
  * @retval true
  * @retval false
  */
static inline bool IsI2cRxWaterMark(unsigned int rxWaterMark)
{
 30082b2:	1101                	addi	sp,sp,-32
 30082b4:	ce22                	sw	s0,28(sp)
 30082b6:	1000                	addi	s0,sp,32
 30082b8:	fea42623          	sw	a0,-20(s0)
    return (rxWaterMark <= 0xF); /* The rxWaterMark value is 0 to 0xF */
 30082bc:	fec42783          	lw	a5,-20(s0)
 30082c0:	0107b793          	sltiu	a5,a5,16
 30082c4:	9f81                	uxtb	a5
}
 30082c6:	853e                	mv	a0,a5
 30082c8:	4472                	lw	s0,28(sp)
 30082ca:	6105                	addi	sp,sp,32
 30082cc:	8082                	ret

030082ce <IsI2cSdaDelayTime>:
  * @param sdaDelayTime The value of SDA delay time.
  * @retval true
  * @retval false
  */
static inline bool IsI2cSdaDelayTime(unsigned int sdaDelayTime)
{
 30082ce:	1101                	addi	sp,sp,-32
 30082d0:	ce22                	sw	s0,28(sp)
 30082d2:	1000                	addi	s0,sp,32
 30082d4:	fea42623          	sw	a0,-20(s0)
    return (sdaDelayTime <= 0x0F); /* The SDA delay time upper limit is 0x0F. */
 30082d8:	fec42783          	lw	a5,-20(s0)
 30082dc:	0107b793          	sltiu	a5,a5,16
 30082e0:	9f81                	uxtb	a5
}
 30082e2:	853e                	mv	a0,a5
 30082e4:	4472                	lw	s0,28(sp)
 30082e6:	6105                	addi	sp,sp,32
 30082e8:	8082                	ret

030082ea <CheckAllInitParameters>:
  * @param handle I2C handle.
  * @param clockFreq  I2C work clock freq;
  * @retval BASE status type: OK, ERROR, BUSY, TIMEOUT, NOT SUPPORT.
  */
static BASE_StatusType CheckAllInitParameters(I2C_Handle *handle, unsigned int clockFreq)
{
 30082ea:	1101                	addi	sp,sp,-32
 30082ec:	ce06                	sw	ra,28(sp)
 30082ee:	cc22                	sw	s0,24(sp)
 30082f0:	1000                	addi	s0,sp,32
 30082f2:	fea42623          	sw	a0,-20(s0)
 30082f6:	feb42423          	sw	a1,-24(s0)
    /* Check the configuration of basic function parameters. */
    I2C_PARAM_CHECK_WITH_RET(IsI2cFunctionMode(handle->functionMode), BASE_STATUS_ERROR);
 30082fa:	fec42783          	lw	a5,-20(s0)
 30082fe:	43dc                	lw	a5,4(a5)
 3008300:	853e                	mv	a0,a5
 3008302:	3d19                	jal	ra,3008118 <IsI2cFunctionMode>
 3008304:	87aa                	mv	a5,a0
 3008306:	0017c793          	xori	a5,a5,1
 300830a:	9f81                	uxtb	a5
 300830c:	cb91                	beqz	a5,3008320 <CheckAllInitParameters+0x36>
 300830e:	09000593          	li	a1,144
 3008312:	030127b7          	lui	a5,0x3012
 3008316:	d1478513          	addi	a0,a5,-748 # 3011d14 <g_crgIpMatch+0x47c>
 300831a:	3bed                	jal	ra,3008114 <AssertErrorLog.trans.5>
 300831c:	4785                	li	a5,1
 300831e:	a439                	j	300852c <CheckAllInitParameters+0x242>
    I2C_PARAM_CHECK_WITH_RET(IsI2cAddressMode(handle->addrMode), BASE_STATUS_ERROR);
 3008320:	fec42783          	lw	a5,-20(s0)
 3008324:	479c                	lw	a5,8(a5)
 3008326:	853e                	mv	a0,a5
 3008328:	3d05                	jal	ra,3008158 <IsI2cAddressMode>
 300832a:	87aa                	mv	a5,a0
 300832c:	0017c793          	xori	a5,a5,1
 3008330:	9f81                	uxtb	a5
 3008332:	cb91                	beqz	a5,3008346 <CheckAllInitParameters+0x5c>
 3008334:	09100593          	li	a1,145
 3008338:	030127b7          	lui	a5,0x3012
 300833c:	d1478513          	addi	a0,a5,-748 # 3011d14 <g_crgIpMatch+0x47c>
 3008340:	3bd1                	jal	ra,3008114 <AssertErrorLog.trans.5>
 3008342:	4785                	li	a5,1
 3008344:	a2e5                	j	300852c <CheckAllInitParameters+0x242>
    I2C_PARAM_CHECK_WITH_RET(IsI2cSdaHoldTime(handle->sdaHoldTime), BASE_STATUS_ERROR);
 3008346:	fec42783          	lw	a5,-20(s0)
 300834a:	4b9c                	lw	a5,16(a5)
 300834c:	853e                	mv	a0,a5
 300834e:	3d1d                	jal	ra,3008184 <IsI2cSdaHoldTime>
 3008350:	87aa                	mv	a5,a0
 3008352:	0017c793          	xori	a5,a5,1
 3008356:	9f81                	uxtb	a5
 3008358:	cb91                	beqz	a5,300836c <CheckAllInitParameters+0x82>
 300835a:	09200593          	li	a1,146
 300835e:	030127b7          	lui	a5,0x3012
 3008362:	d1478513          	addi	a0,a5,-748 # 3011d14 <g_crgIpMatch+0x47c>
 3008366:	337d                	jal	ra,3008114 <AssertErrorLog.trans.5>
 3008368:	4785                	li	a5,1
 300836a:	a2c9                	j	300852c <CheckAllInitParameters+0x242>
    /* Check whether the I2C freq is valid. */
    I2C_PARAM_CHECK_WITH_RET(IsI2cFreq(handle->freq), BASE_STATUS_ERROR);
 300836c:	fec42783          	lw	a5,-20(s0)
 3008370:	4bdc                	lw	a5,20(a5)
 3008372:	853e                	mv	a0,a5
 3008374:	3de9                	jal	ra,300824e <IsI2cFreq>
 3008376:	87aa                	mv	a5,a0
 3008378:	0017c793          	xori	a5,a5,1
 300837c:	9f81                	uxtb	a5
 300837e:	cb91                	beqz	a5,3008392 <CheckAllInitParameters+0xa8>
 3008380:	09400593          	li	a1,148
 3008384:	030127b7          	lui	a5,0x3012
 3008388:	d1478513          	addi	a0,a5,-748 # 3011d14 <g_crgIpMatch+0x47c>
 300838c:	3361                	jal	ra,3008114 <AssertErrorLog.trans.5>
 300838e:	4785                	li	a5,1
 3008390:	aa71                	j	300852c <CheckAllInitParameters+0x242>
    I2C_PARAM_CHECK_WITH_RET((clockFreq > 0), BASE_STATUS_ERROR);
 3008392:	fe842783          	lw	a5,-24(s0)
 3008396:	eb91                	bnez	a5,30083aa <CheckAllInitParameters+0xc0>
 3008398:	09500593          	li	a1,149
 300839c:	030127b7          	lui	a5,0x3012
 30083a0:	d1478513          	addi	a0,a5,-748 # 3011d14 <g_crgIpMatch+0x47c>
 30083a4:	3b85                	jal	ra,3008114 <AssertErrorLog.trans.5>
 30083a6:	4785                	li	a5,1
 30083a8:	a251                	j	300852c <CheckAllInitParameters+0x242>

    if (handle->freq > clockFreq) {
 30083aa:	fec42783          	lw	a5,-20(s0)
 30083ae:	4bdc                	lw	a5,20(a5)
 30083b0:	fe842703          	lw	a4,-24(s0)
 30083b4:	00f77463          	bgeu	a4,a5,30083bc <CheckAllInitParameters+0xd2>
        return BASE_STATUS_ERROR;
 30083b8:	4785                	li	a5,1
 30083ba:	aa8d                	j	300852c <CheckAllInitParameters+0x242>
    }
    /* Check the configuration of basic function parameters. */
    I2C_PARAM_CHECK_WITH_RET(IsI2cIgnoreAckFlag(handle->ignoreAckFlag), BASE_STATUS_ERROR);
 30083bc:	fec42783          	lw	a5,-20(s0)
 30083c0:	4f9c                	lw	a5,24(a5)
 30083c2:	853e                	mv	a0,a5
 30083c4:	355d                	jal	ra,300826a <IsI2cIgnoreAckFlag>
 30083c6:	87aa                	mv	a5,a0
 30083c8:	0017c793          	xori	a5,a5,1
 30083cc:	9f81                	uxtb	a5
 30083ce:	cb91                	beqz	a5,30083e2 <CheckAllInitParameters+0xf8>
 30083d0:	09b00593          	li	a1,155
 30083d4:	030127b7          	lui	a5,0x3012
 30083d8:	d1478513          	addi	a0,a5,-748 # 3011d14 <g_crgIpMatch+0x47c>
 30083dc:	3b25                	jal	ra,3008114 <AssertErrorLog.trans.5>
 30083de:	4785                	li	a5,1
 30083e0:	a2b1                	j	300852c <CheckAllInitParameters+0x242>
    I2C_PARAM_CHECK_WITH_RET(IsI2cTxWaterMark(handle->txWaterMark), BASE_STATUS_ERROR);
 30083e2:	fec42783          	lw	a5,-20(s0)
 30083e6:	5bdc                	lw	a5,52(a5)
 30083e8:	853e                	mv	a0,a5
 30083ea:	3575                	jal	ra,3008296 <IsI2cTxWaterMark>
 30083ec:	87aa                	mv	a5,a0
 30083ee:	0017c793          	xori	a5,a5,1
 30083f2:	9f81                	uxtb	a5
 30083f4:	cb91                	beqz	a5,3008408 <CheckAllInitParameters+0x11e>
 30083f6:	09c00593          	li	a1,156
 30083fa:	030127b7          	lui	a5,0x3012
 30083fe:	d1478513          	addi	a0,a5,-748 # 3011d14 <g_crgIpMatch+0x47c>
 3008402:	3b09                	jal	ra,3008114 <AssertErrorLog.trans.5>
 3008404:	4785                	li	a5,1
 3008406:	a21d                	j	300852c <CheckAllInitParameters+0x242>
    I2C_PARAM_CHECK_WITH_RET(IsI2cRxWaterMark(handle->rxWaterMark), BASE_STATUS_ERROR);
 3008408:	fec42783          	lw	a5,-20(s0)
 300840c:	5b9c                	lw	a5,48(a5)
 300840e:	853e                	mv	a0,a5
 3008410:	354d                	jal	ra,30082b2 <IsI2cRxWaterMark>
 3008412:	87aa                	mv	a5,a0
 3008414:	0017c793          	xori	a5,a5,1
 3008418:	9f81                	uxtb	a5
 300841a:	cb91                	beqz	a5,300842e <CheckAllInitParameters+0x144>
 300841c:	09d00593          	li	a1,157
 3008420:	030127b7          	lui	a5,0x3012
 3008424:	d1478513          	addi	a0,a5,-748 # 3011d14 <g_crgIpMatch+0x47c>
 3008428:	31f5                	jal	ra,3008114 <AssertErrorLog.trans.5>
 300842a:	4785                	li	a5,1
 300842c:	a201                	j	300852c <CheckAllInitParameters+0x242>
    I2C_PARAM_CHECK_WITH_RET(IsI2cSpikeFilterTime(handle->handleEx.spikeFilterTime), BASE_STATUS_ERROR);
 300842e:	fec42783          	lw	a5,-20(s0)
 3008432:	4fbc                	lw	a5,88(a5)
 3008434:	853e                	mv	a0,a5
 3008436:	3bf5                	jal	ra,3008232 <IsI2cSpikeFilterTime>
 3008438:	87aa                	mv	a5,a0
 300843a:	0017c793          	xori	a5,a5,1
 300843e:	9f81                	uxtb	a5
 3008440:	cb91                	beqz	a5,3008454 <CheckAllInitParameters+0x16a>
 3008442:	09e00593          	li	a1,158
 3008446:	030127b7          	lui	a5,0x3012
 300844a:	d1478513          	addi	a0,a5,-748 # 3011d14 <g_crgIpMatch+0x47c>
 300844e:	31d9                	jal	ra,3008114 <AssertErrorLog.trans.5>
 3008450:	4785                	li	a5,1
 3008452:	a8e9                	j	300852c <CheckAllInitParameters+0x242>
    I2C_PARAM_CHECK_WITH_RET(IsI2cSdaDelayTime(handle->handleEx.sdaDelayTime), BASE_STATUS_ERROR);
 3008454:	fec42783          	lw	a5,-20(s0)
 3008458:	4ffc                	lw	a5,92(a5)
 300845a:	853e                	mv	a0,a5
 300845c:	3d8d                	jal	ra,30082ce <IsI2cSdaDelayTime>
 300845e:	87aa                	mv	a5,a0
 3008460:	0017c793          	xori	a5,a5,1
 3008464:	9f81                	uxtb	a5
 3008466:	cb91                	beqz	a5,300847a <CheckAllInitParameters+0x190>
 3008468:	09f00593          	li	a1,159
 300846c:	030127b7          	lui	a5,0x3012
 3008470:	d1478513          	addi	a0,a5,-748 # 3011d14 <g_crgIpMatch+0x47c>
 3008474:	3145                	jal	ra,3008114 <AssertErrorLog.trans.5>
 3008476:	4785                	li	a5,1
 3008478:	a855                	j	300852c <CheckAllInitParameters+0x242>

    /* Checking the own address and generalCall parameter enable when is used as slave. */
    if (handle->functionMode == I2C_MODE_SELECT_SLAVE_ONLY || handle->functionMode == I2C_MODE_SELECT_MASTER_SLAVE) {
 300847a:	fec42783          	lw	a5,-20(s0)
 300847e:	43d8                	lw	a4,4(a5)
 3008480:	4789                	li	a5,2
 3008482:	00f70863          	beq	a4,a5,3008492 <CheckAllInitParameters+0x1a8>
 3008486:	fec42783          	lw	a5,-20(s0)
 300848a:	43d8                	lw	a4,4(a5)
 300848c:	478d                	li	a5,3
 300848e:	08f71e63          	bne	a4,a5,300852a <CheckAllInitParameters+0x240>
        I2C_PARAM_CHECK_WITH_RET(IsI2cOwnAddressOrMask(handle->slaveOwnAddress), BASE_STATUS_ERROR);
 3008492:	fec42783          	lw	a5,-20(s0)
 3008496:	47dc                	lw	a5,12(a5)
 3008498:	853e                	mv	a0,a5
 300849a:	3b15                	jal	ra,30081ce <IsI2cOwnAddressOrMask>
 300849c:	87aa                	mv	a5,a0
 300849e:	0017c793          	xori	a5,a5,1
 30084a2:	9f81                	uxtb	a5
 30084a4:	cb91                	beqz	a5,30084b8 <CheckAllInitParameters+0x1ce>
 30084a6:	0a300593          	li	a1,163
 30084aa:	030127b7          	lui	a5,0x3012
 30084ae:	d1478513          	addi	a0,a5,-748 # 3011d14 <g_crgIpMatch+0x47c>
 30084b2:	318d                	jal	ra,3008114 <AssertErrorLog.trans.5>
 30084b4:	4785                	li	a5,1
 30084b6:	a89d                	j	300852c <CheckAllInitParameters+0x242>
        I2C_PARAM_CHECK_WITH_RET(IsI2cGeneralCallMode(handle->generalCallMode), BASE_STATUS_ERROR);
 30084b8:	fec42783          	lw	a5,-20(s0)
 30084bc:	4fdc                	lw	a5,28(a5)
 30084be:	853e                	mv	a0,a5
 30084c0:	31cd                	jal	ra,30081a2 <IsI2cGeneralCallMode>
 30084c2:	87aa                	mv	a5,a0
 30084c4:	0017c793          	xori	a5,a5,1
 30084c8:	9f81                	uxtb	a5
 30084ca:	cb91                	beqz	a5,30084de <CheckAllInitParameters+0x1f4>
 30084cc:	0a400593          	li	a1,164
 30084d0:	030127b7          	lui	a5,0x3012
 30084d4:	d1478513          	addi	a0,a5,-748 # 3011d14 <g_crgIpMatch+0x47c>
 30084d8:	3935                	jal	ra,3008114 <AssertErrorLog.trans.5>
 30084da:	4785                	li	a5,1
 30084dc:	a881                	j	300852c <CheckAllInitParameters+0x242>
        I2C_PARAM_CHECK_WITH_RET(IsXMBusAddressEnable(handle->handleEx.slaveOwnXmbAddressEnable), BASE_STATUS_ERROR);
 30084de:	fec42783          	lw	a5,-20(s0)
 30084e2:	53bc                	lw	a5,96(a5)
 30084e4:	853e                	mv	a0,a5
 30084e6:	3305                	jal	ra,3008206 <IsXMBusAddressEnable>
 30084e8:	87aa                	mv	a5,a0
 30084ea:	0017c793          	xori	a5,a5,1
 30084ee:	9f81                	uxtb	a5
 30084f0:	cb91                	beqz	a5,3008504 <CheckAllInitParameters+0x21a>
 30084f2:	0a500593          	li	a1,165
 30084f6:	030127b7          	lui	a5,0x3012
 30084fa:	d1478513          	addi	a0,a5,-748 # 3011d14 <g_crgIpMatch+0x47c>
 30084fe:	3919                	jal	ra,3008114 <AssertErrorLog.trans.5>
 3008500:	4785                	li	a5,1
 3008502:	a02d                	j	300852c <CheckAllInitParameters+0x242>
        I2C_PARAM_CHECK_WITH_RET(IsXMBusAddressOrMask(handle->handleEx.slaveOwnXmbAddress), BASE_STATUS_ERROR);
 3008504:	fec42783          	lw	a5,-20(s0)
 3008508:	53fc                	lw	a5,100(a5)
 300850a:	853e                	mv	a0,a5
 300850c:	39f9                	jal	ra,30081ea <IsXMBusAddressOrMask>
 300850e:	87aa                	mv	a5,a0
 3008510:	0017c793          	xori	a5,a5,1
 3008514:	9f81                	uxtb	a5
 3008516:	cb91                	beqz	a5,300852a <CheckAllInitParameters+0x240>
 3008518:	0a600593          	li	a1,166
 300851c:	030127b7          	lui	a5,0x3012
 3008520:	d1478513          	addi	a0,a5,-748 # 3011d14 <g_crgIpMatch+0x47c>
 3008524:	3ec5                	jal	ra,3008114 <AssertErrorLog.trans.5>
 3008526:	4785                	li	a5,1
 3008528:	a011                	j	300852c <CheckAllInitParameters+0x242>
    }
    return BASE_STATUS_OK;
 300852a:	4781                	li	a5,0
}
 300852c:	853e                	mv	a0,a5
 300852e:	40f2                	lw	ra,28(sp)
 3008530:	4462                	lw	s0,24(sp)
 3008532:	6105                	addi	sp,sp,32
 3008534:	8082                	ret

03008536 <SetSlaveDevAddr>:
  * @param handle I2C handle.
  * @param devAddr Slave device address
  * @retval None.
  */
static void SetSlaveDevAddr(I2C_Handle *handle, const unsigned int devAddr)
{
 3008536:	7179                	addi	sp,sp,-48
 3008538:	d622                	sw	s0,44(sp)
 300853a:	1800                	addi	s0,sp,48
 300853c:	fca42e23          	sw	a0,-36(s0)
 3008540:	fcb42c23          	sw	a1,-40(s0)
    unsigned int addr;

    if (handle->addrMode == I2C_10_BITS) {
 3008544:	fdc42783          	lw	a5,-36(s0)
 3008548:	4798                	lw	a4,8(a5)
 300854a:	4785                	li	a5,1
 300854c:	02f71663          	bne	a4,a5,3008578 <SetSlaveDevAddr+0x42>
        /* The upper 16 bits are the read operation address, and the lower 16 bits are the write operation address. */
        addr = (((devAddr << 16) & I2C_10BIT_SLAVE_READ_ADDR_MASK) | I2C_10BIT_SLAVE_READ_OPT_MASK) |
 3008550:	fd842783          	lw	a5,-40(s0)
 3008554:	01079713          	slli	a4,a5,0x10
 3008558:	feff07b7          	lui	a5,0xfeff0
 300855c:	8f7d                	and	a4,a4,a5
               (devAddr & I2C_10BIT_SLAVE_WRITE_ADDR_MASK);
 300855e:	fd842683          	lw	a3,-40(s0)
 3008562:	67c1                	lui	a5,0x10
 3008564:	eff78793          	addi	a5,a5,-257 # feff <RAM_SIZE+0xaeff>
 3008568:	8ff5                	and	a5,a5,a3
        addr = (((devAddr << 16) & I2C_10BIT_SLAVE_READ_ADDR_MASK) | I2C_10BIT_SLAVE_READ_OPT_MASK) |
 300856a:	8f5d                	or	a4,a4,a5
 300856c:	010007b7          	lui	a5,0x1000
 3008570:	8fd9                	or	a5,a5,a4
 3008572:	fef42623          	sw	a5,-20(s0)
 3008576:	a00d                	j	3008598 <SetSlaveDevAddr+0x62>
    } else {
        /* The upper 16 bits are the read operation address, and the lower 16 bits are the write operation address. */
        addr = (((devAddr << 16) & I2C_7BIT_SLAVE_READ_ADDR_MASK) | I2C_7BIT_SLAVE_READ_OPT_MASK) |
 3008578:	fd842783          	lw	a5,-40(s0)
 300857c:	01079713          	slli	a4,a5,0x10
 3008580:	00fe07b7          	lui	a5,0xfe0
 3008584:	8f7d                	and	a4,a4,a5
               (devAddr & I2C_7BIT_SLAVE_WRITE_ADDR_MASK);
 3008586:	fd842783          	lw	a5,-40(s0)
 300858a:	0fe7f793          	andi	a5,a5,254
        addr = (((devAddr << 16) & I2C_7BIT_SLAVE_READ_ADDR_MASK) | I2C_7BIT_SLAVE_READ_OPT_MASK) |
 300858e:	8f5d                	or	a4,a4,a5
 3008590:	67c1                	lui	a5,0x10
 3008592:	8fd9                	or	a5,a5,a4
 3008594:	fef42623          	sw	a5,-20(s0)
    }
    
    if (handle->baseAddress == I2C0) {
 3008598:	fdc42783          	lw	a5,-36(s0)
 300859c:	4398                	lw	a4,0(a5)
 300859e:	141007b7          	lui	a5,0x14100
 30085a2:	00f71863          	bne	a4,a5,30085b2 <SetSlaveDevAddr+0x7c>
        g_internalConfigParam[I2C_INTERFACE_INDEX_0].slaveAddress = addr;
 30085a6:	c9a18793          	addi	a5,gp,-870 # 40005a4 <g_internalConfigParam>
 30085aa:	fec42703          	lw	a4,-20(s0)
 30085ae:	c3d8                	sw	a4,4(a5)
    } else if (handle->baseAddress == I2C1) {
        g_internalConfigParam[I2C_INTERFACE_INDEX_1].slaveAddress = addr;
    }
}
 30085b0:	a829                	j	30085ca <SetSlaveDevAddr+0x94>
    } else if (handle->baseAddress == I2C1) {
 30085b2:	fdc42783          	lw	a5,-36(s0)
 30085b6:	4398                	lw	a4,0(a5)
 30085b8:	141017b7          	lui	a5,0x14101
 30085bc:	00f71763          	bne	a4,a5,30085ca <SetSlaveDevAddr+0x94>
        g_internalConfigParam[I2C_INTERFACE_INDEX_1].slaveAddress = addr;
 30085c0:	c9a18793          	addi	a5,gp,-870 # 40005a4 <g_internalConfigParam>
 30085c4:	fec42703          	lw	a4,-20(s0)
 30085c8:	cb98                	sw	a4,16(a5)
}
 30085ca:	0001                	nop
 30085cc:	5432                	lw	s0,44(sp)
 30085ce:	6145                	addi	sp,sp,48
 30085d0:	8082                	ret

030085d2 <I2cBusClear>:
  * @brief I2C Bus clear.
  * @param handle I2C handle.
  * @retval None.
  */
static void I2cBusClear(I2C_Handle *handle)
{
 30085d2:	7179                	addi	sp,sp,-48
 30085d4:	d606                	sw	ra,44(sp)
 30085d6:	d422                	sw	s0,40(sp)
 30085d8:	1800                	addi	s0,sp,48
 30085da:	fca42e23          	sw	a0,-36(s0)
    handle->state = I2C_STATE_READY;
 30085de:	fdc42783          	lw	a5,-36(s0)
 30085e2:	4705                	li	a4,1
 30085e4:	c3f8                	sw	a4,68(a5)
    handle->baseAddress->I2C_MODE.BIT.mst_slv_function = I2C_STATE_RESET;
 30085e6:	fdc42783          	lw	a5,-36(s0)
 30085ea:	4398                	lw	a4,0(a5)
 30085ec:	431c                	lw	a5,0(a4)
 30085ee:	9bf1                	andi	a5,a5,-4
 30085f0:	c31c                	sw	a5,0(a4)
    /* Clears interrupts and disables interrupt reporting to
       facilitate switching between different working modes. */
    handle->baseAddress->I2C_INTR_EN.reg = I2C_INTR_EN_ALL_DISABLE;
 30085f2:	fdc42783          	lw	a5,-36(s0)
 30085f6:	439c                	lw	a5,0(a5)
 30085f8:	0e07a223          	sw	zero,228(a5) # 141010e4 <RAM_END+0x100f90e4>
    handle->baseAddress->I2C_INTR_RAW.reg = I2C_INTR_RAW_ALL_ENABLE;
 30085fc:	fdc42783          	lw	a5,-36(s0)
 3008600:	439c                	lw	a5,0(a5)
 3008602:	01000737          	lui	a4,0x1000
 3008606:	177d                	addi	a4,a4,-1 # ffffff <FLASH_SIZE+0xfe0003>
 3008608:	0ee7a023          	sw	a4,224(a5)

    /* Set the SCL and SDA pins of the I2C to GPIO mode. */
    handle->baseAddress->I2C_CTRL2.BIT.gpio_mode = BASE_CFG_ENABLE;
 300860c:	fdc42783          	lw	a5,-36(s0)
 3008610:	4398                	lw	a4,0(a5)
 3008612:	0d472783          	lw	a5,212(a4)
 3008616:	1007e793          	ori	a5,a5,256
 300861a:	0cf72a23          	sw	a5,212(a4)
    handle->baseAddress->I2C_CTRL2.BIT.force_scl = BASE_CFG_ENABLE;
 300861e:	fdc42783          	lw	a5,-36(s0)
 3008622:	4398                	lw	a4,0(a5)
 3008624:	0d472783          	lw	a5,212(a4)
 3008628:	0107e793          	ori	a5,a5,16
 300862c:	0cf72a23          	sw	a5,212(a4)
    handle->baseAddress->I2C_CTRL2.BIT.force_sda = BASE_CFG_ENABLE;
 3008630:	fdc42783          	lw	a5,-36(s0)
 3008634:	4398                	lw	a4,0(a5)
 3008636:	0d472783          	lw	a5,212(a4)
 300863a:	0017e793          	ori	a5,a5,1
 300863e:	0cf72a23          	sw	a5,212(a4)
    /* The device that controls the bus to be pulled down needs to release the bus within the 9 clocks. */
    for (unsigned int index = 0; index < 9; index++) {
 3008642:	fe042623          	sw	zero,-20(s0)
 3008646:	a099                	j	300868c <I2cBusClear+0xba>
        handle->baseAddress->I2C_CTRL2.BIT.force_scl = BASE_CFG_UNSET;
 3008648:	fdc42783          	lw	a5,-36(s0)
 300864c:	4398                	lw	a4,0(a5)
 300864e:	0d472783          	lw	a5,212(a4)
 3008652:	9bbd                	andi	a5,a5,-17
 3008654:	0cf72a23          	sw	a5,212(a4)
        BASE_FUNC_DELAY_US(5); /* The I2C timing is required. The delay is about 5 μs. */
 3008658:	000f47b7          	lui	a5,0xf4
 300865c:	24078593          	addi	a1,a5,576 # f4240 <FLASH_SIZE+0xd4244>
 3008660:	4515                	li	a0,5
 3008662:	204d                	jal	ra,3008704 <BASE_FUNC_Delay.trans.27>
        handle->baseAddress->I2C_CTRL2.BIT.force_scl = BASE_CFG_SET;
 3008664:	fdc42783          	lw	a5,-36(s0)
 3008668:	4398                	lw	a4,0(a5)
 300866a:	0d472783          	lw	a5,212(a4)
 300866e:	0107e793          	ori	a5,a5,16
 3008672:	0cf72a23          	sw	a5,212(a4)
        BASE_FUNC_DELAY_US(5); /* The I2C timing is required. The delay is about 5 μs. */
 3008676:	000f47b7          	lui	a5,0xf4
 300867a:	24078593          	addi	a1,a5,576 # f4240 <FLASH_SIZE+0xd4244>
 300867e:	4515                	li	a0,5
 3008680:	2051                	jal	ra,3008704 <BASE_FUNC_Delay.trans.27>
    for (unsigned int index = 0; index < 9; index++) {
 3008682:	fec42783          	lw	a5,-20(s0)
 3008686:	0785                	addi	a5,a5,1
 3008688:	fef42623          	sw	a5,-20(s0)
 300868c:	fec42703          	lw	a4,-20(s0)
 3008690:	47a1                	li	a5,8
 3008692:	fae7fbe3          	bgeu	a5,a4,3008648 <I2cBusClear+0x76>
    }
    handle->baseAddress->I2C_CTRL2.BIT.force_scl = BASE_CFG_ENABLE;
 3008696:	fdc42783          	lw	a5,-36(s0)
 300869a:	4398                	lw	a4,0(a5)
 300869c:	0d472783          	lw	a5,212(a4)
 30086a0:	0107e793          	ori	a5,a5,16
 30086a4:	0cf72a23          	sw	a5,212(a4)
    handle->baseAddress->I2C_CTRL2.BIT.force_sda = BASE_CFG_ENABLE;
 30086a8:	fdc42783          	lw	a5,-36(s0)
 30086ac:	4398                	lw	a4,0(a5)
 30086ae:	0d472783          	lw	a5,212(a4)
 30086b2:	0017e793          	ori	a5,a5,1
 30086b6:	0cf72a23          	sw	a5,212(a4)
    /* I2C start */
    handle->baseAddress->I2C_CTRL2.BIT.force_sda = BASE_CFG_UNSET;
 30086ba:	fdc42783          	lw	a5,-36(s0)
 30086be:	4398                	lw	a4,0(a5)
 30086c0:	0d472783          	lw	a5,212(a4)
 30086c4:	9bf9                	andi	a5,a5,-2
 30086c6:	0cf72a23          	sw	a5,212(a4)
    BASE_FUNC_DELAY_US(10); /* The I2C timing is required. The delay is about 10 μs. */
 30086ca:	000f47b7          	lui	a5,0xf4
 30086ce:	24078593          	addi	a1,a5,576 # f4240 <FLASH_SIZE+0xd4244>
 30086d2:	4529                	li	a0,10
 30086d4:	2805                	jal	ra,3008704 <BASE_FUNC_Delay.trans.27>
    /* I2C stop */
    handle->baseAddress->I2C_CTRL2.BIT.force_sda = BASE_CFG_SET;
 30086d6:	fdc42783          	lw	a5,-36(s0)
 30086da:	4398                	lw	a4,0(a5)
 30086dc:	0d472783          	lw	a5,212(a4)
 30086e0:	0017e793          	ori	a5,a5,1
 30086e4:	0cf72a23          	sw	a5,212(a4)
    handle->baseAddress->I2C_CTRL2.BIT.gpio_mode = BASE_CFG_DISABLE; /* Exit the I2C GPIO mode. */
 30086e8:	fdc42783          	lw	a5,-36(s0)
 30086ec:	4398                	lw	a4,0(a5)
 30086ee:	0d472783          	lw	a5,212(a4)
 30086f2:	eff7f793          	andi	a5,a5,-257
 30086f6:	0cf72a23          	sw	a5,212(a4)
}
 30086fa:	0001                	nop
 30086fc:	50b2                	lw	ra,44(sp)
 30086fe:	5422                	lw	s0,40(sp)
 3008700:	6145                	addi	sp,sp,48
 3008702:	8082                	ret

03008704 <BASE_FUNC_Delay.trans.27>:
 3008704:	f5cfa06f          	j	3002e60 <BASE_FUNC_Delay>

03008708 <SetErrorHandling>:
  * @brief Setting Error Handling.
  * @param handle I2C handle.
  * @retval None.
  */
static void SetErrorHandling(I2C_Handle *handle)
{
 3008708:	1101                	addi	sp,sp,-32
 300870a:	ce06                	sw	ra,28(sp)
 300870c:	cc22                	sw	s0,24(sp)
 300870e:	1000                	addi	s0,sp,32
 3008710:	fea42623          	sw	a0,-20(s0)
    /* If the low level times out, the I2C bus is cleared and the bus is expected to be released. */
    if (handle->baseAddress->I2C_INTR_RAW.BIT.scl_low_timeout_raw == BASE_CFG_ENABLE) {
 3008714:	fec42783          	lw	a5,-20(s0)
 3008718:	439c                	lw	a5,0(a5)
 300871a:	0e07a783          	lw	a5,224(a5)
 300871e:	83b5                	srli	a5,a5,0xd
 3008720:	8b85                	andi	a5,a5,1
 3008722:	0ff7f713          	andi	a4,a5,255
 3008726:	4785                	li	a5,1
 3008728:	00f71e63          	bne	a4,a5,3008744 <SetErrorHandling+0x3c>
        I2cBusClear(handle);
 300872c:	fec42503          	lw	a0,-20(s0)
 3008730:	354d                	jal	ra,30085d2 <I2cBusClear>
        handle->baseAddress->I2C_INTR_RAW.BIT.scl_low_timeout_raw = BASE_CFG_ENABLE;
 3008732:	fec42783          	lw	a5,-20(s0)
 3008736:	4398                	lw	a4,0(a5)
 3008738:	0e072783          	lw	a5,224(a4)
 300873c:	6689                	lui	a3,0x2
 300873e:	8fd5                	or	a5,a5,a3
 3008740:	0ef72023          	sw	a5,224(a4)
    }

    if (handle->errorCode != BASE_STATUS_OK && handle->userCallBack.ErrorCallback != NULL) {
 3008744:	fec42783          	lw	a5,-20(s0)
 3008748:	47bc                	lw	a5,72(a5)
 300874a:	cb99                	beqz	a5,3008760 <SetErrorHandling+0x58>
 300874c:	fec42783          	lw	a5,-20(s0)
 3008750:	4bfc                	lw	a5,84(a5)
 3008752:	c799                	beqz	a5,3008760 <SetErrorHandling+0x58>
        handle->userCallBack.ErrorCallback(handle);
 3008754:	fec42783          	lw	a5,-20(s0)
 3008758:	4bfc                	lw	a5,84(a5)
 300875a:	fec42503          	lw	a0,-20(s0)
 300875e:	9782                	jalr	a5
    }
    /* Clears interrupts and disables interrupt reporting to
       facilitate switching between different working modes. */
    handle->baseAddress->I2C_INTR_EN.reg = I2C_INTR_EN_ALL_DISABLE;
 3008760:	fec42783          	lw	a5,-20(s0)
 3008764:	439c                	lw	a5,0(a5)
 3008766:	0e07a223          	sw	zero,228(a5)
    handle->baseAddress->I2C_INTR_RAW.reg = I2C_INTR_RAW_ALL_ENABLE;
 300876a:	fec42783          	lw	a5,-20(s0)
 300876e:	439c                	lw	a5,0(a5)
 3008770:	01000737          	lui	a4,0x1000
 3008774:	177d                	addi	a4,a4,-1 # ffffff <FLASH_SIZE+0xfe0003>
 3008776:	0ee7a023          	sw	a4,224(a5)

    handle->state = I2C_STATE_READY;
 300877a:	fec42783          	lw	a5,-20(s0)
 300877e:	4705                	li	a4,1
 3008780:	c3f8                	sw	a4,68(a5)
}
 3008782:	0001                	nop
 3008784:	40f2                	lw	ra,28(sp)
 3008786:	4462                	lw	s0,24(sp)
 3008788:	6105                	addi	sp,sp,32
 300878a:	8082                	ret

0300878c <CheckItemStatus>:
  * @param checkItem The item to be checked.
  * @param opt Read or write flag.
  * @retval false, item is not ready. true, item is ready.
  */
static unsigned int CheckItemStatus(I2C_Handle *handle, unsigned int checkItem, unsigned int opt)
{
 300878c:	7179                	addi	sp,sp,-48
 300878e:	d622                	sw	s0,44(sp)
 3008790:	1800                	addi	s0,sp,48
 3008792:	fca42e23          	sw	a0,-36(s0)
 3008796:	fcb42c23          	sw	a1,-40(s0)
 300879a:	fcc42a23          	sw	a2,-44(s0)
    unsigned int ret = 0;
 300879e:	fe042623          	sw	zero,-20(s0)
    unsigned int tempStatusValue = 0;
 30087a2:	fe042423          	sw	zero,-24(s0)
    switch (checkItem) {
 30087a6:	fd842703          	lw	a4,-40(s0)
 30087aa:	4791                	li	a5,4
 30087ac:	0ce7e263          	bltu	a5,a4,3008870 <CheckItemStatus+0xe4>
 30087b0:	fd842783          	lw	a5,-40(s0)
 30087b4:	00279713          	slli	a4,a5,0x2
 30087b8:	030127b7          	lui	a5,0x3012
 30087bc:	d3078793          	addi	a5,a5,-720 # 3011d30 <g_crgIpMatch+0x498>
 30087c0:	97ba                	add	a5,a5,a4
 30087c2:	439c                	lw	a5,0(a5)
 30087c4:	8782                	jr	a5
        case COMMAND_ALL_DONE:
            /* The 0x1200 is the bit of mst_cmd_done_raw and stop_det_raw. */
            tempStatusValue = (handle->baseAddress->I2C_INTR_RAW.reg & 0x1200); /* Check the I2C is all command done. */
 30087c6:	fdc42783          	lw	a5,-36(s0)
 30087ca:	439c                	lw	a5,0(a5)
 30087cc:	0e07a703          	lw	a4,224(a5)
 30087d0:	6785                	lui	a5,0x1
 30087d2:	20078793          	addi	a5,a5,512 # 1200 <__bss_size__+0x16c>
 30087d6:	8ff9                	and	a5,a5,a4
 30087d8:	fef42423          	sw	a5,-24(s0)
            ret = tempStatusValue;
 30087dc:	fe842783          	lw	a5,-24(s0)
 30087e0:	fef42623          	sw	a5,-20(s0)
            break;
 30087e4:	a079                	j	3008872 <CheckItemStatus+0xe6>
        case I2C_BUS_IS_FREE:
            /* The I2C bus is free. */
            ret = handle->baseAddress->I2C_FSM_STAT.BIT.i2c_bus_free;
 30087e6:	fdc42783          	lw	a5,-36(s0)
 30087ea:	439c                	lw	a5,0(a5)
 30087ec:	0dc7a783          	lw	a5,220(a5)
 30087f0:	83f9                	srli	a5,a5,0x1e
 30087f2:	8b85                	andi	a5,a5,1
 30087f4:	9f81                	uxtb	a5
 30087f6:	fef42623          	sw	a5,-20(s0)
            break;
 30087fa:	a8a5                	j	3008872 <CheckItemStatus+0xe6>
        case SLAVE_ADDRESS_MATCH:
            /* Slave servers are matched */
            tempStatusValue = (handle->baseAddress->I2C_RX_ADDR.BIT.rx_rw == opt) ? 1 : 0;
 30087fc:	fdc42783          	lw	a5,-36(s0)
 3008800:	439c                	lw	a5,0(a5)
 3008802:	4f9c                	lw	a5,24(a5)
 3008804:	8b85                	andi	a5,a5,1
 3008806:	9f81                	uxtb	a5
 3008808:	873e                	mv	a4,a5
 300880a:	fd442783          	lw	a5,-44(s0)
 300880e:	8f99                	sub	a5,a5,a4
 3008810:	0017b793          	seqz	a5,a5
 3008814:	9f81                	uxtb	a5
 3008816:	fef42423          	sw	a5,-24(s0)
            tempStatusValue |= handle->baseAddress->I2C_INTR_RAW.BIT.slv_addr_match_raw;
 300881a:	fdc42783          	lw	a5,-36(s0)
 300881e:	439c                	lw	a5,0(a5)
 3008820:	0e07a783          	lw	a5,224(a5)
 3008824:	83d5                	srli	a5,a5,0x15
 3008826:	8b85                	andi	a5,a5,1
 3008828:	9f81                	uxtb	a5
 300882a:	873e                	mv	a4,a5
 300882c:	fe842783          	lw	a5,-24(s0)
 3008830:	8fd9                	or	a5,a5,a4
 3008832:	fef42423          	sw	a5,-24(s0)
            ret = tempStatusValue;
 3008836:	fe842783          	lw	a5,-24(s0)
 300883a:	fef42623          	sw	a5,-20(s0)
            break;
 300883e:	a815                	j	3008872 <CheckItemStatus+0xe6>
        case TX_FIFO_NOT_FULL:
            /* Tx fifo is not full. */
            ret = ((handle->baseAddress->I2C_FIFO_STAT.BIT.tx_fifo_vld_num < I2C_MAX_FIFO_SIZE)) ? 1 : 0;
 3008840:	fdc42783          	lw	a5,-36(s0)
 3008844:	439c                	lw	a5,0(a5)
 3008846:	0d87a783          	lw	a5,216(a5)
 300884a:	83a1                	srli	a5,a5,0x8
 300884c:	8bfd                	andi	a5,a5,31
 300884e:	9f81                	uxtb	a5
 3008850:	0107b793          	sltiu	a5,a5,16
 3008854:	9f81                	uxtb	a5
 3008856:	fef42623          	sw	a5,-20(s0)
            break;
 300885a:	a821                	j	3008872 <CheckItemStatus+0xe6>
        case RX_FIFO_NOT_EMPTY:
            /* Rx fifo is not empty. */
            ret = handle->baseAddress->I2C_FIFO_STAT.BIT.rx_fifo_vld_num;
 300885c:	fdc42783          	lw	a5,-36(s0)
 3008860:	439c                	lw	a5,0(a5)
 3008862:	0d87a783          	lw	a5,216(a5)
 3008866:	8bfd                	andi	a5,a5,31
 3008868:	9f81                	uxtb	a5
 300886a:	fef42623          	sw	a5,-20(s0)
            break;
 300886e:	a011                	j	3008872 <CheckItemStatus+0xe6>
        default:
            break;
 3008870:	0001                	nop
    }
    return ret;
 3008872:	fec42783          	lw	a5,-20(s0)
}
 3008876:	853e                	mv	a0,a5
 3008878:	5432                	lw	s0,44(sp)
 300887a:	6145                	addi	sp,sp,48
 300887c:	8082                	ret

0300887e <WaitStatusReady>:
  * @param checkItem The item to be checked.
  * @param opt Read or write flag.
  * @retval BASE status type: OK, ERROR, BUSY, TIMEOUT, NOT SUPPORT.
  */
static BASE_StatusType WaitStatusReady(I2C_Handle *handle, unsigned int checkItem, unsigned int opt)
{
 300887e:	7139                	addi	sp,sp,-64
 3008880:	03010293          	addi	t0,sp,48
 3008884:	0062928b          	stmia	{ra,s0,s2-s3},(t0)
 3008888:	0080                	addi	s0,sp,64
 300888a:	fca42623          	sw	a0,-52(s0)
 300888e:	fcb42423          	sw	a1,-56(s0)
 3008892:	fcc42223          	sw	a2,-60(s0)
    unsigned int preTick = DCL_SYSTICK_GetTick();
 3008896:	cd2fa0ef          	jal	ra,3002d68 <DCL_SYSTICK_GetTick>
 300889a:	fea42623          	sw	a0,-20(s0)
    unsigned int curTick;
    unsigned long long delta = 0;
 300889e:	4781                	li	a5,0
 30088a0:	4801                	li	a6,0
 30088a2:	fef42023          	sw	a5,-32(s0)
 30088a6:	ff042223          	sw	a6,-28(s0)
    unsigned long long targetDelta = HAL_CRG_GetIpFreq(SYSTICK_BASE) / I2C_TICK_MS_DIV * handle->timeout;
 30088aa:	14380537          	lui	a0,0x14380
 30088ae:	e68fc0ef          	jal	ra,3004f16 <HAL_CRG_GetIpFreq>
 30088b2:	872a                	mv	a4,a0
 30088b4:	3e800793          	li	a5,1000
 30088b8:	02f75733          	divu	a4,a4,a5
 30088bc:	fcc42783          	lw	a5,-52(s0)
 30088c0:	57dc                	lw	a5,44(a5)
 30088c2:	02f707b3          	mul	a5,a4,a5
 30088c6:	fcf42c23          	sw	a5,-40(s0)
 30088ca:	fc042e23          	sw	zero,-36(s0)

    while (true) {
        if (handle->baseAddress->I2C_INTR_RAW.reg & I2C_ERROR_BIT_MASK) {
 30088ce:	fcc42783          	lw	a5,-52(s0)
 30088d2:	439c                	lw	a5,0(a5)
 30088d4:	0e07a703          	lw	a4,224(a5)
 30088d8:	001017b7          	lui	a5,0x101
 30088dc:	80178793          	addi	a5,a5,-2047 # 100801 <FLASH_SIZE+0xe0805>
 30088e0:	8ff9                	and	a5,a5,a4
 30088e2:	c791                	beqz	a5,30088ee <WaitStatusReady+0x70>
            SetErrorHandling(handle);
 30088e4:	fcc42503          	lw	a0,-52(s0)
 30088e8:	3505                	jal	ra,3008708 <SetErrorHandling>
            return BASE_STATUS_ERROR;
 30088ea:	4785                	li	a5,1
 30088ec:	a0d1                	j	30089b0 <WaitStatusReady+0x132>
        }
        
        /* Check the status of the item is ready. */
        if (CheckItemStatus(handle, checkItem, opt)) {
 30088ee:	fc442603          	lw	a2,-60(s0)
 30088f2:	fc842583          	lw	a1,-56(s0)
 30088f6:	fcc42503          	lw	a0,-52(s0)
 30088fa:	3d49                	jal	ra,300878c <CheckItemStatus>
 30088fc:	87aa                	mv	a5,a0
 30088fe:	c395                	beqz	a5,3008922 <WaitStatusReady+0xa4>
            if (checkItem == SLAVE_ADDRESS_MATCH) {
 3008900:	fc842703          	lw	a4,-56(s0)
 3008904:	4789                	li	a5,2
 3008906:	00f71c63          	bne	a4,a5,300891e <WaitStatusReady+0xa0>
                /* Clear slave address match raw interrupt */
                handle->baseAddress->I2C_INTR_RAW.BIT.slv_addr_match_raw = BASE_CFG_SET;
 300890a:	fcc42783          	lw	a5,-52(s0)
 300890e:	4398                	lw	a4,0(a5)
 3008910:	0e072783          	lw	a5,224(a4)
 3008914:	002006b7          	lui	a3,0x200
 3008918:	8fd5                	or	a5,a5,a3
 300891a:	0ef72023          	sw	a5,224(a4)
            }
            return BASE_STATUS_OK;
 300891e:	4781                	li	a5,0
 3008920:	a841                	j	30089b0 <WaitStatusReady+0x132>
        }

        curTick = DCL_SYSTICK_GetTick();
 3008922:	c46fa0ef          	jal	ra,3002d68 <DCL_SYSTICK_GetTick>
 3008926:	fca42a23          	sw	a0,-44(s0)
        delta += curTick > preTick ? curTick - preTick : SYSTICK_MAX_VALUE - preTick + curTick;
 300892a:	fd442703          	lw	a4,-44(s0)
 300892e:	fec42783          	lw	a5,-20(s0)
 3008932:	00e7fb63          	bgeu	a5,a4,3008948 <WaitStatusReady+0xca>
 3008936:	fd442703          	lw	a4,-44(s0)
 300893a:	fec42783          	lw	a5,-20(s0)
 300893e:	40f707b3          	sub	a5,a4,a5
 3008942:	893e                	mv	s2,a5
 3008944:	4981                	li	s3,0
 3008946:	a811                	j	300895a <WaitStatusReady+0xdc>
 3008948:	fd442703          	lw	a4,-44(s0)
 300894c:	fec42783          	lw	a5,-20(s0)
 3008950:	40f707b3          	sub	a5,a4,a5
 3008954:	17fd                	addi	a5,a5,-1
 3008956:	893e                	mv	s2,a5
 3008958:	4981                	li	s3,0
 300895a:	fe042683          	lw	a3,-32(s0)
 300895e:	fe442703          	lw	a4,-28(s0)
 3008962:	012687b3          	add	a5,a3,s2
 3008966:	863e                	mv	a2,a5
 3008968:	00d63633          	sltu	a2,a2,a3
 300896c:	01370833          	add	a6,a4,s3
 3008970:	01060733          	add	a4,a2,a6
 3008974:	883a                	mv	a6,a4
 3008976:	fef42023          	sw	a5,-32(s0)
 300897a:	ff042223          	sw	a6,-28(s0)
        if (delta >= targetDelta) { /* Check timeout. */
 300897e:	fdc42703          	lw	a4,-36(s0)
 3008982:	fe442783          	lw	a5,-28(s0)
 3008986:	00e7ee63          	bltu	a5,a4,30089a2 <WaitStatusReady+0x124>
 300898a:	fdc42703          	lw	a4,-36(s0)
 300898e:	fe442783          	lw	a5,-28(s0)
 3008992:	00f71d63          	bne	a4,a5,30089ac <WaitStatusReady+0x12e>
 3008996:	fd842703          	lw	a4,-40(s0)
 300899a:	fe042783          	lw	a5,-32(s0)
 300899e:	00e7f763          	bgeu	a5,a4,30089ac <WaitStatusReady+0x12e>
            break;
        }
        preTick = curTick;
 30089a2:	fd442783          	lw	a5,-44(s0)
 30089a6:	fef42623          	sw	a5,-20(s0)
        if (handle->baseAddress->I2C_INTR_RAW.reg & I2C_ERROR_BIT_MASK) {
 30089aa:	b715                	j	30088ce <WaitStatusReady+0x50>
            break;
 30089ac:	0001                	nop
    }
    return BASE_STATUS_TIMEOUT;
 30089ae:	478d                	li	a5,3
}
 30089b0:	853e                	mv	a0,a5
 30089b2:	03010293          	addi	t0,sp,48
 30089b6:	0062828b          	ldmia	{ra,s0,s2-s3},(t0)
 30089ba:	6121                	addi	sp,sp,64
 30089bc:	8082                	ret

030089be <SetTxFIFODataAndCmd>:
  * @param cmd Operation commands.
  * @param data Sending data.
  * @retval BASE status type: OK, ERROR, BUSY, TIMEOUT, NOT SUPPORT.
  */
static BASE_StatusType SetTxFIFODataAndCmd(I2C_Handle *handle, I2C_CmdType cmd, unsigned char data)
{
 30089be:	7179                	addi	sp,sp,-48
 30089c0:	d606                	sw	ra,44(sp)
 30089c2:	d422                	sw	s0,40(sp)
 30089c4:	1800                	addi	s0,sp,48
 30089c6:	fca42e23          	sw	a0,-36(s0)
 30089ca:	fcb42c23          	sw	a1,-40(s0)
 30089ce:	87b2                	mv	a5,a2
 30089d0:	fcf40ba3          	sb	a5,-41(s0)
    BASE_StatusType ret;
    unsigned int temp;

    ret = WaitStatusReady(handle, TX_FIFO_NOT_FULL, I2C_OPERATION_WRITE);
 30089d4:	4601                	li	a2,0
 30089d6:	458d                	li	a1,3
 30089d8:	fdc42503          	lw	a0,-36(s0)
 30089dc:	354d                	jal	ra,300887e <WaitStatusReady>
 30089de:	fea42623          	sw	a0,-20(s0)
    if (ret != BASE_STATUS_OK) {
 30089e2:	fec42783          	lw	a5,-20(s0)
 30089e6:	c781                	beqz	a5,30089ee <SetTxFIFODataAndCmd+0x30>
        return ret;
 30089e8:	fec42783          	lw	a5,-20(s0)
 30089ec:	a80d                	j	3008a1e <SetTxFIFODataAndCmd+0x60>
    }
    /* The 8 to 11 bits are the Timing Commands, and the 0 to 7 bits are the write data. */
    temp = (((unsigned int)cmd << I2C_TXFIFO_CMD_POS) & I2C_TXFIFO_CMD_MASK);
 30089ee:	fd842783          	lw	a5,-40(s0)
 30089f2:	00879713          	slli	a4,a5,0x8
 30089f6:	6785                	lui	a5,0x1
 30089f8:	f0078793          	addi	a5,a5,-256 # f00 <prithd+0x302>
 30089fc:	8ff9                	and	a5,a5,a4
 30089fe:	fef42423          	sw	a5,-24(s0)
    temp |= (((unsigned int)data << I2C_TXFIFO_WDATA_POS) & I2C_TXFIFO_WDATA_MASK);
 3008a02:	fd744783          	lbu	a5,-41(s0)
 3008a06:	fe842703          	lw	a4,-24(s0)
 3008a0a:	8fd9                	or	a5,a5,a4
 3008a0c:	fef42423          	sw	a5,-24(s0)
    handle->baseAddress->I2C_TX_FIFO.reg = temp; /* Sets the data and commands to be sent. */
 3008a10:	fdc42783          	lw	a5,-36(s0)
 3008a14:	439c                	lw	a5,0(a5)
 3008a16:	fe842703          	lw	a4,-24(s0)
 3008a1a:	d398                	sw	a4,32(a5)
    return BASE_STATUS_OK;
 3008a1c:	4781                	li	a5,0
}
 3008a1e:	853e                	mv	a0,a5
 3008a20:	50b2                	lw	ra,44(sp)
 3008a22:	5422                	lw	s0,40(sp)
 3008a24:	6145                	addi	sp,sp,48
 3008a26:	8082                	ret

03008a28 <SendSlaveAddressWriteCmd>:
  * @param handle I2C handle.
  * @param index The number of I2C.
  * @retval BASE status type: OK, ERROR, BUSY, TIMEOUT, NOT SUPPORT.
  */
static BASE_StatusType SendSlaveAddressWriteCmd(I2C_Handle *handle, unsigned int index)
{
 3008a28:	7179                	addi	sp,sp,-48
 3008a2a:	d606                	sw	ra,44(sp)
 3008a2c:	d422                	sw	s0,40(sp)
 3008a2e:	1800                	addi	s0,sp,48
 3008a30:	fca42e23          	sw	a0,-36(s0)
 3008a34:	fcb42c23          	sw	a1,-40(s0)
    BASE_StatusType ret;
    unsigned char addr;
    /* Write slave address */
    if (handle->addrMode == I2C_10_BITS) { /* 10bit address Configuration */
 3008a38:	fdc42783          	lw	a5,-36(s0)
 3008a3c:	4798                	lw	a4,8(a5)
 3008a3e:	4785                	li	a5,1
 3008a40:	0af71663          	bne	a4,a5,3008aec <SendSlaveAddressWriteCmd+0xc4>
        if (handle->transferCount == 0) {
 3008a44:	fdc42783          	lw	a5,-36(s0)
 3008a48:	579c                	lw	a5,40(a5)
 3008a4a:	e7b5                	bnez	a5,3008ab6 <SendSlaveAddressWriteCmd+0x8e>
            /* The first address of a 10-bit address configuration */
            addr = (unsigned char)((g_internalConfigParam[index].slaveAddress >> I2C_SLAVE_WRITE_ADDR_POS) &
 3008a4c:	c9a18713          	addi	a4,gp,-870 # 40005a4 <g_internalConfigParam>
 3008a50:	fd842683          	lw	a3,-40(s0)
 3008a54:	47b1                	li	a5,12
 3008a56:	02f687b3          	mul	a5,a3,a5
 3008a5a:	97ba                	add	a5,a5,a4
 3008a5c:	43dc                	lw	a5,4(a5)
 3008a5e:	83a1                	srli	a5,a5,0x8
 3008a60:	fef407a3          	sb	a5,-17(s0)
                                   I2C_SLAVE_ADDR_MASK);
            ret = SetTxFIFODataAndCmd(handle, I2C_CMD_M_TD_RACK_S_RD_TACK, addr);
 3008a64:	fef44783          	lbu	a5,-17(s0)
 3008a68:	863e                	mv	a2,a5
 3008a6a:	4589                	li	a1,2
 3008a6c:	fdc42503          	lw	a0,-36(s0)
 3008a70:	37b9                	jal	ra,30089be <SetTxFIFODataAndCmd>
 3008a72:	fea42423          	sw	a0,-24(s0)
            if (ret != BASE_STATUS_OK) {
 3008a76:	fe842783          	lw	a5,-24(s0)
 3008a7a:	c781                	beqz	a5,3008a82 <SendSlaveAddressWriteCmd+0x5a>
                return ret;
 3008a7c:	fe842783          	lw	a5,-24(s0)
 3008a80:	a04d                	j	3008b22 <SendSlaveAddressWriteCmd+0xfa>
            }
            /* The second address of the 10-bit address configuration */
            addr = (unsigned char)(g_internalConfigParam[index].slaveAddress & I2C_SLAVE_ADDR_MASK);
 3008a82:	c9a18713          	addi	a4,gp,-870 # 40005a4 <g_internalConfigParam>
 3008a86:	fd842683          	lw	a3,-40(s0)
 3008a8a:	47b1                	li	a5,12
 3008a8c:	02f687b3          	mul	a5,a3,a5
 3008a90:	97ba                	add	a5,a5,a4
 3008a92:	43dc                	lw	a5,4(a5)
 3008a94:	fef407a3          	sb	a5,-17(s0)
            ret = SetTxFIFODataAndCmd(handle, I2C_CMD_M_TD_RACK_S_RD_TACK, addr);
 3008a98:	fef44783          	lbu	a5,-17(s0)
 3008a9c:	863e                	mv	a2,a5
 3008a9e:	4589                	li	a1,2
 3008aa0:	fdc42503          	lw	a0,-36(s0)
 3008aa4:	3f29                	jal	ra,30089be <SetTxFIFODataAndCmd>
 3008aa6:	fea42423          	sw	a0,-24(s0)
            if (ret != BASE_STATUS_OK) {
 3008aaa:	fe842783          	lw	a5,-24(s0)
 3008aae:	cbad                	beqz	a5,3008b20 <SendSlaveAddressWriteCmd+0xf8>
                return ret;
 3008ab0:	fe842783          	lw	a5,-24(s0)
 3008ab4:	a0bd                	j	3008b22 <SendSlaveAddressWriteCmd+0xfa>
            }
        } else {
            addr = (unsigned char)((g_internalConfigParam[index].slaveAddress >> I2C_SLAVE_WRITE_ADDR_POS) &
 3008ab6:	c9a18713          	addi	a4,gp,-870 # 40005a4 <g_internalConfigParam>
 3008aba:	fd842683          	lw	a3,-40(s0)
 3008abe:	47b1                	li	a5,12
 3008ac0:	02f687b3          	mul	a5,a3,a5
 3008ac4:	97ba                	add	a5,a5,a4
 3008ac6:	43dc                	lw	a5,4(a5)
 3008ac8:	83a1                	srli	a5,a5,0x8
 3008aca:	fef407a3          	sb	a5,-17(s0)
                                   I2C_SLAVE_ADDR_MASK);
            ret = SetTxFIFODataAndCmd(handle, I2C_CMD_M_TD_RACK_S_RD_TACK, addr);
 3008ace:	fef44783          	lbu	a5,-17(s0)
 3008ad2:	863e                	mv	a2,a5
 3008ad4:	4589                	li	a1,2
 3008ad6:	fdc42503          	lw	a0,-36(s0)
 3008ada:	35d5                	jal	ra,30089be <SetTxFIFODataAndCmd>
 3008adc:	fea42423          	sw	a0,-24(s0)
            if (ret != BASE_STATUS_OK) {
 3008ae0:	fe842783          	lw	a5,-24(s0)
 3008ae4:	cf95                	beqz	a5,3008b20 <SendSlaveAddressWriteCmd+0xf8>
                return ret;
 3008ae6:	fe842783          	lw	a5,-24(s0)
 3008aea:	a825                	j	3008b22 <SendSlaveAddressWriteCmd+0xfa>
            }
        }
    } else { /* 7bit address Configuration */
        addr = (unsigned char)(g_internalConfigParam[index].slaveAddress & I2C_SLAVE_ADDR_MASK);
 3008aec:	c9a18713          	addi	a4,gp,-870 # 40005a4 <g_internalConfigParam>
 3008af0:	fd842683          	lw	a3,-40(s0)
 3008af4:	47b1                	li	a5,12
 3008af6:	02f687b3          	mul	a5,a3,a5
 3008afa:	97ba                	add	a5,a5,a4
 3008afc:	43dc                	lw	a5,4(a5)
 3008afe:	fef407a3          	sb	a5,-17(s0)
        ret = SetTxFIFODataAndCmd(handle, I2C_CMD_M_TD_RACK_S_RD_TACK, addr);
 3008b02:	fef44783          	lbu	a5,-17(s0)
 3008b06:	863e                	mv	a2,a5
 3008b08:	4589                	li	a1,2
 3008b0a:	fdc42503          	lw	a0,-36(s0)
 3008b0e:	3d45                	jal	ra,30089be <SetTxFIFODataAndCmd>
 3008b10:	fea42423          	sw	a0,-24(s0)
        if (ret != BASE_STATUS_OK) {
 3008b14:	fe842783          	lw	a5,-24(s0)
 3008b18:	c781                	beqz	a5,3008b20 <SendSlaveAddressWriteCmd+0xf8>
            return ret;
 3008b1a:	fe842783          	lw	a5,-24(s0)
 3008b1e:	a011                	j	3008b22 <SendSlaveAddressWriteCmd+0xfa>
        }
    }
    return BASE_STATUS_OK;
 3008b20:	4781                	li	a5,0
}
 3008b22:	853e                	mv	a0,a5
 3008b24:	50b2                	lw	ra,44(sp)
 3008b26:	5422                	lw	s0,40(sp)
 3008b28:	6145                	addi	sp,sp,48
 3008b2a:	8082                	ret

03008b2c <I2C_ConfigParametersAndStartBlocking>:
  * @param handle I2C handle.
  * @param transferStatus The status is used to indicate read or write.
  * @retval BASE status type: OK, ERROR, BUSY, TIMEOUT, NOT SUPPORT.
  */
static BASE_StatusType I2C_ConfigParametersAndStartBlocking(I2C_Handle *handle, unsigned int transferStatus)
{
 3008b2c:	7179                	addi	sp,sp,-48
 3008b2e:	d606                	sw	ra,44(sp)
 3008b30:	d422                	sw	s0,40(sp)
 3008b32:	1800                	addi	s0,sp,48
 3008b34:	fca42e23          	sw	a0,-36(s0)
 3008b38:	fcb42c23          	sw	a1,-40(s0)
    BASE_StatusType ret;
    /* Startup Control */
    handle->baseAddress->I2C_CTRL1.BIT.dma_operation = I2C_DMA_OP_NONE;
 3008b3c:	fdc42783          	lw	a5,-36(s0)
 3008b40:	4398                	lw	a4,0(a5)
 3008b42:	0d072783          	lw	a5,208(a4)
 3008b46:	cff7f793          	andi	a5,a5,-769
 3008b4a:	0cf72823          	sw	a5,208(a4)
    handle->baseAddress->I2C_CTRL1.BIT.rst_rx_fifo = BASE_CFG_SET;
 3008b4e:	fdc42783          	lw	a5,-36(s0)
 3008b52:	4398                	lw	a4,0(a5)
 3008b54:	0d072783          	lw	a5,208(a4)
 3008b58:	0047e793          	ori	a5,a5,4
 3008b5c:	0cf72823          	sw	a5,208(a4)
    handle->baseAddress->I2C_CTRL1.BIT.rst_tx_fifo = BASE_CFG_SET;
 3008b60:	fdc42783          	lw	a5,-36(s0)
 3008b64:	4398                	lw	a4,0(a5)
 3008b66:	0d072783          	lw	a5,208(a4)
 3008b6a:	0087e793          	ori	a5,a5,8
 3008b6e:	0cf72823          	sw	a5,208(a4)

    handle->baseAddress->I2C_CTRL1.BIT.mst_start = (transferStatus == I2C_MASTER_STATUS) ? BASE_CFG_SET :
 3008b72:	fdc42783          	lw	a5,-36(s0)
 3008b76:	4398                	lw	a4,0(a5)
 3008b78:	fd842783          	lw	a5,-40(s0)
 3008b7c:	0017b793          	seqz	a5,a5
 3008b80:	0ff7f693          	andi	a3,a5,255
 3008b84:	0d072783          	lw	a5,208(a4)
 3008b88:	8a85                	andi	a3,a3,1
 3008b8a:	9bf9                	andi	a5,a5,-2
 3008b8c:	8fd5                	or	a5,a5,a3
 3008b8e:	0cf72823          	sw	a5,208(a4)
                                                    BASE_CFG_UNSET;
    if (transferStatus == I2C_SLAVE_STATUS) {
 3008b92:	fd842703          	lw	a4,-40(s0)
 3008b96:	4785                	li	a5,1
 3008b98:	00f71463          	bne	a4,a5,3008ba0 <I2C_ConfigParametersAndStartBlocking+0x74>
        return BASE_STATUS_OK;
 3008b9c:	4781                	li	a5,0
 3008b9e:	a01d                	j	3008bc4 <I2C_ConfigParametersAndStartBlocking+0x98>
    }
    /* Send I2C start */
    ret = SetTxFIFODataAndCmd(handle, I2C_CMD_S, 0); /* Sets the start command to be sent. */
 3008ba0:	4601                	li	a2,0
 3008ba2:	4585                	li	a1,1
 3008ba4:	fdc42503          	lw	a0,-36(s0)
 3008ba8:	3d19                	jal	ra,30089be <SetTxFIFODataAndCmd>
 3008baa:	fea42623          	sw	a0,-20(s0)
    if (ret != BASE_STATUS_OK) {
 3008bae:	fec42783          	lw	a5,-20(s0)
 3008bb2:	c799                	beqz	a5,3008bc0 <I2C_ConfigParametersAndStartBlocking+0x94>
        SetErrorHandling(handle);
 3008bb4:	fdc42503          	lw	a0,-36(s0)
 3008bb8:	3e81                	jal	ra,3008708 <SetErrorHandling>
        return ret;
 3008bba:	fec42783          	lw	a5,-20(s0)
 3008bbe:	a019                	j	3008bc4 <I2C_ConfigParametersAndStartBlocking+0x98>
    }
    return ret;
 3008bc0:	fec42783          	lw	a5,-20(s0)
}
 3008bc4:	853e                	mv	a0,a5
 3008bc6:	50b2                	lw	ra,44(sp)
 3008bc8:	5422                	lw	s0,40(sp)
 3008bca:	6145                	addi	sp,sp,48
 3008bcc:	8082                	ret

03008bce <BlockingSendStopCommand>:
  * @brief Master send stop command in blocking.
  * @param handle I2C handle.
  * @retval BASE status type: OK, ERROR, BUSY, TIMEOUT, NOT SUPPORT.
  */
static BASE_StatusType BlockingSendStopCommand(I2C_Handle *handle)
{
 3008bce:	7179                	addi	sp,sp,-48
 3008bd0:	d606                	sw	ra,44(sp)
 3008bd2:	d422                	sw	s0,40(sp)
 3008bd4:	1800                	addi	s0,sp,48
 3008bd6:	fca42e23          	sw	a0,-36(s0)
    BASE_StatusType ret;
    ret = SetTxFIFODataAndCmd(handle, I2C_CMD_P, 0);
 3008bda:	4601                	li	a2,0
 3008bdc:	45bd                	li	a1,15
 3008bde:	fdc42503          	lw	a0,-36(s0)
 3008be2:	3bf1                	jal	ra,30089be <SetTxFIFODataAndCmd>
 3008be4:	fea42623          	sw	a0,-20(s0)
    if (ret != BASE_STATUS_OK) {
 3008be8:	fec42783          	lw	a5,-20(s0)
 3008bec:	c799                	beqz	a5,3008bfa <BlockingSendStopCommand+0x2c>
        SetErrorHandling(handle);
 3008bee:	fdc42503          	lw	a0,-36(s0)
 3008bf2:	3e19                	jal	ra,3008708 <SetErrorHandling>
        return ret;
 3008bf4:	fec42783          	lw	a5,-20(s0)
 3008bf8:	a015                	j	3008c1c <BlockingSendStopCommand+0x4e>
    }
    /* Wait until all commands are executed. */
    ret = WaitStatusReady(handle, COMMAND_ALL_DONE, I2C_OPERATION_WRITE);
 3008bfa:	4601                	li	a2,0
 3008bfc:	4581                	li	a1,0
 3008bfe:	fdc42503          	lw	a0,-36(s0)
 3008c02:	39b5                	jal	ra,300887e <WaitStatusReady>
 3008c04:	fea42623          	sw	a0,-20(s0)
    handle->errorCode = ret;
 3008c08:	fdc42783          	lw	a5,-36(s0)
 3008c0c:	fec42703          	lw	a4,-20(s0)
 3008c10:	c7b8                	sw	a4,72(a5)
    SetErrorHandling(handle);
 3008c12:	fdc42503          	lw	a0,-36(s0)
 3008c16:	3ccd                	jal	ra,3008708 <SetErrorHandling>
    return ret;
 3008c18:	fec42783          	lw	a5,-20(s0)
}
 3008c1c:	853e                	mv	a0,a5
 3008c1e:	50b2                	lw	ra,44(sp)
 3008c20:	5422                	lw	s0,40(sp)
 3008c22:	6145                	addi	sp,sp,48
 3008c24:	8082                	ret

03008c26 <BlockingMasterTxDataOptStepNormal>:
  * @brief The step of transmit normal data in blocking as master.
  * @param handle I2C handle.
  * @retval BASE status type: OK, ERROR, BUSY, TIMEOUT, NOT SUPPORT.
  */
static BASE_StatusType BlockingMasterTxDataOptStepNormal(I2C_Handle *handle)
{
 3008c26:	7179                	addi	sp,sp,-48
 3008c28:	d606                	sw	ra,44(sp)
 3008c2a:	d422                	sw	s0,40(sp)
 3008c2c:	1800                	addi	s0,sp,48
 3008c2e:	fca42e23          	sw	a0,-36(s0)
    BASE_StatusType ret;
    /* Sets data to be sent cyclically. */
    while (handle->transferCount < handle->transferSize) {
 3008c32:	a0b1                	j	3008c7e <BlockingMasterTxDataOptStepNormal+0x58>
        ret = SetTxFIFODataAndCmd(handle, I2C_CMD_M_TD_RACK_S_RD_TACK, *handle->transferBuff);
 3008c34:	fdc42783          	lw	a5,-36(s0)
 3008c38:	539c                	lw	a5,32(a5)
 3008c3a:	239c                	lbu	a5,0(a5)
 3008c3c:	9f81                	uxtb	a5
 3008c3e:	863e                	mv	a2,a5
 3008c40:	4589                	li	a1,2
 3008c42:	fdc42503          	lw	a0,-36(s0)
 3008c46:	3ba5                	jal	ra,30089be <SetTxFIFODataAndCmd>
 3008c48:	fea42623          	sw	a0,-20(s0)
        if (ret != BASE_STATUS_OK) {
 3008c4c:	fec42783          	lw	a5,-20(s0)
 3008c50:	c799                	beqz	a5,3008c5e <BlockingMasterTxDataOptStepNormal+0x38>
            SetErrorHandling(handle);
 3008c52:	fdc42503          	lw	a0,-36(s0)
 3008c56:	3c4d                	jal	ra,3008708 <SetErrorHandling>
            return ret;
 3008c58:	fec42783          	lw	a5,-20(s0)
 3008c5c:	a815                	j	3008c90 <BlockingMasterTxDataOptStepNormal+0x6a>
        }
        handle->transferBuff++;
 3008c5e:	fdc42783          	lw	a5,-36(s0)
 3008c62:	539c                	lw	a5,32(a5)
 3008c64:	00178713          	addi	a4,a5,1
 3008c68:	fdc42783          	lw	a5,-36(s0)
 3008c6c:	d398                	sw	a4,32(a5)
        handle->transferCount++;
 3008c6e:	fdc42783          	lw	a5,-36(s0)
 3008c72:	579c                	lw	a5,40(a5)
 3008c74:	00178713          	addi	a4,a5,1
 3008c78:	fdc42783          	lw	a5,-36(s0)
 3008c7c:	d798                	sw	a4,40(a5)
    while (handle->transferCount < handle->transferSize) {
 3008c7e:	fdc42783          	lw	a5,-36(s0)
 3008c82:	5798                	lw	a4,40(a5)
 3008c84:	fdc42783          	lw	a5,-36(s0)
 3008c88:	53dc                	lw	a5,36(a5)
 3008c8a:	faf765e3          	bltu	a4,a5,3008c34 <BlockingMasterTxDataOptStepNormal+0xe>
    }
    return BASE_STATUS_OK;
 3008c8e:	4781                	li	a5,0
}
 3008c90:	853e                	mv	a0,a5
 3008c92:	50b2                	lw	ra,44(sp)
 3008c94:	5422                	lw	s0,40(sp)
 3008c96:	6145                	addi	sp,sp,48
 3008c98:	8082                	ret

03008c9a <HAL_I2C_Init>:
  * @brief Initializing the I2C Module.
  * @param handle I2C handle.
  * @retval BASE status type: OK, ERROR, BUSY, TIMEOUT, NOT SUPPORT.
  */
BASE_StatusType HAL_I2C_Init(I2C_Handle *handle)
{
 3008c9a:	7139                	addi	sp,sp,-64
 3008c9c:	de06                	sw	ra,60(sp)
 3008c9e:	dc22                	sw	s0,56(sp)
 3008ca0:	0080                	addi	s0,sp,64
 3008ca2:	fca42623          	sw	a0,-52(s0)
    unsigned int tempReg;
    unsigned int temp;
    unsigned int tempSclLowTime;
    unsigned int tempSclHighTime;

    I2C_ASSERT_PARAM(handle != NULL);
 3008ca6:	fcc42783          	lw	a5,-52(s0)
 3008caa:	eb89                	bnez	a5,3008cbc <HAL_I2C_Init+0x22>
 3008cac:	4f400593          	li	a1,1268
 3008cb0:	030127b7          	lui	a5,0x3012
 3008cb4:	d1478513          	addi	a0,a5,-748 # 3011d14 <g_crgIpMatch+0x47c>
 3008cb8:	25dd                	jal	ra,300939e <AssertErrorLog.trans.6>
 3008cba:	a001                	j	3008cba <HAL_I2C_Init+0x20>
    I2C_ASSERT_PARAM(IsI2CInstance(handle->baseAddress));
 3008cbc:	fcc42783          	lw	a5,-52(s0)
 3008cc0:	4398                	lw	a4,0(a5)
 3008cc2:	141007b7          	lui	a5,0x14100
 3008cc6:	02f70163          	beq	a4,a5,3008ce8 <HAL_I2C_Init+0x4e>
 3008cca:	fcc42783          	lw	a5,-52(s0)
 3008cce:	4398                	lw	a4,0(a5)
 3008cd0:	141017b7          	lui	a5,0x14101
 3008cd4:	00f70a63          	beq	a4,a5,3008ce8 <HAL_I2C_Init+0x4e>
 3008cd8:	4f500593          	li	a1,1269
 3008cdc:	030127b7          	lui	a5,0x3012
 3008ce0:	d1478513          	addi	a0,a5,-748 # 3011d14 <g_crgIpMatch+0x47c>
 3008ce4:	2d6d                	jal	ra,300939e <AssertErrorLog.trans.6>
 3008ce6:	a001                	j	3008ce6 <HAL_I2C_Init+0x4c>

    clockFreq = HAL_CRG_GetIpFreq((void *)handle->baseAddress);
 3008ce8:	fcc42783          	lw	a5,-52(s0)
 3008cec:	439c                	lw	a5,0(a5)
 3008cee:	853e                	mv	a0,a5
 3008cf0:	a26fc0ef          	jal	ra,3004f16 <HAL_CRG_GetIpFreq>
 3008cf4:	fea42423          	sw	a0,-24(s0)
    if (CheckAllInitParameters(handle, clockFreq) != BASE_STATUS_OK) {
 3008cf8:	fe842583          	lw	a1,-24(s0)
 3008cfc:	fcc42503          	lw	a0,-52(s0)
 3008d00:	deaff0ef          	jal	ra,30082ea <CheckAllInitParameters>
 3008d04:	87aa                	mv	a5,a0
 3008d06:	c399                	beqz	a5,3008d0c <HAL_I2C_Init+0x72>
        return BASE_STATUS_ERROR;
 3008d08:	4785                	li	a5,1
 3008d0a:	a4ad                	j	3008f74 <HAL_I2C_Init+0x2da>
    }

    handle->state = I2C_STATE_BUSY;
 3008d0c:	fcc42783          	lw	a5,-52(s0)
 3008d10:	4709                	li	a4,2
 3008d12:	c3f8                	sw	a4,68(a5)
    /* Clears interrupts and disables interrupt reporting to facilitate switching between different working modes. */
    handle->baseAddress->I2C_INTR_EN.reg = I2C_INTR_EN_ALL_DISABLE;
 3008d14:	fcc42783          	lw	a5,-52(s0)
 3008d18:	439c                	lw	a5,0(a5)
 3008d1a:	0e07a223          	sw	zero,228(a5)
    handle->baseAddress->I2C_INTR_RAW.reg = I2C_INTR_RAW_ALL_ENABLE;
 3008d1e:	fcc42783          	lw	a5,-52(s0)
 3008d22:	439c                	lw	a5,0(a5)
 3008d24:	01000737          	lui	a4,0x1000
 3008d28:	177d                	addi	a4,a4,-1 # ffffff <FLASH_SIZE+0xfe0003>
 3008d2a:	0ee7a023          	sw	a4,224(a5)

    /* Set SDA and SCL glitch filtering time. */
    handle->baseAddress->I2C_FILTER.BIT.spike_filter_time = handle->handleEx.spikeFilterTime;
 3008d2e:	fcc42783          	lw	a5,-52(s0)
 3008d32:	4fb4                	lw	a3,88(a5)
 3008d34:	fcc42783          	lw	a5,-52(s0)
 3008d38:	4398                	lw	a4,0(a5)
 3008d3a:	87b6                	mv	a5,a3
 3008d3c:	8bbd                	andi	a5,a5,15
 3008d3e:	0ff7f693          	andi	a3,a5,255
 3008d42:	10c72783          	lw	a5,268(a4)
 3008d46:	8abd                	andi	a3,a3,15
 3008d48:	9bc1                	andi	a5,a5,-16
 3008d4a:	8fd5                	or	a5,a5,a3
 3008d4c:	10f72623          	sw	a5,268(a4)
    /* Set SCL high and low duratiom time */
    tempSclLowTime = I2C_FREQ_LOW_PARAMTER + handle->handleEx.spikeFilterTime;
 3008d50:	fcc42783          	lw	a5,-52(s0)
 3008d54:	4fbc                	lw	a5,88(a5)
 3008d56:	07a5                	addi	a5,a5,9
 3008d58:	fef42223          	sw	a5,-28(s0)
    tempSclHighTime = I2C_FREQ_HIGH_PARAMTER + handle->handleEx.spikeFilterTime;
 3008d5c:	fcc42783          	lw	a5,-52(s0)
 3008d60:	4fbc                	lw	a5,88(a5)
 3008d62:	07a1                	addi	a5,a5,8
 3008d64:	fef42023          	sw	a5,-32(s0)
    if (handle->freq <= I2C_STANDARD_FREQ_TH) {
 3008d68:	fcc42783          	lw	a5,-52(s0)
 3008d6c:	4bd8                	lw	a4,20(a5)
 3008d6e:	67e1                	lui	a5,0x18
 3008d70:	6a078793          	addi	a5,a5,1696 # 186a0 <RAM_SIZE+0x136a0>
 3008d74:	02e7ee63          	bltu	a5,a4,3008db0 <HAL_I2C_Init+0x116>
        /* scl_high_time = (fclk_i2c/fSCL) x 0.5 - 8 - spike_filter_time. */
        val = clockFreq / (handle->freq * 2) - tempSclHighTime; /* The clockFreq / (freq * 2) = cloclFreq/0.5/freq. */
 3008d78:	fcc42783          	lw	a5,-52(s0)
 3008d7c:	4bdc                	lw	a5,20(a5)
 3008d7e:	0786                	slli	a5,a5,0x1
 3008d80:	fe842703          	lw	a4,-24(s0)
 3008d84:	02f75733          	divu	a4,a4,a5
 3008d88:	fe042783          	lw	a5,-32(s0)
 3008d8c:	40f707b3          	sub	a5,a4,a5
 3008d90:	fef42623          	sw	a5,-20(s0)
        /* scl_low_time = (fclk_i2c/fSCL) x 0.5 - 9 - spike_filter_time. */
        val = ((val - 1) & LOW_HOLD_TIME_MASK) | ((val << HIGH_HOLD_TIME_POS) & HIGH_HOLD_TIME_MASK);
 3008d94:	fec42783          	lw	a5,-20(s0)
 3008d98:	fff78713          	addi	a4,a5,-1
 3008d9c:	67c1                	lui	a5,0x10
 3008d9e:	17fd                	addi	a5,a5,-1 # ffff <RAM_SIZE+0xafff>
 3008da0:	8f7d                	and	a4,a4,a5
 3008da2:	fec42783          	lw	a5,-20(s0)
 3008da6:	07c2                	slli	a5,a5,0x10
 3008da8:	8fd9                	or	a5,a5,a4
 3008daa:	fef42623          	sw	a5,-20(s0)
 3008dae:	a8b9                	j	3008e0c <HAL_I2C_Init+0x172>
    } else {
        /* scl_high_time = (fclk_i2c/fSCL) x 0.36 - 8 - spike_filter_time. (n/100*36)=0.36n. */
        val = ((((clockFreq / 100) * 36) / handle->freq) - tempSclHighTime) << HIGH_HOLD_TIME_POS;
 3008db0:	fe842703          	lw	a4,-24(s0)
 3008db4:	06400793          	li	a5,100
 3008db8:	02f75733          	divu	a4,a4,a5
 3008dbc:	02400793          	li	a5,36
 3008dc0:	02f70733          	mul	a4,a4,a5
 3008dc4:	fcc42783          	lw	a5,-52(s0)
 3008dc8:	4bdc                	lw	a5,20(a5)
 3008dca:	02f75733          	divu	a4,a4,a5
 3008dce:	fe042783          	lw	a5,-32(s0)
 3008dd2:	40f707b3          	sub	a5,a4,a5
 3008dd6:	07c2                	slli	a5,a5,0x10
 3008dd8:	fef42623          	sw	a5,-20(s0)
        /* scl_low_time = (fclk_i2c/fSCL) x 0.64 - 9 - spike_filter_time. (n/100*64)=0.64n. */
        val |= (((((clockFreq / 100) * 64) / handle->freq) - tempSclLowTime) & LOW_HOLD_TIME_MASK);
 3008ddc:	fe842703          	lw	a4,-24(s0)
 3008de0:	06400793          	li	a5,100
 3008de4:	02f757b3          	divu	a5,a4,a5
 3008de8:	00679713          	slli	a4,a5,0x6
 3008dec:	fcc42783          	lw	a5,-52(s0)
 3008df0:	4bdc                	lw	a5,20(a5)
 3008df2:	02f75733          	divu	a4,a4,a5
 3008df6:	fe442783          	lw	a5,-28(s0)
 3008dfa:	8f1d                	sub	a4,a4,a5
 3008dfc:	67c1                	lui	a5,0x10
 3008dfe:	17fd                	addi	a5,a5,-1 # ffff <RAM_SIZE+0xafff>
 3008e00:	8ff9                	and	a5,a5,a4
 3008e02:	fec42703          	lw	a4,-20(s0)
 3008e06:	8fd9                	or	a5,a5,a4
 3008e08:	fef42623          	sw	a5,-20(s0)
    }
    handle->baseAddress->I2C_SCL_CFG.reg = val;
 3008e0c:	fcc42783          	lw	a5,-52(s0)
 3008e10:	439c                	lw	a5,0(a5)
 3008e12:	fec42703          	lw	a4,-20(s0)
 3008e16:	c3d8                	sw	a4,4(a5)

    /* Set sda hold duration.The value is fixed to 0xa */
    temp = ((handle->sdaHoldTime & 0x0000FFFF) << I2C_SDA_HOLD_DURATION_POS);
 3008e18:	fcc42783          	lw	a5,-52(s0)
 3008e1c:	4b9c                	lw	a5,16(a5)
 3008e1e:	07c2                	slli	a5,a5,0x10
 3008e20:	fcf42e23          	sw	a5,-36(s0)
    tempReg = (handle->handleEx.sdaDelayTime & 0x0000000F) | temp;
 3008e24:	fcc42783          	lw	a5,-52(s0)
 3008e28:	4ffc                	lw	a5,92(a5)
 3008e2a:	8bbd                	andi	a5,a5,15
 3008e2c:	fdc42703          	lw	a4,-36(s0)
 3008e30:	8fd9                	or	a5,a5,a4
 3008e32:	fcf42c23          	sw	a5,-40(s0)
    handle->baseAddress->I2C_SDA_CFG.reg = tempReg;
 3008e36:	fcc42783          	lw	a5,-52(s0)
 3008e3a:	439c                	lw	a5,0(a5)
 3008e3c:	fd842703          	lw	a4,-40(s0)
 3008e40:	c798                	sw	a4,8(a5)

    /* Set I2C TX FIFO watermark */
    handle->baseAddress->I2C_TX_WATERMARK.BIT.tx_watermark = handle->txWaterMark;
 3008e42:	fcc42783          	lw	a5,-52(s0)
 3008e46:	5bd4                	lw	a3,52(a5)
 3008e48:	fcc42783          	lw	a5,-52(s0)
 3008e4c:	4398                	lw	a4,0(a5)
 3008e4e:	87b6                	mv	a5,a3
 3008e50:	8bbd                	andi	a5,a5,15
 3008e52:	0ff7f693          	andi	a3,a5,255
 3008e56:	0c872783          	lw	a5,200(a4)
 3008e5a:	8abd                	andi	a3,a3,15
 3008e5c:	9bc1                	andi	a5,a5,-16
 3008e5e:	8fd5                	or	a5,a5,a3
 3008e60:	0cf72423          	sw	a5,200(a4)
    /* Set I2C RX FIFO watermark */
    handle->baseAddress->I2C_RX_WATERMARK.BIT.rx_watermark = handle->rxWaterMark;
 3008e64:	fcc42783          	lw	a5,-52(s0)
 3008e68:	5b94                	lw	a3,48(a5)
 3008e6a:	fcc42783          	lw	a5,-52(s0)
 3008e6e:	4398                	lw	a4,0(a5)
 3008e70:	87b6                	mv	a5,a3
 3008e72:	8bbd                	andi	a5,a5,15
 3008e74:	0ff7f693          	andi	a3,a5,255
 3008e78:	0cc72783          	lw	a5,204(a4)
 3008e7c:	8abd                	andi	a3,a3,15
 3008e7e:	9bc1                	andi	a5,a5,-16
 3008e80:	8fd5                	or	a5,a5,a3
 3008e82:	0cf72623          	sw	a5,204(a4)
    handle->baseAddress->I2C_MODE.BIT.mst_slv_function = handle->functionMode;
 3008e86:	fcc42783          	lw	a5,-52(s0)
 3008e8a:	43d4                	lw	a3,4(a5)
 3008e8c:	fcc42783          	lw	a5,-52(s0)
 3008e90:	4398                	lw	a4,0(a5)
 3008e92:	87b6                	mv	a5,a3
 3008e94:	8b8d                	andi	a5,a5,3
 3008e96:	0ff7f693          	andi	a3,a5,255
 3008e9a:	431c                	lw	a5,0(a4)
 3008e9c:	8a8d                	andi	a3,a3,3
 3008e9e:	9bf1                	andi	a5,a5,-4
 3008ea0:	8fd5                	or	a5,a5,a3
 3008ea2:	c31c                	sw	a5,0(a4)
    handle->baseAddress->I2C_MODE.BIT.rack_mode = handle->ignoreAckFlag;
 3008ea4:	fcc42783          	lw	a5,-52(s0)
 3008ea8:	4f94                	lw	a3,24(a5)
 3008eaa:	fcc42783          	lw	a5,-52(s0)
 3008eae:	4398                	lw	a4,0(a5)
 3008eb0:	87b6                	mv	a5,a3
 3008eb2:	8b85                	andi	a5,a5,1
 3008eb4:	0ff7f693          	andi	a3,a5,255
 3008eb8:	431c                	lw	a5,0(a4)
 3008eba:	8a85                	andi	a3,a3,1
 3008ebc:	0692                	slli	a3,a3,0x4
 3008ebe:	9bbd                	andi	a5,a5,-17
 3008ec0:	8fd5                	or	a5,a5,a3
 3008ec2:	c31c                	sw	a5,0(a4)

    if (handle->functionMode == I2C_MODE_SELECT_SLAVE_ONLY || handle->functionMode == I2C_MODE_SELECT_MASTER_SLAVE) {
 3008ec4:	fcc42783          	lw	a5,-52(s0)
 3008ec8:	43d8                	lw	a4,4(a5)
 3008eca:	4789                	li	a5,2
 3008ecc:	00f70863          	beq	a4,a5,3008edc <HAL_I2C_Init+0x242>
 3008ed0:	fcc42783          	lw	a5,-52(s0)
 3008ed4:	43d8                	lw	a4,4(a5)
 3008ed6:	478d                	li	a5,3
 3008ed8:	08f71963          	bne	a4,a5,3008f6a <HAL_I2C_Init+0x2d0>
        /* Sets the first own address of the slave. */
        handle->baseAddress->I2C_OWN_ADDR.BIT.own_address = handle->slaveOwnAddress;
 3008edc:	fcc42783          	lw	a5,-52(s0)
 3008ee0:	47d4                	lw	a3,12(a5)
 3008ee2:	fcc42783          	lw	a5,-52(s0)
 3008ee6:	4398                	lw	a4,0(a5)
 3008ee8:	87b6                	mv	a5,a3
 3008eea:	3ff7f793          	andi	a5,a5,1023
 3008eee:	01079693          	slli	a3,a5,0x10
 3008ef2:	82c1                	srli	a3,a3,0x10
 3008ef4:	475c                	lw	a5,12(a4)
 3008ef6:	3ff6f693          	andi	a3,a3,1023
 3008efa:	c007f793          	andi	a5,a5,-1024
 3008efe:	8fd5                	or	a5,a5,a3
 3008f00:	c75c                	sw	a5,12(a4)
        handle->baseAddress->I2C_OWN_ADDR.BIT.i2c_general_call_en = handle->generalCallMode;
 3008f02:	fcc42783          	lw	a5,-52(s0)
 3008f06:	4fd4                	lw	a3,28(a5)
 3008f08:	fcc42783          	lw	a5,-52(s0)
 3008f0c:	4398                	lw	a4,0(a5)
 3008f0e:	87b6                	mv	a5,a3
 3008f10:	8b85                	andi	a5,a5,1
 3008f12:	0ff7f693          	andi	a3,a5,255
 3008f16:	475c                	lw	a5,12(a4)
 3008f18:	8a85                	andi	a3,a3,1
 3008f1a:	06e2                	slli	a3,a3,0x18
 3008f1c:	ff000637          	lui	a2,0xff000
 3008f20:	167d                	addi	a2,a2,-1 # feffffff <RAM_END+0xfaff7fff>
 3008f22:	8ff1                	and	a5,a5,a2
 3008f24:	8fd5                	or	a5,a5,a3
 3008f26:	c75c                	sw	a5,12(a4)
        /* Sets the second own address of the slave. */
        if (handle->handleEx.slaveOwnXmbAddressEnable == BASE_CFG_ENABLE) {
 3008f28:	fcc42783          	lw	a5,-52(s0)
 3008f2c:	53b8                	lw	a4,96(a5)
 3008f2e:	4785                	li	a5,1
 3008f30:	02f71d63          	bne	a4,a5,3008f6a <HAL_I2C_Init+0x2d0>
            handle->baseAddress->XMB_DEV_ADDR.BIT.xmb_address_en = BASE_CFG_ENABLE;
 3008f34:	fcc42783          	lw	a5,-52(s0)
 3008f38:	4398                	lw	a4,0(a5)
 3008f3a:	4b1c                	lw	a5,16(a4)
 3008f3c:	004006b7          	lui	a3,0x400
 3008f40:	8fd5                	or	a5,a5,a3
 3008f42:	cb1c                	sw	a5,16(a4)
            handle->baseAddress->XMB_DEV_ADDR.BIT.xmb_address = handle->handleEx.slaveOwnXmbAddress;
 3008f44:	fcc42783          	lw	a5,-52(s0)
 3008f48:	53f4                	lw	a3,100(a5)
 3008f4a:	fcc42783          	lw	a5,-52(s0)
 3008f4e:	4398                	lw	a4,0(a5)
 3008f50:	87b6                	mv	a5,a3
 3008f52:	3ff7f793          	andi	a5,a5,1023
 3008f56:	01079693          	slli	a3,a5,0x10
 3008f5a:	82c1                	srli	a3,a3,0x10
 3008f5c:	4b1c                	lw	a5,16(a4)
 3008f5e:	3ff6f693          	andi	a3,a3,1023
 3008f62:	c007f793          	andi	a5,a5,-1024
 3008f66:	8fd5                	or	a5,a5,a3
 3008f68:	cb1c                	sw	a5,16(a4)
        }
    }
    handle->state = I2C_STATE_READY;
 3008f6a:	fcc42783          	lw	a5,-52(s0)
 3008f6e:	4705                	li	a4,1
 3008f70:	c3f8                	sw	a4,68(a5)
    return BASE_STATUS_OK;
 3008f72:	4781                	li	a5,0
}
 3008f74:	853e                	mv	a0,a5
 3008f76:	50f2                	lw	ra,60(sp)
 3008f78:	5462                	lw	s0,56(sp)
 3008f7a:	6121                	addi	sp,sp,64
 3008f7c:	8082                	ret

03008f7e <HAL_I2C_MasterWriteBlocking>:
  * @param timeout Timeout period,unit: ms.
  * @retval BASE status type: OK, ERROR, BUSY, TIMEOUT, NOT SUPPORT.
  */
BASE_StatusType HAL_I2C_MasterWriteBlocking(I2C_Handle *handle, unsigned short devAddr, unsigned char *wData,
                                            unsigned int dataSize, unsigned int timeout)
{
 3008f7e:	7139                	addi	sp,sp,-64
 3008f80:	de06                	sw	ra,60(sp)
 3008f82:	dc22                	sw	s0,56(sp)
 3008f84:	0080                	addi	s0,sp,64
 3008f86:	fca42e23          	sw	a0,-36(s0)
 3008f8a:	87ae                	mv	a5,a1
 3008f8c:	fcc42a23          	sw	a2,-44(s0)
 3008f90:	fcd42823          	sw	a3,-48(s0)
 3008f94:	fce42623          	sw	a4,-52(s0)
 3008f98:	fcf41d23          	sh	a5,-38(s0)
    I2C_ASSERT_PARAM(handle != NULL && wData != NULL);
 3008f9c:	fdc42783          	lw	a5,-36(s0)
 3008fa0:	c781                	beqz	a5,3008fa8 <HAL_I2C_MasterWriteBlocking+0x2a>
 3008fa2:	fd442783          	lw	a5,-44(s0)
 3008fa6:	eb89                	bnez	a5,3008fb8 <HAL_I2C_MasterWriteBlocking+0x3a>
 3008fa8:	5bf00593          	li	a1,1471
 3008fac:	030127b7          	lui	a5,0x3012
 3008fb0:	d1478513          	addi	a0,a5,-748 # 3011d14 <g_crgIpMatch+0x47c>
 3008fb4:	26ed                	jal	ra,300939e <AssertErrorLog.trans.6>
 3008fb6:	a001                	j	3008fb6 <HAL_I2C_MasterWriteBlocking+0x38>
    I2C_ASSERT_PARAM(IsI2CInstance(handle->baseAddress));
 3008fb8:	fdc42783          	lw	a5,-36(s0)
 3008fbc:	4398                	lw	a4,0(a5)
 3008fbe:	141007b7          	lui	a5,0x14100
 3008fc2:	02f70163          	beq	a4,a5,3008fe4 <HAL_I2C_MasterWriteBlocking+0x66>
 3008fc6:	fdc42783          	lw	a5,-36(s0)
 3008fca:	4398                	lw	a4,0(a5)
 3008fcc:	141017b7          	lui	a5,0x14101
 3008fd0:	00f70a63          	beq	a4,a5,3008fe4 <HAL_I2C_MasterWriteBlocking+0x66>
 3008fd4:	5c000593          	li	a1,1472
 3008fd8:	030127b7          	lui	a5,0x3012
 3008fdc:	d1478513          	addi	a0,a5,-748 # 3011d14 <g_crgIpMatch+0x47c>
 3008fe0:	2e7d                	jal	ra,300939e <AssertErrorLog.trans.6>
 3008fe2:	a001                	j	3008fe2 <HAL_I2C_MasterWriteBlocking+0x64>
    I2C_PARAM_CHECK_WITH_RET(devAddr <= I2C_MAX_DEV_ADDR, BASE_STATUS_ERROR);
 3008fe4:	fda45703          	lhu	a4,-38(s0)
 3008fe8:	3ff00793          	li	a5,1023
 3008fec:	00e7fb63          	bgeu	a5,a4,3009002 <HAL_I2C_MasterWriteBlocking+0x84>
 3008ff0:	5c100593          	li	a1,1473
 3008ff4:	030127b7          	lui	a5,0x3012
 3008ff8:	d1478513          	addi	a0,a5,-748 # 3011d14 <g_crgIpMatch+0x47c>
 3008ffc:	264d                	jal	ra,300939e <AssertErrorLog.trans.6>
 3008ffe:	4785                	li	a5,1
 3009000:	aaad                	j	300917a <HAL_I2C_MasterWriteBlocking+0x1fc>
    I2C_PARAM_CHECK_WITH_RET(dataSize > 0, BASE_STATUS_ERROR);
 3009002:	fd042783          	lw	a5,-48(s0)
 3009006:	eb91                	bnez	a5,300901a <HAL_I2C_MasterWriteBlocking+0x9c>
 3009008:	5c200593          	li	a1,1474
 300900c:	030127b7          	lui	a5,0x3012
 3009010:	d1478513          	addi	a0,a5,-748 # 3011d14 <g_crgIpMatch+0x47c>
 3009014:	2669                	jal	ra,300939e <AssertErrorLog.trans.6>
 3009016:	4785                	li	a5,1
 3009018:	a28d                	j	300917a <HAL_I2C_MasterWriteBlocking+0x1fc>
    I2C_PARAM_CHECK_WITH_RET(timeout > 0, BASE_STATUS_ERROR);
 300901a:	fcc42783          	lw	a5,-52(s0)
 300901e:	eb91                	bnez	a5,3009032 <HAL_I2C_MasterWriteBlocking+0xb4>
 3009020:	5c300593          	li	a1,1475
 3009024:	030127b7          	lui	a5,0x3012
 3009028:	d1478513          	addi	a0,a5,-748 # 3011d14 <g_crgIpMatch+0x47c>
 300902c:	2e8d                	jal	ra,300939e <AssertErrorLog.trans.6>
 300902e:	4785                	li	a5,1
 3009030:	a2a9                	j	300917a <HAL_I2C_MasterWriteBlocking+0x1fc>
    I2C_PARAM_CHECK_WITH_RET(handle->state == I2C_STATE_READY, BASE_STATUS_ERROR);
 3009032:	fdc42783          	lw	a5,-36(s0)
 3009036:	43f8                	lw	a4,68(a5)
 3009038:	4785                	li	a5,1
 300903a:	00f70b63          	beq	a4,a5,3009050 <HAL_I2C_MasterWriteBlocking+0xd2>
 300903e:	5c400593          	li	a1,1476
 3009042:	030127b7          	lui	a5,0x3012
 3009046:	d1478513          	addi	a0,a5,-748 # 3011d14 <g_crgIpMatch+0x47c>
 300904a:	2e91                	jal	ra,300939e <AssertErrorLog.trans.6>
 300904c:	4785                	li	a5,1
 300904e:	a235                	j	300917a <HAL_I2C_MasterWriteBlocking+0x1fc>

    BASE_StatusType ret = BASE_STATUS_OK;
 3009050:	fe042623          	sw	zero,-20(s0)
    unsigned int index;
    handle->baseAddress->I2C_INTR_EN.reg = I2C_INTR_EN_ALL_DISABLE;
 3009054:	fdc42783          	lw	a5,-36(s0)
 3009058:	439c                	lw	a5,0(a5)
 300905a:	0e07a223          	sw	zero,228(a5)
    handle->baseAddress->I2C_INTR_RAW.reg = I2C_INTR_RAW_ALL_ENABLE;
 300905e:	fdc42783          	lw	a5,-36(s0)
 3009062:	439c                	lw	a5,0(a5)
 3009064:	01000737          	lui	a4,0x1000
 3009068:	177d                	addi	a4,a4,-1 # ffffff <FLASH_SIZE+0xfe0003>
 300906a:	0ee7a023          	sw	a4,224(a5)

    /* Determine which I2C is used. */
    index = (handle->baseAddress == I2C0) ? I2C_INTERFACE_INDEX_0 : I2C_INTERFACE_INDEX_1;
 300906e:	fdc42783          	lw	a5,-36(s0)
 3009072:	4398                	lw	a4,0(a5)
 3009074:	ebf007b7          	lui	a5,0xebf00
 3009078:	97ba                	add	a5,a5,a4
 300907a:	00f037b3          	snez	a5,a5
 300907e:	9f81                	uxtb	a5
 3009080:	fef42423          	sw	a5,-24(s0)

    /* Configuring I2C Parameters. */
    handle->state = I2C_STATE_BUSY_MASTER_TX;
 3009084:	fdc42783          	lw	a5,-36(s0)
 3009088:	470d                	li	a4,3
 300908a:	c3f8                	sw	a4,68(a5)
    handle->transferBuff = wData;
 300908c:	fdc42783          	lw	a5,-36(s0)
 3009090:	fd442703          	lw	a4,-44(s0)
 3009094:	d398                	sw	a4,32(a5)
    handle->transferSize = dataSize;
 3009096:	fdc42783          	lw	a5,-36(s0)
 300909a:	fd042703          	lw	a4,-48(s0)
 300909e:	d3d8                	sw	a4,36(a5)
    handle->transferCount = 0;
 30090a0:	fdc42783          	lw	a5,-36(s0)
 30090a4:	0207a423          	sw	zero,40(a5) # ebf00028 <RAM_END+0xe7ef8028>
    handle->timeout = timeout;
 30090a8:	fdc42783          	lw	a5,-36(s0)
 30090ac:	fcc42703          	lw	a4,-52(s0)
 30090b0:	d7d8                	sw	a4,44(a5)
    SetSlaveDevAddr(handle, devAddr);
 30090b2:	fda45783          	lhu	a5,-38(s0)
 30090b6:	85be                	mv	a1,a5
 30090b8:	fdc42503          	lw	a0,-36(s0)
 30090bc:	c7aff0ef          	jal	ra,3008536 <SetSlaveDevAddr>

    /* Waiting for the i2c bus to be idle. */
    ret = WaitStatusReady(handle, I2C_BUS_IS_FREE, I2C_SEND_ADDR_STATUS_READ);
 30090c0:	4609                	li	a2,2
 30090c2:	4585                	li	a1,1
 30090c4:	fdc42503          	lw	a0,-36(s0)
 30090c8:	fb6ff0ef          	jal	ra,300887e <WaitStatusReady>
 30090cc:	fea42623          	sw	a0,-20(s0)
    if (ret != BASE_STATUS_OK) {
 30090d0:	fec42783          	lw	a5,-20(s0)
 30090d4:	cf89                	beqz	a5,30090ee <HAL_I2C_MasterWriteBlocking+0x170>
        handle->errorCode = ret;
 30090d6:	fdc42783          	lw	a5,-36(s0)
 30090da:	fec42703          	lw	a4,-20(s0)
 30090de:	c7b8                	sw	a4,72(a5)
        SetErrorHandling(handle);
 30090e0:	fdc42503          	lw	a0,-36(s0)
 30090e4:	e24ff0ef          	jal	ra,3008708 <SetErrorHandling>
        return ret;
 30090e8:	fec42783          	lw	a5,-20(s0)
 30090ec:	a079                	j	300917a <HAL_I2C_MasterWriteBlocking+0x1fc>
    }

    /* step1 : Parameter Settings and startup Control. */
    ret = I2C_ConfigParametersAndStartBlocking(handle, I2C_MASTER_STATUS);
 30090ee:	4581                	li	a1,0
 30090f0:	fdc42503          	lw	a0,-36(s0)
 30090f4:	3c25                	jal	ra,3008b2c <I2C_ConfigParametersAndStartBlocking>
 30090f6:	fea42623          	sw	a0,-20(s0)
    if (ret != BASE_STATUS_OK) {
 30090fa:	fec42783          	lw	a5,-20(s0)
 30090fe:	cf89                	beqz	a5,3009118 <HAL_I2C_MasterWriteBlocking+0x19a>
        handle->errorCode = ret;
 3009100:	fdc42783          	lw	a5,-36(s0)
 3009104:	fec42703          	lw	a4,-20(s0)
 3009108:	c7b8                	sw	a4,72(a5)
        SetErrorHandling(handle);
 300910a:	fdc42503          	lw	a0,-36(s0)
 300910e:	dfaff0ef          	jal	ra,3008708 <SetErrorHandling>
        return ret;
 3009112:	fec42783          	lw	a5,-20(s0)
 3009116:	a095                	j	300917a <HAL_I2C_MasterWriteBlocking+0x1fc>
    }
    /* step2 : send slave addr */
    ret = SendSlaveAddressWriteCmd(handle, index);
 3009118:	fe842583          	lw	a1,-24(s0)
 300911c:	fdc42503          	lw	a0,-36(s0)
 3009120:	3221                	jal	ra,3008a28 <SendSlaveAddressWriteCmd>
 3009122:	fea42623          	sw	a0,-20(s0)
    if (ret != BASE_STATUS_OK) {
 3009126:	fec42783          	lw	a5,-20(s0)
 300912a:	cf89                	beqz	a5,3009144 <HAL_I2C_MasterWriteBlocking+0x1c6>
        handle->errorCode = ret;
 300912c:	fdc42783          	lw	a5,-36(s0)
 3009130:	fec42703          	lw	a4,-20(s0)
 3009134:	c7b8                	sw	a4,72(a5)
        SetErrorHandling(handle);
 3009136:	fdc42503          	lw	a0,-36(s0)
 300913a:	dceff0ef          	jal	ra,3008708 <SetErrorHandling>
        return ret;
 300913e:	fec42783          	lw	a5,-20(s0)
 3009142:	a825                	j	300917a <HAL_I2C_MasterWriteBlocking+0x1fc>
    }
    /* step3 : Send to slave data */
    ret = BlockingMasterTxDataOptStepNormal(handle);
 3009144:	fdc42503          	lw	a0,-36(s0)
 3009148:	3cf9                	jal	ra,3008c26 <BlockingMasterTxDataOptStepNormal>
 300914a:	fea42623          	sw	a0,-20(s0)
    if (ret != BASE_STATUS_OK) {
 300914e:	fec42783          	lw	a5,-20(s0)
 3009152:	cf89                	beqz	a5,300916c <HAL_I2C_MasterWriteBlocking+0x1ee>
        handle->errorCode = ret;
 3009154:	fdc42783          	lw	a5,-36(s0)
 3009158:	fec42703          	lw	a4,-20(s0)
 300915c:	c7b8                	sw	a4,72(a5)
        SetErrorHandling(handle);
 300915e:	fdc42503          	lw	a0,-36(s0)
 3009162:	da6ff0ef          	jal	ra,3008708 <SetErrorHandling>
        return ret;
 3009166:	fec42783          	lw	a5,-20(s0)
 300916a:	a801                	j	300917a <HAL_I2C_MasterWriteBlocking+0x1fc>
    }
    /* step4 : send stop CMD */
    ret = BlockingSendStopCommand(handle);
 300916c:	fdc42503          	lw	a0,-36(s0)
 3009170:	3cb9                	jal	ra,3008bce <BlockingSendStopCommand>
 3009172:	fea42623          	sw	a0,-20(s0)

    return ret;
 3009176:	fec42783          	lw	a5,-20(s0)
}
 300917a:	853e                	mv	a0,a5
 300917c:	50f2                	lw	ra,60(sp)
 300917e:	5462                	lw	s0,56(sp)
 3009180:	6121                	addi	sp,sp,64
 3009182:	8082                	ret

03009184 <DCL_IOCMG_SetRegValue>:
  * @param iocmgRegx Value of @ref IOCMG_REG.
  * @param regValue value of @ref IOCMG_REG.
  * @retval None.
  */
static inline void DCL_IOCMG_SetRegValue(IOCMG_REG *iocmgRegx, unsigned int regValue)
{
 3009184:	1101                	addi	sp,sp,-32
 3009186:	ce06                	sw	ra,28(sp)
 3009188:	cc22                	sw	s0,24(sp)
 300918a:	1000                	addi	s0,sp,32
 300918c:	fea42623          	sw	a0,-20(s0)
 3009190:	feb42423          	sw	a1,-24(s0)
    IOCMG_ASSERT_PARAM(IsIOCMGInstance((void *)((uintptr_t)(void *)iocmgRegx & IOCMG_BASE_ADDR_MASK)));
 3009194:	fec42703          	lw	a4,-20(s0)
 3009198:	77c1                	lui	a5,0xffff0
 300919a:	8f7d                	and	a4,a4,a5
 300919c:	147f07b7          	lui	a5,0x147f0
 30091a0:	00f70a63          	beq	a4,a5,30091b4 <DCL_IOCMG_SetRegValue+0x30>
 30091a4:	08500593          	li	a1,133
 30091a8:	030127b7          	lui	a5,0x3012
 30091ac:	d4478513          	addi	a0,a5,-700 # 3011d44 <g_crgIpMatch+0x4ac>
 30091b0:	22fd                	jal	ra,300939e <AssertErrorLog.trans.6>
 30091b2:	a001                	j	30091b2 <DCL_IOCMG_SetRegValue+0x2e>
    iocmgRegx->reg = regValue;
 30091b4:	fec42783          	lw	a5,-20(s0)
 30091b8:	fe842703          	lw	a4,-24(s0)
 30091bc:	c398                	sw	a4,0(a5)
}
 30091be:	0001                	nop
 30091c0:	40f2                	lw	ra,28(sp)
 30091c2:	4462                	lw	s0,24(sp)
 30091c4:	6105                	addi	sp,sp,32
 30091c6:	8082                	ret

030091c8 <DCL_IOCMG_SetDriveRate>:
  * @param iocmgRegx Value of @ref IOCMG_REG.
  * @param driveRate value of @ref IOCMG_DriveRate.
  * @retval None.
  */
static inline void DCL_IOCMG_SetDriveRate(IOCMG_REG *iocmgRegx, IOCMG_DriveRate driveRate)
{
 30091c8:	1101                	addi	sp,sp,-32
 30091ca:	ce06                	sw	ra,28(sp)
 30091cc:	cc22                	sw	s0,24(sp)
 30091ce:	1000                	addi	s0,sp,32
 30091d0:	fea42623          	sw	a0,-20(s0)
 30091d4:	feb42423          	sw	a1,-24(s0)
    IOCMG_ASSERT_PARAM(IsIOCMGInstance((void *)((uintptr_t)(void *)iocmgRegx & IOCMG_BASE_ADDR_MASK)));
 30091d8:	fec42703          	lw	a4,-20(s0)
 30091dc:	77c1                	lui	a5,0xffff0
 30091de:	8f7d                	and	a4,a4,a5
 30091e0:	147f07b7          	lui	a5,0x147f0
 30091e4:	00f70a63          	beq	a4,a5,30091f8 <DCL_IOCMG_SetDriveRate+0x30>
 30091e8:	0b400593          	li	a1,180
 30091ec:	030127b7          	lui	a5,0x3012
 30091f0:	d4478513          	addi	a0,a5,-700 # 3011d44 <g_crgIpMatch+0x4ac>
 30091f4:	226d                	jal	ra,300939e <AssertErrorLog.trans.6>
 30091f6:	a001                	j	30091f6 <DCL_IOCMG_SetDriveRate+0x2e>
    IOCMG_PARAM_CHECK_NO_RET(driveRate < DRIVER_RATE_MAX && driveRate >= DRIVER_RATE_4);
 30091f8:	fe842703          	lw	a4,-24(s0)
 30091fc:	478d                	li	a5,3
 30091fe:	00e7fa63          	bgeu	a5,a4,3009212 <DCL_IOCMG_SetDriveRate+0x4a>
 3009202:	0b500593          	li	a1,181
 3009206:	030127b7          	lui	a5,0x3012
 300920a:	d4478513          	addi	a0,a5,-700 # 3011d44 <g_crgIpMatch+0x4ac>
 300920e:	2a41                	jal	ra,300939e <AssertErrorLog.trans.6>
 3009210:	a839                	j	300922e <DCL_IOCMG_SetDriveRate+0x66>
    iocmgRegx->BIT.ds = driveRate;
 3009212:	fe842783          	lw	a5,-24(s0)
 3009216:	8b8d                	andi	a5,a5,3
 3009218:	0ff7f693          	andi	a3,a5,255
 300921c:	fec42703          	lw	a4,-20(s0)
 3009220:	431c                	lw	a5,0(a4)
 3009222:	8a8d                	andi	a3,a3,3
 3009224:	0692                	slli	a3,a3,0x4
 3009226:	fcf7f793          	andi	a5,a5,-49
 300922a:	8fd5                	or	a5,a5,a3
 300922c:	c31c                	sw	a5,0(a4)
}
 300922e:	40f2                	lw	ra,28(sp)
 3009230:	4462                	lw	s0,24(sp)
 3009232:	6105                	addi	sp,sp,32
 3009234:	8082                	ret

03009236 <DCL_IOCMG_SetPullMode>:
  * @param iocmgRegx Value of @ref IOCMG_REG.
  * @param pullMode value of @ref IOCMG_PullMode.
  * @retval None.
  */
static inline void DCL_IOCMG_SetPullMode(IOCMG_REG *iocmgRegx, IOCMG_PullMode pullMode)
{
 3009236:	1101                	addi	sp,sp,-32
 3009238:	ce06                	sw	ra,28(sp)
 300923a:	cc22                	sw	s0,24(sp)
 300923c:	1000                	addi	s0,sp,32
 300923e:	fea42623          	sw	a0,-20(s0)
 3009242:	feb42423          	sw	a1,-24(s0)
    IOCMG_ASSERT_PARAM(IsIOCMGInstance((void *)((uintptr_t)(void *)iocmgRegx & IOCMG_BASE_ADDR_MASK)));
 3009246:	fec42703          	lw	a4,-20(s0)
 300924a:	77c1                	lui	a5,0xffff0
 300924c:	8f7d                	and	a4,a4,a5
 300924e:	147f07b7          	lui	a5,0x147f0
 3009252:	00f70a63          	beq	a4,a5,3009266 <DCL_IOCMG_SetPullMode+0x30>
 3009256:	0cc00593          	li	a1,204
 300925a:	030127b7          	lui	a5,0x3012
 300925e:	d4478513          	addi	a0,a5,-700 # 3011d44 <g_crgIpMatch+0x4ac>
 3009262:	2a35                	jal	ra,300939e <AssertErrorLog.trans.6>
 3009264:	a001                	j	3009264 <DCL_IOCMG_SetPullMode+0x2e>
    IOCMG_PARAM_CHECK_NO_RET(pullMode < PULL_MODE_MAX && pullMode >= PULL_NONE);
 3009266:	fe842703          	lw	a4,-24(s0)
 300926a:	478d                	li	a5,3
 300926c:	00e7fa63          	bgeu	a5,a4,3009280 <DCL_IOCMG_SetPullMode+0x4a>
 3009270:	0cd00593          	li	a1,205
 3009274:	030127b7          	lui	a5,0x3012
 3009278:	d4478513          	addi	a0,a5,-700 # 3011d44 <g_crgIpMatch+0x4ac>
 300927c:	220d                	jal	ra,300939e <AssertErrorLog.trans.6>
 300927e:	a835                	j	30092ba <DCL_IOCMG_SetPullMode+0x84>
    iocmgRegx->BIT.pu = (pullMode & 0x02) >> 1; /* 10b: pull up mode */
 3009280:	fe842783          	lw	a5,-24(s0)
 3009284:	8385                	srli	a5,a5,0x1
 3009286:	8b85                	andi	a5,a5,1
 3009288:	0ff7f693          	andi	a3,a5,255
 300928c:	fec42703          	lw	a4,-20(s0)
 3009290:	431c                	lw	a5,0(a4)
 3009292:	8a85                	andi	a3,a3,1
 3009294:	06a2                	slli	a3,a3,0x8
 3009296:	eff7f793          	andi	a5,a5,-257
 300929a:	8fd5                	or	a5,a5,a3
 300929c:	c31c                	sw	a5,0(a4)
    iocmgRegx->BIT.pd = pullMode & 0x01; /* 01b: pull down mode */
 300929e:	fe842783          	lw	a5,-24(s0)
 30092a2:	8b85                	andi	a5,a5,1
 30092a4:	0ff7f693          	andi	a3,a5,255
 30092a8:	fec42703          	lw	a4,-20(s0)
 30092ac:	431c                	lw	a5,0(a4)
 30092ae:	8a85                	andi	a3,a3,1
 30092b0:	069e                	slli	a3,a3,0x7
 30092b2:	f7f7f793          	andi	a5,a5,-129
 30092b6:	8fd5                	or	a5,a5,a3
 30092b8:	c31c                	sw	a5,0(a4)
}
 30092ba:	40f2                	lw	ra,28(sp)
 30092bc:	4462                	lw	s0,24(sp)
 30092be:	6105                	addi	sp,sp,32
 30092c0:	8082                	ret

030092c2 <DCL_IOCMG_SetLevelShiftRate>:
  * @param iocmgRegx Value of @ref IOCMG_REG.
  * @param levelShiftRate value of @ref IOCMG_LevelShiftRate.
  * @retval None.
  */
static inline void DCL_IOCMG_SetLevelShiftRate(IOCMG_REG *iocmgRegx, IOCMG_LevelShiftRate levelShiftRate)
{
 30092c2:	1101                	addi	sp,sp,-32
 30092c4:	ce06                	sw	ra,28(sp)
 30092c6:	cc22                	sw	s0,24(sp)
 30092c8:	1000                	addi	s0,sp,32
 30092ca:	fea42623          	sw	a0,-20(s0)
 30092ce:	feb42423          	sw	a1,-24(s0)
    IOCMG_ASSERT_PARAM(IsIOCMGInstance((void *)((uintptr_t)(void *)iocmgRegx & IOCMG_BASE_ADDR_MASK)));
 30092d2:	fec42703          	lw	a4,-20(s0)
 30092d6:	77c1                	lui	a5,0xffff0
 30092d8:	8f7d                	and	a4,a4,a5
 30092da:	147f07b7          	lui	a5,0x147f0
 30092de:	00f70a63          	beq	a4,a5,30092f2 <DCL_IOCMG_SetLevelShiftRate+0x30>
 30092e2:	0e700593          	li	a1,231
 30092e6:	030127b7          	lui	a5,0x3012
 30092ea:	d4478513          	addi	a0,a5,-700 # 3011d44 <g_crgIpMatch+0x4ac>
 30092ee:	2845                	jal	ra,300939e <AssertErrorLog.trans.6>
 30092f0:	a001                	j	30092f0 <DCL_IOCMG_SetLevelShiftRate+0x2e>
    IOCMG_PARAM_CHECK_NO_RET(levelShiftRate < LEVEL_SHIFT_RATE_MAX && levelShiftRate >= LEVEL_SHIFT_RATE_FAST);
 30092f2:	fe842703          	lw	a4,-24(s0)
 30092f6:	4785                	li	a5,1
 30092f8:	00e7fa63          	bgeu	a5,a4,300930c <DCL_IOCMG_SetLevelShiftRate+0x4a>
 30092fc:	0e800593          	li	a1,232
 3009300:	030127b7          	lui	a5,0x3012
 3009304:	d4478513          	addi	a0,a5,-700 # 3011d44 <g_crgIpMatch+0x4ac>
 3009308:	2859                	jal	ra,300939e <AssertErrorLog.trans.6>
 300930a:	a839                	j	3009328 <DCL_IOCMG_SetLevelShiftRate+0x66>
    iocmgRegx->BIT.sr = levelShiftRate;
 300930c:	fe842783          	lw	a5,-24(s0)
 3009310:	8b85                	andi	a5,a5,1
 3009312:	0ff7f693          	andi	a3,a5,255
 3009316:	fec42703          	lw	a4,-20(s0)
 300931a:	431c                	lw	a5,0(a4)
 300931c:	8a85                	andi	a3,a3,1
 300931e:	06a6                	slli	a3,a3,0x9
 3009320:	dff7f793          	andi	a5,a5,-513
 3009324:	8fd5                	or	a5,a5,a3
 3009326:	c31c                	sw	a5,0(a4)
}
 3009328:	40f2                	lw	ra,28(sp)
 300932a:	4462                	lw	s0,24(sp)
 300932c:	6105                	addi	sp,sp,32
 300932e:	8082                	ret

03009330 <DCL_IOCMG_SetSchmidtMode>:
  * @param iocmgRegx Value of @ref IOCMG_REG.
  * @param schmidtMode value of @ref IOCMG_SchmidtMode.
  * @retval None.
  */
static inline void DCL_IOCMG_SetSchmidtMode(IOCMG_REG *iocmgRegx, IOCMG_SchmidtMode schmidtMode)
{
 3009330:	1101                	addi	sp,sp,-32
 3009332:	ce06                	sw	ra,28(sp)
 3009334:	cc22                	sw	s0,24(sp)
 3009336:	1000                	addi	s0,sp,32
 3009338:	fea42623          	sw	a0,-20(s0)
 300933c:	feb42423          	sw	a1,-24(s0)
    IOCMG_ASSERT_PARAM(IsIOCMGInstance((void *)((uintptr_t)(void *)iocmgRegx & IOCMG_BASE_ADDR_MASK)));
 3009340:	fec42703          	lw	a4,-20(s0)
 3009344:	77c1                	lui	a5,0xffff0
 3009346:	8f7d                	and	a4,a4,a5
 3009348:	147f07b7          	lui	a5,0x147f0
 300934c:	00f70a63          	beq	a4,a5,3009360 <DCL_IOCMG_SetSchmidtMode+0x30>
 3009350:	0ff00593          	li	a1,255
 3009354:	030127b7          	lui	a5,0x3012
 3009358:	d4478513          	addi	a0,a5,-700 # 3011d44 <g_crgIpMatch+0x4ac>
 300935c:	2089                	jal	ra,300939e <AssertErrorLog.trans.6>
 300935e:	a001                	j	300935e <DCL_IOCMG_SetSchmidtMode+0x2e>
    IOCMG_PARAM_CHECK_NO_RET(schmidtMode <= SCHMIDT_ENABLE && schmidtMode >= SCHMIDT_DISABLE);
 3009360:	fe842703          	lw	a4,-24(s0)
 3009364:	4785                	li	a5,1
 3009366:	00e7fa63          	bgeu	a5,a4,300937a <DCL_IOCMG_SetSchmidtMode+0x4a>
 300936a:	10000593          	li	a1,256
 300936e:	030127b7          	lui	a5,0x3012
 3009372:	d4478513          	addi	a0,a5,-700 # 3011d44 <g_crgIpMatch+0x4ac>
 3009376:	2025                	jal	ra,300939e <AssertErrorLog.trans.6>
 3009378:	a839                	j	3009396 <DCL_IOCMG_SetSchmidtMode+0x66>
    iocmgRegx->BIT.se = schmidtMode;
 300937a:	fe842783          	lw	a5,-24(s0)
 300937e:	8b85                	andi	a5,a5,1
 3009380:	0ff7f693          	andi	a3,a5,255
 3009384:	fec42703          	lw	a4,-20(s0)
 3009388:	431c                	lw	a5,0(a4)
 300938a:	8a85                	andi	a3,a3,1
 300938c:	06aa                	slli	a3,a3,0xa
 300938e:	bff7f793          	andi	a5,a5,-1025
 3009392:	8fd5                	or	a5,a5,a3
 3009394:	c31c                	sw	a5,0(a4)
}
 3009396:	40f2                	lw	ra,28(sp)
 3009398:	4462                	lw	s0,24(sp)
 300939a:	6105                	addi	sp,sp,32
 300939c:	8082                	ret

0300939e <AssertErrorLog.trans.6>:
 300939e:	9b5f906f          	j	3002d52 <AssertErrorLog>

030093a2 <IOCMG_GetRegAddr>:
  * @brief Get pins iocmg reg address
  * @param pinTypedef the pin type defined in iomap.h
  * @retval IOCMG_REG iocmg reg address.
  */
static IOCMG_REG* IOCMG_GetRegAddr(unsigned int pinTypedef)
{
 30093a2:	7179                	addi	sp,sp,-48
 30093a4:	d622                	sw	s0,44(sp)
 30093a6:	1800                	addi	s0,sp,48
 30093a8:	fca42e23          	sw	a0,-36(s0)
    /* decode pin's iocmg reg offset address in base address, and conver value to point address */
    unsigned int iocmgBaseAddrValue = (uintptr_t)IOCMG_BASE;
 30093ac:	147f07b7          	lui	a5,0x147f0
 30093b0:	fef42623          	sw	a5,-20(s0)
    unsigned int iocmgRegOffsetAddrValue = (pinTypedef >> 16) & 0x00000FFF; /* 16 : shift 16 bit */
 30093b4:	fdc42783          	lw	a5,-36(s0)
 30093b8:	0107d713          	srli	a4,a5,0x10
 30093bc:	6785                	lui	a5,0x1
 30093be:	17fd                	addi	a5,a5,-1 # fff <prithd+0x401>
 30093c0:	8ff9                	and	a5,a5,a4
 30093c2:	fef42423          	sw	a5,-24(s0)
    IOCMG_REG* iocmgRegxAddr = (IOCMG_REG*)(void*)(iocmgBaseAddrValue + iocmgRegOffsetAddrValue);
 30093c6:	fec42703          	lw	a4,-20(s0)
 30093ca:	fe842783          	lw	a5,-24(s0)
 30093ce:	97ba                	add	a5,a5,a4
 30093d0:	fef42223          	sw	a5,-28(s0)
    if (!IsIOCMGInstance((void *)((uintptr_t)(void *)iocmgRegxAddr & IOCMG_BASE_ADDR_MASK))) {
 30093d4:	fe442703          	lw	a4,-28(s0)
 30093d8:	77c1                	lui	a5,0xffff0
 30093da:	8f7d                	and	a4,a4,a5
 30093dc:	147f07b7          	lui	a5,0x147f0
 30093e0:	00f70463          	beq	a4,a5,30093e8 <IOCMG_GetRegAddr+0x46>
        return NULL;
 30093e4:	4781                	li	a5,0
 30093e6:	a019                	j	30093ec <IOCMG_GetRegAddr+0x4a>
    }
    return iocmgRegxAddr;
 30093e8:	fe442783          	lw	a5,-28(s0)
}
 30093ec:	853e                	mv	a0,a5
 30093ee:	5432                	lw	s0,44(sp)
 30093f0:	6145                	addi	sp,sp,48
 30093f2:	8082                	ret

030093f4 <HAL_IOCMG_SetPinAltFuncMode>:
  * @brief Set pins as function mode
  * @param pinTypedef the pin type defined in iomap.h
  * @retval IOCMG_Status @ref IOCMG_Status.
  */
IOCMG_Status HAL_IOCMG_SetPinAltFuncMode(unsigned int pinTypedef)
{
 30093f4:	7179                	addi	sp,sp,-48
 30093f6:	d606                	sw	ra,44(sp)
 30093f8:	d422                	sw	s0,40(sp)
 30093fa:	1800                	addi	s0,sp,48
 30093fc:	fca42e23          	sw	a0,-36(s0)
    /* get iocmg reg address */
    IOCMG_REG* iocmgRegx = IOCMG_GetRegAddr(pinTypedef);
 3009400:	fdc42503          	lw	a0,-36(s0)
 3009404:	3f79                	jal	ra,30093a2 <IOCMG_GetRegAddr>
 3009406:	fea42623          	sw	a0,-20(s0)
    /* get iocmg reg default value */
    unsigned int regValue = pinTypedef & IOCMG_REG_VALUE_MASK;
 300940a:	fdc42703          	lw	a4,-36(s0)
 300940e:	67c1                	lui	a5,0x10
 3009410:	17fd                	addi	a5,a5,-1 # ffff <RAM_SIZE+0xafff>
 3009412:	8ff9                	and	a5,a5,a4
 3009414:	fef42423          	sw	a5,-24(s0)
    DCL_IOCMG_SetRegValue(iocmgRegx, regValue);
 3009418:	fe842583          	lw	a1,-24(s0)
 300941c:	fec42503          	lw	a0,-20(s0)
 3009420:	3395                	jal	ra,3009184 <DCL_IOCMG_SetRegValue>
    return IOCMG_STATUS_OK;
 3009422:	4781                	li	a5,0
}
 3009424:	853e                	mv	a0,a5
 3009426:	50b2                	lw	ra,44(sp)
 3009428:	5422                	lw	s0,40(sp)
 300942a:	6145                	addi	sp,sp,48
 300942c:	8082                	ret

0300942e <HAL_IOCMG_SetPinPullMode>:
  * @param pinTypedef the pin type defined in iomap.h
  * @param pullMode function define as @ref IOCMG_PullMode
  * @retval IOCMG_Status @ref IOCMG_Status.
  */
IOCMG_Status HAL_IOCMG_SetPinPullMode(unsigned int pinTypedef, IOCMG_PullMode pullMode)
{
 300942e:	7179                	addi	sp,sp,-48
 3009430:	d606                	sw	ra,44(sp)
 3009432:	d422                	sw	s0,40(sp)
 3009434:	1800                	addi	s0,sp,48
 3009436:	fca42e23          	sw	a0,-36(s0)
 300943a:	fcb42c23          	sw	a1,-40(s0)
    IOCMG_PARAM_CHECK_WITH_RET(pullMode < PULL_MODE_MAX && pullMode >= PULL_NONE, IOCMG_PARAM_ERROR);
 300943e:	fd842703          	lw	a4,-40(s0)
 3009442:	478d                	li	a5,3
 3009444:	00e7fb63          	bgeu	a5,a4,300945a <HAL_IOCMG_SetPinPullMode+0x2c>
 3009448:	07800593          	li	a1,120
 300944c:	030127b7          	lui	a5,0x3012
 3009450:	d6478513          	addi	a0,a5,-668 # 3011d64 <g_crgIpMatch+0x4cc>
 3009454:	37a9                	jal	ra,300939e <AssertErrorLog.trans.6>
 3009456:	4791                	li	a5,4
 3009458:	a821                	j	3009470 <HAL_IOCMG_SetPinPullMode+0x42>
    /* get iocmg reg address */
    IOCMG_REG* iocmgRegx = IOCMG_GetRegAddr(pinTypedef);
 300945a:	fdc42503          	lw	a0,-36(s0)
 300945e:	3791                	jal	ra,30093a2 <IOCMG_GetRegAddr>
 3009460:	fea42623          	sw	a0,-20(s0)
    DCL_IOCMG_SetPullMode(iocmgRegx, pullMode);
 3009464:	fd842583          	lw	a1,-40(s0)
 3009468:	fec42503          	lw	a0,-20(s0)
 300946c:	33e9                	jal	ra,3009236 <DCL_IOCMG_SetPullMode>
    return IOCMG_STATUS_OK;
 300946e:	4781                	li	a5,0
}
 3009470:	853e                	mv	a0,a5
 3009472:	50b2                	lw	ra,44(sp)
 3009474:	5422                	lw	s0,40(sp)
 3009476:	6145                	addi	sp,sp,48
 3009478:	8082                	ret

0300947a <HAL_IOCMG_SetPinSchmidtMode>:
  * @param pinTypedef the pin type defined in iomap.h
  * @param schmidtMode function define as @ref IOCMG_SchmidtMode
  * @retval IOCMG_Status @ref IOCMG_Status.
  */
IOCMG_Status HAL_IOCMG_SetPinSchmidtMode(unsigned int pinTypedef, IOCMG_SchmidtMode schmidtMode)
{
 300947a:	7179                	addi	sp,sp,-48
 300947c:	d606                	sw	ra,44(sp)
 300947e:	d422                	sw	s0,40(sp)
 3009480:	1800                	addi	s0,sp,48
 3009482:	fca42e23          	sw	a0,-36(s0)
 3009486:	fcb42c23          	sw	a1,-40(s0)
    IOCMG_PARAM_CHECK_WITH_RET(schmidtMode <= SCHMIDT_ENABLE && schmidtMode >= SCHMIDT_DISABLE, IOCMG_PARAM_ERROR);
 300948a:	fd842703          	lw	a4,-40(s0)
 300948e:	4785                	li	a5,1
 3009490:	00e7fb63          	bgeu	a5,a4,30094a6 <HAL_IOCMG_SetPinSchmidtMode+0x2c>
 3009494:	09300593          	li	a1,147
 3009498:	030127b7          	lui	a5,0x3012
 300949c:	d6478513          	addi	a0,a5,-668 # 3011d64 <g_crgIpMatch+0x4cc>
 30094a0:	3dfd                	jal	ra,300939e <AssertErrorLog.trans.6>
 30094a2:	4791                	li	a5,4
 30094a4:	a821                	j	30094bc <HAL_IOCMG_SetPinSchmidtMode+0x42>
    /* get iocmg reg address */
    IOCMG_REG* iocmgRegx = IOCMG_GetRegAddr(pinTypedef);
 30094a6:	fdc42503          	lw	a0,-36(s0)
 30094aa:	3de5                	jal	ra,30093a2 <IOCMG_GetRegAddr>
 30094ac:	fea42623          	sw	a0,-20(s0)
    DCL_IOCMG_SetSchmidtMode(iocmgRegx, schmidtMode);
 30094b0:	fd842583          	lw	a1,-40(s0)
 30094b4:	fec42503          	lw	a0,-20(s0)
 30094b8:	3da5                	jal	ra,3009330 <DCL_IOCMG_SetSchmidtMode>
    return IOCMG_STATUS_OK;
 30094ba:	4781                	li	a5,0
}
 30094bc:	853e                	mv	a0,a5
 30094be:	50b2                	lw	ra,44(sp)
 30094c0:	5422                	lw	s0,40(sp)
 30094c2:	6145                	addi	sp,sp,48
 30094c4:	8082                	ret

030094c6 <HAL_IOCMG_SetPinLevelShiftRate>:
  * @param pinTypedef the pin type defined in iomap.h
  * @param schmidtMode function define as @ref IOCMG_SchmidtMode
  * @retval IOCMG_Status @ref IOCMG_Status.
  */
IOCMG_Status HAL_IOCMG_SetPinLevelShiftRate(unsigned int pinTypedef, IOCMG_LevelShiftRate levelShiftRate)
{
 30094c6:	7179                	addi	sp,sp,-48
 30094c8:	d606                	sw	ra,44(sp)
 30094ca:	d422                	sw	s0,40(sp)
 30094cc:	1800                	addi	s0,sp,48
 30094ce:	fca42e23          	sw	a0,-36(s0)
 30094d2:	fcb42c23          	sw	a1,-40(s0)
    IOCMG_PARAM_CHECK_WITH_RET(levelShiftRate < LEVEL_SHIFT_RATE_MAX, IOCMG_PARAM_ERROR);
 30094d6:	fd842703          	lw	a4,-40(s0)
 30094da:	4785                	li	a5,1
 30094dc:	00e7fb63          	bgeu	a5,a4,30094f2 <HAL_IOCMG_SetPinLevelShiftRate+0x2c>
 30094e0:	0ae00593          	li	a1,174
 30094e4:	030127b7          	lui	a5,0x3012
 30094e8:	d6478513          	addi	a0,a5,-668 # 3011d64 <g_crgIpMatch+0x4cc>
 30094ec:	3d4d                	jal	ra,300939e <AssertErrorLog.trans.6>
 30094ee:	4791                	li	a5,4
 30094f0:	a821                	j	3009508 <HAL_IOCMG_SetPinLevelShiftRate+0x42>
    IOCMG_PARAM_CHECK_WITH_RET(levelShiftRate >= LEVEL_SHIFT_RATE_FAST, IOCMG_PARAM_ERROR);
    /* get iocmg reg address */
    IOCMG_REG* iocmgRegx = IOCMG_GetRegAddr(pinTypedef);
 30094f2:	fdc42503          	lw	a0,-36(s0)
 30094f6:	3575                	jal	ra,30093a2 <IOCMG_GetRegAddr>
 30094f8:	fea42623          	sw	a0,-20(s0)
    DCL_IOCMG_SetLevelShiftRate(iocmgRegx, levelShiftRate);
 30094fc:	fd842583          	lw	a1,-40(s0)
 3009500:	fec42503          	lw	a0,-20(s0)
 3009504:	3b7d                	jal	ra,30092c2 <DCL_IOCMG_SetLevelShiftRate>
    return IOCMG_STATUS_OK;
 3009506:	4781                	li	a5,0
}
 3009508:	853e                	mv	a0,a5
 300950a:	50b2                	lw	ra,44(sp)
 300950c:	5422                	lw	s0,40(sp)
 300950e:	6145                	addi	sp,sp,48
 3009510:	8082                	ret

03009512 <HAL_IOCMG_SetPinDriveRate>:
  * @param pinTypedef the pin type defined in iomap.h
  * @param driveRate function define as @ref IOCMG_DriveRate
  * @retval IOCMG_Status @ref IOCMG_Status.
  */
IOCMG_Status HAL_IOCMG_SetPinDriveRate(unsigned int pinTypedef, IOCMG_DriveRate driveRate)
{
 3009512:	7179                	addi	sp,sp,-48
 3009514:	d606                	sw	ra,44(sp)
 3009516:	d422                	sw	s0,40(sp)
 3009518:	1800                	addi	s0,sp,48
 300951a:	fca42e23          	sw	a0,-36(s0)
 300951e:	fcb42c23          	sw	a1,-40(s0)
    /* get iocmg reg address */
    IOCMG_PARAM_CHECK_WITH_RET(driveRate < DRIVER_RATE_MAX && driveRate >= DRIVER_RATE_4, IOCMG_PARAM_ERROR);
 3009522:	fd842703          	lw	a4,-40(s0)
 3009526:	478d                	li	a5,3
 3009528:	00e7fb63          	bgeu	a5,a4,300953e <HAL_IOCMG_SetPinDriveRate+0x2c>
 300952c:	0cb00593          	li	a1,203
 3009530:	030127b7          	lui	a5,0x3012
 3009534:	d6478513          	addi	a0,a5,-668 # 3011d64 <g_crgIpMatch+0x4cc>
 3009538:	359d                	jal	ra,300939e <AssertErrorLog.trans.6>
 300953a:	4791                	li	a5,4
 300953c:	a821                	j	3009554 <HAL_IOCMG_SetPinDriveRate+0x42>
    IOCMG_REG* iocmgRegx = IOCMG_GetRegAddr(pinTypedef);
 300953e:	fdc42503          	lw	a0,-36(s0)
 3009542:	3585                	jal	ra,30093a2 <IOCMG_GetRegAddr>
 3009544:	fea42623          	sw	a0,-20(s0)
    DCL_IOCMG_SetDriveRate(iocmgRegx, driveRate);
 3009548:	fd842583          	lw	a1,-40(s0)
 300954c:	fec42503          	lw	a0,-20(s0)
 3009550:	39a5                	jal	ra,30091c8 <DCL_IOCMG_SetDriveRate>
    return IOCMG_STATUS_OK;
 3009552:	4781                	li	a5,0
}
 3009554:	853e                	mv	a0,a5
 3009556:	50b2                	lw	ra,44(sp)
 3009558:	5422                	lw	s0,40(sp)
 300955a:	6145                	addi	sp,sp,48
 300955c:	8082                	ret

0300955e <IsEmuMode>:
  * @param mode QDM mode
  * @retval true
  * @retval false
  */
static inline bool IsEmuMode(unsigned int mode)
{
 300955e:	1101                	addi	sp,sp,-32
 3009560:	ce22                	sw	s0,28(sp)
 3009562:	1000                	addi	s0,sp,32
 3009564:	fea42623          	sw	a0,-20(s0)
    if (mode == QDM_EMULATION_MODE_STOP_IMMEDIATELY || mode == QDM_EMULATION_MODE_STOP_AT_ROLLOVER ||
 3009568:	fec42783          	lw	a5,-20(s0)
 300956c:	cb99                	beqz	a5,3009582 <IsEmuMode+0x24>
 300956e:	fec42703          	lw	a4,-20(s0)
 3009572:	4785                	li	a5,1
 3009574:	00f70763          	beq	a4,a5,3009582 <IsEmuMode+0x24>
 3009578:	fec42703          	lw	a4,-20(s0)
 300957c:	4789                	li	a5,2
 300957e:	00f71463          	bne	a4,a5,3009586 <IsEmuMode+0x28>
        mode == QDM_EMULATION_MODE_RUN_FREE) {
        return true;
 3009582:	4785                	li	a5,1
 3009584:	a011                	j	3009588 <IsEmuMode+0x2a>
    }
    return false;
 3009586:	4781                	li	a5,0
}
 3009588:	853e                	mv	a0,a5
 300958a:	4472                	lw	s0,28(sp)
 300958c:	6105                	addi	sp,sp,32
 300958e:	8082                	ret

03009590 <IsLockMode>:
  * @param mode QDM mode
  * @retval true
  * @retval false
  */
static inline bool IsLockMode(unsigned int mode)
{
 3009590:	1101                	addi	sp,sp,-32
 3009592:	ce22                	sw	s0,28(sp)
 3009594:	1000                	addi	s0,sp,32
 3009596:	fea42623          	sw	a0,-20(s0)
    if (mode == QDM_LOCK_RESERVE || mode == QDM_LOCK_RISING_INDEX ||
 300959a:	fec42783          	lw	a5,-20(s0)
 300959e:	c385                	beqz	a5,30095be <IsLockMode+0x2e>
 30095a0:	fec42703          	lw	a4,-20(s0)
 30095a4:	4785                	li	a5,1
 30095a6:	00f70c63          	beq	a4,a5,30095be <IsLockMode+0x2e>
 30095aa:	fec42703          	lw	a4,-20(s0)
 30095ae:	4789                	li	a5,2
 30095b0:	00f70763          	beq	a4,a5,30095be <IsLockMode+0x2e>
        mode == QDM_LOCK_FALLING_INDEX || mode == QDM_LOCK_SW_INDEX_MARKER) {
 30095b4:	fec42703          	lw	a4,-20(s0)
 30095b8:	478d                	li	a5,3
 30095ba:	00f71463          	bne	a4,a5,30095c2 <IsLockMode+0x32>
        return true;
 30095be:	4785                	li	a5,1
 30095c0:	a011                	j	30095c4 <IsLockMode+0x34>
    }
    return false;
 30095c2:	4781                	li	a5,0
}
 30095c4:	853e                	mv	a0,a5
 30095c6:	4472                	lw	s0,28(sp)
 30095c8:	6105                	addi	sp,sp,32
 30095ca:	8082                	ret

030095cc <IsDecodeMode>:
  * @param mode QDM decode mode
  * @retval true
  * @retval false
  */
static inline bool IsDecodeMode(unsigned int mode)
{
 30095cc:	1101                	addi	sp,sp,-32
 30095ce:	ce22                	sw	s0,28(sp)
 30095d0:	1000                	addi	s0,sp,32
 30095d2:	fea42623          	sw	a0,-20(s0)
    if (mode <= QDM_NONSTANDARD_TYPE2) {
 30095d6:	fec42703          	lw	a4,-20(s0)
 30095da:	478d                	li	a5,3
 30095dc:	00e7e463          	bltu	a5,a4,30095e4 <IsDecodeMode+0x18>
        return true;
 30095e0:	4785                	li	a5,1
 30095e2:	a011                	j	30095e6 <IsDecodeMode+0x1a>
    }
    return false;
 30095e4:	4781                	li	a5,0
}
 30095e6:	853e                	mv	a0,a5
 30095e8:	4472                	lw	s0,28(sp)
 30095ea:	6105                	addi	sp,sp,32
 30095ec:	8082                	ret

030095ee <IsResolution>:
  * @param mode QDM mode
  * @retval true
  * @retval false
  */
static inline bool IsResolution(unsigned int mode)
{
 30095ee:	1101                	addi	sp,sp,-32
 30095f0:	ce22                	sw	s0,28(sp)
 30095f2:	1000                	addi	s0,sp,32
 30095f4:	fea42623          	sw	a0,-20(s0)
    if (mode == QDM_1X_RESOLUTION || mode == QDM_2X_RESOLUTION || mode == QDM_4X_RESOLUTION) {
 30095f8:	fec42783          	lw	a5,-20(s0)
 30095fc:	cb99                	beqz	a5,3009612 <IsResolution+0x24>
 30095fe:	fec42703          	lw	a4,-20(s0)
 3009602:	4785                	li	a5,1
 3009604:	00f70763          	beq	a4,a5,3009612 <IsResolution+0x24>
 3009608:	fec42703          	lw	a4,-20(s0)
 300960c:	4789                	li	a5,2
 300960e:	00f71463          	bne	a4,a5,3009616 <IsResolution+0x28>
        return true;
 3009612:	4785                	li	a5,1
 3009614:	a011                	j	3009618 <IsResolution+0x2a>
    }
    return false;
 3009616:	4781                	li	a5,0
}
 3009618:	853e                	mv	a0,a5
 300961a:	4472                	lw	s0,28(sp)
 300961c:	6105                	addi	sp,sp,32
 300961e:	8082                	ret

03009620 <IsSwap>:
  * @param mode QDM mode
  * @retval true
  * @retval false
  */
static inline bool IsSwap(unsigned int mode)
{
 3009620:	1101                	addi	sp,sp,-32
 3009622:	ce22                	sw	s0,28(sp)
 3009624:	1000                	addi	s0,sp,32
 3009626:	fea42623          	sw	a0,-20(s0)
    if (mode == QDM_SWAP_DISABLE || mode == QDM_SWAP_ENABLE) {
 300962a:	fec42783          	lw	a5,-20(s0)
 300962e:	c791                	beqz	a5,300963a <IsSwap+0x1a>
 3009630:	fec42703          	lw	a4,-20(s0)
 3009634:	4785                	li	a5,1
 3009636:	00f71463          	bne	a4,a5,300963e <IsSwap+0x1e>
        return true;
 300963a:	4785                	li	a5,1
 300963c:	a011                	j	3009640 <IsSwap+0x20>
    }
    return false;
 300963e:	4781                	li	a5,0
}
 3009640:	853e                	mv	a0,a5
 3009642:	4472                	lw	s0,28(sp)
 3009644:	6105                	addi	sp,sp,32
 3009646:	8082                	ret

03009648 <IsTrgLockMode>:
  * @param mode QDM mode
  * @retval true
  * @retval false
  */
static inline bool IsTrgLockMode(unsigned int mode)
{
 3009648:	1101                	addi	sp,sp,-32
 300964a:	ce22                	sw	s0,28(sp)
 300964c:	1000                	addi	s0,sp,32
 300964e:	fea42623          	sw	a0,-20(s0)
    if (mode == QDM_TRG_BY_READ || mode == QDM_TRG_BY_CYCLE) {
 3009652:	fec42783          	lw	a5,-20(s0)
 3009656:	c791                	beqz	a5,3009662 <IsTrgLockMode+0x1a>
 3009658:	fec42703          	lw	a4,-20(s0)
 300965c:	4785                	li	a5,1
 300965e:	00f71463          	bne	a4,a5,3009666 <IsTrgLockMode+0x1e>
        return true;
 3009662:	4785                	li	a5,1
 3009664:	a011                	j	3009668 <IsTrgLockMode+0x20>
    }
    return false;
 3009666:	4781                	li	a5,0
}
 3009668:	853e                	mv	a0,a5
 300966a:	4472                	lw	s0,28(sp)
 300966c:	6105                	addi	sp,sp,32
 300966e:	8082                	ret

03009670 <IsPtuMode>:
  * @param mode QDM mode
  * @retval true
  * @retval false
  */
static inline bool IsPtuMode(unsigned int mode)
{
 3009670:	1101                	addi	sp,sp,-32
 3009672:	ce22                	sw	s0,28(sp)
 3009674:	1000                	addi	s0,sp,32
 3009676:	fea42623          	sw	a0,-20(s0)
    if (mode == QDM_PTU_MODE_CYCLE || mode == QDM_PTU_MODE_WATCHDOG) {
 300967a:	fec42783          	lw	a5,-20(s0)
 300967e:	c791                	beqz	a5,300968a <IsPtuMode+0x1a>
 3009680:	fec42703          	lw	a4,-20(s0)
 3009684:	4785                	li	a5,1
 3009686:	00f71463          	bne	a4,a5,300968e <IsPtuMode+0x1e>
        return true;
 300968a:	4785                	li	a5,1
 300968c:	a011                	j	3009690 <IsPtuMode+0x20>
    }
    return false;
 300968e:	4781                	li	a5,0
}
 3009690:	853e                	mv	a0,a5
 3009692:	4472                	lw	s0,28(sp)
 3009694:	6105                	addi	sp,sp,32
 3009696:	8082                	ret

03009698 <IsPcntMode>:
  * @param mode QDM mode
  * @retval true
  * @retval false
  */
static inline bool IsPcntMode(unsigned int mode)
{
 3009698:	1101                	addi	sp,sp,-32
 300969a:	ce22                	sw	s0,28(sp)
 300969c:	1000                	addi	s0,sp,32
 300969e:	fea42623          	sw	a0,-20(s0)
    if (mode == QDM_PCNT_MODE_BY_DIR || mode == QDM_PCNT_MODE_UP || mode == QDM_PCNT_MODE_DOWN) {
 30096a2:	fec42783          	lw	a5,-20(s0)
 30096a6:	cb99                	beqz	a5,30096bc <IsPcntMode+0x24>
 30096a8:	fec42703          	lw	a4,-20(s0)
 30096ac:	4785                	li	a5,1
 30096ae:	00f70763          	beq	a4,a5,30096bc <IsPcntMode+0x24>
 30096b2:	fec42703          	lw	a4,-20(s0)
 30096b6:	4789                	li	a5,2
 30096b8:	00f71463          	bne	a4,a5,30096c0 <IsPcntMode+0x28>
        return true;
 30096bc:	4785                	li	a5,1
 30096be:	a011                	j	30096c2 <IsPcntMode+0x2a>
    }
    return false;
 30096c0:	4781                	li	a5,0
}
 30096c2:	853e                	mv	a0,a5
 30096c4:	4472                	lw	s0,28(sp)
 30096c6:	6105                	addi	sp,sp,32
 30096c8:	8082                	ret

030096ca <IsPcntRstMode>:
  * @param mode QDM mode
  * @retval true
  * @retval false
  */
static inline bool IsPcntRstMode(unsigned int mode)
{
 30096ca:	1101                	addi	sp,sp,-32
 30096cc:	ce22                	sw	s0,28(sp)
 30096ce:	1000                	addi	s0,sp,32
 30096d0:	fea42623          	sw	a0,-20(s0)
    if (mode == QDM_PCNT_RST_AUTO || mode == QDM_PCNT_RST_OVF ||
 30096d4:	fec42783          	lw	a5,-20(s0)
 30096d8:	c385                	beqz	a5,30096f8 <IsPcntRstMode+0x2e>
 30096da:	fec42703          	lw	a4,-20(s0)
 30096de:	4785                	li	a5,1
 30096e0:	00f70c63          	beq	a4,a5,30096f8 <IsPcntRstMode+0x2e>
 30096e4:	fec42703          	lw	a4,-20(s0)
 30096e8:	4789                	li	a5,2
 30096ea:	00f70763          	beq	a4,a5,30096f8 <IsPcntRstMode+0x2e>
        mode == QDM_PCNT_RST_HARDWARE_ONCE || mode == QDM_PCNT_RST_BY_PTU) {
 30096ee:	fec42703          	lw	a4,-20(s0)
 30096f2:	478d                	li	a5,3
 30096f4:	00f71463          	bne	a4,a5,30096fc <IsPcntRstMode+0x32>
        return true;
 30096f8:	4785                	li	a5,1
 30096fa:	a011                	j	30096fe <IsPcntRstMode+0x34>
    }
    return false;
 30096fc:	4781                	li	a5,0
}
 30096fe:	853e                	mv	a0,a5
 3009700:	4472                	lw	s0,28(sp)
 3009702:	6105                	addi	sp,sp,32
 3009704:	8082                	ret

03009706 <IsPcntIdxInitMode>:
  * @param mode QDM mode
  * @retval true
  * @retval false
  */
static inline bool IsPcntIdxInitMode(unsigned int mode)
{
 3009706:	1101                	addi	sp,sp,-32
 3009708:	ce22                	sw	s0,28(sp)
 300970a:	1000                	addi	s0,sp,32
 300970c:	fea42623          	sw	a0,-20(s0)
    if (mode == QDM_IDX_INIT_DISABLE || mode == QDM_IDX_INIT_AUTO ||
 3009710:	fec42783          	lw	a5,-20(s0)
 3009714:	c385                	beqz	a5,3009734 <IsPcntIdxInitMode+0x2e>
 3009716:	fec42703          	lw	a4,-20(s0)
 300971a:	4785                	li	a5,1
 300971c:	00f70c63          	beq	a4,a5,3009734 <IsPcntIdxInitMode+0x2e>
 3009720:	fec42703          	lw	a4,-20(s0)
 3009724:	4789                	li	a5,2
 3009726:	00f70763          	beq	a4,a5,3009734 <IsPcntIdxInitMode+0x2e>
        mode == QDM_IDX_INIT_Z_UP || mode == QDM_IDX_INIT_Z_DOWN) {
 300972a:	fec42703          	lw	a4,-20(s0)
 300972e:	478d                	li	a5,3
 3009730:	00f71463          	bne	a4,a5,3009738 <IsPcntIdxInitMode+0x32>
        return true;
 3009734:	4785                	li	a5,1
 3009736:	a011                	j	300973a <IsPcntIdxInitMode+0x34>
    }
    return false;
 3009738:	4781                	li	a5,0
}
 300973a:	853e                	mv	a0,a5
 300973c:	4472                	lw	s0,28(sp)
 300973e:	6105                	addi	sp,sp,32
 3009740:	8082                	ret

03009742 <IsTsuPrescaler>:
  * @param mode QDM mode
  * @retval true
  * @retval false
  */
static inline bool IsTsuPrescaler(unsigned int mode)
{
 3009742:	1101                	addi	sp,sp,-32
 3009744:	ce22                	sw	s0,28(sp)
 3009746:	1000                	addi	s0,sp,32
 3009748:	fea42623          	sw	a0,-20(s0)
    /* Check whether the TSU prescaler is right. */
    if (mode == QDM_TSU_PRESCALER_EQUAL || mode == QDM_TSU_PRESCALER_2X ||
 300974c:	fec42783          	lw	a5,-20(s0)
 3009750:	cba9                	beqz	a5,30097a2 <IsTsuPrescaler+0x60>
 3009752:	fec42703          	lw	a4,-20(s0)
 3009756:	4785                	li	a5,1
 3009758:	04f70563          	beq	a4,a5,30097a2 <IsTsuPrescaler+0x60>
 300975c:	fec42703          	lw	a4,-20(s0)
 3009760:	4789                	li	a5,2
 3009762:	04f70063          	beq	a4,a5,30097a2 <IsTsuPrescaler+0x60>
        mode == QDM_TSU_PRESCALER_4X || mode == QDM_TSU_PRESCALER_8X ||
 3009766:	fec42703          	lw	a4,-20(s0)
 300976a:	478d                	li	a5,3
 300976c:	02f70b63          	beq	a4,a5,30097a2 <IsTsuPrescaler+0x60>
 3009770:	fec42703          	lw	a4,-20(s0)
 3009774:	4791                	li	a5,4
 3009776:	02f70663          	beq	a4,a5,30097a2 <IsTsuPrescaler+0x60>
        mode == QDM_TSU_PRESCALER_16X || mode == QDM_TSU_PRESCALER_32X ||
 300977a:	fec42703          	lw	a4,-20(s0)
 300977e:	4795                	li	a5,5
 3009780:	02f70163          	beq	a4,a5,30097a2 <IsTsuPrescaler+0x60>
 3009784:	fec42703          	lw	a4,-20(s0)
 3009788:	4799                	li	a5,6
 300978a:	00f70c63          	beq	a4,a5,30097a2 <IsTsuPrescaler+0x60>
        mode == QDM_TSU_PRESCALER_64X || mode == QDM_TSU_PRESCALER_128X ||
 300978e:	fec42703          	lw	a4,-20(s0)
 3009792:	479d                	li	a5,7
 3009794:	00f70763          	beq	a4,a5,30097a2 <IsTsuPrescaler+0x60>
 3009798:	fec42703          	lw	a4,-20(s0)
 300979c:	47a1                	li	a5,8
 300979e:	00f71463          	bne	a4,a5,30097a6 <IsTsuPrescaler+0x64>
        mode == QDM_TSU_PRESCALER_256X) {
        return true;
 30097a2:	4785                	li	a5,1
 30097a4:	a011                	j	30097a8 <IsTsuPrescaler+0x66>
    }
    return false;
 30097a6:	4781                	li	a5,0
}
 30097a8:	853e                	mv	a0,a5
 30097aa:	4472                	lw	s0,28(sp)
 30097ac:	6105                	addi	sp,sp,32
 30097ae:	8082                	ret

030097b0 <IsCevtPrescaler>:
  * @param mode QDM mode
  * @retval true
  * @retval false
  */
static inline bool IsCevtPrescaler(unsigned int mode)
{
 30097b0:	1101                	addi	sp,sp,-32
 30097b2:	ce22                	sw	s0,28(sp)
 30097b4:	1000                	addi	s0,sp,32
 30097b6:	fea42623          	sw	a0,-20(s0)
    /* Check whether the CEVT prescaler is right. */
    if (mode == QDM_CEVT_PRESCALER_DIVI1 || mode == QDM_CEVT_PRESCALER_DIVI2 ||
 30097ba:	fec42783          	lw	a5,-20(s0)
 30097be:	cba5                	beqz	a5,300982e <IsCevtPrescaler+0x7e>
 30097c0:	fec42703          	lw	a4,-20(s0)
 30097c4:	4785                	li	a5,1
 30097c6:	06f70463          	beq	a4,a5,300982e <IsCevtPrescaler+0x7e>
 30097ca:	fec42703          	lw	a4,-20(s0)
 30097ce:	4789                	li	a5,2
 30097d0:	04f70f63          	beq	a4,a5,300982e <IsCevtPrescaler+0x7e>
        mode == QDM_CEVT_PRESCALER_DIVI4 || mode == QDM_CEVT_PRESCALER_DIVI8 ||
 30097d4:	fec42703          	lw	a4,-20(s0)
 30097d8:	478d                	li	a5,3
 30097da:	04f70a63          	beq	a4,a5,300982e <IsCevtPrescaler+0x7e>
 30097de:	fec42703          	lw	a4,-20(s0)
 30097e2:	4791                	li	a5,4
 30097e4:	04f70563          	beq	a4,a5,300982e <IsCevtPrescaler+0x7e>
        mode == QDM_CEVT_PRESCALER_DIVI16 || mode == QDM_CEVT_PRESCALER_DIVI32 ||
 30097e8:	fec42703          	lw	a4,-20(s0)
 30097ec:	4795                	li	a5,5
 30097ee:	04f70063          	beq	a4,a5,300982e <IsCevtPrescaler+0x7e>
 30097f2:	fec42703          	lw	a4,-20(s0)
 30097f6:	4799                	li	a5,6
 30097f8:	02f70b63          	beq	a4,a5,300982e <IsCevtPrescaler+0x7e>
        mode == QDM_CEVT_PRESCALER_DIVI64 || mode == QDM_CEVT_PRESCALER_DIVI128 ||
 30097fc:	fec42703          	lw	a4,-20(s0)
 3009800:	479d                	li	a5,7
 3009802:	02f70663          	beq	a4,a5,300982e <IsCevtPrescaler+0x7e>
 3009806:	fec42703          	lw	a4,-20(s0)
 300980a:	47a1                	li	a5,8
 300980c:	02f70163          	beq	a4,a5,300982e <IsCevtPrescaler+0x7e>
        mode == QDM_CEVT_PRESCALER_DIVI256 || mode == QDM_CEVT_PRESCALER_DIVI512 ||
 3009810:	fec42703          	lw	a4,-20(s0)
 3009814:	47a5                	li	a5,9
 3009816:	00f70c63          	beq	a4,a5,300982e <IsCevtPrescaler+0x7e>
 300981a:	fec42703          	lw	a4,-20(s0)
 300981e:	47a9                	li	a5,10
 3009820:	00f70763          	beq	a4,a5,300982e <IsCevtPrescaler+0x7e>
        mode == QDM_CEVT_PRESCALER_DIVI1024 || mode == QDM_CEVT_PRESCALER_DIVI2048) {
 3009824:	fec42703          	lw	a4,-20(s0)
 3009828:	47ad                	li	a5,11
 300982a:	00f71463          	bne	a4,a5,3009832 <IsCevtPrescaler+0x82>
        return true;
 300982e:	4785                	li	a5,1
 3009830:	a011                	j	3009834 <IsCevtPrescaler+0x84>
    }
    return false;
 3009832:	4781                	li	a5,0
}
 3009834:	853e                	mv	a0,a5
 3009836:	4472                	lw	s0,28(sp)
 3009838:	6105                	addi	sp,sp,32
 300983a:	8082                	ret

0300983c <DCL_QDM_SetInputFilterWidth>:
  */
static inline void DCL_QDM_SetInputFilterWidth(QDM_RegStruct *qdmx,
                                               unsigned short filtWidthQDMA,
                                               unsigned short filtWidthQDMB,
                                               unsigned short filtWidthQDMI)
{
 300983c:	1101                	addi	sp,sp,-32
 300983e:	ce06                	sw	ra,28(sp)
 3009840:	cc22                	sw	s0,24(sp)
 3009842:	1000                	addi	s0,sp,32
 3009844:	fea42623          	sw	a0,-20(s0)
 3009848:	87ae                	mv	a5,a1
 300984a:	8736                	mv	a4,a3
 300984c:	fef41523          	sh	a5,-22(s0)
 3009850:	87b2                	mv	a5,a2
 3009852:	fef41423          	sh	a5,-24(s0)
 3009856:	87ba                	mv	a5,a4
 3009858:	fef41323          	sh	a5,-26(s0)
    QDM_ASSERT_PARAM(IsQDMInstance(qdmx));
 300985c:	fec42703          	lw	a4,-20(s0)
 3009860:	14c007b7          	lui	a5,0x14c00
 3009864:	02f70063          	beq	a4,a5,3009884 <DCL_QDM_SetInputFilterWidth+0x48>
 3009868:	fec42703          	lw	a4,-20(s0)
 300986c:	14c017b7          	lui	a5,0x14c01
 3009870:	00f70a63          	beq	a4,a5,3009884 <DCL_QDM_SetInputFilterWidth+0x48>
 3009874:	3e700593          	li	a1,999
 3009878:	030127b7          	lui	a5,0x3012
 300987c:	d8478513          	addi	a0,a5,-636 # 3011d84 <g_crgIpMatch+0x4ec>
 3009880:	3e39                	jal	ra,300939e <AssertErrorLog.trans.6>
 3009882:	a001                	j	3009882 <DCL_QDM_SetInputFilterWidth+0x46>
    QDM_PARAM_CHECK_NO_RET(filtWidthQDMA <= QDM_MAX_FILTER_LEVEL);
 3009884:	fea45703          	lhu	a4,-22(s0)
 3009888:	6789                	lui	a5,0x2
 300988a:	00f76a63          	bltu	a4,a5,300989e <DCL_QDM_SetInputFilterWidth+0x62>
 300988e:	3e800593          	li	a1,1000
 3009892:	030127b7          	lui	a5,0x3012
 3009896:	d8478513          	addi	a0,a5,-636 # 3011d84 <g_crgIpMatch+0x4ec>
 300989a:	3611                	jal	ra,300939e <AssertErrorLog.trans.6>
 300989c:	a04d                	j	300993e <DCL_QDM_SetInputFilterWidth+0x102>
    QDM_PARAM_CHECK_NO_RET(filtWidthQDMB <= QDM_MAX_FILTER_LEVEL);
 300989e:	fe845703          	lhu	a4,-24(s0)
 30098a2:	6789                	lui	a5,0x2
 30098a4:	00f76a63          	bltu	a4,a5,30098b8 <DCL_QDM_SetInputFilterWidth+0x7c>
 30098a8:	3e900593          	li	a1,1001
 30098ac:	030127b7          	lui	a5,0x3012
 30098b0:	d8478513          	addi	a0,a5,-636 # 3011d84 <g_crgIpMatch+0x4ec>
 30098b4:	34ed                	jal	ra,300939e <AssertErrorLog.trans.6>
 30098b6:	a061                	j	300993e <DCL_QDM_SetInputFilterWidth+0x102>
    QDM_PARAM_CHECK_NO_RET(filtWidthQDMI <= QDM_MAX_FILTER_LEVEL);
 30098b8:	fe645703          	lhu	a4,-26(s0)
 30098bc:	6789                	lui	a5,0x2
 30098be:	00f76a63          	bltu	a4,a5,30098d2 <DCL_QDM_SetInputFilterWidth+0x96>
 30098c2:	3ea00593          	li	a1,1002
 30098c6:	030127b7          	lui	a5,0x3012
 30098ca:	d8478513          	addi	a0,a5,-636 # 3011d84 <g_crgIpMatch+0x4ec>
 30098ce:	3cc1                	jal	ra,300939e <AssertErrorLog.trans.6>
 30098d0:	a0bd                	j	300993e <DCL_QDM_SetInputFilterWidth+0x102>
    /* Set QDM input filter width. */
    qdmx->QDMAFT.BIT.qdma_ft_level = filtWidthQDMA;
 30098d2:	fea45703          	lhu	a4,-22(s0)
 30098d6:	6789                	lui	a5,0x2
 30098d8:	17fd                	addi	a5,a5,-1 # 1fff <__bss_size__+0xf6b>
 30098da:	8ff9                	and	a5,a5,a4
 30098dc:	01079613          	slli	a2,a5,0x10
 30098e0:	8241                	srli	a2,a2,0x10
 30098e2:	fec42703          	lw	a4,-20(s0)
 30098e6:	4f7c                	lw	a5,92(a4)
 30098e8:	6689                	lui	a3,0x2
 30098ea:	16fd                	addi	a3,a3,-1 # 1fff <__bss_size__+0xf6b>
 30098ec:	8ef1                	and	a3,a3,a2
 30098ee:	7679                	lui	a2,0xffffe
 30098f0:	8ff1                	and	a5,a5,a2
 30098f2:	8fd5                	or	a5,a5,a3
 30098f4:	cf7c                	sw	a5,92(a4)
    qdmx->QDMBFT.BIT.qdmb_ft_level = filtWidthQDMB;
 30098f6:	fe845703          	lhu	a4,-24(s0)
 30098fa:	6789                	lui	a5,0x2
 30098fc:	17fd                	addi	a5,a5,-1 # 1fff <__bss_size__+0xf6b>
 30098fe:	8ff9                	and	a5,a5,a4
 3009900:	01079613          	slli	a2,a5,0x10
 3009904:	8241                	srli	a2,a2,0x10
 3009906:	fec42703          	lw	a4,-20(s0)
 300990a:	533c                	lw	a5,96(a4)
 300990c:	6689                	lui	a3,0x2
 300990e:	16fd                	addi	a3,a3,-1 # 1fff <__bss_size__+0xf6b>
 3009910:	8ef1                	and	a3,a3,a2
 3009912:	7679                	lui	a2,0xffffe
 3009914:	8ff1                	and	a5,a5,a2
 3009916:	8fd5                	or	a5,a5,a3
 3009918:	d33c                	sw	a5,96(a4)
    qdmx->QDMIFT.BIT.qdmi_ft_level = filtWidthQDMI;
 300991a:	fe645703          	lhu	a4,-26(s0)
 300991e:	6789                	lui	a5,0x2
 3009920:	17fd                	addi	a5,a5,-1 # 1fff <__bss_size__+0xf6b>
 3009922:	8ff9                	and	a5,a5,a4
 3009924:	01079613          	slli	a2,a5,0x10
 3009928:	8241                	srli	a2,a2,0x10
 300992a:	fec42703          	lw	a4,-20(s0)
 300992e:	537c                	lw	a5,100(a4)
 3009930:	6689                	lui	a3,0x2
 3009932:	16fd                	addi	a3,a3,-1 # 1fff <__bss_size__+0xf6b>
 3009934:	8ef1                	and	a3,a3,a2
 3009936:	7679                	lui	a2,0xffffe
 3009938:	8ff1                	and	a5,a5,a2
 300993a:	8fd5                	or	a5,a5,a3
 300993c:	d37c                	sw	a5,100(a4)
}
 300993e:	40f2                	lw	ra,28(sp)
 3009940:	4462                	lw	s0,24(sp)
 3009942:	6105                	addi	sp,sp,32
 3009944:	8082                	ret

03009946 <DCL_QDM_SetIndexLockMode>:
  * @param qdmx QDM register base address.
  * @param lockMode Lock mode of index.
  * @retval None.
  */
static inline void DCL_QDM_SetIndexLockMode(QDM_RegStruct *qdmx, QDM_IndexLockMode lockMode)
{
 3009946:	1101                	addi	sp,sp,-32
 3009948:	ce06                	sw	ra,28(sp)
 300994a:	cc22                	sw	s0,24(sp)
 300994c:	1000                	addi	s0,sp,32
 300994e:	fea42623          	sw	a0,-20(s0)
 3009952:	feb42423          	sw	a1,-24(s0)
    QDM_ASSERT_PARAM(IsQDMInstance(qdmx));
 3009956:	fec42703          	lw	a4,-20(s0)
 300995a:	14c007b7          	lui	a5,0x14c00
 300995e:	02f70063          	beq	a4,a5,300997e <DCL_QDM_SetIndexLockMode+0x38>
 3009962:	fec42703          	lw	a4,-20(s0)
 3009966:	14c017b7          	lui	a5,0x14c01
 300996a:	00f70a63          	beq	a4,a5,300997e <DCL_QDM_SetIndexLockMode+0x38>
 300996e:	46d00593          	li	a1,1133
 3009972:	030127b7          	lui	a5,0x3012
 3009976:	d8478513          	addi	a0,a5,-636 # 3011d84 <g_crgIpMatch+0x4ec>
 300997a:	3415                	jal	ra,300939e <AssertErrorLog.trans.6>
 300997c:	a001                	j	300997c <DCL_QDM_SetIndexLockMode+0x36>
    QDM_PARAM_CHECK_NO_RET(lockMode >= QDM_LOCK_RESERVE);
    QDM_PARAM_CHECK_NO_RET(lockMode <= QDM_LOCK_SW_INDEX_MARKER);
 300997e:	fe842703          	lw	a4,-24(s0)
 3009982:	478d                	li	a5,3
 3009984:	00e7fa63          	bgeu	a5,a4,3009998 <DCL_QDM_SetIndexLockMode+0x52>
 3009988:	46f00593          	li	a1,1135
 300998c:	030127b7          	lui	a5,0x3012
 3009990:	d8478513          	addi	a0,a5,-636 # 3011d84 <g_crgIpMatch+0x4ec>
 3009994:	3429                	jal	ra,300939e <AssertErrorLog.trans.6>
 3009996:	a00d                	j	30099b8 <DCL_QDM_SetIndexLockMode+0x72>
    qdmx->QPPUCTRL.BIT.pcnt_idx_lock_mode = lockMode;
 3009998:	fe842783          	lw	a5,-24(s0)
 300999c:	8b8d                	andi	a5,a5,3
 300999e:	0ff7f693          	andi	a3,a5,255
 30099a2:	fec42703          	lw	a4,-20(s0)
 30099a6:	475c                	lw	a5,12(a4)
 30099a8:	8a8d                	andi	a3,a3,3
 30099aa:	06d2                	slli	a3,a3,0x14
 30099ac:	ffd00637          	lui	a2,0xffd00
 30099b0:	167d                	addi	a2,a2,-1 # ffcfffff <RAM_END+0xfbcf7fff>
 30099b2:	8ff1                	and	a5,a5,a2
 30099b4:	8fd5                	or	a5,a5,a3
 30099b6:	c75c                	sw	a5,12(a4)
}
 30099b8:	40f2                	lw	ra,28(sp)
 30099ba:	4462                	lw	s0,24(sp)
 30099bc:	6105                	addi	sp,sp,32
 30099be:	8082                	ret

030099c0 <QDM_DecoderConfig>:
  * @brief Set Decoder configurations
  * @param qdmHandle Value of @ref QDM_Handle.
  * @retval None
  */
static void QDM_DecoderConfig(QDM_Handle *qdmHandle)
{
 30099c0:	1101                	addi	sp,sp,-32
 30099c2:	ce06                	sw	ra,28(sp)
 30099c4:	cc22                	sw	s0,24(sp)
 30099c6:	1000                	addi	s0,sp,32
 30099c8:	fea42623          	sw	a0,-20(s0)
    QDM_ASSERT_PARAM(qdmHandle != NULL);
 30099cc:	fec42783          	lw	a5,-20(s0)
 30099d0:	eb89                	bnez	a5,30099e2 <QDM_DecoderConfig+0x22>
 30099d2:	02700593          	li	a1,39
 30099d6:	030127b7          	lui	a5,0x3012
 30099da:	da078513          	addi	a0,a5,-608 # 3011da0 <g_crgIpMatch+0x508>
 30099de:	32c1                	jal	ra,300939e <AssertErrorLog.trans.6>
 30099e0:	a001                	j	30099e0 <QDM_DecoderConfig+0x20>
    QDM_ASSERT_PARAM(IsQDMInstance(qdmHandle->baseAddress));
 30099e2:	fec42783          	lw	a5,-20(s0)
 30099e6:	4398                	lw	a4,0(a5)
 30099e8:	14c007b7          	lui	a5,0x14c00
 30099ec:	02f70163          	beq	a4,a5,3009a0e <QDM_DecoderConfig+0x4e>
 30099f0:	fec42783          	lw	a5,-20(s0)
 30099f4:	4398                	lw	a4,0(a5)
 30099f6:	14c017b7          	lui	a5,0x14c01
 30099fa:	00f70a63          	beq	a4,a5,3009a0e <QDM_DecoderConfig+0x4e>
 30099fe:	02800593          	li	a1,40
 3009a02:	030127b7          	lui	a5,0x3012
 3009a06:	da078513          	addi	a0,a5,-608 # 3011da0 <g_crgIpMatch+0x508>
 3009a0a:	3a51                	jal	ra,300939e <AssertErrorLog.trans.6>
 3009a0c:	a001                	j	3009a0c <QDM_DecoderConfig+0x4c>
    QDM_PARAM_CHECK_NO_RET(IsDecodeMode(qdmHandle->ctrlConfig.decoderMode));
 3009a0e:	fec42783          	lw	a5,-20(s0)
 3009a12:	4bdc                	lw	a5,20(a5)
 3009a14:	853e                	mv	a0,a5
 3009a16:	3e5d                	jal	ra,30095cc <IsDecodeMode>
 3009a18:	87aa                	mv	a5,a0
 3009a1a:	0017c793          	xori	a5,a5,1
 3009a1e:	9f81                	uxtb	a5
 3009a20:	cb89                	beqz	a5,3009a32 <QDM_DecoderConfig+0x72>
 3009a22:	02900593          	li	a1,41
 3009a26:	030127b7          	lui	a5,0x3012
 3009a2a:	da078513          	addi	a0,a5,-608 # 3011da0 <g_crgIpMatch+0x508>
 3009a2e:	3a85                	jal	ra,300939e <AssertErrorLog.trans.6>
 3009a30:	a27d                	j	3009bde <QDM_DecoderConfig+0x21e>
    QDM_PARAM_CHECK_NO_RET(IsSwap(qdmHandle->ctrlConfig.swap));
 3009a32:	fec42783          	lw	a5,-20(s0)
 3009a36:	53dc                	lw	a5,36(a5)
 3009a38:	853e                	mv	a0,a5
 3009a3a:	36dd                	jal	ra,3009620 <IsSwap>
 3009a3c:	87aa                	mv	a5,a0
 3009a3e:	0017c793          	xori	a5,a5,1
 3009a42:	9f81                	uxtb	a5
 3009a44:	cb89                	beqz	a5,3009a56 <QDM_DecoderConfig+0x96>
 3009a46:	02a00593          	li	a1,42
 3009a4a:	030127b7          	lui	a5,0x3012
 3009a4e:	da078513          	addi	a0,a5,-608 # 3011da0 <g_crgIpMatch+0x508>
 3009a52:	32b1                	jal	ra,300939e <AssertErrorLog.trans.6>
 3009a54:	a269                	j	3009bde <QDM_DecoderConfig+0x21e>
    QDM_PARAM_CHECK_NO_RET(IsResolution(qdmHandle->ctrlConfig.resolution));
 3009a56:	fec42783          	lw	a5,-20(s0)
 3009a5a:	4f9c                	lw	a5,24(a5)
 3009a5c:	853e                	mv	a0,a5
 3009a5e:	3e41                	jal	ra,30095ee <IsResolution>
 3009a60:	87aa                	mv	a5,a0
 3009a62:	0017c793          	xori	a5,a5,1
 3009a66:	9f81                	uxtb	a5
 3009a68:	cb89                	beqz	a5,3009a7a <QDM_DecoderConfig+0xba>
 3009a6a:	02b00593          	li	a1,43
 3009a6e:	030127b7          	lui	a5,0x3012
 3009a72:	da078513          	addi	a0,a5,-608 # 3011da0 <g_crgIpMatch+0x508>
 3009a76:	3225                	jal	ra,300939e <AssertErrorLog.trans.6>
 3009a78:	a29d                	j	3009bde <QDM_DecoderConfig+0x21e>
    QDM_PARAM_CHECK_NO_RET(IsTrgLockMode(qdmHandle->ctrlConfig.trgLockMode));
 3009a7a:	fec42783          	lw	a5,-20(s0)
 3009a7e:	4fdc                	lw	a5,28(a5)
 3009a80:	853e                	mv	a0,a5
 3009a82:	36d9                	jal	ra,3009648 <IsTrgLockMode>
 3009a84:	87aa                	mv	a5,a0
 3009a86:	0017c793          	xori	a5,a5,1
 3009a8a:	9f81                	uxtb	a5
 3009a8c:	cb89                	beqz	a5,3009a9e <QDM_DecoderConfig+0xde>
 3009a8e:	02c00593          	li	a1,44
 3009a92:	030127b7          	lui	a5,0x3012
 3009a96:	da078513          	addi	a0,a5,-608 # 3011da0 <g_crgIpMatch+0x508>
 3009a9a:	3211                	jal	ra,300939e <AssertErrorLog.trans.6>
 3009a9c:	a289                	j	3009bde <QDM_DecoderConfig+0x21e>
    QDM_PARAM_CHECK_NO_RET(IsPtuMode(qdmHandle->ctrlConfig.ptuMode));
 3009a9e:	fec42783          	lw	a5,-20(s0)
 3009aa2:	539c                	lw	a5,32(a5)
 3009aa4:	853e                	mv	a0,a5
 3009aa6:	36e9                	jal	ra,3009670 <IsPtuMode>
 3009aa8:	87aa                	mv	a5,a0
 3009aaa:	0017c793          	xori	a5,a5,1
 3009aae:	9f81                	uxtb	a5
 3009ab0:	cb89                	beqz	a5,3009ac2 <QDM_DecoderConfig+0x102>
 3009ab2:	02d00593          	li	a1,45
 3009ab6:	030127b7          	lui	a5,0x3012
 3009aba:	da078513          	addi	a0,a5,-608 # 3011da0 <g_crgIpMatch+0x508>
 3009abe:	2139                	jal	ra,3009ecc <AssertErrorLog.trans.7>
 3009ac0:	aa39                	j	3009bde <QDM_DecoderConfig+0x21e>

    /* input mode setting */
    qdmHandle->baseAddress->QCTRL.BIT.qdu_mode = qdmHandle->ctrlConfig.decoderMode;
 3009ac2:	fec42783          	lw	a5,-20(s0)
 3009ac6:	4bd4                	lw	a3,20(a5)
 3009ac8:	fec42783          	lw	a5,-20(s0)
 3009acc:	4398                	lw	a4,0(a5)
 3009ace:	87b6                	mv	a5,a3
 3009ad0:	8b8d                	andi	a5,a5,3
 3009ad2:	0ff7f693          	andi	a3,a5,255
 3009ad6:	471c                	lw	a5,8(a4)
 3009ad8:	8a8d                	andi	a3,a3,3
 3009ada:	06ba                	slli	a3,a3,0xe
 3009adc:	7651                	lui	a2,0xffff4
 3009ade:	167d                	addi	a2,a2,-1 # ffff3fff <RAM_END+0xfbfebfff>
 3009ae0:	8ff1                	and	a5,a5,a2
 3009ae2:	8fd5                	or	a5,a5,a3
 3009ae4:	c71c                	sw	a5,8(a4)
    /* swap */
    qdmHandle->baseAddress->QCTRL.BIT.qdm_ab_swap = qdmHandle->ctrlConfig.swap;
 3009ae6:	fec42783          	lw	a5,-20(s0)
 3009aea:	53d4                	lw	a3,36(a5)
 3009aec:	fec42783          	lw	a5,-20(s0)
 3009af0:	4398                	lw	a4,0(a5)
 3009af2:	87b6                	mv	a5,a3
 3009af4:	8b85                	andi	a5,a5,1
 3009af6:	0ff7f693          	andi	a3,a5,255
 3009afa:	471c                	lw	a5,8(a4)
 3009afc:	8a85                	andi	a3,a3,1
 3009afe:	06ae                	slli	a3,a3,0xb
 3009b00:	767d                	lui	a2,0xfffff
 3009b02:	7ff60613          	addi	a2,a2,2047 # fffff7ff <RAM_END+0xfbff77ff>
 3009b06:	8ff1                	and	a5,a5,a2
 3009b08:	8fd5                	or	a5,a5,a3
 3009b0a:	c71c                	sw	a5,8(a4)
    /* qdm xclk */
    qdmHandle->baseAddress->QCTRL.BIT.qdu_xclk = qdmHandle->ctrlConfig.resolution;
 3009b0c:	fec42783          	lw	a5,-20(s0)
 3009b10:	4f94                	lw	a3,24(a5)
 3009b12:	fec42783          	lw	a5,-20(s0)
 3009b16:	4398                	lw	a4,0(a5)
 3009b18:	87b6                	mv	a5,a3
 3009b1a:	8b8d                	andi	a5,a5,3
 3009b1c:	0ff7f693          	andi	a3,a5,255
 3009b20:	471c                	lw	a5,8(a4)
 3009b22:	8a8d                	andi	a3,a3,3
 3009b24:	06b2                	slli	a3,a3,0xc
 3009b26:	7675                	lui	a2,0xffffd
 3009b28:	167d                	addi	a2,a2,-1 # ffffcfff <RAM_END+0xfbff4fff>
 3009b2a:	8ff1                	and	a5,a5,a2
 3009b2c:	8fd5                	or	a5,a5,a3
 3009b2e:	c71c                	sw	a5,8(a4)
    /* polarity */
    /* bit0: A input polarity, bit value: 0--direct input, 1--invert input */
    qdmHandle->baseAddress->QCTRL.BIT.qdma_polarity = (qdmHandle->ctrlConfig.polarity & 0x01);
 3009b30:	fec42783          	lw	a5,-20(s0)
 3009b34:	5794                	lw	a3,40(a5)
 3009b36:	fec42783          	lw	a5,-20(s0)
 3009b3a:	4398                	lw	a4,0(a5)
 3009b3c:	87b6                	mv	a5,a3
 3009b3e:	8b85                	andi	a5,a5,1
 3009b40:	0ff7f693          	andi	a3,a5,255
 3009b44:	471c                	lw	a5,8(a4)
 3009b46:	8a85                	andi	a3,a3,1
 3009b48:	06aa                	slli	a3,a3,0xa
 3009b4a:	bff7f793          	andi	a5,a5,-1025
 3009b4e:	8fd5                	or	a5,a5,a3
 3009b50:	c71c                	sw	a5,8(a4)
    /* bit1: B input polarity, bit value: 0--direct input, 1--invert input */
    qdmHandle->baseAddress->QCTRL.BIT.qdmb_polarity = ((qdmHandle->ctrlConfig.polarity >> 1) & 0x01);
 3009b52:	fec42783          	lw	a5,-20(s0)
 3009b56:	579c                	lw	a5,40(a5)
 3009b58:	0017d693          	srli	a3,a5,0x1
 3009b5c:	fec42783          	lw	a5,-20(s0)
 3009b60:	4398                	lw	a4,0(a5)
 3009b62:	87b6                	mv	a5,a3
 3009b64:	8b85                	andi	a5,a5,1
 3009b66:	0ff7f693          	andi	a3,a5,255
 3009b6a:	471c                	lw	a5,8(a4)
 3009b6c:	8a85                	andi	a3,a3,1
 3009b6e:	06a6                	slli	a3,a3,0x9
 3009b70:	dff7f793          	andi	a5,a5,-513
 3009b74:	8fd5                	or	a5,a5,a3
 3009b76:	c71c                	sw	a5,8(a4)
    /* bit2: index input polarity, bit value: 0--direct input, 1--invert input */
    qdmHandle->baseAddress->QCTRL.BIT.qdmi_polarity = ((qdmHandle->ctrlConfig.polarity >> 2) & 0x01);
 3009b78:	fec42783          	lw	a5,-20(s0)
 3009b7c:	579c                	lw	a5,40(a5)
 3009b7e:	0027d693          	srli	a3,a5,0x2
 3009b82:	fec42783          	lw	a5,-20(s0)
 3009b86:	4398                	lw	a4,0(a5)
 3009b88:	87b6                	mv	a5,a3
 3009b8a:	8b85                	andi	a5,a5,1
 3009b8c:	0ff7f693          	andi	a3,a5,255
 3009b90:	471c                	lw	a5,8(a4)
 3009b92:	8a85                	andi	a3,a3,1
 3009b94:	06a2                	slli	a3,a3,0x8
 3009b96:	eff7f793          	andi	a5,a5,-257
 3009b9a:	8fd5                	or	a5,a5,a3
 3009b9c:	c71c                	sw	a5,8(a4)
    /* lock mode */
    qdmHandle->baseAddress->QCTRL.BIT.qtrg_lock_mode = qdmHandle->ctrlConfig.trgLockMode;
 3009b9e:	fec42783          	lw	a5,-20(s0)
 3009ba2:	4fd4                	lw	a3,28(a5)
 3009ba4:	fec42783          	lw	a5,-20(s0)
 3009ba8:	4398                	lw	a4,0(a5)
 3009baa:	87b6                	mv	a5,a3
 3009bac:	8b85                	andi	a5,a5,1
 3009bae:	0ff7f693          	andi	a3,a5,255
 3009bb2:	471c                	lw	a5,8(a4)
 3009bb4:	8a85                	andi	a3,a3,1
 3009bb6:	0692                	slli	a3,a3,0x4
 3009bb8:	9bbd                	andi	a5,a5,-17
 3009bba:	8fd5                	or	a5,a5,a3
 3009bbc:	c71c                	sw	a5,8(a4)
    /* ptu mode */
    qdmHandle->baseAddress->QCTRL.BIT.ptu_mode = qdmHandle->ctrlConfig.ptuMode;
 3009bbe:	fec42783          	lw	a5,-20(s0)
 3009bc2:	5394                	lw	a3,32(a5)
 3009bc4:	fec42783          	lw	a5,-20(s0)
 3009bc8:	4398                	lw	a4,0(a5)
 3009bca:	87b6                	mv	a5,a3
 3009bcc:	8b85                	andi	a5,a5,1
 3009bce:	0ff7f693          	andi	a3,a5,255
 3009bd2:	471c                	lw	a5,8(a4)
 3009bd4:	8a85                	andi	a3,a3,1
 3009bd6:	068e                	slli	a3,a3,0x3
 3009bd8:	9bdd                	andi	a5,a5,-9
 3009bda:	8fd5                	or	a5,a5,a3
 3009bdc:	c71c                	sw	a5,8(a4)
}
 3009bde:	40f2                	lw	ra,28(sp)
 3009be0:	4462                	lw	s0,24(sp)
 3009be2:	6105                	addi	sp,sp,32
 3009be4:	8082                	ret

03009be6 <QDM_CounterConfig>:
  * @brief Set counter configurations
  * @param qdmHandle Value of @ref QDM_Handle.
  * @retval None
  */
static void QDM_CounterConfig(QDM_Handle *qdmHandle)
{
 3009be6:	1101                	addi	sp,sp,-32
 3009be8:	ce06                	sw	ra,28(sp)
 3009bea:	cc22                	sw	s0,24(sp)
 3009bec:	1000                	addi	s0,sp,32
 3009bee:	fea42623          	sw	a0,-20(s0)
    QDM_ASSERT_PARAM(qdmHandle != NULL);
 3009bf2:	fec42783          	lw	a5,-20(s0)
 3009bf6:	eb89                	bnez	a5,3009c08 <QDM_CounterConfig+0x22>
 3009bf8:	04900593          	li	a1,73
 3009bfc:	030127b7          	lui	a5,0x3012
 3009c00:	da078513          	addi	a0,a5,-608 # 3011da0 <g_crgIpMatch+0x508>
 3009c04:	24e1                	jal	ra,3009ecc <AssertErrorLog.trans.7>
 3009c06:	a001                	j	3009c06 <QDM_CounterConfig+0x20>
    QDM_ASSERT_PARAM(IsQDMInstance(qdmHandle->baseAddress));
 3009c08:	fec42783          	lw	a5,-20(s0)
 3009c0c:	4398                	lw	a4,0(a5)
 3009c0e:	14c007b7          	lui	a5,0x14c00
 3009c12:	02f70163          	beq	a4,a5,3009c34 <QDM_CounterConfig+0x4e>
 3009c16:	fec42783          	lw	a5,-20(s0)
 3009c1a:	4398                	lw	a4,0(a5)
 3009c1c:	14c017b7          	lui	a5,0x14c01
 3009c20:	00f70a63          	beq	a4,a5,3009c34 <QDM_CounterConfig+0x4e>
 3009c24:	04a00593          	li	a1,74
 3009c28:	030127b7          	lui	a5,0x3012
 3009c2c:	da078513          	addi	a0,a5,-608 # 3011da0 <g_crgIpMatch+0x508>
 3009c30:	2c71                	jal	ra,3009ecc <AssertErrorLog.trans.7>
 3009c32:	a001                	j	3009c32 <QDM_CounterConfig+0x4c>
    QDM_PARAM_CHECK_NO_RET(IsPcntMode(qdmHandle->pcntMode));
 3009c34:	fec42783          	lw	a5,-20(s0)
 3009c38:	57dc                	lw	a5,44(a5)
 3009c3a:	853e                	mv	a0,a5
 3009c3c:	3cb1                	jal	ra,3009698 <IsPcntMode>
 3009c3e:	87aa                	mv	a5,a0
 3009c40:	0017c793          	xori	a5,a5,1
 3009c44:	9f81                	uxtb	a5
 3009c46:	cb89                	beqz	a5,3009c58 <QDM_CounterConfig+0x72>
 3009c48:	04b00593          	li	a1,75
 3009c4c:	030127b7          	lui	a5,0x3012
 3009c50:	da078513          	addi	a0,a5,-608 # 3011da0 <g_crgIpMatch+0x508>
 3009c54:	2ca5                	jal	ra,3009ecc <AssertErrorLog.trans.7>
 3009c56:	aab5                	j	3009dd2 <QDM_CounterConfig+0x1ec>
    QDM_PARAM_CHECK_NO_RET(IsPcntRstMode(qdmHandle->pcntRstMode));
 3009c58:	fec42783          	lw	a5,-20(s0)
 3009c5c:	5b9c                	lw	a5,48(a5)
 3009c5e:	853e                	mv	a0,a5
 3009c60:	34ad                	jal	ra,30096ca <IsPcntRstMode>
 3009c62:	87aa                	mv	a5,a0
 3009c64:	0017c793          	xori	a5,a5,1
 3009c68:	9f81                	uxtb	a5
 3009c6a:	cb89                	beqz	a5,3009c7c <QDM_CounterConfig+0x96>
 3009c6c:	04c00593          	li	a1,76
 3009c70:	030127b7          	lui	a5,0x3012
 3009c74:	da078513          	addi	a0,a5,-608 # 3011da0 <g_crgIpMatch+0x508>
 3009c78:	2c91                	jal	ra,3009ecc <AssertErrorLog.trans.7>
 3009c7a:	aaa1                	j	3009dd2 <QDM_CounterConfig+0x1ec>
    QDM_PARAM_CHECK_NO_RET(IsPcntIdxInitMode(qdmHandle->pcntIdxInitMode));
 3009c7c:	fec42783          	lw	a5,-20(s0)
 3009c80:	5bdc                	lw	a5,52(a5)
 3009c82:	853e                	mv	a0,a5
 3009c84:	3449                	jal	ra,3009706 <IsPcntIdxInitMode>
 3009c86:	87aa                	mv	a5,a0
 3009c88:	0017c793          	xori	a5,a5,1
 3009c8c:	9f81                	uxtb	a5
 3009c8e:	cb89                	beqz	a5,3009ca0 <QDM_CounterConfig+0xba>
 3009c90:	04d00593          	li	a1,77
 3009c94:	030127b7          	lui	a5,0x3012
 3009c98:	da078513          	addi	a0,a5,-608 # 3011da0 <g_crgIpMatch+0x508>
 3009c9c:	2c05                	jal	ra,3009ecc <AssertErrorLog.trans.7>
 3009c9e:	aa15                	j	3009dd2 <QDM_CounterConfig+0x1ec>
    QDM_PARAM_CHECK_NO_RET(IsTsuPrescaler(qdmHandle->tsuPrescaler));
 3009ca0:	fec42783          	lw	a5,-20(s0)
 3009ca4:	5fdc                	lw	a5,60(a5)
 3009ca6:	853e                	mv	a0,a5
 3009ca8:	3c69                	jal	ra,3009742 <IsTsuPrescaler>
 3009caa:	87aa                	mv	a5,a0
 3009cac:	0017c793          	xori	a5,a5,1
 3009cb0:	9f81                	uxtb	a5
 3009cb2:	cb89                	beqz	a5,3009cc4 <QDM_CounterConfig+0xde>
 3009cb4:	04e00593          	li	a1,78
 3009cb8:	030127b7          	lui	a5,0x3012
 3009cbc:	da078513          	addi	a0,a5,-608 # 3011da0 <g_crgIpMatch+0x508>
 3009cc0:	2431                	jal	ra,3009ecc <AssertErrorLog.trans.7>
 3009cc2:	aa01                	j	3009dd2 <QDM_CounterConfig+0x1ec>
    QDM_PARAM_CHECK_NO_RET(IsCevtPrescaler(qdmHandle->cevtPrescaler));
 3009cc4:	fec42783          	lw	a5,-20(s0)
 3009cc8:	43bc                	lw	a5,64(a5)
 3009cca:	853e                	mv	a0,a5
 3009ccc:	34d5                	jal	ra,30097b0 <IsCevtPrescaler>
 3009cce:	87aa                	mv	a5,a0
 3009cd0:	0017c793          	xori	a5,a5,1
 3009cd4:	9f81                	uxtb	a5
 3009cd6:	cb89                	beqz	a5,3009ce8 <QDM_CounterConfig+0x102>
 3009cd8:	04f00593          	li	a1,79
 3009cdc:	030127b7          	lui	a5,0x3012
 3009ce0:	da078513          	addi	a0,a5,-608 # 3011da0 <g_crgIpMatch+0x508>
 3009ce4:	22e5                	jal	ra,3009ecc <AssertErrorLog.trans.7>
 3009ce6:	a0f5                	j	3009dd2 <QDM_CounterConfig+0x1ec>

    /* set pcnt mode */
    qdmHandle->baseAddress->QPPUCTRL.BIT.pcnt_mode = qdmHandle->pcntMode;
 3009ce8:	fec42783          	lw	a5,-20(s0)
 3009cec:	57d4                	lw	a3,44(a5)
 3009cee:	fec42783          	lw	a5,-20(s0)
 3009cf2:	4398                	lw	a4,0(a5)
 3009cf4:	87b6                	mv	a5,a3
 3009cf6:	8b8d                	andi	a5,a5,3
 3009cf8:	0ff7f693          	andi	a3,a5,255
 3009cfc:	475c                	lw	a5,12(a4)
 3009cfe:	8a8d                	andi	a3,a3,3
 3009d00:	06ea                	slli	a3,a3,0x1a
 3009d02:	f4000637          	lui	a2,0xf4000
 3009d06:	167d                	addi	a2,a2,-1 # f3ffffff <RAM_END+0xefff7fff>
 3009d08:	8ff1                	and	a5,a5,a2
 3009d0a:	8fd5                	or	a5,a5,a3
 3009d0c:	c75c                	sw	a5,12(a4)
    qdmHandle->baseAddress->QPPUCTRL.BIT.pcnt_rst_mode = qdmHandle->pcntRstMode;
 3009d0e:	fec42783          	lw	a5,-20(s0)
 3009d12:	5b94                	lw	a3,48(a5)
 3009d14:	fec42783          	lw	a5,-20(s0)
 3009d18:	4398                	lw	a4,0(a5)
 3009d1a:	87b6                	mv	a5,a3
 3009d1c:	8b8d                	andi	a5,a5,3
 3009d1e:	0ff7f693          	andi	a3,a5,255
 3009d22:	475c                	lw	a5,12(a4)
 3009d24:	8a8d                	andi	a3,a3,3
 3009d26:	06e2                	slli	a3,a3,0x18
 3009d28:	fd000637          	lui	a2,0xfd000
 3009d2c:	167d                	addi	a2,a2,-1 # fcffffff <RAM_END+0xf8ff7fff>
 3009d2e:	8ff1                	and	a5,a5,a2
 3009d30:	8fd5                	or	a5,a5,a3
 3009d32:	c75c                	sw	a5,12(a4)
    qdmHandle->baseAddress->QPPUCTRL.BIT.pcnt_idx_init_mode = qdmHandle->pcntIdxInitMode;
 3009d34:	fec42783          	lw	a5,-20(s0)
 3009d38:	5bd4                	lw	a3,52(a5)
 3009d3a:	fec42783          	lw	a5,-20(s0)
 3009d3e:	4398                	lw	a4,0(a5)
 3009d40:	87b6                	mv	a5,a3
 3009d42:	8b8d                	andi	a5,a5,3
 3009d44:	0ff7f693          	andi	a3,a5,255
 3009d48:	475c                	lw	a5,12(a4)
 3009d4a:	8a8d                	andi	a3,a3,3
 3009d4c:	06da                	slli	a3,a3,0x16
 3009d4e:	ff400637          	lui	a2,0xff400
 3009d52:	167d                	addi	a2,a2,-1 # ff3fffff <RAM_END+0xfb3f7fff>
 3009d54:	8ff1                	and	a5,a5,a2
 3009d56:	8fd5                	or	a5,a5,a3
 3009d58:	c75c                	sw	a5,12(a4)
    /* set TSU */
    qdmHandle->baseAddress->QTSUCTRL.BIT.tsu_prescaler = qdmHandle->tsuPrescaler;
 3009d5a:	fec42783          	lw	a5,-20(s0)
 3009d5e:	5fd4                	lw	a3,60(a5)
 3009d60:	fec42783          	lw	a5,-20(s0)
 3009d64:	4398                	lw	a4,0(a5)
 3009d66:	87b6                	mv	a5,a3
 3009d68:	8bbd                	andi	a5,a5,15
 3009d6a:	0ff7f693          	andi	a3,a5,255
 3009d6e:	4b1c                	lw	a5,16(a4)
 3009d70:	8abd                	andi	a3,a3,15
 3009d72:	0692                	slli	a3,a3,0x4
 3009d74:	f0f7f793          	andi	a5,a5,-241
 3009d78:	8fd5                	or	a5,a5,a3
 3009d7a:	cb1c                	sw	a5,16(a4)
    qdmHandle->baseAddress->QTSUCTRL.BIT.cevt_prescaler = qdmHandle->cevtPrescaler;
 3009d7c:	fec42783          	lw	a5,-20(s0)
 3009d80:	43b4                	lw	a3,64(a5)
 3009d82:	fec42783          	lw	a5,-20(s0)
 3009d86:	4398                	lw	a4,0(a5)
 3009d88:	87b6                	mv	a5,a3
 3009d8a:	8bbd                	andi	a5,a5,15
 3009d8c:	0ff7f693          	andi	a3,a5,255
 3009d90:	4b1c                	lw	a5,16(a4)
 3009d92:	8abd                	andi	a3,a3,15
 3009d94:	9bc1                	andi	a5,a5,-16
 3009d96:	8fd5                	or	a5,a5,a3
 3009d98:	cb1c                	sw	a5,16(a4)
    /* set init value */
    qdmHandle->baseAddress->QPOSINIT = qdmHandle->posInit;
 3009d9a:	fec42783          	lw	a5,-20(s0)
 3009d9e:	439c                	lw	a5,0(a5)
 3009da0:	fec42703          	lw	a4,-20(s0)
 3009da4:	4378                	lw	a4,68(a4)
 3009da6:	d7d8                	sw	a4,44(a5)
    /* set count max value */
    qdmHandle->baseAddress->QPOSMAX  = qdmHandle->posMax;
 3009da8:	fec42783          	lw	a5,-20(s0)
 3009dac:	439c                	lw	a5,0(a5)
 3009dae:	fec42703          	lw	a4,-20(s0)
 3009db2:	4738                	lw	a4,72(a4)
 3009db4:	db98                	sw	a4,48(a5)
    qdmHandle->baseAddress->QUPRD    = qdmHandle->period;
 3009db6:	fec42783          	lw	a5,-20(s0)
 3009dba:	439c                	lw	a5,0(a5)
 3009dbc:	fec42703          	lw	a4,-20(s0)
 3009dc0:	4b38                	lw	a4,80(a4)
 3009dc2:	c3f8                	sw	a4,68(a5)
    qdmHandle->baseAddress->QCMAX = qdmHandle->qcMax;
 3009dc4:	fec42783          	lw	a5,-20(s0)
 3009dc8:	439c                	lw	a5,0(a5)
 3009dca:	fec42703          	lw	a4,-20(s0)
 3009dce:	4778                	lw	a4,76(a4)
 3009dd0:	c7f8                	sw	a4,76(a5)
}
 3009dd2:	40f2                	lw	ra,28(sp)
 3009dd4:	4462                	lw	s0,24(sp)
 3009dd6:	6105                	addi	sp,sp,32
 3009dd8:	8082                	ret

03009dda <QDM_EnableSubmodule>:
  * @brief enable submodules
  * @param qdmHandle Value of @ref QDM_Handle.
  * @retval None
  */
static void QDM_EnableSubmodule(QDM_Handle *qdmHandle)
{
 3009dda:	1101                	addi	sp,sp,-32
 3009ddc:	ce06                	sw	ra,28(sp)
 3009dde:	cc22                	sw	s0,24(sp)
 3009de0:	1000                	addi	s0,sp,32
 3009de2:	fea42623          	sw	a0,-20(s0)
    QDM_ASSERT_PARAM(qdmHandle != NULL);
 3009de6:	fec42783          	lw	a5,-20(s0)
 3009dea:	eb89                	bnez	a5,3009dfc <QDM_EnableSubmodule+0x22>
 3009dec:	06700593          	li	a1,103
 3009df0:	030127b7          	lui	a5,0x3012
 3009df4:	da078513          	addi	a0,a5,-608 # 3011da0 <g_crgIpMatch+0x508>
 3009df8:	28d1                	jal	ra,3009ecc <AssertErrorLog.trans.7>
 3009dfa:	a001                	j	3009dfa <QDM_EnableSubmodule+0x20>
    QDM_ASSERT_PARAM(IsQDMInstance(qdmHandle->baseAddress));
 3009dfc:	fec42783          	lw	a5,-20(s0)
 3009e00:	4398                	lw	a4,0(a5)
 3009e02:	14c007b7          	lui	a5,0x14c00
 3009e06:	02f70163          	beq	a4,a5,3009e28 <QDM_EnableSubmodule+0x4e>
 3009e0a:	fec42783          	lw	a5,-20(s0)
 3009e0e:	4398                	lw	a4,0(a5)
 3009e10:	14c017b7          	lui	a5,0x14c01
 3009e14:	00f70a63          	beq	a4,a5,3009e28 <QDM_EnableSubmodule+0x4e>
 3009e18:	06800593          	li	a1,104
 3009e1c:	030127b7          	lui	a5,0x3012
 3009e20:	da078513          	addi	a0,a5,-608 # 3011da0 <g_crgIpMatch+0x508>
 3009e24:	2065                	jal	ra,3009ecc <AssertErrorLog.trans.7>
 3009e26:	a001                	j	3009e26 <QDM_EnableSubmodule+0x4c>
    if (qdmHandle->subModeEn == true) {
 3009e28:	fec42783          	lw	a5,-20(s0)
 3009e2c:	0387c783          	lbu	a5,56(a5)
 3009e30:	c795                	beqz	a5,3009e5c <QDM_EnableSubmodule+0x82>
        qdmHandle->baseAddress->QCTRL.BIT.ppu_en = BASE_CFG_ENABLE;
 3009e32:	fec42783          	lw	a5,-20(s0)
 3009e36:	4398                	lw	a4,0(a5)
 3009e38:	471c                	lw	a5,8(a4)
 3009e3a:	0027e793          	ori	a5,a5,2
 3009e3e:	c71c                	sw	a5,8(a4)
        qdmHandle->baseAddress->QCTRL.BIT.ptu_en = BASE_CFG_ENABLE;
 3009e40:	fec42783          	lw	a5,-20(s0)
 3009e44:	4398                	lw	a4,0(a5)
 3009e46:	471c                	lw	a5,8(a4)
 3009e48:	0017e793          	ori	a5,a5,1
 3009e4c:	c71c                	sw	a5,8(a4)
        qdmHandle->baseAddress->QCTRL.BIT.tsu_en = BASE_CFG_ENABLE;
 3009e4e:	fec42783          	lw	a5,-20(s0)
 3009e52:	4398                	lw	a4,0(a5)
 3009e54:	471c                	lw	a5,8(a4)
 3009e56:	0047e793          	ori	a5,a5,4
 3009e5a:	c71c                	sw	a5,8(a4)
    }
}
 3009e5c:	0001                	nop
 3009e5e:	40f2                	lw	ra,28(sp)
 3009e60:	4462                	lw	s0,24(sp)
 3009e62:	6105                	addi	sp,sp,32
 3009e64:	8082                	ret

03009e66 <QDM_InterruptEnable>:
  * @brief enable interrupt
  * @param qdmHandle Value of @ref QDM_Handle.
  * @retval None
  */
static void QDM_InterruptEnable(QDM_Handle *qdmHandle)
{
 3009e66:	1101                	addi	sp,sp,-32
 3009e68:	ce06                	sw	ra,28(sp)
 3009e6a:	cc22                	sw	s0,24(sp)
 3009e6c:	1000                	addi	s0,sp,32
 3009e6e:	fea42623          	sw	a0,-20(s0)
    QDM_ASSERT_PARAM(qdmHandle != NULL);
 3009e72:	fec42783          	lw	a5,-20(s0)
 3009e76:	eb89                	bnez	a5,3009e88 <QDM_InterruptEnable+0x22>
 3009e78:	07700593          	li	a1,119
 3009e7c:	030127b7          	lui	a5,0x3012
 3009e80:	da078513          	addi	a0,a5,-608 # 3011da0 <g_crgIpMatch+0x508>
 3009e84:	20a1                	jal	ra,3009ecc <AssertErrorLog.trans.7>
 3009e86:	a001                	j	3009e86 <QDM_InterruptEnable+0x20>
    QDM_ASSERT_PARAM(IsQDMInstance(qdmHandle->baseAddress));
 3009e88:	fec42783          	lw	a5,-20(s0)
 3009e8c:	4398                	lw	a4,0(a5)
 3009e8e:	14c007b7          	lui	a5,0x14c00
 3009e92:	02f70163          	beq	a4,a5,3009eb4 <QDM_InterruptEnable+0x4e>
 3009e96:	fec42783          	lw	a5,-20(s0)
 3009e9a:	4398                	lw	a4,0(a5)
 3009e9c:	14c017b7          	lui	a5,0x14c01
 3009ea0:	00f70a63          	beq	a4,a5,3009eb4 <QDM_InterruptEnable+0x4e>
 3009ea4:	07800593          	li	a1,120
 3009ea8:	030127b7          	lui	a5,0x3012
 3009eac:	da078513          	addi	a0,a5,-608 # 3011da0 <g_crgIpMatch+0x508>
 3009eb0:	2831                	jal	ra,3009ecc <AssertErrorLog.trans.7>
 3009eb2:	a001                	j	3009eb2 <QDM_InterruptEnable+0x4c>
    qdmHandle->baseAddress->QINTENA.reg = qdmHandle->interruptEn;
 3009eb4:	fec42783          	lw	a5,-20(s0)
 3009eb8:	439c                	lw	a5,0(a5)
 3009eba:	fec42703          	lw	a4,-20(s0)
 3009ebe:	4b78                	lw	a4,84(a4)
 3009ec0:	cbd8                	sw	a4,20(a5)
}
 3009ec2:	0001                	nop
 3009ec4:	40f2                	lw	ra,28(sp)
 3009ec6:	4462                	lw	s0,24(sp)
 3009ec8:	6105                	addi	sp,sp,32
 3009eca:	8082                	ret

03009ecc <AssertErrorLog.trans.7>:
 3009ecc:	e87f806f          	j	3002d52 <AssertErrorLog>

03009ed0 <SpeedLose>:
 * @brief Speed lose interrupt.
 * @param qdmHandle Value of @ref QDM_Handle.
 * @retval None
 */
static void SpeedLose(QDM_Handle *qdmHandle)
{
 3009ed0:	1101                	addi	sp,sp,-32
 3009ed2:	ce06                	sw	ra,28(sp)
 3009ed4:	cc22                	sw	s0,24(sp)
 3009ed6:	1000                	addi	s0,sp,32
 3009ed8:	fea42623          	sw	a0,-20(s0)
    if (qdmHandle->userCallBack.SpeedLoseCallback != NULL) {
 3009edc:	fec42783          	lw	a5,-20(s0)
 3009ee0:	57bc                	lw	a5,104(a5)
 3009ee2:	c799                	beqz	a5,3009ef0 <SpeedLose+0x20>
        qdmHandle->userCallBack.SpeedLoseCallback(qdmHandle);
 3009ee4:	fec42783          	lw	a5,-20(s0)
 3009ee8:	57bc                	lw	a5,104(a5)
 3009eea:	fec42503          	lw	a0,-20(s0)
 3009eee:	9782                	jalr	a5
    }
}
 3009ef0:	0001                	nop
 3009ef2:	40f2                	lw	ra,28(sp)
 3009ef4:	4462                	lw	s0,24(sp)
 3009ef6:	6105                	addi	sp,sp,32
 3009ef8:	8082                	ret

03009efa <ZIndexLock>:
 * @brief QDM Z index lock interrupt.
 * @param qdmHandle Value of @ref QDM_Handle.
 * @retval None
 */
static void ZIndexLock(QDM_Handle *qdmHandle)
{
 3009efa:	1101                	addi	sp,sp,-32
 3009efc:	ce06                	sw	ra,28(sp)
 3009efe:	cc22                	sw	s0,24(sp)
 3009f00:	1000                	addi	s0,sp,32
 3009f02:	fea42623          	sw	a0,-20(s0)
    if (qdmHandle->userCallBack.ZIndexLockedCallBack != NULL) {
 3009f06:	fec42783          	lw	a5,-20(s0)
 3009f0a:	57fc                	lw	a5,108(a5)
 3009f0c:	c799                	beqz	a5,3009f1a <ZIndexLock+0x20>
        qdmHandle->userCallBack.ZIndexLockedCallBack(qdmHandle);
 3009f0e:	fec42783          	lw	a5,-20(s0)
 3009f12:	57fc                	lw	a5,108(a5)
 3009f14:	fec42503          	lw	a0,-20(s0)
 3009f18:	9782                	jalr	a5
    }
}
 3009f1a:	0001                	nop
 3009f1c:	40f2                	lw	ra,28(sp)
 3009f1e:	4462                	lw	s0,24(sp)
 3009f20:	6105                	addi	sp,sp,32
 3009f22:	8082                	ret

03009f24 <OrthoDirChange>:
 * @brief Orthogonal direction change interrupt.
 * @param qdmHandle Value of @ref QDM_Handle.
 * @retval None
 */
static void OrthoDirChange(QDM_Handle *qdmHandle)
{
 3009f24:	1101                	addi	sp,sp,-32
 3009f26:	ce06                	sw	ra,28(sp)
 3009f28:	cc22                	sw	s0,24(sp)
 3009f2a:	1000                	addi	s0,sp,32
 3009f2c:	fea42623          	sw	a0,-20(s0)
    if (qdmHandle->userCallBack.OrthogonalDirectionChangeCallBack != NULL) {
 3009f30:	fec42783          	lw	a5,-20(s0)
 3009f34:	0807a783          	lw	a5,128(a5)
 3009f38:	cb81                	beqz	a5,3009f48 <OrthoDirChange+0x24>
        qdmHandle->userCallBack.OrthogonalDirectionChangeCallBack(qdmHandle);
 3009f3a:	fec42783          	lw	a5,-20(s0)
 3009f3e:	0807a783          	lw	a5,128(a5)
 3009f42:	fec42503          	lw	a0,-20(s0)
 3009f46:	9782                	jalr	a5
    }
}
 3009f48:	0001                	nop
 3009f4a:	40f2                	lw	ra,28(sp)
 3009f4c:	4462                	lw	s0,24(sp)
 3009f4e:	6105                	addi	sp,sp,32
 3009f50:	8082                	ret

03009f52 <OrthoPhaseErr>:
 * @brief Orthogonal phase error interrupt.
 * @param qdmHandle Value of @ref QDM_Handle.
 * @retval None
 */
static void OrthoPhaseErr(QDM_Handle *qdmHandle)
{
 3009f52:	1101                	addi	sp,sp,-32
 3009f54:	ce06                	sw	ra,28(sp)
 3009f56:	cc22                	sw	s0,24(sp)
 3009f58:	1000                	addi	s0,sp,32
 3009f5a:	fea42623          	sw	a0,-20(s0)
    if (qdmHandle->userCallBack.OrthogonalPhaseErrorCallBack != NULL) {
 3009f5e:	fec42783          	lw	a5,-20(s0)
 3009f62:	0847a783          	lw	a5,132(a5)
 3009f66:	cb81                	beqz	a5,3009f76 <OrthoPhaseErr+0x24>
        qdmHandle->userCallBack.OrthogonalPhaseErrorCallBack(qdmHandle);
 3009f68:	fec42783          	lw	a5,-20(s0)
 3009f6c:	0847a783          	lw	a5,132(a5)
 3009f70:	fec42503          	lw	a0,-20(s0)
 3009f74:	9782                	jalr	a5
    }
}
 3009f76:	0001                	nop
 3009f78:	40f2                	lw	ra,28(sp)
 3009f7a:	4462                	lw	s0,24(sp)
 3009f7c:	6105                	addi	sp,sp,32
 3009f7e:	8082                	ret

03009f80 <PosCompareMatch>:
 * @brief Position compare match interrupt.
 * @param qdmHandle Value of @ref QDM_Handle.
 * @retval None
 */
static void PosCompareMatch(QDM_Handle *qdmHandle)
{
 3009f80:	1101                	addi	sp,sp,-32
 3009f82:	ce06                	sw	ra,28(sp)
 3009f84:	cc22                	sw	s0,24(sp)
 3009f86:	1000                	addi	s0,sp,32
 3009f88:	fea42623          	sw	a0,-20(s0)
    if (qdmHandle->userCallBack.PositionCompareMatchCallBack != NULL) {
 3009f8c:	fec42783          	lw	a5,-20(s0)
 3009f90:	5bbc                	lw	a5,112(a5)
 3009f92:	c799                	beqz	a5,3009fa0 <PosCompareMatch+0x20>
        qdmHandle->userCallBack.PositionCompareMatchCallBack(qdmHandle);
 3009f94:	fec42783          	lw	a5,-20(s0)
 3009f98:	5bbc                	lw	a5,112(a5)
 3009f9a:	fec42503          	lw	a0,-20(s0)
 3009f9e:	9782                	jalr	a5
    }
}
 3009fa0:	0001                	nop
 3009fa2:	40f2                	lw	ra,28(sp)
 3009fa4:	4462                	lw	s0,24(sp)
 3009fa6:	6105                	addi	sp,sp,32
 3009fa8:	8082                	ret

03009faa <PosCompareReady>:
 * @brief Position compare ready interrupt.
 * @param qdmHandle Value of @ref QDM_Handle.
 * @retval None
 */
static void PosCompareReady(QDM_Handle *qdmHandle)
{
 3009faa:	1101                	addi	sp,sp,-32
 3009fac:	ce06                	sw	ra,28(sp)
 3009fae:	cc22                	sw	s0,24(sp)
 3009fb0:	1000                	addi	s0,sp,32
 3009fb2:	fea42623          	sw	a0,-20(s0)
    if (qdmHandle->userCallBack.PositionCompareReadyCallBack != NULL) {
 3009fb6:	fec42783          	lw	a5,-20(s0)
 3009fba:	5bfc                	lw	a5,116(a5)
 3009fbc:	c799                	beqz	a5,3009fca <PosCompareReady+0x20>
        qdmHandle->userCallBack.PositionCompareReadyCallBack(qdmHandle);
 3009fbe:	fec42783          	lw	a5,-20(s0)
 3009fc2:	5bfc                	lw	a5,116(a5)
 3009fc4:	fec42503          	lw	a0,-20(s0)
 3009fc8:	9782                	jalr	a5
    }
}
 3009fca:	0001                	nop
 3009fcc:	40f2                	lw	ra,28(sp)
 3009fce:	4462                	lw	s0,24(sp)
 3009fd0:	6105                	addi	sp,sp,32
 3009fd2:	8082                	ret

03009fd4 <PosCounterErr>:
 * @brief Position counter error interrupt.
 * @param qdmHandle Value of @ref QDM_Handle.
 * @retval None
 */
static void PosCounterErr(QDM_Handle *qdmHandle)
{
 3009fd4:	1101                	addi	sp,sp,-32
 3009fd6:	ce06                	sw	ra,28(sp)
 3009fd8:	cc22                	sw	s0,24(sp)
 3009fda:	1000                	addi	s0,sp,32
 3009fdc:	fea42623          	sw	a0,-20(s0)
    if (qdmHandle->userCallBack.PositionCounterErrorCallBack != NULL) {
 3009fe0:	fec42783          	lw	a5,-20(s0)
 3009fe4:	0887a783          	lw	a5,136(a5)
 3009fe8:	cb81                	beqz	a5,3009ff8 <PosCounterErr+0x24>
        qdmHandle->userCallBack.PositionCounterErrorCallBack(qdmHandle);
 3009fea:	fec42783          	lw	a5,-20(s0)
 3009fee:	0887a783          	lw	a5,136(a5)
 3009ff2:	fec42503          	lw	a0,-20(s0)
 3009ff6:	9782                	jalr	a5
    }
}
 3009ff8:	0001                	nop
 3009ffa:	40f2                	lw	ra,28(sp)
 3009ffc:	4462                	lw	s0,24(sp)
 3009ffe:	6105                	addi	sp,sp,32
 300a000:	8082                	ret

0300a002 <PosCounterOverflow>:
 * @brief Position counter overflow interrupt.
 * @param qdmHandle Value of @ref QDM_Handle.
 * @retval None
 */
static void PosCounterOverflow(QDM_Handle *qdmHandle)
{
 300a002:	1101                	addi	sp,sp,-32
 300a004:	ce06                	sw	ra,28(sp)
 300a006:	cc22                	sw	s0,24(sp)
 300a008:	1000                	addi	s0,sp,32
 300a00a:	fea42623          	sw	a0,-20(s0)
    if (qdmHandle->userCallBack.PositionCounterOverflowCallBack != NULL) {
 300a00e:	fec42783          	lw	a5,-20(s0)
 300a012:	5fbc                	lw	a5,120(a5)
 300a014:	c799                	beqz	a5,300a022 <PosCounterOverflow+0x20>
        qdmHandle->userCallBack.PositionCounterOverflowCallBack(qdmHandle);
 300a016:	fec42783          	lw	a5,-20(s0)
 300a01a:	5fbc                	lw	a5,120(a5)
 300a01c:	fec42503          	lw	a0,-20(s0)
 300a020:	9782                	jalr	a5
    }
}
 300a022:	0001                	nop
 300a024:	40f2                	lw	ra,28(sp)
 300a026:	4462                	lw	s0,24(sp)
 300a028:	6105                	addi	sp,sp,32
 300a02a:	8082                	ret

0300a02c <PosCounterUnderflow>:
 * @brief Position counter underflow interrupt.
 * @param qdmHandle Value of @ref QDM_Handle.
 * @retval None
 */
static void PosCounterUnderflow(QDM_Handle *qdmHandle)
{
 300a02c:	1101                	addi	sp,sp,-32
 300a02e:	ce06                	sw	ra,28(sp)
 300a030:	cc22                	sw	s0,24(sp)
 300a032:	1000                	addi	s0,sp,32
 300a034:	fea42623          	sw	a0,-20(s0)
    if (qdmHandle->userCallBack.PositionCounterUnderflowCallBack != NULL) {
 300a038:	fec42783          	lw	a5,-20(s0)
 300a03c:	5ffc                	lw	a5,124(a5)
 300a03e:	c799                	beqz	a5,300a04c <PosCounterUnderflow+0x20>
        qdmHandle->userCallBack.PositionCounterUnderflowCallBack(qdmHandle);
 300a040:	fec42783          	lw	a5,-20(s0)
 300a044:	5ffc                	lw	a5,124(a5)
 300a046:	fec42503          	lw	a0,-20(s0)
 300a04a:	9782                	jalr	a5
    }
}
 300a04c:	0001                	nop
 300a04e:	40f2                	lw	ra,28(sp)
 300a050:	4462                	lw	s0,24(sp)
 300a052:	6105                	addi	sp,sp,32
 300a054:	8082                	ret

0300a056 <OtherInterruptCallBack>:
 * @param qdmHandle Value of @ref QDM_Handle.
 * @param qinsts: Interrupt status register.
 * @retval None
 */
static void OtherInterruptCallBack(QDM_Handle *qdmHandle, QDM_QINTSTS_REG qinsts)
{
 300a056:	1101                	addi	sp,sp,-32
 300a058:	ce06                	sw	ra,28(sp)
 300a05a:	cc22                	sw	s0,24(sp)
 300a05c:	1000                	addi	s0,sp,32
 300a05e:	fea42623          	sw	a0,-20(s0)
 300a062:	feb42423          	sw	a1,-24(s0)
    if (qinsts.BIT.qphs_err_int == BASE_CFG_SET) {
 300a066:	fe842783          	lw	a5,-24(s0)
 300a06a:	8385                	srli	a5,a5,0x1
 300a06c:	8b85                	andi	a5,a5,1
 300a06e:	0ff7f713          	andi	a4,a5,255
 300a072:	4785                	li	a5,1
 300a074:	00f71c63          	bne	a4,a5,300a08c <OtherInterruptCallBack+0x36>
        /* Orthogonal phase error interrupt. */
        OrthoPhaseErr(qdmHandle);
 300a078:	fec42503          	lw	a0,-20(s0)
 300a07c:	3dd9                	jal	ra,3009f52 <OrthoPhaseErr>
        qdmHandle->baseAddress->QINTRAW.BIT.qphs_err_raw = BASE_CFG_ENABLE;
 300a07e:	fec42783          	lw	a5,-20(s0)
 300a082:	4398                	lw	a4,0(a5)
 300a084:	4f5c                	lw	a5,28(a4)
 300a086:	0027e793          	ori	a5,a5,2
 300a08a:	cf5c                	sw	a5,28(a4)
    }
    if (qinsts.BIT.pcnt_cpm_int == BASE_CFG_SET) {
 300a08c:	fe842783          	lw	a5,-24(s0)
 300a090:	839d                	srli	a5,a5,0x7
 300a092:	8b85                	andi	a5,a5,1
 300a094:	0ff7f713          	andi	a4,a5,255
 300a098:	4785                	li	a5,1
 300a09a:	00f71c63          	bne	a4,a5,300a0b2 <OtherInterruptCallBack+0x5c>
        /* Position compare match interrupt. */
        PosCompareMatch(qdmHandle);
 300a09e:	fec42503          	lw	a0,-20(s0)
 300a0a2:	3df9                	jal	ra,3009f80 <PosCompareMatch>
        qdmHandle->baseAddress->QINTRAW.BIT.pcnt_cpm_raw = BASE_CFG_ENABLE;
 300a0a4:	fec42783          	lw	a5,-20(s0)
 300a0a8:	4398                	lw	a4,0(a5)
 300a0aa:	4f5c                	lw	a5,28(a4)
 300a0ac:	0807e793          	ori	a5,a5,128
 300a0b0:	cf5c                	sw	a5,28(a4)
    }
    if (qinsts.BIT.pcnt_cpr_int == BASE_CFG_SET) {
 300a0b2:	fe842783          	lw	a5,-24(s0)
 300a0b6:	8399                	srli	a5,a5,0x6
 300a0b8:	8b85                	andi	a5,a5,1
 300a0ba:	0ff7f713          	andi	a4,a5,255
 300a0be:	4785                	li	a5,1
 300a0c0:	00f71c63          	bne	a4,a5,300a0d8 <OtherInterruptCallBack+0x82>
        /* Position compare ready interrupt. */
        PosCompareReady(qdmHandle);
 300a0c4:	fec42503          	lw	a0,-20(s0)
 300a0c8:	35cd                	jal	ra,3009faa <PosCompareReady>
        qdmHandle->baseAddress->QINTRAW.BIT.pcnt_cpr_raw = BASE_CFG_ENABLE;
 300a0ca:	fec42783          	lw	a5,-20(s0)
 300a0ce:	4398                	lw	a4,0(a5)
 300a0d0:	4f5c                	lw	a5,28(a4)
 300a0d2:	0407e793          	ori	a5,a5,64
 300a0d6:	cf5c                	sw	a5,28(a4)
    }
    if (qinsts.BIT.pcnt_err_int == BASE_CFG_SET) {
 300a0d8:	fe842783          	lw	a5,-24(s0)
 300a0dc:	8b85                	andi	a5,a5,1
 300a0de:	0ff7f713          	andi	a4,a5,255
 300a0e2:	4785                	li	a5,1
 300a0e4:	00f71c63          	bne	a4,a5,300a0fc <OtherInterruptCallBack+0xa6>
        /* Position counter error interrupt. */
        PosCounterErr(qdmHandle);
 300a0e8:	fec42503          	lw	a0,-20(s0)
 300a0ec:	35e5                	jal	ra,3009fd4 <PosCounterErr>
        qdmHandle->baseAddress->QINTRAW.BIT.pcnt_err_raw = BASE_CFG_ENABLE;
 300a0ee:	fec42783          	lw	a5,-20(s0)
 300a0f2:	4398                	lw	a4,0(a5)
 300a0f4:	4f5c                	lw	a5,28(a4)
 300a0f6:	0017e793          	ori	a5,a5,1
 300a0fa:	cf5c                	sw	a5,28(a4)
    }
    if (qinsts.BIT.pcnt_ovf_int == BASE_CFG_SET) {
 300a0fc:	fe842783          	lw	a5,-24(s0)
 300a100:	8395                	srli	a5,a5,0x5
 300a102:	8b85                	andi	a5,a5,1
 300a104:	0ff7f713          	andi	a4,a5,255
 300a108:	4785                	li	a5,1
 300a10a:	00f71c63          	bne	a4,a5,300a122 <OtherInterruptCallBack+0xcc>
        /* Position counter overflow interrupt. */
        PosCounterOverflow(qdmHandle);
 300a10e:	fec42503          	lw	a0,-20(s0)
 300a112:	3dc5                	jal	ra,300a002 <PosCounterOverflow>
        qdmHandle->baseAddress->QINTRAW.BIT.pcnt_ovf_raw = BASE_CFG_ENABLE;
 300a114:	fec42783          	lw	a5,-20(s0)
 300a118:	4398                	lw	a4,0(a5)
 300a11a:	4f5c                	lw	a5,28(a4)
 300a11c:	0207e793          	ori	a5,a5,32
 300a120:	cf5c                	sw	a5,28(a4)
    }
    if (qinsts.BIT.pcnt_udf_int == BASE_CFG_SET) {
 300a122:	fe842783          	lw	a5,-24(s0)
 300a126:	8391                	srli	a5,a5,0x4
 300a128:	8b85                	andi	a5,a5,1
 300a12a:	0ff7f713          	andi	a4,a5,255
 300a12e:	4785                	li	a5,1
 300a130:	00f71c63          	bne	a4,a5,300a148 <OtherInterruptCallBack+0xf2>
        /* Position counter underflow interrupt. */
        PosCounterUnderflow(qdmHandle);
 300a134:	fec42503          	lw	a0,-20(s0)
 300a138:	3dd5                	jal	ra,300a02c <PosCounterUnderflow>
        qdmHandle->baseAddress->QINTRAW.BIT.pcnt_udf_raw = BASE_CFG_ENABLE;
 300a13a:	fec42783          	lw	a5,-20(s0)
 300a13e:	4398                	lw	a4,0(a5)
 300a140:	4f5c                	lw	a5,28(a4)
 300a142:	0107e793          	ori	a5,a5,16
 300a146:	cf5c                	sw	a5,28(a4)
    }
}
 300a148:	0001                	nop
 300a14a:	40f2                	lw	ra,28(sp)
 300a14c:	4462                	lw	s0,24(sp)
 300a14e:	6105                	addi	sp,sp,32
 300a150:	8082                	ret

0300a152 <CalculateSpeed>:
  * @brief M-method speed calculation.
  * @param qdmHandle Value of @ref QDM_Handle.
  * @retval None
  */
static void CalculateSpeed(QDM_Handle *qdmHandle)
{
 300a152:	7179                	addi	sp,sp,-48
 300a154:	d606                	sw	ra,44(sp)
 300a156:	d422                	sw	s0,40(sp)
 300a158:	d226                	sw	s1,36(sp)
 300a15a:	1800                	addi	s0,sp,48
 300a15c:	fca42e23          	sw	a0,-36(s0)
    unsigned int deltaValue, tmp, intFlag;
    /* Last QPOSLOCK value */
    static unsigned int lastPoslockValue = 0;
    int speed;
    deltaValue = qdmHandle->baseAddress->QPOSLOCK;
 300a160:	fdc42783          	lw	a5,-36(s0)
 300a164:	439c                	lw	a5,0(a5)
 300a166:	5fdc                	lw	a5,60(a5)
 300a168:	fef42623          	sw	a5,-20(s0)
    /* The position count reset mode is overflow reset. */
    intFlag = (qdmHandle->baseAddress->QINTSTS.reg & QDM_INT_MASK);
 300a16c:	fdc42783          	lw	a5,-36(s0)
 300a170:	439c                	lw	a5,0(a5)
 300a172:	4f9c                	lw	a5,24(a5)
 300a174:	0387f793          	andi	a5,a5,56
 300a178:	fef42423          	sw	a5,-24(s0)
    if ((qdmHandle->pcntRstMode == QDM_PCNT_RST_OVF) && (intFlag == 0)) {
 300a17c:	fdc42783          	lw	a5,-36(s0)
 300a180:	5b98                	lw	a4,48(a5)
 300a182:	4785                	li	a5,1
 300a184:	00f71f63          	bne	a4,a5,300a1a2 <CalculateSpeed+0x50>
 300a188:	fe842783          	lw	a5,-24(s0)
 300a18c:	eb99                	bnez	a5,300a1a2 <CalculateSpeed+0x50>
        deltaValue = qdmHandle->baseAddress->QPOSLOCK - lastPoslockValue;
 300a18e:	fdc42783          	lw	a5,-36(s0)
 300a192:	439c                	lw	a5,0(a5)
 300a194:	5fd8                	lw	a4,60(a5)
 300a196:	cb21a783          	lw	a5,-846(gp) # 40005bc <lastPoslockValue.3568>
 300a19a:	40f707b3          	sub	a5,a4,a5
 300a19e:	fef42623          	sw	a5,-20(s0)
    }
    lastPoslockValue = qdmHandle->baseAddress->QPOSLOCK;
 300a1a2:	fdc42783          	lw	a5,-36(s0)
 300a1a6:	439c                	lw	a5,0(a5)
 300a1a8:	5fd8                	lw	a4,60(a5)
 300a1aa:	cae1a923          	sw	a4,-846(gp) # 40005bc <lastPoslockValue.3568>
    if (qdmHandle->baseAddress->QDMSTS.BIT.qdir_sts == 1) { /* forward */
 300a1ae:	fdc42783          	lw	a5,-36(s0)
 300a1b2:	439c                	lw	a5,0(a5)
 300a1b4:	53dc                	lw	a5,36(a5)
 300a1b6:	8399                	srli	a5,a5,0x6
 300a1b8:	8b85                	andi	a5,a5,1
 300a1ba:	0ff7f713          	andi	a4,a5,255
 300a1be:	4785                	li	a5,1
 300a1c0:	04f71d63          	bne	a4,a5,300a21a <CalculateSpeed+0xc8>
        tmp = deltaValue >> qdmHandle->baseAddress->QCTRL.BIT.qdu_xclk;
 300a1c4:	fdc42783          	lw	a5,-36(s0)
 300a1c8:	439c                	lw	a5,0(a5)
 300a1ca:	479c                	lw	a5,8(a5)
 300a1cc:	83b1                	srli	a5,a5,0xc
 300a1ce:	8b8d                	andi	a5,a5,3
 300a1d0:	9f81                	uxtb	a5
 300a1d2:	873e                	mv	a4,a5
 300a1d4:	fec42783          	lw	a5,-20(s0)
 300a1d8:	00e7d7b3          	srl	a5,a5,a4
 300a1dc:	fef42223          	sw	a5,-28(s0)
        speed = ((tmp * SECONDS_PER_MINUTES) / qdmHandle->motorLineNum) \
 300a1e0:	fe442703          	lw	a4,-28(s0)
 300a1e4:	03c00793          	li	a5,60
 300a1e8:	02f707b3          	mul	a5,a4,a5
 300a1ec:	fdc42703          	lw	a4,-36(s0)
 300a1f0:	4f38                	lw	a4,88(a4)
 300a1f2:	02e7d4b3          	divu	s1,a5,a4
                * (BASE_FUNC_GetCpuFreqHz() / qdmHandle->period);
 300a1f6:	b87f80ef          	jal	ra,3002d7c <BASE_FUNC_GetCpuFreqHz>
 300a1fa:	872a                	mv	a4,a0
 300a1fc:	fdc42783          	lw	a5,-36(s0)
 300a200:	4bbc                	lw	a5,80(a5)
 300a202:	02f757b3          	divu	a5,a4,a5
 300a206:	02f487b3          	mul	a5,s1,a5
        speed = ((tmp * SECONDS_PER_MINUTES) / qdmHandle->motorLineNum) \
 300a20a:	fef42023          	sw	a5,-32(s0)
        qdmHandle->speedRpm = speed;
 300a20e:	fdc42783          	lw	a5,-36(s0)
 300a212:	fe042703          	lw	a4,-32(s0)
 300a216:	cff8                	sw	a4,92(a5)
        tmp = (qdmHandle->posMax - deltaValue) >> qdmHandle->baseAddress->QCTRL.BIT.qdu_xclk;
        speed = ((tmp * SECONDS_PER_MINUTES) / qdmHandle->motorLineNum) \
                * (BASE_FUNC_GetCpuFreqHz() / qdmHandle->period);
        qdmHandle->speedRpm = -speed;
    }
}
 300a218:	a08d                	j	300a27a <CalculateSpeed+0x128>
        tmp = (qdmHandle->posMax - deltaValue) >> qdmHandle->baseAddress->QCTRL.BIT.qdu_xclk;
 300a21a:	fdc42783          	lw	a5,-36(s0)
 300a21e:	47b8                	lw	a4,72(a5)
 300a220:	fec42783          	lw	a5,-20(s0)
 300a224:	40f707b3          	sub	a5,a4,a5
 300a228:	fdc42703          	lw	a4,-36(s0)
 300a22c:	4318                	lw	a4,0(a4)
 300a22e:	4718                	lw	a4,8(a4)
 300a230:	8331                	srli	a4,a4,0xc
 300a232:	8b0d                	andi	a4,a4,3
 300a234:	9f01                	uxtb	a4
 300a236:	00e7d7b3          	srl	a5,a5,a4
 300a23a:	fef42223          	sw	a5,-28(s0)
        speed = ((tmp * SECONDS_PER_MINUTES) / qdmHandle->motorLineNum) \
 300a23e:	fe442703          	lw	a4,-28(s0)
 300a242:	03c00793          	li	a5,60
 300a246:	02f707b3          	mul	a5,a4,a5
 300a24a:	fdc42703          	lw	a4,-36(s0)
 300a24e:	4f38                	lw	a4,88(a4)
 300a250:	02e7d4b3          	divu	s1,a5,a4
                * (BASE_FUNC_GetCpuFreqHz() / qdmHandle->period);
 300a254:	b29f80ef          	jal	ra,3002d7c <BASE_FUNC_GetCpuFreqHz>
 300a258:	872a                	mv	a4,a0
 300a25a:	fdc42783          	lw	a5,-36(s0)
 300a25e:	4bbc                	lw	a5,80(a5)
 300a260:	02f757b3          	divu	a5,a4,a5
 300a264:	02f487b3          	mul	a5,s1,a5
        speed = ((tmp * SECONDS_PER_MINUTES) / qdmHandle->motorLineNum) \
 300a268:	fef42023          	sw	a5,-32(s0)
        qdmHandle->speedRpm = -speed;
 300a26c:	fe042783          	lw	a5,-32(s0)
 300a270:	40f00733          	neg	a4,a5
 300a274:	fdc42783          	lw	a5,-36(s0)
 300a278:	cff8                	sw	a4,92(a5)
}
 300a27a:	0001                	nop
 300a27c:	50b2                	lw	ra,44(sp)
 300a27e:	5422                	lw	s0,40(sp)
 300a280:	5492                	lw	s1,36(sp)
 300a282:	6145                	addi	sp,sp,48
 300a284:	8082                	ret

0300a286 <HAL_QDM_IrqHandler>:
  * @brief IRQ Handler
  * @param handle: QDM handle.
  * @retval None
  */
void HAL_QDM_IrqHandler(void *handle)
{
 300a286:	7179                	addi	sp,sp,-48
 300a288:	d606                	sw	ra,44(sp)
 300a28a:	d422                	sw	s0,40(sp)
 300a28c:	1800                	addi	s0,sp,48
 300a28e:	fca42e23          	sw	a0,-36(s0)
    QDM_ASSERT_PARAM(handle != NULL);
 300a292:	fdc42783          	lw	a5,-36(s0)
 300a296:	eb89                	bnez	a5,300a2a8 <HAL_QDM_IrqHandler+0x22>
 300a298:	13600593          	li	a1,310
 300a29c:	030127b7          	lui	a5,0x3012
 300a2a0:	da078513          	addi	a0,a5,-608 # 3011da0 <g_crgIpMatch+0x508>
 300a2a4:	3125                	jal	ra,3009ecc <AssertErrorLog.trans.7>
 300a2a6:	a001                	j	300a2a6 <HAL_QDM_IrqHandler+0x20>
    QDM_Handle *qdmHandle = (QDM_Handle *)handle;
 300a2a8:	fdc42783          	lw	a5,-36(s0)
 300a2ac:	fef42623          	sw	a5,-20(s0)
    QDM_ASSERT_PARAM(IsQDMInstance(qdmHandle->baseAddress));
 300a2b0:	fec42783          	lw	a5,-20(s0)
 300a2b4:	4398                	lw	a4,0(a5)
 300a2b6:	14c007b7          	lui	a5,0x14c00
 300a2ba:	02f70163          	beq	a4,a5,300a2dc <HAL_QDM_IrqHandler+0x56>
 300a2be:	fec42783          	lw	a5,-20(s0)
 300a2c2:	4398                	lw	a4,0(a5)
 300a2c4:	14c017b7          	lui	a5,0x14c01
 300a2c8:	00f70a63          	beq	a4,a5,300a2dc <HAL_QDM_IrqHandler+0x56>
 300a2cc:	13800593          	li	a1,312
 300a2d0:	030127b7          	lui	a5,0x3012
 300a2d4:	da078513          	addi	a0,a5,-608 # 3011da0 <g_crgIpMatch+0x508>
 300a2d8:	3ed5                	jal	ra,3009ecc <AssertErrorLog.trans.7>
 300a2da:	a001                	j	300a2da <HAL_QDM_IrqHandler+0x54>


    if (qdmHandle->motorLineNum == 0 || qdmHandle->period == 0) {
 300a2dc:	fec42783          	lw	a5,-20(s0)
 300a2e0:	4fbc                	lw	a5,88(a5)
 300a2e2:	c789                	beqz	a5,300a2ec <HAL_QDM_IrqHandler+0x66>
 300a2e4:	fec42783          	lw	a5,-20(s0)
 300a2e8:	4bbc                	lw	a5,80(a5)
 300a2ea:	e385                	bnez	a5,300a30a <HAL_QDM_IrqHandler+0x84>
        /* clear interrupt */
        qdmHandle->baseAddress->QINTRAW.BIT.sped_lst_raw = BASE_CFG_ENABLE;
 300a2ec:	fec42783          	lw	a5,-20(s0)
 300a2f0:	4398                	lw	a4,0(a5)
 300a2f2:	4f5c                	lw	a5,28(a4)
 300a2f4:	0047e793          	ori	a5,a5,4
 300a2f8:	cf5c                	sw	a5,28(a4)
        qdmHandle->baseAddress->QINTRAW.BIT.utmr_prd_raw = BASE_CFG_ENABLE;
 300a2fa:	fec42783          	lw	a5,-20(s0)
 300a2fe:	4398                	lw	a4,0(a5)
 300a300:	4f5c                	lw	a5,28(a4)
 300a302:	2007e793          	ori	a5,a5,512
 300a306:	cf5c                	sw	a5,28(a4)
        return;
 300a308:	a0d9                	j	300a3ce <HAL_QDM_IrqHandler+0x148>
    }

    QDM_QINTSTS_REG qinsts = qdmHandle->baseAddress->QINTSTS;
 300a30a:	fec42783          	lw	a5,-20(s0)
 300a30e:	439c                	lw	a5,0(a5)
 300a310:	4f9c                	lw	a5,24(a5)
 300a312:	fef42423          	sw	a5,-24(s0)
    if (qinsts.BIT.utmr_prd_int == BASE_CFG_SET) {
 300a316:	fe842783          	lw	a5,-24(s0)
 300a31a:	83a5                	srli	a5,a5,0x9
 300a31c:	8b85                	andi	a5,a5,1
 300a31e:	0ff7f713          	andi	a4,a5,255
 300a322:	4785                	li	a5,1
 300a324:	02f71663          	bne	a4,a5,300a350 <HAL_QDM_IrqHandler+0xca>
        //int temp = qdmHandle->baseAddress->QPOSLOCK;
        //DBG_PRINTF("QPOSLOCK num: %d\r\n", temp);
        //DBG_PRINTF("temp num: %d\r\n", qdmHandle->baseAddress->QUPRD);
        CalculateSpeed(qdmHandle);
 300a328:	fec42503          	lw	a0,-20(s0)
 300a32c:	351d                	jal	ra,300a152 <CalculateSpeed>
        /* PTU timer cycle triggle interrupt */
        if (qdmHandle->userCallBack.PtuCycleTrgCallback != NULL) {
 300a32e:	fec42783          	lw	a5,-20(s0)
 300a332:	53fc                	lw	a5,100(a5)
 300a334:	c799                	beqz	a5,300a342 <HAL_QDM_IrqHandler+0xbc>
            qdmHandle->userCallBack.PtuCycleTrgCallback(qdmHandle);
 300a336:	fec42783          	lw	a5,-20(s0)
 300a33a:	53fc                	lw	a5,100(a5)
 300a33c:	fec42503          	lw	a0,-20(s0)
 300a340:	9782                	jalr	a5
        }
        qdmHandle->baseAddress->QINTRAW.BIT.utmr_prd_raw = BASE_CFG_ENABLE;
 300a342:	fec42783          	lw	a5,-20(s0)
 300a346:	4398                	lw	a4,0(a5)
 300a348:	4f5c                	lw	a5,28(a4)
 300a34a:	2007e793          	ori	a5,a5,512
 300a34e:	cf5c                	sw	a5,28(a4)
    }
    if (qinsts.BIT.sped_lst_int == BASE_CFG_SET) {
 300a350:	fe842783          	lw	a5,-24(s0)
 300a354:	8389                	srli	a5,a5,0x2
 300a356:	8b85                	andi	a5,a5,1
 300a358:	0ff7f713          	andi	a4,a5,255
 300a35c:	4785                	li	a5,1
 300a35e:	00f71c63          	bne	a4,a5,300a376 <HAL_QDM_IrqHandler+0xf0>
        /* speed lose interrupt */
        SpeedLose(qdmHandle);
 300a362:	fec42503          	lw	a0,-20(s0)
 300a366:	36ad                	jal	ra,3009ed0 <SpeedLose>
        qdmHandle->baseAddress->QINTRAW.BIT.sped_lst_raw = BASE_CFG_ENABLE;
 300a368:	fec42783          	lw	a5,-20(s0)
 300a36c:	4398                	lw	a4,0(a5)
 300a36e:	4f5c                	lw	a5,28(a4)
 300a370:	0047e793          	ori	a5,a5,4
 300a374:	cf5c                	sw	a5,28(a4)
    }
    if (qinsts.BIT.indx_lck_int == BASE_CFG_SET) {
 300a376:	fe842783          	lw	a5,-24(s0)
 300a37a:	83a1                	srli	a5,a5,0x8
 300a37c:	8b85                	andi	a5,a5,1
 300a37e:	0ff7f713          	andi	a4,a5,255
 300a382:	4785                	li	a5,1
 300a384:	00f71c63          	bne	a4,a5,300a39c <HAL_QDM_IrqHandler+0x116>
        /* QDM Z index lock interrupt. */
        ZIndexLock(qdmHandle);
 300a388:	fec42503          	lw	a0,-20(s0)
 300a38c:	36bd                	jal	ra,3009efa <ZIndexLock>
        qdmHandle->baseAddress->QINTRAW.BIT.indx_lck_raw = BASE_CFG_ENABLE;
 300a38e:	fec42783          	lw	a5,-20(s0)
 300a392:	4398                	lw	a4,0(a5)
 300a394:	4f5c                	lw	a5,28(a4)
 300a396:	1007e793          	ori	a5,a5,256
 300a39a:	cf5c                	sw	a5,28(a4)
    }
    if (qinsts.BIT.qdir_chg_int == BASE_CFG_SET) {
 300a39c:	fe842783          	lw	a5,-24(s0)
 300a3a0:	838d                	srli	a5,a5,0x3
 300a3a2:	8b85                	andi	a5,a5,1
 300a3a4:	0ff7f713          	andi	a4,a5,255
 300a3a8:	4785                	li	a5,1
 300a3aa:	00f71c63          	bne	a4,a5,300a3c2 <HAL_QDM_IrqHandler+0x13c>
        /* Orthogonal direction change interrupt. */
        OrthoDirChange(qdmHandle);
 300a3ae:	fec42503          	lw	a0,-20(s0)
 300a3b2:	3e8d                	jal	ra,3009f24 <OrthoDirChange>
        qdmHandle->baseAddress->QINTRAW.BIT.qdir_chg_raw = BASE_CFG_ENABLE;
 300a3b4:	fec42783          	lw	a5,-20(s0)
 300a3b8:	4398                	lw	a4,0(a5)
 300a3ba:	4f5c                	lw	a5,28(a4)
 300a3bc:	0087e793          	ori	a5,a5,8
 300a3c0:	cf5c                	sw	a5,28(a4)
    }
    OtherInterruptCallBack(qdmHandle, qinsts);
 300a3c2:	fe842583          	lw	a1,-24(s0)
 300a3c6:	fec42503          	lw	a0,-20(s0)
 300a3ca:	3171                	jal	ra,300a056 <OtherInterruptCallBack>
    return;
 300a3cc:	0001                	nop
}
 300a3ce:	50b2                	lw	ra,44(sp)
 300a3d0:	5422                	lw	s0,40(sp)
 300a3d2:	6145                	addi	sp,sp,48
 300a3d4:	8082                	ret

0300a3d6 <SelectInterruptCallback>:
 * @param typeId: Interrupt type.
 * @param pCallBack: Interrupt callback function.
 * @retval None
 */
static void SelectInterruptCallback(QDM_Handle *qdmHandle, QDM_CallbackFuncType typeID, QDM_CallbackType pCallback)
{
 300a3d6:	1101                	addi	sp,sp,-32
 300a3d8:	ce22                	sw	s0,28(sp)
 300a3da:	1000                	addi	s0,sp,32
 300a3dc:	fea42623          	sw	a0,-20(s0)
 300a3e0:	feb42423          	sw	a1,-24(s0)
 300a3e4:	fec42223          	sw	a2,-28(s0)
    switch (typeID) {
 300a3e8:	fe842703          	lw	a4,-24(s0)
 300a3ec:	47a5                	li	a5,9
 300a3ee:	08e7ec63          	bltu	a5,a4,300a486 <SelectInterruptCallback+0xb0>
 300a3f2:	fe842783          	lw	a5,-24(s0)
 300a3f6:	00279713          	slli	a4,a5,0x2
 300a3fa:	030127b7          	lui	a5,0x3012
 300a3fe:	dbc78793          	addi	a5,a5,-580 # 3011dbc <g_crgIpMatch+0x524>
 300a402:	97ba                	add	a5,a5,a4
 300a404:	439c                	lw	a5,0(a5)
 300a406:	8782                	jr	a5
        case QDM_TSU_CYCLE:
            /* PTU timer cycle triggle interrupt. */
            qdmHandle->userCallBack.PtuCycleTrgCallback = pCallback;
 300a408:	fec42783          	lw	a5,-20(s0)
 300a40c:	fe442703          	lw	a4,-28(s0)
 300a410:	d3f8                	sw	a4,100(a5)
            break;
 300a412:	a89d                	j	300a488 <SelectInterruptCallback+0xb2>
        case QDM_SPEED_LOSE:
            /* Speed lose interrupt. */
            qdmHandle->userCallBack.SpeedLoseCallback = pCallback;
 300a414:	fec42783          	lw	a5,-20(s0)
 300a418:	fe442703          	lw	a4,-28(s0)
 300a41c:	d7b8                	sw	a4,104(a5)
            break;
 300a41e:	a0ad                	j	300a488 <SelectInterruptCallback+0xb2>
        case QDM_INDEX_LOCKED:
            /* QDM Z index lock interrupt. */
            qdmHandle->userCallBack.ZIndexLockedCallBack = pCallback;
 300a420:	fec42783          	lw	a5,-20(s0)
 300a424:	fe442703          	lw	a4,-28(s0)
 300a428:	d7f8                	sw	a4,108(a5)
            break;
 300a42a:	a8b9                	j	300a488 <SelectInterruptCallback+0xb2>
        case QDM_DIR_CHANGE:
            /* Orthogonal direction change interrupt. */
            qdmHandle->userCallBack.OrthogonalDirectionChangeCallBack = pCallback;
 300a42c:	fec42783          	lw	a5,-20(s0)
 300a430:	fe442703          	lw	a4,-28(s0)
 300a434:	08e7a023          	sw	a4,128(a5)
            break;
 300a438:	a881                	j	300a488 <SelectInterruptCallback+0xb2>
        case QDM_PHASE_ERROR:
            /* Orthogonal phase error interrupt. */
            qdmHandle->userCallBack.OrthogonalPhaseErrorCallBack = pCallback;
 300a43a:	fec42783          	lw	a5,-20(s0)
 300a43e:	fe442703          	lw	a4,-28(s0)
 300a442:	08e7a223          	sw	a4,132(a5)
            break;
 300a446:	a089                	j	300a488 <SelectInterruptCallback+0xb2>
        case QDM_POS_MATCH:
            /* Position compare match interrupt. */
            qdmHandle->userCallBack.PositionCompareMatchCallBack = pCallback;
 300a448:	fec42783          	lw	a5,-20(s0)
 300a44c:	fe442703          	lw	a4,-28(s0)
 300a450:	dbb8                	sw	a4,112(a5)
            break;
 300a452:	a81d                	j	300a488 <SelectInterruptCallback+0xb2>
        case QDM_POS_READY:
            /* Position compare ready interrupt. */
            qdmHandle->userCallBack.PositionCompareReadyCallBack = pCallback;
 300a454:	fec42783          	lw	a5,-20(s0)
 300a458:	fe442703          	lw	a4,-28(s0)
 300a45c:	dbf8                	sw	a4,116(a5)
            break;
 300a45e:	a02d                	j	300a488 <SelectInterruptCallback+0xb2>
        case QDM_POS_CNT_ERROR:
            /* Position counter error interrupt. */
            qdmHandle->userCallBack.PositionCounterErrorCallBack = pCallback;
 300a460:	fec42783          	lw	a5,-20(s0)
 300a464:	fe442703          	lw	a4,-28(s0)
 300a468:	08e7a423          	sw	a4,136(a5)
            break;
 300a46c:	a831                	j	300a488 <SelectInterruptCallback+0xb2>
        case QDM_POS_CNT_OVERFLOW:
            /* Position counter overflow interrupt. */
            qdmHandle->userCallBack.PositionCounterOverflowCallBack = pCallback;
 300a46e:	fec42783          	lw	a5,-20(s0)
 300a472:	fe442703          	lw	a4,-28(s0)
 300a476:	dfb8                	sw	a4,120(a5)
            break;
 300a478:	a801                	j	300a488 <SelectInterruptCallback+0xb2>
        case QDM_POS_CNT_UNDERFLOW:
            /* Position counter underflow interrupt. */
            qdmHandle->userCallBack.PositionCounterUnderflowCallBack = pCallback;
 300a47a:	fec42783          	lw	a5,-20(s0)
 300a47e:	fe442703          	lw	a4,-28(s0)
 300a482:	dff8                	sw	a4,124(a5)
            break;
 300a484:	a011                	j	300a488 <SelectInterruptCallback+0xb2>
        default:
            return;
 300a486:	0001                	nop
    }
}
 300a488:	4472                	lw	s0,28(sp)
 300a48a:	6105                	addi	sp,sp,32
 300a48c:	8082                	ret

0300a48e <HAL_QDM_RegisterCallback>:
  * @param typeID: callback function type ID.
  * @param pCallback: pointer of callback function.
  * @retval None
  */
void HAL_QDM_RegisterCallback(QDM_Handle *qdmHandle, QDM_CallbackFuncType typeID, QDM_CallbackType pCallback)
{
 300a48e:	1101                	addi	sp,sp,-32
 300a490:	ce06                	sw	ra,28(sp)
 300a492:	cc22                	sw	s0,24(sp)
 300a494:	1000                	addi	s0,sp,32
 300a496:	fea42623          	sw	a0,-20(s0)
 300a49a:	feb42423          	sw	a1,-24(s0)
 300a49e:	fec42223          	sw	a2,-28(s0)
    QDM_ASSERT_PARAM(qdmHandle != NULL);
 300a4a2:	fec42783          	lw	a5,-20(s0)
 300a4a6:	eb89                	bnez	a5,300a4b8 <HAL_QDM_RegisterCallback+0x2a>
 300a4a8:	1a100593          	li	a1,417
 300a4ac:	030127b7          	lui	a5,0x3012
 300a4b0:	da078513          	addi	a0,a5,-608 # 3011da0 <g_crgIpMatch+0x508>
 300a4b4:	3c21                	jal	ra,3009ecc <AssertErrorLog.trans.7>
 300a4b6:	a001                	j	300a4b6 <HAL_QDM_RegisterCallback+0x28>
    QDM_ASSERT_PARAM(pCallback != NULL);
 300a4b8:	fe442783          	lw	a5,-28(s0)
 300a4bc:	eb89                	bnez	a5,300a4ce <HAL_QDM_RegisterCallback+0x40>
 300a4be:	1a200593          	li	a1,418
 300a4c2:	030127b7          	lui	a5,0x3012
 300a4c6:	da078513          	addi	a0,a5,-608 # 3011da0 <g_crgIpMatch+0x508>
 300a4ca:	3409                	jal	ra,3009ecc <AssertErrorLog.trans.7>
 300a4cc:	a001                	j	300a4cc <HAL_QDM_RegisterCallback+0x3e>
    QDM_ASSERT_PARAM(IsQDMInstance(qdmHandle->baseAddress));
 300a4ce:	fec42783          	lw	a5,-20(s0)
 300a4d2:	4398                	lw	a4,0(a5)
 300a4d4:	14c007b7          	lui	a5,0x14c00
 300a4d8:	02f70163          	beq	a4,a5,300a4fa <HAL_QDM_RegisterCallback+0x6c>
 300a4dc:	fec42783          	lw	a5,-20(s0)
 300a4e0:	4398                	lw	a4,0(a5)
 300a4e2:	14c017b7          	lui	a5,0x14c01
 300a4e6:	00f70a63          	beq	a4,a5,300a4fa <HAL_QDM_RegisterCallback+0x6c>
 300a4ea:	1a300593          	li	a1,419
 300a4ee:	030127b7          	lui	a5,0x3012
 300a4f2:	da078513          	addi	a0,a5,-608 # 3011da0 <g_crgIpMatch+0x508>
 300a4f6:	3ad9                	jal	ra,3009ecc <AssertErrorLog.trans.7>
 300a4f8:	a001                	j	300a4f8 <HAL_QDM_RegisterCallback+0x6a>
    /* Select the interrupt callback function by the switch-case. */
    SelectInterruptCallback(qdmHandle, typeID, pCallback);
 300a4fa:	fe442603          	lw	a2,-28(s0)
 300a4fe:	fe842583          	lw	a1,-24(s0)
 300a502:	fec42503          	lw	a0,-20(s0)
 300a506:	3dc1                	jal	ra,300a3d6 <SelectInterruptCallback>
}
 300a508:	0001                	nop
 300a50a:	40f2                	lw	ra,28(sp)
 300a50c:	4462                	lw	s0,24(sp)
 300a50e:	6105                	addi	sp,sp,32
 300a510:	8082                	ret

0300a512 <HAL_QDM_Init>:
  * @brief  QDM initialization functions
  * @param qdmHandle Value of @ref QDM_Handle.
  * @retval BASE_StatusType:BASE_STATUS_OK, BASE_STATUS_ERROR, BASE_STATUS_BUSY, BASE_STATUS_TIMEOUT
  */
BASE_StatusType HAL_QDM_Init(QDM_Handle *qdmHandle)
{
 300a512:	1101                	addi	sp,sp,-32
 300a514:	ce06                	sw	ra,28(sp)
 300a516:	cc22                	sw	s0,24(sp)
 300a518:	1000                	addi	s0,sp,32
 300a51a:	fea42623          	sw	a0,-20(s0)
    QDM_ASSERT_PARAM(qdmHandle != NULL);
 300a51e:	fec42783          	lw	a5,-20(s0)
 300a522:	eb89                	bnez	a5,300a534 <HAL_QDM_Init+0x22>
 300a524:	1af00593          	li	a1,431
 300a528:	030127b7          	lui	a5,0x3012
 300a52c:	da078513          	addi	a0,a5,-608 # 3011da0 <g_crgIpMatch+0x508>
 300a530:	3a71                	jal	ra,3009ecc <AssertErrorLog.trans.7>
 300a532:	a001                	j	300a532 <HAL_QDM_Init+0x20>
    QDM_ASSERT_PARAM(IsQDMInstance(qdmHandle->baseAddress));
 300a534:	fec42783          	lw	a5,-20(s0)
 300a538:	4398                	lw	a4,0(a5)
 300a53a:	14c007b7          	lui	a5,0x14c00
 300a53e:	02f70163          	beq	a4,a5,300a560 <HAL_QDM_Init+0x4e>
 300a542:	fec42783          	lw	a5,-20(s0)
 300a546:	4398                	lw	a4,0(a5)
 300a548:	14c017b7          	lui	a5,0x14c01
 300a54c:	00f70a63          	beq	a4,a5,300a560 <HAL_QDM_Init+0x4e>
 300a550:	1b000593          	li	a1,432
 300a554:	030127b7          	lui	a5,0x3012
 300a558:	da078513          	addi	a0,a5,-608 # 3011da0 <g_crgIpMatch+0x508>
 300a55c:	3a85                	jal	ra,3009ecc <AssertErrorLog.trans.7>
 300a55e:	a001                	j	300a55e <HAL_QDM_Init+0x4c>
    QDM_PARAM_CHECK_WITH_RET(IsEmuMode(qdmHandle->emuMode), BASE_STATUS_ERROR);
 300a560:	fec42783          	lw	a5,-20(s0)
 300a564:	43dc                	lw	a5,4(a5)
 300a566:	853e                	mv	a0,a5
 300a568:	ff7fe0ef          	jal	ra,300955e <IsEmuMode>
 300a56c:	87aa                	mv	a5,a0
 300a56e:	0017c793          	xori	a5,a5,1
 300a572:	9f81                	uxtb	a5
 300a574:	cb91                	beqz	a5,300a588 <HAL_QDM_Init+0x76>
 300a576:	1b100593          	li	a1,433
 300a57a:	030127b7          	lui	a5,0x3012
 300a57e:	da078513          	addi	a0,a5,-608 # 3011da0 <g_crgIpMatch+0x508>
 300a582:	32a9                	jal	ra,3009ecc <AssertErrorLog.trans.7>
 300a584:	4785                	li	a5,1
 300a586:	a85d                	j	300a63c <HAL_QDM_Init+0x12a>
    QDM_PARAM_CHECK_WITH_RET(IsLockMode(qdmHandle->lock_mode), BASE_STATUS_ERROR);
 300a588:	fec42783          	lw	a5,-20(s0)
 300a58c:	53bc                	lw	a5,96(a5)
 300a58e:	853e                	mv	a0,a5
 300a590:	800ff0ef          	jal	ra,3009590 <IsLockMode>
 300a594:	87aa                	mv	a5,a0
 300a596:	0017c793          	xori	a5,a5,1
 300a59a:	9f81                	uxtb	a5
 300a59c:	cb91                	beqz	a5,300a5b0 <HAL_QDM_Init+0x9e>
 300a59e:	1b200593          	li	a1,434
 300a5a2:	030127b7          	lui	a5,0x3012
 300a5a6:	da078513          	addi	a0,a5,-608 # 3011da0 <g_crgIpMatch+0x508>
 300a5aa:	320d                	jal	ra,3009ecc <AssertErrorLog.trans.7>
 300a5ac:	4785                	li	a5,1
 300a5ae:	a079                	j	300a63c <HAL_QDM_Init+0x12a>

    qdmHandle->baseAddress->QEMUMODE.BIT.emu_mode = qdmHandle->emuMode;
 300a5b0:	fec42783          	lw	a5,-20(s0)
 300a5b4:	43d4                	lw	a3,4(a5)
 300a5b6:	fec42783          	lw	a5,-20(s0)
 300a5ba:	4398                	lw	a4,0(a5)
 300a5bc:	87b6                	mv	a5,a3
 300a5be:	8b8d                	andi	a5,a5,3
 300a5c0:	0ff7f693          	andi	a3,a5,255
 300a5c4:	435c                	lw	a5,4(a4)
 300a5c6:	8a8d                	andi	a3,a3,3
 300a5c8:	9bf1                	andi	a5,a5,-4
 300a5ca:	8fd5                	or	a5,a5,a3
 300a5cc:	c35c                	sw	a5,4(a4)
    /* Set Z index locked mode. */
    if ((qdmHandle->interruptEn & QDM_INT_INDEX_EVNT_LATCH) == QDM_INT_INDEX_EVNT_LATCH) {
 300a5ce:	fec42783          	lw	a5,-20(s0)
 300a5d2:	4bfc                	lw	a5,84(a5)
 300a5d4:	1007f793          	andi	a5,a5,256
 300a5d8:	cb99                	beqz	a5,300a5ee <HAL_QDM_Init+0xdc>
        DCL_QDM_SetIndexLockMode(qdmHandle->baseAddress, qdmHandle->lock_mode);
 300a5da:	fec42783          	lw	a5,-20(s0)
 300a5de:	4398                	lw	a4,0(a5)
 300a5e0:	fec42783          	lw	a5,-20(s0)
 300a5e4:	53bc                	lw	a5,96(a5)
 300a5e6:	85be                	mv	a1,a5
 300a5e8:	853a                	mv	a0,a4
 300a5ea:	b5cff0ef          	jal	ra,3009946 <DCL_QDM_SetIndexLockMode>
    }
    /* Set input filter width. */
    DCL_QDM_SetInputFilterWidth(qdmHandle->baseAddress, qdmHandle->inputFilter.qdmAFilterLevel, \
 300a5ee:	fec42783          	lw	a5,-20(s0)
 300a5f2:	4398                	lw	a4,0(a5)
 300a5f4:	fec42783          	lw	a5,-20(s0)
 300a5f8:	479c                	lw	a5,8(a5)
 300a5fa:	01079593          	slli	a1,a5,0x10
 300a5fe:	81c1                	srli	a1,a1,0x10
                                qdmHandle->inputFilter.qdmBFilterLevel, qdmHandle->inputFilter.qdmZFilterLevel);
 300a600:	fec42783          	lw	a5,-20(s0)
 300a604:	47dc                	lw	a5,12(a5)
    DCL_QDM_SetInputFilterWidth(qdmHandle->baseAddress, qdmHandle->inputFilter.qdmAFilterLevel, \
 300a606:	01079613          	slli	a2,a5,0x10
 300a60a:	8241                	srli	a2,a2,0x10
                                qdmHandle->inputFilter.qdmBFilterLevel, qdmHandle->inputFilter.qdmZFilterLevel);
 300a60c:	fec42783          	lw	a5,-20(s0)
 300a610:	4b9c                	lw	a5,16(a5)
    DCL_QDM_SetInputFilterWidth(qdmHandle->baseAddress, qdmHandle->inputFilter.qdmAFilterLevel, \
 300a612:	9fa1                	uxth	a5
 300a614:	86be                	mv	a3,a5
 300a616:	853a                	mv	a0,a4
 300a618:	a24ff0ef          	jal	ra,300983c <DCL_QDM_SetInputFilterWidth>
    QDM_DecoderConfig(qdmHandle);
 300a61c:	fec42503          	lw	a0,-20(s0)
 300a620:	ba0ff0ef          	jal	ra,30099c0 <QDM_DecoderConfig>
    QDM_CounterConfig(qdmHandle);
 300a624:	fec42503          	lw	a0,-20(s0)
 300a628:	dbeff0ef          	jal	ra,3009be6 <QDM_CounterConfig>
    /* Enable interrupt. */
    QDM_InterruptEnable(qdmHandle);
 300a62c:	fec42503          	lw	a0,-20(s0)
 300a630:	381d                	jal	ra,3009e66 <QDM_InterruptEnable>
    QDM_EnableSubmodule(qdmHandle);
 300a632:	fec42503          	lw	a0,-20(s0)
 300a636:	fa4ff0ef          	jal	ra,3009dda <QDM_EnableSubmodule>
    return BASE_STATUS_OK;
 300a63a:	4781                	li	a5,0
}
 300a63c:	853e                	mv	a0,a5
 300a63e:	40f2                	lw	ra,28(sp)
 300a640:	4462                	lw	s0,24(sp)
 300a642:	6105                	addi	sp,sp,32
 300a644:	8082                	ret

0300a646 <HAL_QDM_ReadPosCountAndDir>:
  * @param count: count value pointer.
  * @param dir: dir.
  * @retval none.
  */
void HAL_QDM_ReadPosCountAndDir(const QDM_Handle *qdmHandle, unsigned int *count, unsigned int *dir)
{
 300a646:	1101                	addi	sp,sp,-32
 300a648:	ce06                	sw	ra,28(sp)
 300a64a:	cc22                	sw	s0,24(sp)
 300a64c:	1000                	addi	s0,sp,32
 300a64e:	fea42623          	sw	a0,-20(s0)
 300a652:	feb42423          	sw	a1,-24(s0)
 300a656:	fec42223          	sw	a2,-28(s0)
    QDM_ASSERT_PARAM(qdmHandle != NULL);
 300a65a:	fec42783          	lw	a5,-20(s0)
 300a65e:	eb89                	bnez	a5,300a670 <HAL_QDM_ReadPosCountAndDir+0x2a>
 300a660:	1e300593          	li	a1,483
 300a664:	030127b7          	lui	a5,0x3012
 300a668:	da078513          	addi	a0,a5,-608 # 3011da0 <g_crgIpMatch+0x508>
 300a66c:	2b6d                	jal	ra,300ac26 <AssertErrorLog.trans.8>
 300a66e:	a001                	j	300a66e <HAL_QDM_ReadPosCountAndDir+0x28>
    QDM_ASSERT_PARAM(count != NULL);
 300a670:	fe842783          	lw	a5,-24(s0)
 300a674:	eb89                	bnez	a5,300a686 <HAL_QDM_ReadPosCountAndDir+0x40>
 300a676:	1e400593          	li	a1,484
 300a67a:	030127b7          	lui	a5,0x3012
 300a67e:	da078513          	addi	a0,a5,-608 # 3011da0 <g_crgIpMatch+0x508>
 300a682:	2355                	jal	ra,300ac26 <AssertErrorLog.trans.8>
 300a684:	a001                	j	300a684 <HAL_QDM_ReadPosCountAndDir+0x3e>
    QDM_ASSERT_PARAM(dir != NULL);
 300a686:	fe442783          	lw	a5,-28(s0)
 300a68a:	eb89                	bnez	a5,300a69c <HAL_QDM_ReadPosCountAndDir+0x56>
 300a68c:	1e500593          	li	a1,485
 300a690:	030127b7          	lui	a5,0x3012
 300a694:	da078513          	addi	a0,a5,-608 # 3011da0 <g_crgIpMatch+0x508>
 300a698:	2379                	jal	ra,300ac26 <AssertErrorLog.trans.8>
 300a69a:	a001                	j	300a69a <HAL_QDM_ReadPosCountAndDir+0x54>
    QDM_ASSERT_PARAM(IsQDMInstance(qdmHandle->baseAddress));
 300a69c:	fec42783          	lw	a5,-20(s0)
 300a6a0:	4398                	lw	a4,0(a5)
 300a6a2:	14c007b7          	lui	a5,0x14c00
 300a6a6:	02f70163          	beq	a4,a5,300a6c8 <HAL_QDM_ReadPosCountAndDir+0x82>
 300a6aa:	fec42783          	lw	a5,-20(s0)
 300a6ae:	4398                	lw	a4,0(a5)
 300a6b0:	14c017b7          	lui	a5,0x14c01
 300a6b4:	00f70a63          	beq	a4,a5,300a6c8 <HAL_QDM_ReadPosCountAndDir+0x82>
 300a6b8:	1e600593          	li	a1,486
 300a6bc:	030127b7          	lui	a5,0x3012
 300a6c0:	da078513          	addi	a0,a5,-608 # 3011da0 <g_crgIpMatch+0x508>
 300a6c4:	238d                	jal	ra,300ac26 <AssertErrorLog.trans.8>
 300a6c6:	a001                	j	300a6c6 <HAL_QDM_ReadPosCountAndDir+0x80>
    *count = qdmHandle->baseAddress->QPOSCNT;
 300a6c8:	fec42783          	lw	a5,-20(s0)
 300a6cc:	439c                	lw	a5,0(a5)
 300a6ce:	5798                	lw	a4,40(a5)
 300a6d0:	fe842783          	lw	a5,-24(s0)
 300a6d4:	c398                	sw	a4,0(a5)
    *dir = qdmHandle->baseAddress->QDMSTS.BIT.qdir_sts;
 300a6d6:	fec42783          	lw	a5,-20(s0)
 300a6da:	439c                	lw	a5,0(a5)
 300a6dc:	53dc                	lw	a5,36(a5)
 300a6de:	8399                	srli	a5,a5,0x6
 300a6e0:	8b85                	andi	a5,a5,1
 300a6e2:	9f81                	uxtb	a5
 300a6e4:	873e                	mv	a4,a5
 300a6e6:	fe442783          	lw	a5,-28(s0)
 300a6ea:	c398                	sw	a4,0(a5)

    return;
 300a6ec:	0001                	nop
}
 300a6ee:	40f2                	lw	ra,28(sp)
 300a6f0:	4462                	lw	s0,24(sp)
 300a6f2:	6105                	addi	sp,sp,32
 300a6f4:	8082                	ret

0300a6f6 <IsTimerMode>:
  * @param mode Timer Mode, @ref TIMER_Mode
  * @retval true
  * @retval false
  */
static inline bool IsTimerMode(TIMER_Mode mode)
{
 300a6f6:	1101                	addi	sp,sp,-32
 300a6f8:	ce22                	sw	s0,28(sp)
 300a6fa:	1000                	addi	s0,sp,32
 300a6fc:	fea42623          	sw	a0,-20(s0)
    return (((mode) == TIMER_MODE_RUN_FREE) ||
            ((mode) == TIMER_MODE_RUN_PERIODIC) ||
 300a700:	fec42783          	lw	a5,-20(s0)
 300a704:	cb99                	beqz	a5,300a71a <IsTimerMode+0x24>
    return (((mode) == TIMER_MODE_RUN_FREE) ||
 300a706:	fec42703          	lw	a4,-20(s0)
 300a70a:	4785                	li	a5,1
 300a70c:	00f70763          	beq	a4,a5,300a71a <IsTimerMode+0x24>
            ((mode) == TIMER_MODE_RUN_PERIODIC) ||
 300a710:	fec42703          	lw	a4,-20(s0)
 300a714:	4789                	li	a5,2
 300a716:	00f71463          	bne	a4,a5,300a71e <IsTimerMode+0x28>
 300a71a:	4785                	li	a5,1
 300a71c:	a011                	j	300a720 <IsTimerMode+0x2a>
 300a71e:	4781                	li	a5,0
 300a720:	8b85                	andi	a5,a5,1
 300a722:	9f81                	uxtb	a5
            ((mode) == TIMER_MODE_RUN_ONTSHOT));
}
 300a724:	853e                	mv	a0,a5
 300a726:	4472                	lw	s0,28(sp)
 300a728:	6105                	addi	sp,sp,32
 300a72a:	8082                	ret

0300a72c <IsTimerInterruptType>:
  * @param mode Timer Interrupt Type, @ref TIMER_InterruptType
  * @retval true
  * @retval false
  */
static inline bool IsTimerInterruptType(TIMER_InterruptType interruptType)
{
 300a72c:	1101                	addi	sp,sp,-32
 300a72e:	ce22                	sw	s0,28(sp)
 300a730:	1000                	addi	s0,sp,32
 300a732:	fea42623          	sw	a0,-20(s0)
    return (((interruptType) == TIMER_PERIOD_FIN) ||
 300a736:	fec42783          	lw	a5,-20(s0)
 300a73a:	c791                	beqz	a5,300a746 <IsTimerInterruptType+0x1a>
 300a73c:	fec42703          	lw	a4,-20(s0)
 300a740:	4785                	li	a5,1
 300a742:	00f71463          	bne	a4,a5,300a74a <IsTimerInterruptType+0x1e>
 300a746:	4785                	li	a5,1
 300a748:	a011                	j	300a74c <IsTimerInterruptType+0x20>
 300a74a:	4781                	li	a5,0
 300a74c:	8b85                	andi	a5,a5,1
 300a74e:	9f81                	uxtb	a5
            ((interruptType) == TIMER_OVER_FLOW));
}
 300a750:	853e                	mv	a0,a5
 300a752:	4472                	lw	s0,28(sp)
 300a754:	6105                	addi	sp,sp,32
 300a756:	8082                	ret

0300a758 <IsTimerSize>:
  * @param size  Timer Size, @ref TIMER_Size
  * @retval true
  * @retval false
  */
static inline bool IsTimerSize(TIMER_Size size)
{
 300a758:	1101                	addi	sp,sp,-32
 300a75a:	ce22                	sw	s0,28(sp)
 300a75c:	1000                	addi	s0,sp,32
 300a75e:	fea42623          	sw	a0,-20(s0)
    return (((size) == TIMER_SIZE_16BIT) ||
 300a762:	fec42783          	lw	a5,-20(s0)
 300a766:	c791                	beqz	a5,300a772 <IsTimerSize+0x1a>
 300a768:	fec42703          	lw	a4,-20(s0)
 300a76c:	4785                	li	a5,1
 300a76e:	00f71463          	bne	a4,a5,300a776 <IsTimerSize+0x1e>
 300a772:	4785                	li	a5,1
 300a774:	a011                	j	300a778 <IsTimerSize+0x20>
 300a776:	4781                	li	a5,0
 300a778:	8b85                	andi	a5,a5,1
 300a77a:	9f81                	uxtb	a5
            ((size) == TIMER_SIZE_32BIT));
}
 300a77c:	853e                	mv	a0,a5
 300a77e:	4472                	lw	s0,28(sp)
 300a780:	6105                	addi	sp,sp,32
 300a782:	8082                	ret

0300a784 <IsTimerPeriod>:
  * @param period
  * @retval true
  * @retval false
  */
static inline bool IsTimerPeriod(unsigned int period)
{
 300a784:	1101                	addi	sp,sp,-32
 300a786:	ce22                	sw	s0,28(sp)
 300a788:	1000                	addi	s0,sp,32
 300a78a:	fea42623          	sw	a0,-20(s0)
    return ((period) >= PERIOD_MIN_VALUE);
 300a78e:	fec42783          	lw	a5,-20(s0)
 300a792:	00f037b3          	snez	a5,a5
 300a796:	9f81                	uxtb	a5
}
 300a798:	853e                	mv	a0,a5
 300a79a:	4472                	lw	s0,28(sp)
 300a79c:	6105                	addi	sp,sp,32
 300a79e:	8082                	ret

0300a7a0 <IsTimerDiv>:
  * @param div @see TIMER_PrescalerFactor
  * @retval true
  * @retval false
  */
static inline bool IsTimerDiv(TIMER_PrescalerFactor div)
{
 300a7a0:	1101                	addi	sp,sp,-32
 300a7a2:	ce22                	sw	s0,28(sp)
 300a7a4:	1000                	addi	s0,sp,32
 300a7a6:	fea42623          	sw	a0,-20(s0)
    return (((div) == TIMERPRESCALER_NO_DIV) ||
            ((div) == TIMERPRESCALER_DIV_16) ||
 300a7aa:	fec42783          	lw	a5,-20(s0)
 300a7ae:	cb99                	beqz	a5,300a7c4 <IsTimerDiv+0x24>
    return (((div) == TIMERPRESCALER_NO_DIV) ||
 300a7b0:	fec42703          	lw	a4,-20(s0)
 300a7b4:	4785                	li	a5,1
 300a7b6:	00f70763          	beq	a4,a5,300a7c4 <IsTimerDiv+0x24>
            ((div) == TIMERPRESCALER_DIV_16) ||
 300a7ba:	fec42703          	lw	a4,-20(s0)
 300a7be:	4789                	li	a5,2
 300a7c0:	00f71463          	bne	a4,a5,300a7c8 <IsTimerDiv+0x28>
 300a7c4:	4785                	li	a5,1
 300a7c6:	a011                	j	300a7ca <IsTimerDiv+0x2a>
 300a7c8:	4781                	li	a5,0
 300a7ca:	8b85                	andi	a5,a5,1
 300a7cc:	9f81                	uxtb	a5
            ((div) == TIMERPRESCALER_DIV_256));
}
 300a7ce:	853e                	mv	a0,a5
 300a7d0:	4472                	lw	s0,28(sp)
 300a7d2:	6105                	addi	sp,sp,32
 300a7d4:	8082                	ret

0300a7d6 <HAL_TIMER_Init>:
  * @param   handle  Timer Handle
  * @retval  BASE_STATUS_OK    Success
  * @retval  BASE_STATUS_ERROR parameter check fail
  */
BASE_StatusType HAL_TIMER_Init(TIMER_Handle *handle)
{
 300a7d6:	1101                	addi	sp,sp,-32
 300a7d8:	ce06                	sw	ra,28(sp)
 300a7da:	cc22                	sw	s0,24(sp)
 300a7dc:	1000                	addi	s0,sp,32
 300a7de:	fea42623          	sw	a0,-20(s0)
    TIMER_ASSERT_PARAM(handle != NULL);
 300a7e2:	fec42783          	lw	a5,-20(s0)
 300a7e6:	eb89                	bnez	a5,300a7f8 <HAL_TIMER_Init+0x22>
 300a7e8:	02800593          	li	a1,40
 300a7ec:	030127b7          	lui	a5,0x3012
 300a7f0:	e0478513          	addi	a0,a5,-508 # 3011e04 <g_crgIpMatch+0x56c>
 300a7f4:	290d                	jal	ra,300ac26 <AssertErrorLog.trans.8>
 300a7f6:	a001                	j	300a7f6 <HAL_TIMER_Init+0x20>
    TIMER_ASSERT_PARAM(IsTIMERInstance(handle->baseAddress));
 300a7f8:	fec42783          	lw	a5,-20(s0)
 300a7fc:	4398                	lw	a4,0(a5)
 300a7fe:	143007b7          	lui	a5,0x14300
 300a802:	02f70f63          	beq	a4,a5,300a840 <HAL_TIMER_Init+0x6a>
 300a806:	fec42783          	lw	a5,-20(s0)
 300a80a:	4398                	lw	a4,0(a5)
 300a80c:	143017b7          	lui	a5,0x14301
 300a810:	02f70863          	beq	a4,a5,300a840 <HAL_TIMER_Init+0x6a>
 300a814:	fec42783          	lw	a5,-20(s0)
 300a818:	4398                	lw	a4,0(a5)
 300a81a:	143027b7          	lui	a5,0x14302
 300a81e:	02f70163          	beq	a4,a5,300a840 <HAL_TIMER_Init+0x6a>
 300a822:	fec42783          	lw	a5,-20(s0)
 300a826:	4398                	lw	a4,0(a5)
 300a828:	143037b7          	lui	a5,0x14303
 300a82c:	00f70a63          	beq	a4,a5,300a840 <HAL_TIMER_Init+0x6a>
 300a830:	02900593          	li	a1,41
 300a834:	030127b7          	lui	a5,0x3012
 300a838:	e0478513          	addi	a0,a5,-508 # 3011e04 <g_crgIpMatch+0x56c>
 300a83c:	26ed                	jal	ra,300ac26 <AssertErrorLog.trans.8>
 300a83e:	a001                	j	300a83e <HAL_TIMER_Init+0x68>

    TIMER_PARAM_CHECK_WITH_RET(IsTimerPeriod(handle->load), BASE_STATUS_ERROR);
 300a840:	fec42783          	lw	a5,-20(s0)
 300a844:	4bdc                	lw	a5,20(a5)
 300a846:	853e                	mv	a0,a5
 300a848:	3f35                	jal	ra,300a784 <IsTimerPeriod>
 300a84a:	87aa                	mv	a5,a0
 300a84c:	0017c793          	xori	a5,a5,1
 300a850:	9f81                	uxtb	a5
 300a852:	cb91                	beqz	a5,300a866 <HAL_TIMER_Init+0x90>
 300a854:	02b00593          	li	a1,43
 300a858:	030127b7          	lui	a5,0x3012
 300a85c:	e0478513          	addi	a0,a5,-508 # 3011e04 <g_crgIpMatch+0x56c>
 300a860:	26d9                	jal	ra,300ac26 <AssertErrorLog.trans.8>
 300a862:	4785                	li	a5,1
 300a864:	aa6d                	j	300aa1e <HAL_TIMER_Init+0x248>
    TIMER_PARAM_CHECK_WITH_RET(IsTimerPeriod(handle->bgLoad), BASE_STATUS_ERROR);
 300a866:	fec42783          	lw	a5,-20(s0)
 300a86a:	4f9c                	lw	a5,24(a5)
 300a86c:	853e                	mv	a0,a5
 300a86e:	3f19                	jal	ra,300a784 <IsTimerPeriod>
 300a870:	87aa                	mv	a5,a0
 300a872:	0017c793          	xori	a5,a5,1
 300a876:	9f81                	uxtb	a5
 300a878:	cb91                	beqz	a5,300a88c <HAL_TIMER_Init+0xb6>
 300a87a:	02c00593          	li	a1,44
 300a87e:	030127b7          	lui	a5,0x3012
 300a882:	e0478513          	addi	a0,a5,-508 # 3011e04 <g_crgIpMatch+0x56c>
 300a886:	2645                	jal	ra,300ac26 <AssertErrorLog.trans.8>
 300a888:	4785                	li	a5,1
 300a88a:	aa51                	j	300aa1e <HAL_TIMER_Init+0x248>
    TIMER_PARAM_CHECK_WITH_RET(IsTimerMode(handle->mode), BASE_STATUS_ERROR);
 300a88c:	fec42783          	lw	a5,-20(s0)
 300a890:	479c                	lw	a5,8(a5)
 300a892:	853e                	mv	a0,a5
 300a894:	358d                	jal	ra,300a6f6 <IsTimerMode>
 300a896:	87aa                	mv	a5,a0
 300a898:	0017c793          	xori	a5,a5,1
 300a89c:	9f81                	uxtb	a5
 300a89e:	cb91                	beqz	a5,300a8b2 <HAL_TIMER_Init+0xdc>
 300a8a0:	02d00593          	li	a1,45
 300a8a4:	030127b7          	lui	a5,0x3012
 300a8a8:	e0478513          	addi	a0,a5,-508 # 3011e04 <g_crgIpMatch+0x56c>
 300a8ac:	2ead                	jal	ra,300ac26 <AssertErrorLog.trans.8>
 300a8ae:	4785                	li	a5,1
 300a8b0:	a2bd                	j	300aa1e <HAL_TIMER_Init+0x248>
    TIMER_PARAM_CHECK_WITH_RET(IsTimerSize(handle->size), BASE_STATUS_ERROR);
 300a8b2:	fec42783          	lw	a5,-20(s0)
 300a8b6:	4b9c                	lw	a5,16(a5)
 300a8b8:	853e                	mv	a0,a5
 300a8ba:	3d79                	jal	ra,300a758 <IsTimerSize>
 300a8bc:	87aa                	mv	a5,a0
 300a8be:	0017c793          	xori	a5,a5,1
 300a8c2:	9f81                	uxtb	a5
 300a8c4:	cb91                	beqz	a5,300a8d8 <HAL_TIMER_Init+0x102>
 300a8c6:	02e00593          	li	a1,46
 300a8ca:	030127b7          	lui	a5,0x3012
 300a8ce:	e0478513          	addi	a0,a5,-508 # 3011e04 <g_crgIpMatch+0x56c>
 300a8d2:	2e91                	jal	ra,300ac26 <AssertErrorLog.trans.8>
 300a8d4:	4785                	li	a5,1
 300a8d6:	a2a1                	j	300aa1e <HAL_TIMER_Init+0x248>
    TIMER_PARAM_CHECK_WITH_RET(IsTimerDiv(handle->prescaler), BASE_STATUS_ERROR);
 300a8d8:	fec42783          	lw	a5,-20(s0)
 300a8dc:	47dc                	lw	a5,12(a5)
 300a8de:	853e                	mv	a0,a5
 300a8e0:	35c1                	jal	ra,300a7a0 <IsTimerDiv>
 300a8e2:	87aa                	mv	a5,a0
 300a8e4:	0017c793          	xori	a5,a5,1
 300a8e8:	9f81                	uxtb	a5
 300a8ea:	cb91                	beqz	a5,300a8fe <HAL_TIMER_Init+0x128>
 300a8ec:	02f00593          	li	a1,47
 300a8f0:	030127b7          	lui	a5,0x3012
 300a8f4:	e0478513          	addi	a0,a5,-508 # 3011e04 <g_crgIpMatch+0x56c>
 300a8f8:	263d                	jal	ra,300ac26 <AssertErrorLog.trans.8>
 300a8fa:	4785                	li	a5,1
 300a8fc:	a20d                	j	300aa1e <HAL_TIMER_Init+0x248>

    /* Initialize the configuration parameters of the timer */
    handle->baseAddress->timer_intclr = BASE_CFG_SET;   /* Writing to this register clears interrupt output of timer */
 300a8fe:	fec42783          	lw	a5,-20(s0)
 300a902:	439c                	lw	a5,0(a5)
 300a904:	4705                	li	a4,1
 300a906:	c7d8                	sw	a4,12(a5)
    handle->baseAddress->timer_load = handle->load;
 300a908:	fec42783          	lw	a5,-20(s0)
 300a90c:	439c                	lw	a5,0(a5)
 300a90e:	fec42703          	lw	a4,-20(s0)
 300a912:	4b58                	lw	a4,20(a4)
 300a914:	c398                	sw	a4,0(a5)
    handle->baseAddress->timerbgload = handle->bgLoad;
 300a916:	fec42783          	lw	a5,-20(s0)
 300a91a:	439c                	lw	a5,0(a5)
 300a91c:	fec42703          	lw	a4,-20(s0)
 300a920:	4f18                	lw	a4,24(a4)
 300a922:	cf98                	sw	a4,24(a5)
    handle->baseAddress->TIMERx_CONTROL.BIT.timeren = BASE_CFG_DISABLE;
 300a924:	fec42783          	lw	a5,-20(s0)
 300a928:	4398                	lw	a4,0(a5)
 300a92a:	471c                	lw	a5,8(a4)
 300a92c:	f7f7f793          	andi	a5,a5,-129
 300a930:	c71c                	sw	a5,8(a4)
    handle->baseAddress->TIMERx_CONTROL.BIT.timerintenable = handle->interruptEn;
 300a932:	fec42783          	lw	a5,-20(s0)
 300a936:	4398                	lw	a4,0(a5)
 300a938:	fec42783          	lw	a5,-20(s0)
 300a93c:	2fd4                	lbu	a3,28(a5)
 300a93e:	471c                	lw	a5,8(a4)
 300a940:	8a85                	andi	a3,a3,1
 300a942:	0696                	slli	a3,a3,0x5
 300a944:	fdf7f793          	andi	a5,a5,-33
 300a948:	8fd5                	or	a5,a5,a3
 300a94a:	c71c                	sw	a5,8(a4)
    
    /* Sets the frequency divider and size of the timer module. */
    handle->baseAddress->TIMERx_CONTROL.BIT.timerpre = handle->prescaler;
 300a94c:	fec42783          	lw	a5,-20(s0)
 300a950:	47d4                	lw	a3,12(a5)
 300a952:	fec42783          	lw	a5,-20(s0)
 300a956:	4398                	lw	a4,0(a5)
 300a958:	87b6                	mv	a5,a3
 300a95a:	8b8d                	andi	a5,a5,3
 300a95c:	0ff7f693          	andi	a3,a5,255
 300a960:	471c                	lw	a5,8(a4)
 300a962:	8a8d                	andi	a3,a3,3
 300a964:	068a                	slli	a3,a3,0x2
 300a966:	9bcd                	andi	a5,a5,-13
 300a968:	8fd5                	or	a5,a5,a3
 300a96a:	c71c                	sw	a5,8(a4)
    handle->baseAddress->TIMERx_CONTROL.BIT.timersize = handle->size;
 300a96c:	fec42783          	lw	a5,-20(s0)
 300a970:	4b94                	lw	a3,16(a5)
 300a972:	fec42783          	lw	a5,-20(s0)
 300a976:	4398                	lw	a4,0(a5)
 300a978:	87b6                	mv	a5,a3
 300a97a:	8b85                	andi	a5,a5,1
 300a97c:	0ff7f693          	andi	a3,a5,255
 300a980:	471c                	lw	a5,8(a4)
 300a982:	8a85                	andi	a3,a3,1
 300a984:	0686                	slli	a3,a3,0x1
 300a986:	9bf5                	andi	a5,a5,-3
 300a988:	8fd5                	or	a5,a5,a3
 300a98a:	c71c                	sw	a5,8(a4)

    /* Sets the running mode of the timer. */
    if (handle->mode == TIMER_MODE_RUN_ONTSHOT) {
 300a98c:	fec42783          	lw	a5,-20(s0)
 300a990:	4798                	lw	a4,8(a5)
 300a992:	4789                	li	a5,2
 300a994:	00f71a63          	bne	a4,a5,300a9a8 <HAL_TIMER_Init+0x1d2>
        handle->baseAddress->TIMERx_CONTROL.BIT.oneshot = BASE_CFG_SET;
 300a998:	fec42783          	lw	a5,-20(s0)
 300a99c:	4398                	lw	a4,0(a5)
 300a99e:	471c                	lw	a5,8(a4)
 300a9a0:	0017e793          	ori	a5,a5,1
 300a9a4:	c71c                	sw	a5,8(a4)
 300a9a6:	a805                	j	300a9d6 <HAL_TIMER_Init+0x200>
    } else {
        handle->baseAddress->TIMERx_CONTROL.BIT.oneshot = BASE_CFG_UNSET;
 300a9a8:	fec42783          	lw	a5,-20(s0)
 300a9ac:	4398                	lw	a4,0(a5)
 300a9ae:	471c                	lw	a5,8(a4)
 300a9b0:	9bf9                	andi	a5,a5,-2
 300a9b2:	c71c                	sw	a5,8(a4)
        handle->baseAddress->TIMERx_CONTROL.BIT.timermode =
            (handle->mode == TIMER_MODE_RUN_FREE) ? BASE_CFG_UNSET : BASE_CFG_SET;
 300a9b4:	fec42783          	lw	a5,-20(s0)
 300a9b8:	479c                	lw	a5,8(a5)
        handle->baseAddress->TIMERx_CONTROL.BIT.timermode =
 300a9ba:	fec42703          	lw	a4,-20(s0)
 300a9be:	4318                	lw	a4,0(a4)
            (handle->mode == TIMER_MODE_RUN_FREE) ? BASE_CFG_UNSET : BASE_CFG_SET;
 300a9c0:	00f037b3          	snez	a5,a5
 300a9c4:	0ff7f693          	andi	a3,a5,255
        handle->baseAddress->TIMERx_CONTROL.BIT.timermode =
 300a9c8:	471c                	lw	a5,8(a4)
 300a9ca:	8a85                	andi	a3,a3,1
 300a9cc:	069a                	slli	a3,a3,0x6
 300a9ce:	fbf7f793          	andi	a5,a5,-65
 300a9d2:	8fd5                	or	a5,a5,a3
 300a9d4:	c71c                	sw	a5,8(a4)
    }

    /* Request for setting the DMA and ADC. */
    handle->baseAddress->TIMERx_CONTROLB.BIT.dmasreqen = handle->dmaReqEnable;
 300a9d6:	fec42783          	lw	a5,-20(s0)
 300a9da:	4398                	lw	a4,0(a5)
 300a9dc:	fec42783          	lw	a5,-20(s0)
 300a9e0:	2ff4                	lbu	a3,30(a5)
 300a9e2:	4f5c                	lw	a5,28(a4)
 300a9e4:	8a85                	andi	a3,a3,1
 300a9e6:	0686                	slli	a3,a3,0x1
 300a9e8:	9bf5                	andi	a5,a5,-3
 300a9ea:	8fd5                	or	a5,a5,a3
 300a9ec:	cf5c                	sw	a5,28(a4)
    handle->baseAddress->TIMERx_CONTROLB.BIT.dmabreqen = handle->dmaReqEnable;
 300a9ee:	fec42783          	lw	a5,-20(s0)
 300a9f2:	4398                	lw	a4,0(a5)
 300a9f4:	fec42783          	lw	a5,-20(s0)
 300a9f8:	2ff4                	lbu	a3,30(a5)
 300a9fa:	4f5c                	lw	a5,28(a4)
 300a9fc:	8a85                	andi	a3,a3,1
 300a9fe:	9bf9                	andi	a5,a5,-2
 300aa00:	8fd5                	or	a5,a5,a3
 300aa02:	cf5c                	sw	a5,28(a4)
    handle->baseAddress->TIMERx_CONTROLB.BIT.socen = handle->adcSocReqEnable;
 300aa04:	fec42783          	lw	a5,-20(s0)
 300aa08:	4398                	lw	a4,0(a5)
 300aa0a:	fec42783          	lw	a5,-20(s0)
 300aa0e:	3fd4                	lbu	a3,29(a5)
 300aa10:	4f5c                	lw	a5,28(a4)
 300aa12:	8a85                	andi	a3,a3,1
 300aa14:	068a                	slli	a3,a3,0x2
 300aa16:	9bed                	andi	a5,a5,-5
 300aa18:	8fd5                	or	a5,a5,a3
 300aa1a:	cf5c                	sw	a5,28(a4)
    return BASE_STATUS_OK;
 300aa1c:	4781                	li	a5,0
}
 300aa1e:	853e                	mv	a0,a5
 300aa20:	40f2                	lw	ra,28(sp)
 300aa22:	4462                	lw	s0,24(sp)
 300aa24:	6105                	addi	sp,sp,32
 300aa26:	8082                	ret

0300aa28 <HAL_TIMER_Start>:
  * @brief   Start timer.
  * @param   handle Timer Handle
  * @retval  None
  */
void HAL_TIMER_Start(TIMER_Handle *handle)
{
 300aa28:	1101                	addi	sp,sp,-32
 300aa2a:	ce06                	sw	ra,28(sp)
 300aa2c:	cc22                	sw	s0,24(sp)
 300aa2e:	1000                	addi	s0,sp,32
 300aa30:	fea42623          	sw	a0,-20(s0)
    TIMER_ASSERT_PARAM(handle != NULL);
 300aa34:	fec42783          	lw	a5,-20(s0)
 300aa38:	eb89                	bnez	a5,300aa4a <HAL_TIMER_Start+0x22>
 300aa3a:	0bc00593          	li	a1,188
 300aa3e:	030127b7          	lui	a5,0x3012
 300aa42:	e0478513          	addi	a0,a5,-508 # 3011e04 <g_crgIpMatch+0x56c>
 300aa46:	22c5                	jal	ra,300ac26 <AssertErrorLog.trans.8>
 300aa48:	a001                	j	300aa48 <HAL_TIMER_Start+0x20>
    TIMER_ASSERT_PARAM(IsTIMERInstance(handle->baseAddress));
 300aa4a:	fec42783          	lw	a5,-20(s0)
 300aa4e:	4398                	lw	a4,0(a5)
 300aa50:	143007b7          	lui	a5,0x14300
 300aa54:	02f70f63          	beq	a4,a5,300aa92 <HAL_TIMER_Start+0x6a>
 300aa58:	fec42783          	lw	a5,-20(s0)
 300aa5c:	4398                	lw	a4,0(a5)
 300aa5e:	143017b7          	lui	a5,0x14301
 300aa62:	02f70863          	beq	a4,a5,300aa92 <HAL_TIMER_Start+0x6a>
 300aa66:	fec42783          	lw	a5,-20(s0)
 300aa6a:	4398                	lw	a4,0(a5)
 300aa6c:	143027b7          	lui	a5,0x14302
 300aa70:	02f70163          	beq	a4,a5,300aa92 <HAL_TIMER_Start+0x6a>
 300aa74:	fec42783          	lw	a5,-20(s0)
 300aa78:	4398                	lw	a4,0(a5)
 300aa7a:	143037b7          	lui	a5,0x14303
 300aa7e:	00f70a63          	beq	a4,a5,300aa92 <HAL_TIMER_Start+0x6a>
 300aa82:	0bd00593          	li	a1,189
 300aa86:	030127b7          	lui	a5,0x3012
 300aa8a:	e0478513          	addi	a0,a5,-508 # 3011e04 <g_crgIpMatch+0x56c>
 300aa8e:	2a61                	jal	ra,300ac26 <AssertErrorLog.trans.8>
 300aa90:	a001                	j	300aa90 <HAL_TIMER_Start+0x68>
    /* Enable timer */
    handle->baseAddress->TIMERx_CONTROL.BIT.timeren = BASE_CFG_SET;
 300aa92:	fec42783          	lw	a5,-20(s0)
 300aa96:	4398                	lw	a4,0(a5)
 300aa98:	471c                	lw	a5,8(a4)
 300aa9a:	0807e793          	ori	a5,a5,128
 300aa9e:	c71c                	sw	a5,8(a4)
}
 300aaa0:	0001                	nop
 300aaa2:	40f2                	lw	ra,28(sp)
 300aaa4:	4462                	lw	s0,24(sp)
 300aaa6:	6105                	addi	sp,sp,32
 300aaa8:	8082                	ret

0300aaaa <HAL_TIMER_IrqHandler>:
 * @brief   GPT Interrupt service processing function.
 * @param   handle   TIMER Handle
 * @retval  None
 */
void HAL_TIMER_IrqHandler(void *handle)
{
 300aaaa:	7179                	addi	sp,sp,-48
 300aaac:	d606                	sw	ra,44(sp)
 300aaae:	d422                	sw	s0,40(sp)
 300aab0:	1800                	addi	s0,sp,48
 300aab2:	fca42e23          	sw	a0,-36(s0)
    TIMER_ASSERT_PARAM(handle != NULL);
 300aab6:	fdc42783          	lw	a5,-36(s0)
 300aaba:	eb89                	bnez	a5,300aacc <HAL_TIMER_IrqHandler+0x22>
 300aabc:	0d800593          	li	a1,216
 300aac0:	030127b7          	lui	a5,0x3012
 300aac4:	e0478513          	addi	a0,a5,-508 # 3011e04 <g_crgIpMatch+0x56c>
 300aac8:	2ab9                	jal	ra,300ac26 <AssertErrorLog.trans.8>
 300aaca:	a001                	j	300aaca <HAL_TIMER_IrqHandler+0x20>
    TIMER_Handle *timerHandle = (TIMER_Handle *)handle;
 300aacc:	fdc42783          	lw	a5,-36(s0)
 300aad0:	fef42623          	sw	a5,-20(s0)
    TIMER_ASSERT_PARAM(IsTIMERInstance(timerHandle->baseAddress));
 300aad4:	fec42783          	lw	a5,-20(s0)
 300aad8:	4398                	lw	a4,0(a5)
 300aada:	143007b7          	lui	a5,0x14300
 300aade:	02f70f63          	beq	a4,a5,300ab1c <HAL_TIMER_IrqHandler+0x72>
 300aae2:	fec42783          	lw	a5,-20(s0)
 300aae6:	4398                	lw	a4,0(a5)
 300aae8:	143017b7          	lui	a5,0x14301
 300aaec:	02f70863          	beq	a4,a5,300ab1c <HAL_TIMER_IrqHandler+0x72>
 300aaf0:	fec42783          	lw	a5,-20(s0)
 300aaf4:	4398                	lw	a4,0(a5)
 300aaf6:	143027b7          	lui	a5,0x14302
 300aafa:	02f70163          	beq	a4,a5,300ab1c <HAL_TIMER_IrqHandler+0x72>
 300aafe:	fec42783          	lw	a5,-20(s0)
 300ab02:	4398                	lw	a4,0(a5)
 300ab04:	143037b7          	lui	a5,0x14303
 300ab08:	00f70a63          	beq	a4,a5,300ab1c <HAL_TIMER_IrqHandler+0x72>
 300ab0c:	0da00593          	li	a1,218
 300ab10:	030127b7          	lui	a5,0x3012
 300ab14:	e0478513          	addi	a0,a5,-508 # 3011e04 <g_crgIpMatch+0x56c>
 300ab18:	2239                	jal	ra,300ac26 <AssertErrorLog.trans.8>
 300ab1a:	a001                	j	300ab1a <HAL_TIMER_IrqHandler+0x70>
    /* Check interrupt type */
    if (timerHandle->baseAddress->TIMERx_MIS.dmaovmis == BASE_CFG_ENABLE) {
 300ab1c:	fec42783          	lw	a5,-20(s0)
 300ab20:	439c                	lw	a5,0(a5)
 300ab22:	4bdc                	lw	a5,20(a5)
 300ab24:	8385                	srli	a5,a5,0x1
 300ab26:	8b85                	andi	a5,a5,1
 300ab28:	0ff7f713          	andi	a4,a5,255
 300ab2c:	4785                	li	a5,1
 300ab2e:	02f71363          	bne	a4,a5,300ab54 <HAL_TIMER_IrqHandler+0xaa>
        /* DMA overflow interrupt */
        timerHandle->baseAddress->DMAOV_INTCLR.BIT.dmaov_intclr = BASE_CFG_ENABLE;
 300ab32:	fec42783          	lw	a5,-20(s0)
 300ab36:	4398                	lw	a4,0(a5)
 300ab38:	531c                	lw	a5,32(a4)
 300ab3a:	0017e793          	ori	a5,a5,1
 300ab3e:	d31c                	sw	a5,32(a4)
       /* Call the timer DMA request overflow callback function of the user. */
        if (timerHandle->userCallBack.TimerOverFlowCallBack != NULL) {
 300ab40:	fec42783          	lw	a5,-20(s0)
 300ab44:	53dc                	lw	a5,36(a5)
 300ab46:	c799                	beqz	a5,300ab54 <HAL_TIMER_IrqHandler+0xaa>
            timerHandle->userCallBack.TimerOverFlowCallBack(timerHandle);
 300ab48:	fec42783          	lw	a5,-20(s0)
 300ab4c:	53dc                	lw	a5,36(a5)
 300ab4e:	fec42503          	lw	a0,-20(s0)
 300ab52:	9782                	jalr	a5
        }
    }
    if (timerHandle->baseAddress->TIMERx_MIS.timermis == BASE_CFG_ENABLE) {
 300ab54:	fec42783          	lw	a5,-20(s0)
 300ab58:	439c                	lw	a5,0(a5)
 300ab5a:	4bdc                	lw	a5,20(a5)
 300ab5c:	8b85                	andi	a5,a5,1
 300ab5e:	0ff7f713          	andi	a4,a5,255
 300ab62:	4785                	li	a5,1
 300ab64:	02f71263          	bne	a4,a5,300ab88 <HAL_TIMER_IrqHandler+0xde>
        /* TIMER Interrupt */
        timerHandle->baseAddress->timer_intclr = BASE_CFG_ENABLE;
 300ab68:	fec42783          	lw	a5,-20(s0)
 300ab6c:	439c                	lw	a5,0(a5)
 300ab6e:	4705                	li	a4,1
 300ab70:	c7d8                	sw	a4,12(a5)
        /* Call the period finish callback function of the user. */
        if (timerHandle->userCallBack.TimerPeriodFinCallBack != NULL) {
 300ab72:	fec42783          	lw	a5,-20(s0)
 300ab76:	539c                	lw	a5,32(a5)
 300ab78:	cb81                	beqz	a5,300ab88 <HAL_TIMER_IrqHandler+0xde>
            timerHandle->userCallBack.TimerPeriodFinCallBack(timerHandle);
 300ab7a:	fec42783          	lw	a5,-20(s0)
 300ab7e:	539c                	lw	a5,32(a5)
 300ab80:	fec42503          	lw	a0,-20(s0)
 300ab84:	9782                	jalr	a5
        }
    }
    return;
 300ab86:	0001                	nop
 300ab88:	0001                	nop
}
 300ab8a:	50b2                	lw	ra,44(sp)
 300ab8c:	5422                	lw	s0,40(sp)
 300ab8e:	6145                	addi	sp,sp,48
 300ab90:	8082                	ret

0300ab92 <HAL_TIMER_RegisterCallback>:
  * @retval  BASE_STATUS_OK  Success
  * @retval  BASE_STATUS_ERROR Parameter check fail
  */
BASE_StatusType HAL_TIMER_RegisterCallback(TIMER_Handle *handle, TIMER_InterruptType typeID,
                                           TIMER_CallBackFunc callBackFunc)
{
 300ab92:	1101                	addi	sp,sp,-32
 300ab94:	ce06                	sw	ra,28(sp)
 300ab96:	cc22                	sw	s0,24(sp)
 300ab98:	1000                	addi	s0,sp,32
 300ab9a:	fea42623          	sw	a0,-20(s0)
 300ab9e:	feb42423          	sw	a1,-24(s0)
 300aba2:	fec42223          	sw	a2,-28(s0)
    TIMER_ASSERT_PARAM(handle != NULL);
 300aba6:	fec42783          	lw	a5,-20(s0)
 300abaa:	eb89                	bnez	a5,300abbc <HAL_TIMER_RegisterCallback+0x2a>
 300abac:	0fa00593          	li	a1,250
 300abb0:	030127b7          	lui	a5,0x3012
 300abb4:	e0478513          	addi	a0,a5,-508 # 3011e04 <g_crgIpMatch+0x56c>
 300abb8:	20bd                	jal	ra,300ac26 <AssertErrorLog.trans.8>
 300abba:	a001                	j	300abba <HAL_TIMER_RegisterCallback+0x28>
    TIMER_ASSERT_PARAM(callBackFunc != NULL);
 300abbc:	fe442783          	lw	a5,-28(s0)
 300abc0:	eb89                	bnez	a5,300abd2 <HAL_TIMER_RegisterCallback+0x40>
 300abc2:	0fb00593          	li	a1,251
 300abc6:	030127b7          	lui	a5,0x3012
 300abca:	e0478513          	addi	a0,a5,-508 # 3011e04 <g_crgIpMatch+0x56c>
 300abce:	28a1                	jal	ra,300ac26 <AssertErrorLog.trans.8>
 300abd0:	a001                	j	300abd0 <HAL_TIMER_RegisterCallback+0x3e>
    TIMER_ASSERT_PARAM(IsTimerInterruptType(typeID));
 300abd2:	fe842503          	lw	a0,-24(s0)
 300abd6:	3e99                	jal	ra,300a72c <IsTimerInterruptType>
 300abd8:	87aa                	mv	a5,a0
 300abda:	0017c793          	xori	a5,a5,1
 300abde:	9f81                	uxtb	a5
 300abe0:	cb89                	beqz	a5,300abf2 <HAL_TIMER_RegisterCallback+0x60>
 300abe2:	0fc00593          	li	a1,252
 300abe6:	030127b7          	lui	a5,0x3012
 300abea:	e0478513          	addi	a0,a5,-508 # 3011e04 <g_crgIpMatch+0x56c>
 300abee:	2825                	jal	ra,300ac26 <AssertErrorLog.trans.8>
 300abf0:	a001                	j	300abf0 <HAL_TIMER_RegisterCallback+0x5e>
    
    /* Registers the user callback function. */
    switch (typeID) {
 300abf2:	fe842783          	lw	a5,-24(s0)
 300abf6:	cb91                	beqz	a5,300ac0a <HAL_TIMER_RegisterCallback+0x78>
 300abf8:	4705                	li	a4,1
 300abfa:	00e79e63          	bne	a5,a4,300ac16 <HAL_TIMER_RegisterCallback+0x84>
        case TIMER_OVER_FLOW:
            handle->userCallBack.TimerOverFlowCallBack = callBackFunc; /* User DMA request overflow function */
 300abfe:	fec42783          	lw	a5,-20(s0)
 300ac02:	fe442703          	lw	a4,-28(s0)
 300ac06:	d3d8                	sw	a4,36(a5)
            break;
 300ac08:	a809                	j	300ac1a <HAL_TIMER_RegisterCallback+0x88>
        case TIMER_PERIOD_FIN:
            handle->userCallBack.TimerPeriodFinCallBack = callBackFunc; /* User timer period finish call back. */
 300ac0a:	fec42783          	lw	a5,-20(s0)
 300ac0e:	fe442703          	lw	a4,-28(s0)
 300ac12:	d398                	sw	a4,32(a5)
            break;
 300ac14:	a019                	j	300ac1a <HAL_TIMER_RegisterCallback+0x88>
        default:
            return BASE_STATUS_ERROR;
 300ac16:	4785                	li	a5,1
 300ac18:	a011                	j	300ac1c <HAL_TIMER_RegisterCallback+0x8a>
    }
    return BASE_STATUS_OK;
 300ac1a:	4781                	li	a5,0
}
 300ac1c:	853e                	mv	a0,a5
 300ac1e:	40f2                	lw	ra,28(sp)
 300ac20:	4462                	lw	s0,24(sp)
 300ac22:	6105                	addi	sp,sp,32
 300ac24:	8082                	ret

0300ac26 <AssertErrorLog.trans.8>:
 300ac26:	92cf806f          	j	3002d52 <AssertErrorLog>

0300ac2a <IsUartDatalength>:
  * @brief Check UART datalength parameter.
  * @param datalength The number of data bits in a frame, @ref UART_DataLength
  * @retval bool
  */
static inline bool IsUartDatalength(UART_DataLength datalength)
{
 300ac2a:	1101                	addi	sp,sp,-32
 300ac2c:	ce22                	sw	s0,28(sp)
 300ac2e:	1000                	addi	s0,sp,32
 300ac30:	fea42623          	sw	a0,-20(s0)
    return (datalength >= UART_DATALENGTH_5BIT) && (datalength <= UART_DATALENGTH_8BIT);
 300ac34:	fec42783          	lw	a5,-20(s0)
 300ac38:	0047b793          	sltiu	a5,a5,4
 300ac3c:	9f81                	uxtb	a5
}
 300ac3e:	853e                	mv	a0,a5
 300ac40:	4472                	lw	s0,28(sp)
 300ac42:	6105                	addi	sp,sp,32
 300ac44:	8082                	ret

0300ac46 <IsUartStopbits>:
  * @brief Check UART stopbits parameter.
  * @param stopbits The number of stop bits in a frame, @ref UART_StopBits
  * @retval bool
  */
static inline bool IsUartStopbits(UART_StopBits stopbits)
{
 300ac46:	1101                	addi	sp,sp,-32
 300ac48:	ce22                	sw	s0,28(sp)
 300ac4a:	1000                	addi	s0,sp,32
 300ac4c:	fea42623          	sw	a0,-20(s0)
    return (stopbits == UART_STOPBITS_ONE) || (stopbits == UART_STOPBITS_TWO);
 300ac50:	fec42783          	lw	a5,-20(s0)
 300ac54:	c791                	beqz	a5,300ac60 <IsUartStopbits+0x1a>
 300ac56:	fec42703          	lw	a4,-20(s0)
 300ac5a:	4785                	li	a5,1
 300ac5c:	00f71463          	bne	a4,a5,300ac64 <IsUartStopbits+0x1e>
 300ac60:	4785                	li	a5,1
 300ac62:	a011                	j	300ac66 <IsUartStopbits+0x20>
 300ac64:	4781                	li	a5,0
 300ac66:	8b85                	andi	a5,a5,1
 300ac68:	9f81                	uxtb	a5
}
 300ac6a:	853e                	mv	a0,a5
 300ac6c:	4472                	lw	s0,28(sp)
 300ac6e:	6105                	addi	sp,sp,32
 300ac70:	8082                	ret

0300ac72 <IsUartParitymode>:
  * @brief Check UART paritymode parameter.
  * @param paritymode UART parity check mode, @ref UART_Parity_Mode
  * @retval bool
  */
static inline bool IsUartParitymode(UART_Parity_Mode paritymode)
{
 300ac72:	1101                	addi	sp,sp,-32
 300ac74:	ce22                	sw	s0,28(sp)
 300ac76:	1000                	addi	s0,sp,32
 300ac78:	fea42623          	sw	a0,-20(s0)
    if ((paritymode >= UART_PARITY_ODD) && (paritymode <= UART_PARITY_NONE)) {
 300ac7c:	fec42703          	lw	a4,-20(s0)
 300ac80:	4791                	li	a5,4
 300ac82:	00e7e463          	bltu	a5,a4,300ac8a <IsUartParitymode+0x18>
        return true;
 300ac86:	4785                	li	a5,1
 300ac88:	a011                	j	300ac8c <IsUartParitymode+0x1a>
    }
    return false;
 300ac8a:	4781                	li	a5,0
}
 300ac8c:	853e                	mv	a0,a5
 300ac8e:	4472                	lw	s0,28(sp)
 300ac90:	6105                	addi	sp,sp,32
 300ac92:	8082                	ret

0300ac94 <IsUartTransmode>:
  * @brief Check UART transmode parameter.
  * @param transmode Transmit mode, @ref UART_Transmit_Mode
  * @retval bool
  */
static inline bool IsUartTransmode(UART_Transmit_Mode transmode)
{
 300ac94:	1101                	addi	sp,sp,-32
 300ac96:	ce22                	sw	s0,28(sp)
 300ac98:	1000                	addi	s0,sp,32
 300ac9a:	fea42623          	sw	a0,-20(s0)
    if ((transmode == UART_MODE_BLOCKING) ||
 300ac9e:	fec42783          	lw	a5,-20(s0)
 300aca2:	c385                	beqz	a5,300acc2 <IsUartTransmode+0x2e>
 300aca4:	fec42703          	lw	a4,-20(s0)
 300aca8:	4785                	li	a5,1
 300acaa:	00f70c63          	beq	a4,a5,300acc2 <IsUartTransmode+0x2e>
        (transmode == UART_MODE_INTERRUPT) ||
 300acae:	fec42703          	lw	a4,-20(s0)
 300acb2:	4789                	li	a5,2
 300acb4:	00f70763          	beq	a4,a5,300acc2 <IsUartTransmode+0x2e>
        (transmode == UART_MODE_DMA) ||
 300acb8:	fec42703          	lw	a4,-20(s0)
 300acbc:	478d                	li	a5,3
 300acbe:	00f71463          	bne	a4,a5,300acc6 <IsUartTransmode+0x32>
        (transmode == UART_MODE_DISABLE)) {
        return true;
 300acc2:	4785                	li	a5,1
 300acc4:	a011                	j	300acc8 <IsUartTransmode+0x34>
    }
    return false;
 300acc6:	4781                	li	a5,0
}
 300acc8:	853e                	mv	a0,a5
 300acca:	4472                	lw	s0,28(sp)
 300accc:	6105                	addi	sp,sp,32
 300acce:	8082                	ret

0300acd0 <IsUartFIFOThreshold>:
  * @brief Check UART fifoThreshold parameter.
  * @param fifoThreshold UART TX/RX FIFO line interrupt threshold, @ref UART_FIFO_Threshold
  * @retval bool
  */
static inline bool IsUartFIFOThreshold(UART_FIFO_Threshold fifoThreshold)
{
 300acd0:	1101                	addi	sp,sp,-32
 300acd2:	ce22                	sw	s0,28(sp)
 300acd4:	1000                	addi	s0,sp,32
 300acd6:	fea42623          	sw	a0,-20(s0)
    return (fifoThreshold >= UART_FIFODEPTH_SIZE0) && (fifoThreshold <= UART_FIFODEPTH_SIZE15);
 300acda:	fec42783          	lw	a5,-20(s0)
 300acde:	0107b793          	sltiu	a5,a5,16
 300ace2:	9f81                	uxtb	a5
}
 300ace4:	853e                	mv	a0,a5
 300ace6:	4472                	lw	s0,28(sp)
 300ace8:	6105                	addi	sp,sp,32
 300acea:	8082                	ret

0300acec <IsUartOversampleMultiple>:
  * @brief Check UART Oversampling multiple.
  * @param multiple Oversampling multiple, @ref UART_OversampleMultiple
  * @retval bool
  */
static inline bool IsUartOversampleMultiple(UART_OversampleMultiple multiple)
{
 300acec:	1101                	addi	sp,sp,-32
 300acee:	ce22                	sw	s0,28(sp)
 300acf0:	1000                	addi	s0,sp,32
 300acf2:	fea42623          	sw	a0,-20(s0)
    return (multiple >= UART_OVERSAMPLING_16X) && (multiple <= UART_OVERSAMPLING_12X);
 300acf6:	fec42783          	lw	a5,-20(s0)
 300acfa:	0057b793          	sltiu	a5,a5,5
 300acfe:	9f81                	uxtb	a5
}
 300ad00:	853e                	mv	a0,a5
 300ad02:	4472                	lw	s0,28(sp)
 300ad04:	6105                	addi	sp,sp,32
 300ad06:	8082                	ret

0300ad08 <DivClosest>:
#define PARITY_EVEN   0x6
#define PARITY_MARK   0x82
#define PARITY_SPACE  0x86

static unsigned int DivClosest(unsigned int x, unsigned int divisor)
{
 300ad08:	7179                	addi	sp,sp,-48
 300ad0a:	d622                	sw	s0,44(sp)
 300ad0c:	1800                	addi	s0,sp,48
 300ad0e:	fca42e23          	sw	a0,-36(s0)
 300ad12:	fcb42c23          	sw	a1,-40(s0)
    unsigned int ret;
    if (divisor == 0) {
 300ad16:	fd842783          	lw	a5,-40(s0)
 300ad1a:	e399                	bnez	a5,300ad20 <DivClosest+0x18>
        return 0;
 300ad1c:	4781                	li	a5,0
 300ad1e:	a005                	j	300ad3e <DivClosest+0x36>
    }
    ret = (((x) + ((divisor) / 2)) / (divisor));  /* Round up the result, add 1/2 */
 300ad20:	fd842783          	lw	a5,-40(s0)
 300ad24:	0017d713          	srli	a4,a5,0x1
 300ad28:	fdc42783          	lw	a5,-36(s0)
 300ad2c:	973e                	add	a4,a4,a5
 300ad2e:	fd842783          	lw	a5,-40(s0)
 300ad32:	02f757b3          	divu	a5,a4,a5
 300ad36:	fef42623          	sw	a5,-20(s0)
    return ret;
 300ad3a:	fec42783          	lw	a5,-20(s0)
}
 300ad3e:	853e                	mv	a0,a5
 300ad40:	5432                	lw	s0,44(sp)
 300ad42:	6145                	addi	sp,sp,48
 300ad44:	8082                	ret

0300ad46 <BaudDetectCallBack>:
  * @brief Baud rate detection interrupt callback function.
  * @param uartHandle UART handle.
  * @retval None.
  */
static void BaudDetectCallBack(UART_Handle *uartHandle)
{
 300ad46:	1101                	addi	sp,sp,-32
 300ad48:	ce06                	sw	ra,28(sp)
 300ad4a:	cc22                	sw	s0,24(sp)
 300ad4c:	1000                	addi	s0,sp,32
 300ad4e:	fea42623          	sw	a0,-20(s0)
    if (uartHandle->baseAddress->UART_MIS.BIT.abdcis == 0x01) {
 300ad52:	fec42783          	lw	a5,-20(s0)
 300ad56:	439c                	lw	a5,0(a5)
 300ad58:	43bc                	lw	a5,64(a5)
 300ad5a:	83cd                	srli	a5,a5,0x13
 300ad5c:	8b85                	andi	a5,a5,1
 300ad5e:	0ff7f713          	andi	a4,a5,255
 300ad62:	4785                	li	a5,1
 300ad64:	06f71b63          	bne	a4,a5,300adda <BaudDetectCallBack+0x94>
        uartHandle->baseAddress->UART_ABDEN.BIT.abden = BASE_CFG_DISABLE;
 300ad68:	fec42783          	lw	a5,-20(s0)
 300ad6c:	4398                	lw	a4,0(a5)
 300ad6e:	4f7c                	lw	a5,92(a4)
 300ad70:	9bf9                	andi	a5,a5,-2
 300ad72:	cf7c                	sw	a5,92(a4)
        uartHandle->baseAddress->UART_IMSC.BIT.abdeim = BASE_CFG_DISABLE;
 300ad74:	fec42783          	lw	a5,-20(s0)
 300ad78:	4398                	lw	a4,0(a5)
 300ad7a:	5f1c                	lw	a5,56(a4)
 300ad7c:	fff006b7          	lui	a3,0xfff00
 300ad80:	16fd                	addi	a3,a3,-1 # ffefffff <RAM_END+0xfbef7fff>
 300ad82:	8ff5                	and	a5,a5,a3
 300ad84:	df1c                	sw	a5,56(a4)
        uartHandle->baseAddress->UART_IMSC.BIT.abdcim = BASE_CFG_DISABLE;
 300ad86:	fec42783          	lw	a5,-20(s0)
 300ad8a:	4398                	lw	a4,0(a5)
 300ad8c:	5f1c                	lw	a5,56(a4)
 300ad8e:	fff806b7          	lui	a3,0xfff80
 300ad92:	16fd                	addi	a3,a3,-1 # fff7ffff <RAM_END+0xfbf77fff>
 300ad94:	8ff5                	and	a5,a5,a3
 300ad96:	df1c                	sw	a5,56(a4)
        uartHandle->baseAddress->UART_ICR.BIT.abdcic = BASE_CFG_ENABLE;
 300ad98:	fec42783          	lw	a5,-20(s0)
 300ad9c:	4398                	lw	a4,0(a5)
 300ad9e:	437c                	lw	a5,68(a4)
 300ada0:	000806b7          	lui	a3,0x80
 300ada4:	8fd5                	or	a5,a5,a3
 300ada6:	c37c                	sw	a5,68(a4)
        /* After the baud rate automatic detection function is configured, enable UART. */
        uartHandle->baseAddress->UART_CR.BIT.txe = BASE_CFG_ENABLE;
 300ada8:	fec42783          	lw	a5,-20(s0)
 300adac:	4398                	lw	a4,0(a5)
 300adae:	5b1c                	lw	a5,48(a4)
 300adb0:	1007e793          	ori	a5,a5,256
 300adb4:	db1c                	sw	a5,48(a4)
        uartHandle->baseAddress->UART_CR.BIT.rxe = BASE_CFG_ENABLE;
 300adb6:	fec42783          	lw	a5,-20(s0)
 300adba:	4398                	lw	a4,0(a5)
 300adbc:	5b1c                	lw	a5,48(a4)
 300adbe:	2007e793          	ori	a5,a5,512
 300adc2:	db1c                	sw	a5,48(a4)
        /* Call back user detect success function. */
        if (uartHandle->userCallBack.BaudDetectSuccessCallBack != NULL) {
 300adc4:	fec42783          	lw	a5,-20(s0)
 300adc8:	57fc                	lw	a5,108(a5)
 300adca:	c7b9                	beqz	a5,300ae18 <BaudDetectCallBack+0xd2>
            uartHandle->userCallBack.BaudDetectSuccessCallBack(uartHandle);
 300adcc:	fec42783          	lw	a5,-20(s0)
 300add0:	57fc                	lw	a5,108(a5)
 300add2:	fec42503          	lw	a0,-20(s0)
 300add6:	9782                	jalr	a5
        /* Call back user baud detect error function. */
        if (uartHandle->userCallBack.BaudDetectErrorCallBack != NULL) {
            uartHandle->userCallBack.BaudDetectErrorCallBack(uartHandle);
        }
    }
    return;
 300add8:	a081                	j	300ae18 <BaudDetectCallBack+0xd2>
        while (uartHandle->baseAddress->UART_ABDEN.BIT.abdbusy == 0x01) {
 300adda:	0001                	nop
 300addc:	fec42783          	lw	a5,-20(s0)
 300ade0:	439c                	lw	a5,0(a5)
 300ade2:	4ffc                	lw	a5,92(a5)
 300ade4:	8391                	srli	a5,a5,0x4
 300ade6:	8b85                	andi	a5,a5,1
 300ade8:	0ff7f713          	andi	a4,a5,255
 300adec:	4785                	li	a5,1
 300adee:	fef707e3          	beq	a4,a5,300addc <BaudDetectCallBack+0x96>
        uartHandle->baseAddress->UART_ICR.BIT.abdeic = BASE_CFG_ENABLE;
 300adf2:	fec42783          	lw	a5,-20(s0)
 300adf6:	4398                	lw	a4,0(a5)
 300adf8:	437c                	lw	a5,68(a4)
 300adfa:	001006b7          	lui	a3,0x100
 300adfe:	8fd5                	or	a5,a5,a3
 300ae00:	c37c                	sw	a5,68(a4)
        if (uartHandle->userCallBack.BaudDetectErrorCallBack != NULL) {
 300ae02:	fec42783          	lw	a5,-20(s0)
 300ae06:	5bbc                	lw	a5,112(a5)
 300ae08:	cb81                	beqz	a5,300ae18 <BaudDetectCallBack+0xd2>
            uartHandle->userCallBack.BaudDetectErrorCallBack(uartHandle);
 300ae0a:	fec42783          	lw	a5,-20(s0)
 300ae0e:	5bbc                	lw	a5,112(a5)
 300ae10:	fec42503          	lw	a0,-20(s0)
 300ae14:	9782                	jalr	a5
    return;
 300ae16:	0001                	nop
 300ae18:	0001                	nop
}
 300ae1a:	40f2                	lw	ra,28(sp)
 300ae1c:	4462                	lw	s0,24(sp)
 300ae1e:	6105                	addi	sp,sp,32
 300ae20:	8082                	ret

0300ae22 <CharterMatchCallBack>:
  * @brief Character detection interrupt callback function.
  * @param uartHandle UART handle.
  * @retval None.
  */
static void CharterMatchCallBack(UART_Handle *uartHandle)
{
 300ae22:	1101                	addi	sp,sp,-32
 300ae24:	ce06                	sw	ra,28(sp)
 300ae26:	cc22                	sw	s0,24(sp)
 300ae28:	1000                	addi	s0,sp,32
 300ae2a:	fea42623          	sw	a0,-20(s0)
    uartHandle->baseAddress->UART_IMSC.BIT.cmim = BASE_CFG_DISABLE;
 300ae2e:	fec42783          	lw	a5,-20(s0)
 300ae32:	4398                	lw	a4,0(a5)
 300ae34:	5f1c                	lw	a5,56(a4)
 300ae36:	ffe006b7          	lui	a3,0xffe00
 300ae3a:	16fd                	addi	a3,a3,-1 # ffdfffff <RAM_END+0xfbdf7fff>
 300ae3c:	8ff5                	and	a5,a5,a3
 300ae3e:	df1c                	sw	a5,56(a4)
    uartHandle->baseAddress->UART_ICR.BIT.cmic = BASE_CFG_ENABLE;
 300ae40:	fec42783          	lw	a5,-20(s0)
 300ae44:	4398                	lw	a4,0(a5)
 300ae46:	437c                	lw	a5,68(a4)
 300ae48:	002006b7          	lui	a3,0x200
 300ae4c:	8fd5                	or	a5,a5,a3
 300ae4e:	c37c                	sw	a5,68(a4)
    if (uartHandle->userCallBack.CharacterMatchCallBack != NULL) {
 300ae50:	fec42783          	lw	a5,-20(s0)
 300ae54:	5bfc                	lw	a5,116(a5)
 300ae56:	c799                	beqz	a5,300ae64 <CharterMatchCallBack+0x42>
        uartHandle->userCallBack.CharacterMatchCallBack(uartHandle);
 300ae58:	fec42783          	lw	a5,-20(s0)
 300ae5c:	5bfc                	lw	a5,116(a5)
 300ae5e:	fec42503          	lw	a0,-20(s0)
 300ae62:	9782                	jalr	a5
    }
}
 300ae64:	0001                	nop
 300ae66:	40f2                	lw	ra,28(sp)
 300ae68:	4462                	lw	s0,24(sp)
 300ae6a:	6105                	addi	sp,sp,32
 300ae6c:	8082                	ret

0300ae6e <UART_SetParityBit>:
  * @brief Sets the parity bit of the UART.
  * @param uartHandle UART handle.
  * @retval None.
  */
static void UART_SetParityBit(UART_Handle *uartHandle)
{
 300ae6e:	1101                	addi	sp,sp,-32
 300ae70:	ce22                	sw	s0,28(sp)
 300ae72:	1000                	addi	s0,sp,32
 300ae74:	fea42623          	sw	a0,-20(s0)
    /* Sets the UART check mode. */
    switch (uartHandle->parity) {
 300ae78:	fec42783          	lw	a5,-20(s0)
 300ae7c:	4b9c                	lw	a5,16(a5)
 300ae7e:	4711                	li	a4,4
 300ae80:	06f76e63          	bltu	a4,a5,300aefc <UART_SetParityBit+0x8e>
 300ae84:	00279713          	slli	a4,a5,0x2
 300ae88:	030127b7          	lui	a5,0x3012
 300ae8c:	e2478793          	addi	a5,a5,-476 # 3011e24 <g_crgIpMatch+0x58c>
 300ae90:	97ba                	add	a5,a5,a4
 300ae92:	439c                	lw	a5,0(a5)
 300ae94:	8782                	jr	a5
        case UART_PARITY_ODD:
            uartHandle->baseAddress->UART_LCR_H.reg |= PARITY_ODD; /* Odd parity. */
 300ae96:	fec42783          	lw	a5,-20(s0)
 300ae9a:	439c                	lw	a5,0(a5)
 300ae9c:	57d8                	lw	a4,44(a5)
 300ae9e:	fec42783          	lw	a5,-20(s0)
 300aea2:	439c                	lw	a5,0(a5)
 300aea4:	00276713          	ori	a4,a4,2
 300aea8:	d7d8                	sw	a4,44(a5)
            break;
 300aeaa:	a891                	j	300aefe <UART_SetParityBit+0x90>
        case UART_PARITY_EVEN:
            uartHandle->baseAddress->UART_LCR_H.reg |= PARITY_EVEN; /* Even parity. */
 300aeac:	fec42783          	lw	a5,-20(s0)
 300aeb0:	439c                	lw	a5,0(a5)
 300aeb2:	57d8                	lw	a4,44(a5)
 300aeb4:	fec42783          	lw	a5,-20(s0)
 300aeb8:	439c                	lw	a5,0(a5)
 300aeba:	00676713          	ori	a4,a4,6
 300aebe:	d7d8                	sw	a4,44(a5)
            break;
 300aec0:	a83d                	j	300aefe <UART_SetParityBit+0x90>
        case UART_PARITY_MARK:
            uartHandle->baseAddress->UART_LCR_H.reg |= PARITY_MARK; /* Marking parity */
 300aec2:	fec42783          	lw	a5,-20(s0)
 300aec6:	439c                	lw	a5,0(a5)
 300aec8:	57d8                	lw	a4,44(a5)
 300aeca:	fec42783          	lw	a5,-20(s0)
 300aece:	439c                	lw	a5,0(a5)
 300aed0:	08276713          	ori	a4,a4,130
 300aed4:	d7d8                	sw	a4,44(a5)
            break;
 300aed6:	a025                	j	300aefe <UART_SetParityBit+0x90>
        case UART_PARITY_SPACE:
            uartHandle->baseAddress->UART_LCR_H.reg |= PARITY_SPACE; /* space parity */
 300aed8:	fec42783          	lw	a5,-20(s0)
 300aedc:	439c                	lw	a5,0(a5)
 300aede:	57d8                	lw	a4,44(a5)
 300aee0:	fec42783          	lw	a5,-20(s0)
 300aee4:	439c                	lw	a5,0(a5)
 300aee6:	08676713          	ori	a4,a4,134
 300aeea:	d7d8                	sw	a4,44(a5)
            break;
 300aeec:	a809                	j	300aefe <UART_SetParityBit+0x90>
        case UART_PARITY_NONE:
            uartHandle->baseAddress->UART_LCR_H.BIT.pen = BASE_CFG_DISABLE; /* No parity */
 300aeee:	fec42783          	lw	a5,-20(s0)
 300aef2:	4398                	lw	a4,0(a5)
 300aef4:	575c                	lw	a5,44(a4)
 300aef6:	9bf5                	andi	a5,a5,-3
 300aef8:	d75c                	sw	a5,44(a4)
            break;
 300aefa:	a011                	j	300aefe <UART_SetParityBit+0x90>
        default:
            return;
 300aefc:	0001                	nop
    }
}
 300aefe:	4472                	lw	s0,28(sp)
 300af00:	6105                	addi	sp,sp,32
 300af02:	8082                	ret

0300af04 <HAL_UART_Init>:
  * @brief Initialize the UART hardware configuration and configure parameters based on the specified handle.
  * @param uartHandle UART handle.
  * @retval BASE status type: OK, ERROR.
  */
BASE_StatusType HAL_UART_Init(UART_Handle *uartHandle)
{
 300af04:	7179                	addi	sp,sp,-48
 300af06:	d606                	sw	ra,44(sp)
 300af08:	d422                	sw	s0,40(sp)
 300af0a:	1800                	addi	s0,sp,48
 300af0c:	fca42e23          	sw	a0,-36(s0)
    UART_ASSERT_PARAM(uartHandle != NULL);
 300af10:	fdc42783          	lw	a5,-36(s0)
 300af14:	eb89                	bnez	a5,300af26 <HAL_UART_Init+0x22>
 300af16:	09700593          	li	a1,151
 300af1a:	030127b7          	lui	a5,0x3012
 300af1e:	e3878513          	addi	a0,a5,-456 # 3011e38 <g_crgIpMatch+0x5a0>
 300af22:	3311                	jal	ra,300ac26 <AssertErrorLog.trans.8>
 300af24:	a001                	j	300af24 <HAL_UART_Init+0x20>
    UART_ASSERT_PARAM(IsUARTInstance(uartHandle->baseAddress));
 300af26:	fdc42783          	lw	a5,-36(s0)
 300af2a:	4398                	lw	a4,0(a5)
 300af2c:	140007b7          	lui	a5,0x14000
 300af30:	02f70f63          	beq	a4,a5,300af6e <HAL_UART_Init+0x6a>
 300af34:	fdc42783          	lw	a5,-36(s0)
 300af38:	4398                	lw	a4,0(a5)
 300af3a:	140017b7          	lui	a5,0x14001
 300af3e:	02f70863          	beq	a4,a5,300af6e <HAL_UART_Init+0x6a>
 300af42:	fdc42783          	lw	a5,-36(s0)
 300af46:	4398                	lw	a4,0(a5)
 300af48:	140027b7          	lui	a5,0x14002
 300af4c:	02f70163          	beq	a4,a5,300af6e <HAL_UART_Init+0x6a>
 300af50:	fdc42783          	lw	a5,-36(s0)
 300af54:	4398                	lw	a4,0(a5)
 300af56:	140037b7          	lui	a5,0x14003
 300af5a:	00f70a63          	beq	a4,a5,300af6e <HAL_UART_Init+0x6a>
 300af5e:	09800593          	li	a1,152
 300af62:	030127b7          	lui	a5,0x3012
 300af66:	e3878513          	addi	a0,a5,-456 # 3011e38 <g_crgIpMatch+0x5a0>
 300af6a:	3975                	jal	ra,300ac26 <AssertErrorLog.trans.8>
 300af6c:	a001                	j	300af6c <HAL_UART_Init+0x68>
    UART_PARAM_CHECK_WITH_RET(uartHandle->txState == UART_STATE_NONE_INIT, BASE_STATUS_ERROR);
 300af6e:	fdc42783          	lw	a5,-36(s0)
 300af72:	47bc                	lw	a5,72(a5)
 300af74:	cb91                	beqz	a5,300af88 <HAL_UART_Init+0x84>
 300af76:	09900593          	li	a1,153
 300af7a:	030127b7          	lui	a5,0x3012
 300af7e:	e3878513          	addi	a0,a5,-456 # 3011e38 <g_crgIpMatch+0x5a0>
 300af82:	3155                	jal	ra,300ac26 <AssertErrorLog.trans.8>
 300af84:	4785                	li	a5,1
 300af86:	ae0d                	j	300b2b8 <HAL_UART_Init+0x3b4>
    UART_PARAM_CHECK_WITH_RET(uartHandle->rxState == UART_STATE_NONE_INIT, BASE_STATUS_ERROR);
 300af88:	fdc42783          	lw	a5,-36(s0)
 300af8c:	47fc                	lw	a5,76(a5)
 300af8e:	cb91                	beqz	a5,300afa2 <HAL_UART_Init+0x9e>
 300af90:	09a00593          	li	a1,154
 300af94:	030127b7          	lui	a5,0x3012
 300af98:	e3878513          	addi	a0,a5,-456 # 3011e38 <g_crgIpMatch+0x5a0>
 300af9c:	3169                	jal	ra,300ac26 <AssertErrorLog.trans.8>
 300af9e:	4785                	li	a5,1
 300afa0:	ae21                	j	300b2b8 <HAL_UART_Init+0x3b4>
    unsigned int uartClock, quot;
    UART_PARAM_CHECK_WITH_RET(IsUartDatalength(uartHandle->dataLength), BASE_STATUS_ERROR);
 300afa2:	fdc42783          	lw	a5,-36(s0)
 300afa6:	479c                	lw	a5,8(a5)
 300afa8:	853e                	mv	a0,a5
 300afaa:	3141                	jal	ra,300ac2a <IsUartDatalength>
 300afac:	87aa                	mv	a5,a0
 300afae:	0017c793          	xori	a5,a5,1
 300afb2:	9f81                	uxtb	a5
 300afb4:	cb91                	beqz	a5,300afc8 <HAL_UART_Init+0xc4>
 300afb6:	09c00593          	li	a1,156
 300afba:	030127b7          	lui	a5,0x3012
 300afbe:	e3878513          	addi	a0,a5,-456 # 3011e38 <g_crgIpMatch+0x5a0>
 300afc2:	3195                	jal	ra,300ac26 <AssertErrorLog.trans.8>
 300afc4:	4785                	li	a5,1
 300afc6:	accd                	j	300b2b8 <HAL_UART_Init+0x3b4>
    UART_PARAM_CHECK_WITH_RET(IsUartStopbits(uartHandle->stopBits), BASE_STATUS_ERROR);
 300afc8:	fdc42783          	lw	a5,-36(s0)
 300afcc:	47dc                	lw	a5,12(a5)
 300afce:	853e                	mv	a0,a5
 300afd0:	399d                	jal	ra,300ac46 <IsUartStopbits>
 300afd2:	87aa                	mv	a5,a0
 300afd4:	0017c793          	xori	a5,a5,1
 300afd8:	9f81                	uxtb	a5
 300afda:	cb91                	beqz	a5,300afee <HAL_UART_Init+0xea>
 300afdc:	09d00593          	li	a1,157
 300afe0:	030127b7          	lui	a5,0x3012
 300afe4:	e3878513          	addi	a0,a5,-456 # 3011e38 <g_crgIpMatch+0x5a0>
 300afe8:	393d                	jal	ra,300ac26 <AssertErrorLog.trans.8>
 300afea:	4785                	li	a5,1
 300afec:	a4f1                	j	300b2b8 <HAL_UART_Init+0x3b4>
    UART_PARAM_CHECK_WITH_RET(IsUartParitymode(uartHandle->parity), BASE_STATUS_ERROR);
 300afee:	fdc42783          	lw	a5,-36(s0)
 300aff2:	4b9c                	lw	a5,16(a5)
 300aff4:	853e                	mv	a0,a5
 300aff6:	39b5                	jal	ra,300ac72 <IsUartParitymode>
 300aff8:	87aa                	mv	a5,a0
 300affa:	0017c793          	xori	a5,a5,1
 300affe:	9f81                	uxtb	a5
 300b000:	cb91                	beqz	a5,300b014 <HAL_UART_Init+0x110>
 300b002:	09e00593          	li	a1,158
 300b006:	030127b7          	lui	a5,0x3012
 300b00a:	e3878513          	addi	a0,a5,-456 # 3011e38 <g_crgIpMatch+0x5a0>
 300b00e:	3921                	jal	ra,300ac26 <AssertErrorLog.trans.8>
 300b010:	4785                	li	a5,1
 300b012:	a45d                	j	300b2b8 <HAL_UART_Init+0x3b4>
    UART_PARAM_CHECK_WITH_RET(IsUartTransmode(uartHandle->txMode), BASE_STATUS_ERROR);
 300b014:	fdc42783          	lw	a5,-36(s0)
 300b018:	4bdc                	lw	a5,20(a5)
 300b01a:	853e                	mv	a0,a5
 300b01c:	39a5                	jal	ra,300ac94 <IsUartTransmode>
 300b01e:	87aa                	mv	a5,a0
 300b020:	0017c793          	xori	a5,a5,1
 300b024:	9f81                	uxtb	a5
 300b026:	cb91                	beqz	a5,300b03a <HAL_UART_Init+0x136>
 300b028:	09f00593          	li	a1,159
 300b02c:	030127b7          	lui	a5,0x3012
 300b030:	e3878513          	addi	a0,a5,-456 # 3011e38 <g_crgIpMatch+0x5a0>
 300b034:	3ecd                	jal	ra,300ac26 <AssertErrorLog.trans.8>
 300b036:	4785                	li	a5,1
 300b038:	a441                	j	300b2b8 <HAL_UART_Init+0x3b4>
    UART_PARAM_CHECK_WITH_RET(IsUartTransmode(uartHandle->rxMode), BASE_STATUS_ERROR);
 300b03a:	fdc42783          	lw	a5,-36(s0)
 300b03e:	4f9c                	lw	a5,24(a5)
 300b040:	853e                	mv	a0,a5
 300b042:	3989                	jal	ra,300ac94 <IsUartTransmode>
 300b044:	87aa                	mv	a5,a0
 300b046:	0017c793          	xori	a5,a5,1
 300b04a:	9f81                	uxtb	a5
 300b04c:	cb91                	beqz	a5,300b060 <HAL_UART_Init+0x15c>
 300b04e:	0a000593          	li	a1,160
 300b052:	030127b7          	lui	a5,0x3012
 300b056:	e3878513          	addi	a0,a5,-456 # 3011e38 <g_crgIpMatch+0x5a0>
 300b05a:	36f1                	jal	ra,300ac26 <AssertErrorLog.trans.8>
 300b05c:	4785                	li	a5,1
 300b05e:	aca9                	j	300b2b8 <HAL_UART_Init+0x3b4>
    UART_PARAM_CHECK_WITH_RET(IsUartFIFOThreshold(uartHandle->fifoTxThr), BASE_STATUS_ERROR);
 300b060:	fdc42783          	lw	a5,-36(s0)
 300b064:	5b9c                	lw	a5,48(a5)
 300b066:	853e                	mv	a0,a5
 300b068:	31a5                	jal	ra,300acd0 <IsUartFIFOThreshold>
 300b06a:	87aa                	mv	a5,a0
 300b06c:	0017c793          	xori	a5,a5,1
 300b070:	9f81                	uxtb	a5
 300b072:	cb91                	beqz	a5,300b086 <HAL_UART_Init+0x182>
 300b074:	0a100593          	li	a1,161
 300b078:	030127b7          	lui	a5,0x3012
 300b07c:	e3878513          	addi	a0,a5,-456 # 3011e38 <g_crgIpMatch+0x5a0>
 300b080:	365d                	jal	ra,300ac26 <AssertErrorLog.trans.8>
 300b082:	4785                	li	a5,1
 300b084:	ac15                	j	300b2b8 <HAL_UART_Init+0x3b4>
    UART_PARAM_CHECK_WITH_RET(IsUartFIFOThreshold(uartHandle->fifoRxThr), BASE_STATUS_ERROR);
 300b086:	fdc42783          	lw	a5,-36(s0)
 300b08a:	5bdc                	lw	a5,52(a5)
 300b08c:	853e                	mv	a0,a5
 300b08e:	3189                	jal	ra,300acd0 <IsUartFIFOThreshold>
 300b090:	87aa                	mv	a5,a0
 300b092:	0017c793          	xori	a5,a5,1
 300b096:	9f81                	uxtb	a5
 300b098:	cb91                	beqz	a5,300b0ac <HAL_UART_Init+0x1a8>
 300b09a:	0a200593          	li	a1,162
 300b09e:	030127b7          	lui	a5,0x3012
 300b0a2:	e3878513          	addi	a0,a5,-456 # 3011e38 <g_crgIpMatch+0x5a0>
 300b0a6:	3641                	jal	ra,300ac26 <AssertErrorLog.trans.8>
 300b0a8:	4785                	li	a5,1
 300b0aa:	a439                	j	300b2b8 <HAL_UART_Init+0x3b4>
    UART_PARAM_CHECK_WITH_RET(IsUartOversampleMultiple(uartHandle->handleEx.overSampleMultiple), BASE_STATUS_ERROR);
 300b0ac:	fdc42783          	lw	a5,-36(s0)
 300b0b0:	5fbc                	lw	a5,120(a5)
 300b0b2:	853e                	mv	a0,a5
 300b0b4:	3925                	jal	ra,300acec <IsUartOversampleMultiple>
 300b0b6:	87aa                	mv	a5,a0
 300b0b8:	0017c793          	xori	a5,a5,1
 300b0bc:	9f81                	uxtb	a5
 300b0be:	cb91                	beqz	a5,300b0d2 <HAL_UART_Init+0x1ce>
 300b0c0:	0a300593          	li	a1,163
 300b0c4:	030127b7          	lui	a5,0x3012
 300b0c8:	e3878513          	addi	a0,a5,-456 # 3011e38 <g_crgIpMatch+0x5a0>
 300b0cc:	3ea9                	jal	ra,300ac26 <AssertErrorLog.trans.8>
 300b0ce:	4785                	li	a5,1
 300b0d0:	a2e5                	j	300b2b8 <HAL_UART_Init+0x3b4>

    uartHandle->baseAddress->UART_CR.BIT.uarten = BASE_CFG_DISABLE;
 300b0d2:	fdc42783          	lw	a5,-36(s0)
 300b0d6:	4398                	lw	a4,0(a5)
 300b0d8:	5b1c                	lw	a5,48(a4)
 300b0da:	9bf9                	andi	a5,a5,-2
 300b0dc:	db1c                	sw	a5,48(a4)
    while (uartHandle->baseAddress->UART_FR.BIT.busy == 0x01) {
 300b0de:	0001                	nop
 300b0e0:	fdc42783          	lw	a5,-36(s0)
 300b0e4:	439c                	lw	a5,0(a5)
 300b0e6:	4f9c                	lw	a5,24(a5)
 300b0e8:	838d                	srli	a5,a5,0x3
 300b0ea:	8b85                	andi	a5,a5,1
 300b0ec:	0ff7f713          	andi	a4,a5,255
 300b0f0:	4785                	li	a5,1
 300b0f2:	fef707e3          	beq	a4,a5,300b0e0 <HAL_UART_Init+0x1dc>
        ;
    }

    uartClock = HAL_CRG_GetIpFreq((void *)uartHandle->baseAddress);
 300b0f6:	fdc42783          	lw	a5,-36(s0)
 300b0fa:	439c                	lw	a5,0(a5)
 300b0fc:	853e                	mv	a0,a5
 300b0fe:	e19f90ef          	jal	ra,3004f16 <HAL_CRG_GetIpFreq>
 300b102:	fea42623          	sw	a0,-20(s0)

    /* DCL OverSample Multiple check */
    uartHandle->baseAddress->UART_SPCFG.BIT.spcfg = uartHandle->handleEx.overSampleMultiple;
 300b106:	fdc42783          	lw	a5,-36(s0)
 300b10a:	5fb4                	lw	a3,120(a5)
 300b10c:	fdc42783          	lw	a5,-36(s0)
 300b110:	4398                	lw	a4,0(a5)
 300b112:	87b6                	mv	a5,a3
 300b114:	8bbd                	andi	a5,a5,15
 300b116:	0ff7f693          	andi	a3,a5,255
 300b11a:	4f3c                	lw	a5,88(a4)
 300b11c:	8abd                	andi	a3,a3,15
 300b11e:	9bc1                	andi	a5,a5,-16
 300b120:	8fd5                	or	a5,a5,a3
 300b122:	cf3c                	sw	a5,88(a4)

    /* DCL sequences setting */
    uartHandle->baseAddress->UART_DS.BIT.msbfirst = uartHandle->handleEx.msbFirst;
 300b124:	fdc42783          	lw	a5,-36(s0)
 300b128:	4398                	lw	a4,0(a5)
 300b12a:	fdc42783          	lw	a5,-36(s0)
 300b12e:	07c7c683          	lbu	a3,124(a5)
 300b132:	4b3c                	lw	a5,80(a4)
 300b134:	8a85                	andi	a3,a3,1
 300b136:	9bf9                	andi	a5,a5,-2
 300b138:	8fd5                	or	a5,a5,a3
 300b13a:	cb3c                	sw	a5,80(a4)

    /* The baud rate divider(BRD) based on the baud rate and clock frequency, calculation formula */
    unsigned int oversample = uartHandle->baseAddress->UART_SPCFG.reg;
 300b13c:	fdc42783          	lw	a5,-36(s0)
 300b140:	439c                	lw	a5,0(a5)
 300b142:	4fbc                	lw	a5,88(a5)
 300b144:	fef42423          	sw	a5,-24(s0)
    if (uartHandle->baudRate > (uartClock / (OVERSAMPLING_PARAM - oversample))) {
 300b148:	fdc42783          	lw	a5,-36(s0)
 300b14c:	43d8                	lw	a4,4(a5)
 300b14e:	46c1                	li	a3,16
 300b150:	fe842783          	lw	a5,-24(s0)
 300b154:	40f687b3          	sub	a5,a3,a5
 300b158:	fec42683          	lw	a3,-20(s0)
 300b15c:	02f6d7b3          	divu	a5,a3,a5
 300b160:	00e7f463          	bgeu	a5,a4,300b168 <HAL_UART_Init+0x264>
        return BASE_STATUS_ERROR;
 300b164:	4785                	li	a5,1
 300b166:	aa89                	j	300b2b8 <HAL_UART_Init+0x3b4>
    } else {
        unsigned int tmpClock = uartClock / (OVERSAMPLING_PARAM - oversample) * 64;  /* 64 is for decimal parts */
 300b168:	4741                	li	a4,16
 300b16a:	fe842783          	lw	a5,-24(s0)
 300b16e:	40f707b3          	sub	a5,a4,a5
 300b172:	fec42703          	lw	a4,-20(s0)
 300b176:	02f757b3          	divu	a5,a4,a5
 300b17a:	079a                	slli	a5,a5,0x6
 300b17c:	fef42223          	sw	a5,-28(s0)
        quot = DivClosest(tmpClock, uartHandle->baudRate);
 300b180:	fdc42783          	lw	a5,-36(s0)
 300b184:	43dc                	lw	a5,4(a5)
 300b186:	85be                	mv	a1,a5
 300b188:	fe442503          	lw	a0,-28(s0)
 300b18c:	3eb5                	jal	ra,300ad08 <DivClosest>
 300b18e:	fea42023          	sw	a0,-32(s0)
    }
    /* Clear the baud rate divider register */
    uartHandle->baseAddress->UART_FBRD.reg = 0;
 300b192:	fdc42783          	lw	a5,-36(s0)
 300b196:	439c                	lw	a5,0(a5)
 300b198:	0207a423          	sw	zero,40(a5)
    uartHandle->baseAddress->UART_IBRD.reg = 0;
 300b19c:	fdc42783          	lw	a5,-36(s0)
 300b1a0:	439c                	lw	a5,0(a5)
 300b1a2:	0207a223          	sw	zero,36(a5)
    /* The fractional baud rate divider value is stored to the lower 6 bits of the FBRD */
    uartHandle->baseAddress->UART_FBRD.reg = (quot & 0x3F);
 300b1a6:	fdc42783          	lw	a5,-36(s0)
 300b1aa:	439c                	lw	a5,0(a5)
 300b1ac:	fe042703          	lw	a4,-32(s0)
 300b1b0:	03f77713          	andi	a4,a4,63
 300b1b4:	d798                	sw	a4,40(a5)
    /* Right shift 6 bits is the integer baud rate divider value, is stored to IBRD */
    uartHandle->baseAddress->UART_IBRD.reg = (quot >> 6);
 300b1b6:	fdc42783          	lw	a5,-36(s0)
 300b1ba:	439c                	lw	a5,0(a5)
 300b1bc:	fe042703          	lw	a4,-32(s0)
 300b1c0:	8319                	srli	a4,a4,0x6
 300b1c2:	d3d8                	sw	a4,36(a5)
    uartHandle->baseAddress->UART_LCR_H.reg = 0;
 300b1c4:	fdc42783          	lw	a5,-36(s0)
 300b1c8:	439c                	lw	a5,0(a5)
 300b1ca:	0207a623          	sw	zero,44(a5)
    uartHandle->baseAddress->UART_LCR_H.BIT.wlen = uartHandle->dataLength;      /* Frame length seting */
 300b1ce:	fdc42783          	lw	a5,-36(s0)
 300b1d2:	4794                	lw	a3,8(a5)
 300b1d4:	fdc42783          	lw	a5,-36(s0)
 300b1d8:	4398                	lw	a4,0(a5)
 300b1da:	87b6                	mv	a5,a3
 300b1dc:	8b8d                	andi	a5,a5,3
 300b1de:	0ff7f693          	andi	a3,a5,255
 300b1e2:	575c                	lw	a5,44(a4)
 300b1e4:	8a8d                	andi	a3,a3,3
 300b1e6:	0696                	slli	a3,a3,0x5
 300b1e8:	f9f7f793          	andi	a5,a5,-97
 300b1ec:	8fd5                	or	a5,a5,a3
 300b1ee:	d75c                	sw	a5,44(a4)
    uartHandle->baseAddress->UART_LCR_H.BIT.stp2 = uartHandle->stopBits;        /* Stop bit seting */
 300b1f0:	fdc42783          	lw	a5,-36(s0)
 300b1f4:	47d4                	lw	a3,12(a5)
 300b1f6:	fdc42783          	lw	a5,-36(s0)
 300b1fa:	4398                	lw	a4,0(a5)
 300b1fc:	87b6                	mv	a5,a3
 300b1fe:	8b85                	andi	a5,a5,1
 300b200:	0ff7f693          	andi	a3,a5,255
 300b204:	575c                	lw	a5,44(a4)
 300b206:	8a85                	andi	a3,a3,1
 300b208:	068e                	slli	a3,a3,0x3
 300b20a:	9bdd                	andi	a5,a5,-9
 300b20c:	8fd5                	or	a5,a5,a3
 300b20e:	d75c                	sw	a5,44(a4)
    UART_SetParityBit(uartHandle);
 300b210:	fdc42503          	lw	a0,-36(s0)
 300b214:	39a9                	jal	ra,300ae6e <UART_SetParityBit>
    if (uartHandle->fifoMode == true) {                     /* FIFO threshold setting */
 300b216:	fdc42783          	lw	a5,-36(s0)
 300b21a:	02c7c783          	lbu	a5,44(a5)
 300b21e:	cbb1                	beqz	a5,300b272 <HAL_UART_Init+0x36e>
        uartHandle->baseAddress->UART_LCR_H.BIT.fen = BASE_CFG_ENABLE;
 300b220:	fdc42783          	lw	a5,-36(s0)
 300b224:	4398                	lw	a4,0(a5)
 300b226:	575c                	lw	a5,44(a4)
 300b228:	0107e793          	ori	a5,a5,16
 300b22c:	d75c                	sw	a5,44(a4)
        uartHandle->baseAddress->UART_IFLS.BIT.rxiflsel = uartHandle->fifoRxThr;
 300b22e:	fdc42783          	lw	a5,-36(s0)
 300b232:	5bd4                	lw	a3,52(a5)
 300b234:	fdc42783          	lw	a5,-36(s0)
 300b238:	4398                	lw	a4,0(a5)
 300b23a:	87b6                	mv	a5,a3
 300b23c:	8bbd                	andi	a5,a5,15
 300b23e:	0ff7f693          	andi	a3,a5,255
 300b242:	5b5c                	lw	a5,52(a4)
 300b244:	8abd                	andi	a3,a3,15
 300b246:	06a2                	slli	a3,a3,0x8
 300b248:	767d                	lui	a2,0xfffff
 300b24a:	0ff60613          	addi	a2,a2,255 # fffff0ff <RAM_END+0xfbff70ff>
 300b24e:	8ff1                	and	a5,a5,a2
 300b250:	8fd5                	or	a5,a5,a3
 300b252:	db5c                	sw	a5,52(a4)
        uartHandle->baseAddress->UART_IFLS.BIT.txiflsel = uartHandle->fifoTxThr;
 300b254:	fdc42783          	lw	a5,-36(s0)
 300b258:	5b94                	lw	a3,48(a5)
 300b25a:	fdc42783          	lw	a5,-36(s0)
 300b25e:	4398                	lw	a4,0(a5)
 300b260:	87b6                	mv	a5,a3
 300b262:	8bbd                	andi	a5,a5,15
 300b264:	0ff7f693          	andi	a3,a5,255
 300b268:	5b5c                	lw	a5,52(a4)
 300b26a:	8abd                	andi	a3,a3,15
 300b26c:	9bc1                	andi	a5,a5,-16
 300b26e:	8fd5                	or	a5,a5,a3
 300b270:	db5c                	sw	a5,52(a4)
    }
    if (uartHandle->hwFlowCtr == UART_HW_FLOWCTR_ENABLE) {  /* Hardwarer flow control setting */
 300b272:	fdc42783          	lw	a5,-36(s0)
 300b276:	5f98                	lw	a4,56(a5)
 300b278:	4785                	li	a5,1
 300b27a:	00f71c63          	bne	a4,a5,300b292 <HAL_UART_Init+0x38e>
        uartHandle->baseAddress->UART_CR.reg |= 0xC000;
 300b27e:	fdc42783          	lw	a5,-36(s0)
 300b282:	439c                	lw	a5,0(a5)
 300b284:	5b94                	lw	a3,48(a5)
 300b286:	fdc42783          	lw	a5,-36(s0)
 300b28a:	439c                	lw	a5,0(a5)
 300b28c:	6731                	lui	a4,0xc
 300b28e:	8f55                	or	a4,a4,a3
 300b290:	db98                	sw	a4,48(a5)
    }
    uartHandle->baseAddress->UART_CR.reg |= 0x301;          /* Enable bit use 0x301 is to set txe/rxe/uarten */
 300b292:	fdc42783          	lw	a5,-36(s0)
 300b296:	439c                	lw	a5,0(a5)
 300b298:	5b98                	lw	a4,48(a5)
 300b29a:	fdc42783          	lw	a5,-36(s0)
 300b29e:	439c                	lw	a5,0(a5)
 300b2a0:	30176713          	ori	a4,a4,769
 300b2a4:	db98                	sw	a4,48(a5)
    uartHandle->txState = UART_STATE_READY;
 300b2a6:	fdc42783          	lw	a5,-36(s0)
 300b2aa:	4705                	li	a4,1
 300b2ac:	c7b8                	sw	a4,72(a5)
    uartHandle->rxState = UART_STATE_READY;
 300b2ae:	fdc42783          	lw	a5,-36(s0)
 300b2b2:	4705                	li	a4,1
 300b2b4:	c7f8                	sw	a4,76(a5)
    return BASE_STATUS_OK;
 300b2b6:	4781                	li	a5,0
}
 300b2b8:	853e                	mv	a0,a5
 300b2ba:	50b2                	lw	ra,44(sp)
 300b2bc:	5422                	lw	s0,40(sp)
 300b2be:	6145                	addi	sp,sp,48
 300b2c0:	8082                	ret

0300b2c2 <HAL_UART_WriteIT>:
  * @param srcData Address of the data buff to be sent.
  * @param dataLength Number of the data to be sent.
  * @retval BASE status type: OK, ERROR, BUSY, TIMEOUT.
  */
BASE_StatusType HAL_UART_WriteIT(UART_Handle *uartHandle, unsigned char *srcData, unsigned int dataLength)
{
 300b2c2:	1101                	addi	sp,sp,-32
 300b2c4:	ce06                	sw	ra,28(sp)
 300b2c6:	cc22                	sw	s0,24(sp)
 300b2c8:	1000                	addi	s0,sp,32
 300b2ca:	fea42623          	sw	a0,-20(s0)
 300b2ce:	feb42423          	sw	a1,-24(s0)
 300b2d2:	fec42223          	sw	a2,-28(s0)
    UART_ASSERT_PARAM(uartHandle != NULL);
 300b2d6:	fec42783          	lw	a5,-20(s0)
 300b2da:	eb89                	bnez	a5,300b2ec <HAL_UART_WriteIT+0x2a>
 300b2dc:	14400593          	li	a1,324
 300b2e0:	030127b7          	lui	a5,0x3012
 300b2e4:	e3878513          	addi	a0,a5,-456 # 3011e38 <g_crgIpMatch+0x5a0>
 300b2e8:	3a3d                	jal	ra,300ac26 <AssertErrorLog.trans.8>
 300b2ea:	a001                	j	300b2ea <HAL_UART_WriteIT+0x28>
    UART_ASSERT_PARAM(IsUARTInstance(uartHandle->baseAddress));
 300b2ec:	fec42783          	lw	a5,-20(s0)
 300b2f0:	4398                	lw	a4,0(a5)
 300b2f2:	140007b7          	lui	a5,0x14000
 300b2f6:	02f70f63          	beq	a4,a5,300b334 <HAL_UART_WriteIT+0x72>
 300b2fa:	fec42783          	lw	a5,-20(s0)
 300b2fe:	4398                	lw	a4,0(a5)
 300b300:	140017b7          	lui	a5,0x14001
 300b304:	02f70863          	beq	a4,a5,300b334 <HAL_UART_WriteIT+0x72>
 300b308:	fec42783          	lw	a5,-20(s0)
 300b30c:	4398                	lw	a4,0(a5)
 300b30e:	140027b7          	lui	a5,0x14002
 300b312:	02f70163          	beq	a4,a5,300b334 <HAL_UART_WriteIT+0x72>
 300b316:	fec42783          	lw	a5,-20(s0)
 300b31a:	4398                	lw	a4,0(a5)
 300b31c:	140037b7          	lui	a5,0x14003
 300b320:	00f70a63          	beq	a4,a5,300b334 <HAL_UART_WriteIT+0x72>
 300b324:	14500593          	li	a1,325
 300b328:	030127b7          	lui	a5,0x3012
 300b32c:	e3878513          	addi	a0,a5,-456 # 3011e38 <g_crgIpMatch+0x5a0>
 300b330:	38dd                	jal	ra,300ac26 <AssertErrorLog.trans.8>
 300b332:	a001                	j	300b332 <HAL_UART_WriteIT+0x70>
    UART_PARAM_CHECK_WITH_RET(uartHandle->txMode == UART_MODE_INTERRUPT, BASE_STATUS_ERROR);
 300b334:	fec42783          	lw	a5,-20(s0)
 300b338:	4bd8                	lw	a4,20(a5)
 300b33a:	4785                	li	a5,1
 300b33c:	00f70b63          	beq	a4,a5,300b352 <HAL_UART_WriteIT+0x90>
 300b340:	14600593          	li	a1,326
 300b344:	030127b7          	lui	a5,0x3012
 300b348:	e3878513          	addi	a0,a5,-456 # 3011e38 <g_crgIpMatch+0x5a0>
 300b34c:	38e9                	jal	ra,300ac26 <AssertErrorLog.trans.8>
 300b34e:	4785                	li	a5,1
 300b350:	a861                	j	300b3e8 <HAL_UART_WriteIT+0x126>
    UART_PARAM_CHECK_WITH_RET(srcData != NULL, BASE_STATUS_ERROR);
 300b352:	fe842783          	lw	a5,-24(s0)
 300b356:	eb91                	bnez	a5,300b36a <HAL_UART_WriteIT+0xa8>
 300b358:	14700593          	li	a1,327
 300b35c:	030127b7          	lui	a5,0x3012
 300b360:	e3878513          	addi	a0,a5,-456 # 3011e38 <g_crgIpMatch+0x5a0>
 300b364:	2f01                	jal	ra,300ba74 <AssertErrorLog.trans.9>
 300b366:	4785                	li	a5,1
 300b368:	a041                	j	300b3e8 <HAL_UART_WriteIT+0x126>
    UART_PARAM_CHECK_WITH_RET(dataLength > 0, BASE_STATUS_ERROR);
 300b36a:	fe442783          	lw	a5,-28(s0)
 300b36e:	eb91                	bnez	a5,300b382 <HAL_UART_WriteIT+0xc0>
 300b370:	14800593          	li	a1,328
 300b374:	030127b7          	lui	a5,0x3012
 300b378:	e3878513          	addi	a0,a5,-456 # 3011e38 <g_crgIpMatch+0x5a0>
 300b37c:	2de5                	jal	ra,300ba74 <AssertErrorLog.trans.9>
 300b37e:	4785                	li	a5,1
 300b380:	a0a5                	j	300b3e8 <HAL_UART_WriteIT+0x126>

    if (uartHandle->txState == UART_STATE_READY) {
 300b382:	fec42783          	lw	a5,-20(s0)
 300b386:	47b8                	lw	a4,72(a5)
 300b388:	4785                	li	a5,1
 300b38a:	04f71c63          	bne	a4,a5,300b3e2 <HAL_UART_WriteIT+0x120>
        uartHandle->txState = UART_STATE_BUSY_TX;
 300b38e:	fec42783          	lw	a5,-20(s0)
 300b392:	470d                	li	a4,3
 300b394:	c7b8                	sw	a4,72(a5)
        uartHandle->txbuff = srcData;
 300b396:	fec42783          	lw	a5,-20(s0)
 300b39a:	fe842703          	lw	a4,-24(s0)
 300b39e:	cfd8                	sw	a4,28(a5)
        uartHandle->txBuffSize = dataLength;
 300b3a0:	fec42783          	lw	a5,-20(s0)
 300b3a4:	fe442703          	lw	a4,-28(s0)
 300b3a8:	d3d8                	sw	a4,36(a5)
        uartHandle->baseAddress->UART_ICR.BIT.txic = BASE_CFG_ENABLE;
 300b3aa:	fec42783          	lw	a5,-20(s0)
 300b3ae:	4398                	lw	a4,0(a5)
 300b3b0:	437c                	lw	a5,68(a4)
 300b3b2:	0207e793          	ori	a5,a5,32
 300b3b6:	c37c                	sw	a5,68(a4)
        if (uartHandle->fifoMode == true) {
 300b3b8:	fec42783          	lw	a5,-20(s0)
 300b3bc:	02c7c783          	lbu	a5,44(a5)
 300b3c0:	cb89                	beqz	a5,300b3d2 <HAL_UART_WriteIT+0x110>
            uartHandle->baseAddress->UART_IMSC.BIT.txim = BASE_CFG_ENABLE;
 300b3c2:	fec42783          	lw	a5,-20(s0)
 300b3c6:	4398                	lw	a4,0(a5)
 300b3c8:	5f1c                	lw	a5,56(a4)
 300b3ca:	0207e793          	ori	a5,a5,32
 300b3ce:	df1c                	sw	a5,56(a4)
 300b3d0:	a819                	j	300b3e6 <HAL_UART_WriteIT+0x124>
        } else {
            uartHandle->baseAddress->UART_IMSC.BIT.txfeim = BASE_CFG_ENABLE;
 300b3d2:	fec42783          	lw	a5,-20(s0)
 300b3d6:	4398                	lw	a4,0(a5)
 300b3d8:	5f1c                	lw	a5,56(a4)
 300b3da:	6685                	lui	a3,0x1
 300b3dc:	8fd5                	or	a5,a5,a3
 300b3de:	df1c                	sw	a5,56(a4)
 300b3e0:	a019                	j	300b3e6 <HAL_UART_WriteIT+0x124>
        }
    } else {
        return BASE_STATUS_BUSY;
 300b3e2:	4789                	li	a5,2
 300b3e4:	a011                	j	300b3e8 <HAL_UART_WriteIT+0x126>
    }
    return BASE_STATUS_OK;
 300b3e6:	4781                	li	a5,0
}
 300b3e8:	853e                	mv	a0,a5
 300b3ea:	40f2                	lw	ra,28(sp)
 300b3ec:	4462                	lw	s0,24(sp)
 300b3ee:	6105                	addi	sp,sp,32
 300b3f0:	8082                	ret

0300b3f2 <WriteITCallBack>:
  *        The hanler function is called when Tx interruption occurs.
  * @param uartHandle UART handle.
  * @retval None.
  */
static void WriteITCallBack(UART_Handle *uartHandle)
{
 300b3f2:	1101                	addi	sp,sp,-32
 300b3f4:	ce06                	sw	ra,28(sp)
 300b3f6:	cc22                	sw	s0,24(sp)
 300b3f8:	1000                	addi	s0,sp,32
 300b3fa:	fea42623          	sw	a0,-20(s0)
    UART_ASSERT_PARAM(uartHandle != NULL);
 300b3fe:	fec42783          	lw	a5,-20(s0)
 300b402:	eb89                	bnez	a5,300b414 <WriteITCallBack+0x22>
 300b404:	16200593          	li	a1,354
 300b408:	030127b7          	lui	a5,0x3012
 300b40c:	e3878513          	addi	a0,a5,-456 # 3011e38 <g_crgIpMatch+0x5a0>
 300b410:	2595                	jal	ra,300ba74 <AssertErrorLog.trans.9>
 300b412:	a001                	j	300b412 <WriteITCallBack+0x20>
    UART_ASSERT_PARAM(IsUARTInstance(uartHandle->baseAddress));
 300b414:	fec42783          	lw	a5,-20(s0)
 300b418:	4398                	lw	a4,0(a5)
 300b41a:	140007b7          	lui	a5,0x14000
 300b41e:	02f70f63          	beq	a4,a5,300b45c <WriteITCallBack+0x6a>
 300b422:	fec42783          	lw	a5,-20(s0)
 300b426:	4398                	lw	a4,0(a5)
 300b428:	140017b7          	lui	a5,0x14001
 300b42c:	02f70863          	beq	a4,a5,300b45c <WriteITCallBack+0x6a>
 300b430:	fec42783          	lw	a5,-20(s0)
 300b434:	4398                	lw	a4,0(a5)
 300b436:	140027b7          	lui	a5,0x14002
 300b43a:	02f70163          	beq	a4,a5,300b45c <WriteITCallBack+0x6a>
 300b43e:	fec42783          	lw	a5,-20(s0)
 300b442:	4398                	lw	a4,0(a5)
 300b444:	140037b7          	lui	a5,0x14003
 300b448:	00f70a63          	beq	a4,a5,300b45c <WriteITCallBack+0x6a>
 300b44c:	16300593          	li	a1,355
 300b450:	030127b7          	lui	a5,0x3012
 300b454:	e3878513          	addi	a0,a5,-456 # 3011e38 <g_crgIpMatch+0x5a0>
 300b458:	2d31                	jal	ra,300ba74 <AssertErrorLog.trans.9>
 300b45a:	a001                	j	300b45a <WriteITCallBack+0x68>
    UART_ASSERT_PARAM(uartHandle->txbuff != NULL);
 300b45c:	fec42783          	lw	a5,-20(s0)
 300b460:	4fdc                	lw	a5,28(a5)
 300b462:	eb89                	bnez	a5,300b474 <WriteITCallBack+0x82>
 300b464:	16400593          	li	a1,356
 300b468:	030127b7          	lui	a5,0x3012
 300b46c:	e3878513          	addi	a0,a5,-456 # 3011e38 <g_crgIpMatch+0x5a0>
 300b470:	2511                	jal	ra,300ba74 <AssertErrorLog.trans.9>
 300b472:	a001                	j	300b472 <WriteITCallBack+0x80>
    if (uartHandle->txState == UART_STATE_BUSY_TX) {
 300b474:	fec42783          	lw	a5,-20(s0)
 300b478:	47b8                	lw	a4,72(a5)
 300b47a:	478d                	li	a5,3
 300b47c:	0af71f63          	bne	a4,a5,300b53a <WriteITCallBack+0x148>
        while (uartHandle->txBuffSize > 0) {
 300b480:	a8a1                	j	300b4d8 <WriteITCallBack+0xe6>
            if (uartHandle->baseAddress->UART_FR.BIT.txff == 1) {  /* True when the TX FIFO is full */
 300b482:	fec42783          	lw	a5,-20(s0)
 300b486:	439c                	lw	a5,0(a5)
 300b488:	4f9c                	lw	a5,24(a5)
 300b48a:	8395                	srli	a5,a5,0x5
 300b48c:	8b85                	andi	a5,a5,1
 300b48e:	0ff7f713          	andi	a4,a5,255
 300b492:	4785                	li	a5,1
 300b494:	04f70763          	beq	a4,a5,300b4e2 <WriteITCallBack+0xf0>
                break;
            }
            uartHandle->baseAddress->UART_DR.BIT.data = *(uartHandle->txbuff);
 300b498:	fec42783          	lw	a5,-20(s0)
 300b49c:	4fdc                	lw	a5,28(a5)
 300b49e:	fec42703          	lw	a4,-20(s0)
 300b4a2:	4318                	lw	a4,0(a4)
 300b4a4:	239c                	lbu	a5,0(a5)
 300b4a6:	0ff7f693          	andi	a3,a5,255
 300b4aa:	431c                	lw	a5,0(a4)
 300b4ac:	0ff6f693          	andi	a3,a3,255
 300b4b0:	f007f793          	andi	a5,a5,-256
 300b4b4:	8fd5                	or	a5,a5,a3
 300b4b6:	c31c                	sw	a5,0(a4)
            (uartHandle->txbuff)++;
 300b4b8:	fec42783          	lw	a5,-20(s0)
 300b4bc:	4fdc                	lw	a5,28(a5)
 300b4be:	00178713          	addi	a4,a5,1
 300b4c2:	fec42783          	lw	a5,-20(s0)
 300b4c6:	cfd8                	sw	a4,28(a5)
            uartHandle->txBuffSize -= 1;
 300b4c8:	fec42783          	lw	a5,-20(s0)
 300b4cc:	53dc                	lw	a5,36(a5)
 300b4ce:	fff78713          	addi	a4,a5,-1
 300b4d2:	fec42783          	lw	a5,-20(s0)
 300b4d6:	d3d8                	sw	a4,36(a5)
        while (uartHandle->txBuffSize > 0) {
 300b4d8:	fec42783          	lw	a5,-20(s0)
 300b4dc:	53dc                	lw	a5,36(a5)
 300b4de:	f3d5                	bnez	a5,300b482 <WriteITCallBack+0x90>
 300b4e0:	a011                	j	300b4e4 <WriteITCallBack+0xf2>
                break;
 300b4e2:	0001                	nop
        }
        if (uartHandle->txBuffSize == 0) {
 300b4e4:	fec42783          	lw	a5,-20(s0)
 300b4e8:	53dc                	lw	a5,36(a5)
 300b4ea:	eba1                	bnez	a5,300b53a <WriteITCallBack+0x148>
            uartHandle->baseAddress->UART_IMSC.reg &= 0xFFFFEFDF;  /* Disable txim and txfeim */
 300b4ec:	fec42783          	lw	a5,-20(s0)
 300b4f0:	439c                	lw	a5,0(a5)
 300b4f2:	5f94                	lw	a3,56(a5)
 300b4f4:	fec42783          	lw	a5,-20(s0)
 300b4f8:	439c                	lw	a5,0(a5)
 300b4fa:	777d                	lui	a4,0xfffff
 300b4fc:	fdf70713          	addi	a4,a4,-33 # ffffefdf <RAM_END+0xfbff6fdf>
 300b500:	8f75                	and	a4,a4,a3
 300b502:	df98                	sw	a4,56(a5)
            uartHandle->baseAddress->UART_ICR.reg |= 0x1020;       /* Clear txic and txfeic */
 300b504:	fec42783          	lw	a5,-20(s0)
 300b508:	439c                	lw	a5,0(a5)
 300b50a:	43f4                	lw	a3,68(a5)
 300b50c:	fec42783          	lw	a5,-20(s0)
 300b510:	439c                	lw	a5,0(a5)
 300b512:	6705                	lui	a4,0x1
 300b514:	02070713          	addi	a4,a4,32 # 1020 <prithd+0x422>
 300b518:	8f55                	or	a4,a4,a3
 300b51a:	c3f8                	sw	a4,68(a5)
            uartHandle->txState = UART_STATE_READY;
 300b51c:	fec42783          	lw	a5,-20(s0)
 300b520:	4705                	li	a4,1
 300b522:	c7b8                	sw	a4,72(a5)
            /* Call user call back function */
            if (uartHandle->userCallBack.WriteItFinishCallBack != NULL) {
 300b524:	fec42783          	lw	a5,-20(s0)
 300b528:	4bfc                	lw	a5,84(a5)
 300b52a:	cb81                	beqz	a5,300b53a <WriteITCallBack+0x148>
                uartHandle->userCallBack.WriteItFinishCallBack(uartHandle);
 300b52c:	fec42783          	lw	a5,-20(s0)
 300b530:	4bfc                	lw	a5,84(a5)
 300b532:	fec42503          	lw	a0,-20(s0)
 300b536:	9782                	jalr	a5
            }
        }
    }
    return;
 300b538:	0001                	nop
 300b53a:	0001                	nop
}
 300b53c:	40f2                	lw	ra,28(sp)
 300b53e:	4462                	lw	s0,24(sp)
 300b540:	6105                	addi	sp,sp,32
 300b542:	8082                	ret

0300b544 <HAL_UART_ReadIT>:
  * @param saveData Address of the data buff to be saved.
  * @param dataLength length of the data int the storage buffer.
  * @retval BASE status type: OK, ERROR, BUSY, TIMEOUT.
  */
BASE_StatusType HAL_UART_ReadIT(UART_Handle *uartHandle, unsigned char *saveData, unsigned int dataLength)
{
 300b544:	1101                	addi	sp,sp,-32
 300b546:	ce06                	sw	ra,28(sp)
 300b548:	cc22                	sw	s0,24(sp)
 300b54a:	1000                	addi	s0,sp,32
 300b54c:	fea42623          	sw	a0,-20(s0)
 300b550:	feb42423          	sw	a1,-24(s0)
 300b554:	fec42223          	sw	a2,-28(s0)
    UART_ASSERT_PARAM(uartHandle != NULL);
 300b558:	fec42783          	lw	a5,-20(s0)
 300b55c:	eb89                	bnez	a5,300b56e <HAL_UART_ReadIT+0x2a>
 300b55e:	1e100593          	li	a1,481
 300b562:	030127b7          	lui	a5,0x3012
 300b566:	e3878513          	addi	a0,a5,-456 # 3011e38 <g_crgIpMatch+0x5a0>
 300b56a:	2329                	jal	ra,300ba74 <AssertErrorLog.trans.9>
 300b56c:	a001                	j	300b56c <HAL_UART_ReadIT+0x28>
    UART_ASSERT_PARAM(IsUARTInstance(uartHandle->baseAddress));
 300b56e:	fec42783          	lw	a5,-20(s0)
 300b572:	4398                	lw	a4,0(a5)
 300b574:	140007b7          	lui	a5,0x14000
 300b578:	02f70f63          	beq	a4,a5,300b5b6 <HAL_UART_ReadIT+0x72>
 300b57c:	fec42783          	lw	a5,-20(s0)
 300b580:	4398                	lw	a4,0(a5)
 300b582:	140017b7          	lui	a5,0x14001
 300b586:	02f70863          	beq	a4,a5,300b5b6 <HAL_UART_ReadIT+0x72>
 300b58a:	fec42783          	lw	a5,-20(s0)
 300b58e:	4398                	lw	a4,0(a5)
 300b590:	140027b7          	lui	a5,0x14002
 300b594:	02f70163          	beq	a4,a5,300b5b6 <HAL_UART_ReadIT+0x72>
 300b598:	fec42783          	lw	a5,-20(s0)
 300b59c:	4398                	lw	a4,0(a5)
 300b59e:	140037b7          	lui	a5,0x14003
 300b5a2:	00f70a63          	beq	a4,a5,300b5b6 <HAL_UART_ReadIT+0x72>
 300b5a6:	1e200593          	li	a1,482
 300b5aa:	030127b7          	lui	a5,0x3012
 300b5ae:	e3878513          	addi	a0,a5,-456 # 3011e38 <g_crgIpMatch+0x5a0>
 300b5b2:	21c9                	jal	ra,300ba74 <AssertErrorLog.trans.9>
 300b5b4:	a001                	j	300b5b4 <HAL_UART_ReadIT+0x70>
    UART_ASSERT_PARAM(saveData != NULL);
 300b5b6:	fe842783          	lw	a5,-24(s0)
 300b5ba:	eb89                	bnez	a5,300b5cc <HAL_UART_ReadIT+0x88>
 300b5bc:	1e300593          	li	a1,483
 300b5c0:	030127b7          	lui	a5,0x3012
 300b5c4:	e3878513          	addi	a0,a5,-456 # 3011e38 <g_crgIpMatch+0x5a0>
 300b5c8:	2175                	jal	ra,300ba74 <AssertErrorLog.trans.9>
 300b5ca:	a001                	j	300b5ca <HAL_UART_ReadIT+0x86>
    UART_PARAM_CHECK_WITH_RET(uartHandle->rxMode == UART_MODE_INTERRUPT, BASE_STATUS_ERROR);
 300b5cc:	fec42783          	lw	a5,-20(s0)
 300b5d0:	4f98                	lw	a4,24(a5)
 300b5d2:	4785                	li	a5,1
 300b5d4:	00f70b63          	beq	a4,a5,300b5ea <HAL_UART_ReadIT+0xa6>
 300b5d8:	1e400593          	li	a1,484
 300b5dc:	030127b7          	lui	a5,0x3012
 300b5e0:	e3878513          	addi	a0,a5,-456 # 3011e38 <g_crgIpMatch+0x5a0>
 300b5e4:	2941                	jal	ra,300ba74 <AssertErrorLog.trans.9>
 300b5e6:	4785                	li	a5,1
 300b5e8:	a051                	j	300b66c <HAL_UART_ReadIT+0x128>
    UART_PARAM_CHECK_WITH_RET(dataLength > 0, BASE_STATUS_ERROR);
 300b5ea:	fe442783          	lw	a5,-28(s0)
 300b5ee:	eb91                	bnez	a5,300b602 <HAL_UART_ReadIT+0xbe>
 300b5f0:	1e500593          	li	a1,485
 300b5f4:	030127b7          	lui	a5,0x3012
 300b5f8:	e3878513          	addi	a0,a5,-456 # 3011e38 <g_crgIpMatch+0x5a0>
 300b5fc:	29a5                	jal	ra,300ba74 <AssertErrorLog.trans.9>
 300b5fe:	4785                	li	a5,1
 300b600:	a0b5                	j	300b66c <HAL_UART_ReadIT+0x128>
    if (uartHandle->rxState == UART_STATE_READY) {
 300b602:	fec42783          	lw	a5,-20(s0)
 300b606:	47f8                	lw	a4,76(a5)
 300b608:	4785                	li	a5,1
 300b60a:	04f71e63          	bne	a4,a5,300b666 <HAL_UART_ReadIT+0x122>
        uartHandle->rxState = UART_STATE_BUSY_RX;
 300b60e:	fec42783          	lw	a5,-20(s0)
 300b612:	4711                	li	a4,4
 300b614:	c7f8                	sw	a4,76(a5)
        uartHandle->rxbuff = saveData;
 300b616:	fec42783          	lw	a5,-20(s0)
 300b61a:	fe842703          	lw	a4,-24(s0)
 300b61e:	d398                	sw	a4,32(a5)
        uartHandle->rxBuffSize = dataLength;
 300b620:	fec42783          	lw	a5,-20(s0)
 300b624:	fe442703          	lw	a4,-28(s0)
 300b628:	d798                	sw	a4,40(a5)
        if (uartHandle->fifoMode == true) {
 300b62a:	fec42783          	lw	a5,-20(s0)
 300b62e:	02c7c783          	lbu	a5,44(a5)
 300b632:	cf81                	beqz	a5,300b64a <HAL_UART_ReadIT+0x106>
            uartHandle->baseAddress->UART_IMSC.reg |= 0x7D0;  /* Enable rx interrupt and rx timeout interrupt */
 300b634:	fec42783          	lw	a5,-20(s0)
 300b638:	439c                	lw	a5,0(a5)
 300b63a:	5f98                	lw	a4,56(a5)
 300b63c:	fec42783          	lw	a5,-20(s0)
 300b640:	439c                	lw	a5,0(a5)
 300b642:	7d076713          	ori	a4,a4,2000
 300b646:	df98                	sw	a4,56(a5)
 300b648:	a00d                	j	300b66a <HAL_UART_ReadIT+0x126>
        } else {
            uartHandle->baseAddress->UART_IMSC.reg |= 0x20780;  /* Enable rx not empty interrupt */
 300b64a:	fec42783          	lw	a5,-20(s0)
 300b64e:	439c                	lw	a5,0(a5)
 300b650:	5f94                	lw	a3,56(a5)
 300b652:	fec42783          	lw	a5,-20(s0)
 300b656:	439c                	lw	a5,0(a5)
 300b658:	00020737          	lui	a4,0x20
 300b65c:	78070713          	addi	a4,a4,1920 # 20780 <FLASH_SIZE+0x784>
 300b660:	8f55                	or	a4,a4,a3
 300b662:	df98                	sw	a4,56(a5)
 300b664:	a019                	j	300b66a <HAL_UART_ReadIT+0x126>
        }
    } else {
        return BASE_STATUS_BUSY;
 300b666:	4789                	li	a5,2
 300b668:	a011                	j	300b66c <HAL_UART_ReadIT+0x128>
    }
    return BASE_STATUS_OK;
 300b66a:	4781                	li	a5,0
}
 300b66c:	853e                	mv	a0,a5
 300b66e:	40f2                	lw	ra,28(sp)
 300b670:	4462                	lw	s0,24(sp)
 300b672:	6105                	addi	sp,sp,32
 300b674:	8082                	ret

0300b676 <ReadITCallBack>:
  *        The hanler function is called when Rx interruption occurs.
  * @param uartHandle UART handle.
  * @retval None.
  */
static void ReadITCallBack(UART_Handle *uartHandle)
{
 300b676:	7179                	addi	sp,sp,-48
 300b678:	d606                	sw	ra,44(sp)
 300b67a:	d422                	sw	s0,40(sp)
 300b67c:	1800                	addi	s0,sp,48
 300b67e:	fca42e23          	sw	a0,-36(s0)
    UART_ASSERT_PARAM(uartHandle != NULL);
 300b682:	fdc42783          	lw	a5,-36(s0)
 300b686:	eb89                	bnez	a5,300b698 <ReadITCallBack+0x22>
 300b688:	1fd00593          	li	a1,509
 300b68c:	030127b7          	lui	a5,0x3012
 300b690:	e3878513          	addi	a0,a5,-456 # 3011e38 <g_crgIpMatch+0x5a0>
 300b694:	26c5                	jal	ra,300ba74 <AssertErrorLog.trans.9>
 300b696:	a001                	j	300b696 <ReadITCallBack+0x20>
    UART_ASSERT_PARAM(uartHandle->rxbuff != NULL);
 300b698:	fdc42783          	lw	a5,-36(s0)
 300b69c:	539c                	lw	a5,32(a5)
 300b69e:	eb89                	bnez	a5,300b6b0 <ReadITCallBack+0x3a>
 300b6a0:	1fe00593          	li	a1,510
 300b6a4:	030127b7          	lui	a5,0x3012
 300b6a8:	e3878513          	addi	a0,a5,-456 # 3011e38 <g_crgIpMatch+0x5a0>
 300b6ac:	26e1                	jal	ra,300ba74 <AssertErrorLog.trans.9>
 300b6ae:	a001                	j	300b6ae <ReadITCallBack+0x38>
    UART_ASSERT_PARAM(IsUARTInstance(uartHandle->baseAddress));
 300b6b0:	fdc42783          	lw	a5,-36(s0)
 300b6b4:	4398                	lw	a4,0(a5)
 300b6b6:	140007b7          	lui	a5,0x14000
 300b6ba:	02f70f63          	beq	a4,a5,300b6f8 <ReadITCallBack+0x82>
 300b6be:	fdc42783          	lw	a5,-36(s0)
 300b6c2:	4398                	lw	a4,0(a5)
 300b6c4:	140017b7          	lui	a5,0x14001
 300b6c8:	02f70863          	beq	a4,a5,300b6f8 <ReadITCallBack+0x82>
 300b6cc:	fdc42783          	lw	a5,-36(s0)
 300b6d0:	4398                	lw	a4,0(a5)
 300b6d2:	140027b7          	lui	a5,0x14002
 300b6d6:	02f70163          	beq	a4,a5,300b6f8 <ReadITCallBack+0x82>
 300b6da:	fdc42783          	lw	a5,-36(s0)
 300b6de:	4398                	lw	a4,0(a5)
 300b6e0:	140037b7          	lui	a5,0x14003
 300b6e4:	00f70a63          	beq	a4,a5,300b6f8 <ReadITCallBack+0x82>
 300b6e8:	1ff00593          	li	a1,511
 300b6ec:	030127b7          	lui	a5,0x3012
 300b6f0:	e3878513          	addi	a0,a5,-456 # 3011e38 <g_crgIpMatch+0x5a0>
 300b6f4:	2641                	jal	ra,300ba74 <AssertErrorLog.trans.9>
 300b6f6:	a001                	j	300b6f6 <ReadITCallBack+0x80>
    if (uartHandle->rxState == UART_STATE_BUSY_RX) {
 300b6f8:	fdc42783          	lw	a5,-36(s0)
 300b6fc:	47f8                	lw	a4,76(a5)
 300b6fe:	4791                	li	a5,4
 300b700:	0cf71163          	bne	a4,a5,300b7c2 <ReadITCallBack+0x14c>
        unsigned int tmp;
        while (uartHandle->rxBuffSize > 0) {
 300b704:	a889                	j	300b756 <ReadITCallBack+0xe0>
            if (uartHandle->baseAddress->UART_FR.BIT.rxfe == 0x01) {    /* True when the RX FIFO is empty */
 300b706:	fdc42783          	lw	a5,-36(s0)
 300b70a:	439c                	lw	a5,0(a5)
 300b70c:	4f9c                	lw	a5,24(a5)
 300b70e:	8391                	srli	a5,a5,0x4
 300b710:	8b85                	andi	a5,a5,1
 300b712:	0ff7f713          	andi	a4,a5,255
 300b716:	4785                	li	a5,1
 300b718:	04f70463          	beq	a4,a5,300b760 <ReadITCallBack+0xea>
                break;
            }
            tmp = uartHandle->baseAddress->UART_DR.reg;
 300b71c:	fdc42783          	lw	a5,-36(s0)
 300b720:	439c                	lw	a5,0(a5)
 300b722:	439c                	lw	a5,0(a5)
 300b724:	fef42623          	sw	a5,-20(s0)
            *(uartHandle->rxbuff) = (tmp & 0xFF);     /* Read from DR when holding register/FIFO is not empty */
 300b728:	fdc42783          	lw	a5,-36(s0)
 300b72c:	539c                	lw	a5,32(a5)
 300b72e:	fec42703          	lw	a4,-20(s0)
 300b732:	9f01                	uxtb	a4
 300b734:	a398                	sb	a4,0(a5)
            uartHandle->rxbuff++;
 300b736:	fdc42783          	lw	a5,-36(s0)
 300b73a:	539c                	lw	a5,32(a5)
 300b73c:	00178713          	addi	a4,a5,1
 300b740:	fdc42783          	lw	a5,-36(s0)
 300b744:	d398                	sw	a4,32(a5)
            uartHandle->rxBuffSize -= 1;
 300b746:	fdc42783          	lw	a5,-36(s0)
 300b74a:	579c                	lw	a5,40(a5)
 300b74c:	fff78713          	addi	a4,a5,-1
 300b750:	fdc42783          	lw	a5,-36(s0)
 300b754:	d798                	sw	a4,40(a5)
        while (uartHandle->rxBuffSize > 0) {
 300b756:	fdc42783          	lw	a5,-36(s0)
 300b75a:	579c                	lw	a5,40(a5)
 300b75c:	f7cd                	bnez	a5,300b706 <ReadITCallBack+0x90>
 300b75e:	a011                	j	300b762 <ReadITCallBack+0xec>
                break;
 300b760:	0001                	nop
        }
        if (uartHandle->rxBuffSize == 0) {
 300b762:	fdc42783          	lw	a5,-36(s0)
 300b766:	579c                	lw	a5,40(a5)
 300b768:	e38d                	bnez	a5,300b78a <ReadITCallBack+0x114>
            uartHandle->baseAddress->UART_IMSC.reg &= 0xFFFDFFAF;   /* Disable rxim ,rtim and rxfneim */
 300b76a:	fdc42783          	lw	a5,-36(s0)
 300b76e:	439c                	lw	a5,0(a5)
 300b770:	5f94                	lw	a3,56(a5)
 300b772:	fdc42783          	lw	a5,-36(s0)
 300b776:	439c                	lw	a5,0(a5)
 300b778:	7701                	lui	a4,0xfffe0
 300b77a:	faf70713          	addi	a4,a4,-81 # fffdffaf <RAM_END+0xfbfd7faf>
 300b77e:	8f75                	and	a4,a4,a3
 300b780:	df98                	sw	a4,56(a5)
            uartHandle->rxState = UART_STATE_READY;
 300b782:	fdc42783          	lw	a5,-36(s0)
 300b786:	4705                	li	a4,1
 300b788:	c7f8                	sw	a4,76(a5)
        }
        uartHandle->baseAddress->UART_ICR.reg |= 0x20050;      /* Clear rxic, rtic and rxfneic */
 300b78a:	fdc42783          	lw	a5,-36(s0)
 300b78e:	439c                	lw	a5,0(a5)
 300b790:	43f4                	lw	a3,68(a5)
 300b792:	fdc42783          	lw	a5,-36(s0)
 300b796:	439c                	lw	a5,0(a5)
 300b798:	00020737          	lui	a4,0x20
 300b79c:	05070713          	addi	a4,a4,80 # 20050 <FLASH_SIZE+0x54>
 300b7a0:	8f55                	or	a4,a4,a3
 300b7a2:	c3f8                	sw	a4,68(a5)
        if (uartHandle->userCallBack.ReadItFinishCallBack != NULL && uartHandle->rxBuffSize == 0) {
 300b7a4:	fdc42783          	lw	a5,-36(s0)
 300b7a8:	4fbc                	lw	a5,88(a5)
 300b7aa:	cf81                	beqz	a5,300b7c2 <ReadITCallBack+0x14c>
 300b7ac:	fdc42783          	lw	a5,-36(s0)
 300b7b0:	579c                	lw	a5,40(a5)
 300b7b2:	eb81                	bnez	a5,300b7c2 <ReadITCallBack+0x14c>
            uartHandle->userCallBack.ReadItFinishCallBack(uartHandle);
 300b7b4:	fdc42783          	lw	a5,-36(s0)
 300b7b8:	4fbc                	lw	a5,88(a5)
 300b7ba:	fdc42503          	lw	a0,-36(s0)
 300b7be:	9782                	jalr	a5
        }
    }
    return;
 300b7c0:	0001                	nop
 300b7c2:	0001                	nop
}
 300b7c4:	50b2                	lw	ra,44(sp)
 300b7c6:	5422                	lw	s0,40(sp)
 300b7c8:	6145                	addi	sp,sp,48
 300b7ca:	8082                	ret

0300b7cc <ErrorServiceCallback>:
  * @brief Error handler function of receiving.
  * @param uartHandle UART handle.
  * @retval None.
  */
static void ErrorServiceCallback(UART_Handle *uartHandle)
{
 300b7cc:	7179                	addi	sp,sp,-48
 300b7ce:	d606                	sw	ra,44(sp)
 300b7d0:	d422                	sw	s0,40(sp)
 300b7d2:	1800                	addi	s0,sp,48
 300b7d4:	fca42e23          	sw	a0,-36(s0)
    unsigned int error = 0x00;
 300b7d8:	fe042623          	sw	zero,-20(s0)
    if (uartHandle->baseAddress->UART_MIS.BIT.oemis == BASE_CFG_ENABLE) {            /* Overflow error interrupt */
 300b7dc:	fdc42783          	lw	a5,-36(s0)
 300b7e0:	439c                	lw	a5,0(a5)
 300b7e2:	43bc                	lw	a5,64(a5)
 300b7e4:	83a9                	srli	a5,a5,0xa
 300b7e6:	8b85                	andi	a5,a5,1
 300b7e8:	0ff7f713          	andi	a4,a5,255
 300b7ec:	4785                	li	a5,1
 300b7ee:	02f71763          	bne	a4,a5,300b81c <ErrorServiceCallback+0x50>
        error |= uartHandle->baseAddress->UART_MIS.BIT.oemis;
 300b7f2:	fdc42783          	lw	a5,-36(s0)
 300b7f6:	439c                	lw	a5,0(a5)
 300b7f8:	43bc                	lw	a5,64(a5)
 300b7fa:	83a9                	srli	a5,a5,0xa
 300b7fc:	8b85                	andi	a5,a5,1
 300b7fe:	9f81                	uxtb	a5
 300b800:	873e                	mv	a4,a5
 300b802:	fec42783          	lw	a5,-20(s0)
 300b806:	8fd9                	or	a5,a5,a4
 300b808:	fef42623          	sw	a5,-20(s0)
        uartHandle->baseAddress->UART_ICR.BIT.oeic = BASE_CFG_ENABLE;
 300b80c:	fdc42783          	lw	a5,-36(s0)
 300b810:	4398                	lw	a4,0(a5)
 300b812:	437c                	lw	a5,68(a4)
 300b814:	4007e793          	ori	a5,a5,1024
 300b818:	c37c                	sw	a5,68(a4)
 300b81a:	a0c1                	j	300b8da <ErrorServiceCallback+0x10e>
    } else if (uartHandle->baseAddress->UART_MIS.BIT.bemis == BASE_CFG_ENABLE) {     /* Break error interrupt */
 300b81c:	fdc42783          	lw	a5,-36(s0)
 300b820:	439c                	lw	a5,0(a5)
 300b822:	43bc                	lw	a5,64(a5)
 300b824:	83a5                	srli	a5,a5,0x9
 300b826:	8b85                	andi	a5,a5,1
 300b828:	0ff7f713          	andi	a4,a5,255
 300b82c:	4785                	li	a5,1
 300b82e:	02f71763          	bne	a4,a5,300b85c <ErrorServiceCallback+0x90>
        error |= uartHandle->baseAddress->UART_MIS.BIT.bemis;
 300b832:	fdc42783          	lw	a5,-36(s0)
 300b836:	439c                	lw	a5,0(a5)
 300b838:	43bc                	lw	a5,64(a5)
 300b83a:	83a5                	srli	a5,a5,0x9
 300b83c:	8b85                	andi	a5,a5,1
 300b83e:	9f81                	uxtb	a5
 300b840:	873e                	mv	a4,a5
 300b842:	fec42783          	lw	a5,-20(s0)
 300b846:	8fd9                	or	a5,a5,a4
 300b848:	fef42623          	sw	a5,-20(s0)
        uartHandle->baseAddress->UART_ICR.BIT.beic = BASE_CFG_ENABLE;
 300b84c:	fdc42783          	lw	a5,-36(s0)
 300b850:	4398                	lw	a4,0(a5)
 300b852:	437c                	lw	a5,68(a4)
 300b854:	2007e793          	ori	a5,a5,512
 300b858:	c37c                	sw	a5,68(a4)
 300b85a:	a041                	j	300b8da <ErrorServiceCallback+0x10e>
    } else if (uartHandle->baseAddress->UART_MIS.BIT.pemis == BASE_CFG_ENABLE) {     /* Check error interrupt */
 300b85c:	fdc42783          	lw	a5,-36(s0)
 300b860:	439c                	lw	a5,0(a5)
 300b862:	43bc                	lw	a5,64(a5)
 300b864:	83a1                	srli	a5,a5,0x8
 300b866:	8b85                	andi	a5,a5,1
 300b868:	0ff7f713          	andi	a4,a5,255
 300b86c:	4785                	li	a5,1
 300b86e:	02f71763          	bne	a4,a5,300b89c <ErrorServiceCallback+0xd0>
        error |= uartHandle->baseAddress->UART_MIS.BIT.pemis;
 300b872:	fdc42783          	lw	a5,-36(s0)
 300b876:	439c                	lw	a5,0(a5)
 300b878:	43bc                	lw	a5,64(a5)
 300b87a:	83a1                	srli	a5,a5,0x8
 300b87c:	8b85                	andi	a5,a5,1
 300b87e:	9f81                	uxtb	a5
 300b880:	873e                	mv	a4,a5
 300b882:	fec42783          	lw	a5,-20(s0)
 300b886:	8fd9                	or	a5,a5,a4
 300b888:	fef42623          	sw	a5,-20(s0)
        uartHandle->baseAddress->UART_ICR.BIT.peic = BASE_CFG_ENABLE;
 300b88c:	fdc42783          	lw	a5,-36(s0)
 300b890:	4398                	lw	a4,0(a5)
 300b892:	437c                	lw	a5,68(a4)
 300b894:	1007e793          	ori	a5,a5,256
 300b898:	c37c                	sw	a5,68(a4)
 300b89a:	a081                	j	300b8da <ErrorServiceCallback+0x10e>
    } else if (uartHandle->baseAddress->UART_MIS.BIT.femis == BASE_CFG_ENABLE) {     /* Frame error interrupt */
 300b89c:	fdc42783          	lw	a5,-36(s0)
 300b8a0:	439c                	lw	a5,0(a5)
 300b8a2:	43bc                	lw	a5,64(a5)
 300b8a4:	839d                	srli	a5,a5,0x7
 300b8a6:	8b85                	andi	a5,a5,1
 300b8a8:	0ff7f713          	andi	a4,a5,255
 300b8ac:	4785                	li	a5,1
 300b8ae:	02f71663          	bne	a4,a5,300b8da <ErrorServiceCallback+0x10e>
        error |= uartHandle->baseAddress->UART_MIS.BIT.femis;
 300b8b2:	fdc42783          	lw	a5,-36(s0)
 300b8b6:	439c                	lw	a5,0(a5)
 300b8b8:	43bc                	lw	a5,64(a5)
 300b8ba:	839d                	srli	a5,a5,0x7
 300b8bc:	8b85                	andi	a5,a5,1
 300b8be:	9f81                	uxtb	a5
 300b8c0:	873e                	mv	a4,a5
 300b8c2:	fec42783          	lw	a5,-20(s0)
 300b8c6:	8fd9                	or	a5,a5,a4
 300b8c8:	fef42623          	sw	a5,-20(s0)
        uartHandle->baseAddress->UART_ICR.BIT.feic = BASE_CFG_ENABLE;
 300b8cc:	fdc42783          	lw	a5,-36(s0)
 300b8d0:	4398                	lw	a4,0(a5)
 300b8d2:	437c                	lw	a5,68(a4)
 300b8d4:	0807e793          	ori	a5,a5,128
 300b8d8:	c37c                	sw	a5,68(a4)
    }
    if (error != 0x00) {
 300b8da:	fec42783          	lw	a5,-20(s0)
 300b8de:	c79d                	beqz	a5,300b90c <ErrorServiceCallback+0x140>
        uartHandle->errorType = error;
 300b8e0:	fdc42783          	lw	a5,-36(s0)
 300b8e4:	fec42703          	lw	a4,-20(s0)
 300b8e8:	cbb8                	sw	a4,80(a5)
        if (uartHandle->rxMode == UART_MODE_INTERRUPT && uartHandle->userCallBack.TransmitItErrorCallBack != NULL) {
 300b8ea:	fdc42783          	lw	a5,-36(s0)
 300b8ee:	4f98                	lw	a4,24(a5)
 300b8f0:	4785                	li	a5,1
 300b8f2:	00f71d63          	bne	a4,a5,300b90c <ErrorServiceCallback+0x140>
 300b8f6:	fdc42783          	lw	a5,-36(s0)
 300b8fa:	53fc                	lw	a5,100(a5)
 300b8fc:	cb81                	beqz	a5,300b90c <ErrorServiceCallback+0x140>
            uartHandle->userCallBack.TransmitItErrorCallBack(uartHandle);
 300b8fe:	fdc42783          	lw	a5,-36(s0)
 300b902:	53fc                	lw	a5,100(a5)
 300b904:	fdc42503          	lw	a0,-36(s0)
 300b908:	9782                	jalr	a5
        }
    }
    return;
 300b90a:	0001                	nop
 300b90c:	0001                	nop
}
 300b90e:	50b2                	lw	ra,44(sp)
 300b910:	5422                	lw	s0,40(sp)
 300b912:	6145                	addi	sp,sp,48
 300b914:	8082                	ret

0300b916 <HAL_UART_IrqHandler>:
  * @brief UART Interrupt service processing function.
  * @param handle UART handle.
  * @retval None.
  */
void HAL_UART_IrqHandler(void *handle)
{
 300b916:	7179                	addi	sp,sp,-48
 300b918:	d606                	sw	ra,44(sp)
 300b91a:	d422                	sw	s0,40(sp)
 300b91c:	1800                	addi	s0,sp,48
 300b91e:	fca42e23          	sw	a0,-36(s0)
    UART_ASSERT_PARAM(handle != NULL);
 300b922:	fdc42783          	lw	a5,-36(s0)
 300b926:	eb89                	bnez	a5,300b938 <HAL_UART_IrqHandler+0x22>
 300b928:	2d200593          	li	a1,722
 300b92c:	030127b7          	lui	a5,0x3012
 300b930:	e3878513          	addi	a0,a5,-456 # 3011e38 <g_crgIpMatch+0x5a0>
 300b934:	2281                	jal	ra,300ba74 <AssertErrorLog.trans.9>
 300b936:	a001                	j	300b936 <HAL_UART_IrqHandler+0x20>
    UART_Handle *uartHandle = (UART_Handle *)handle;
 300b938:	fdc42783          	lw	a5,-36(s0)
 300b93c:	fef42623          	sw	a5,-20(s0)
    UART_ASSERT_PARAM(IsUARTInstance(uartHandle->baseAddress));
 300b940:	fec42783          	lw	a5,-20(s0)
 300b944:	4398                	lw	a4,0(a5)
 300b946:	140007b7          	lui	a5,0x14000
 300b94a:	02f70f63          	beq	a4,a5,300b988 <HAL_UART_IrqHandler+0x72>
 300b94e:	fec42783          	lw	a5,-20(s0)
 300b952:	4398                	lw	a4,0(a5)
 300b954:	140017b7          	lui	a5,0x14001
 300b958:	02f70863          	beq	a4,a5,300b988 <HAL_UART_IrqHandler+0x72>
 300b95c:	fec42783          	lw	a5,-20(s0)
 300b960:	4398                	lw	a4,0(a5)
 300b962:	140027b7          	lui	a5,0x14002
 300b966:	02f70163          	beq	a4,a5,300b988 <HAL_UART_IrqHandler+0x72>
 300b96a:	fec42783          	lw	a5,-20(s0)
 300b96e:	4398                	lw	a4,0(a5)
 300b970:	140037b7          	lui	a5,0x14003
 300b974:	00f70a63          	beq	a4,a5,300b988 <HAL_UART_IrqHandler+0x72>
 300b978:	2d400593          	li	a1,724
 300b97c:	030127b7          	lui	a5,0x3012
 300b980:	e3878513          	addi	a0,a5,-456 # 3011e38 <g_crgIpMatch+0x5a0>
 300b984:	28c5                	jal	ra,300ba74 <AssertErrorLog.trans.9>
 300b986:	a001                	j	300b986 <HAL_UART_IrqHandler+0x70>
    /* when tx interrupt is generated */
    if ((uartHandle->baseAddress->UART_MIS.BIT.txmis == 0x01) ||
 300b988:	fec42783          	lw	a5,-20(s0)
 300b98c:	439c                	lw	a5,0(a5)
 300b98e:	43bc                	lw	a5,64(a5)
 300b990:	8395                	srli	a5,a5,0x5
 300b992:	8b85                	andi	a5,a5,1
 300b994:	0ff7f713          	andi	a4,a5,255
 300b998:	4785                	li	a5,1
 300b99a:	00f70d63          	beq	a4,a5,300b9b4 <HAL_UART_IrqHandler+0x9e>
        (uartHandle->baseAddress->UART_MIS.BIT.txfeis == 0x01)) {
 300b99e:	fec42783          	lw	a5,-20(s0)
 300b9a2:	439c                	lw	a5,0(a5)
 300b9a4:	43bc                	lw	a5,64(a5)
 300b9a6:	83b1                	srli	a5,a5,0xc
 300b9a8:	8b85                	andi	a5,a5,1
 300b9aa:	0ff7f713          	andi	a4,a5,255
    if ((uartHandle->baseAddress->UART_MIS.BIT.txmis == 0x01) ||
 300b9ae:	4785                	li	a5,1
 300b9b0:	00f71563          	bne	a4,a5,300b9ba <HAL_UART_IrqHandler+0xa4>
        WriteITCallBack(uartHandle);
 300b9b4:	fec42503          	lw	a0,-20(s0)
 300b9b8:	3c2d                	jal	ra,300b3f2 <WriteITCallBack>
    }
    /* when rx interrupt is generated */
    if ((uartHandle->baseAddress->UART_MIS.BIT.rxmis == 0x01 || uartHandle->baseAddress->UART_MIS.BIT.rtmis == 0x01) ||
 300b9ba:	fec42783          	lw	a5,-20(s0)
 300b9be:	439c                	lw	a5,0(a5)
 300b9c0:	43bc                	lw	a5,64(a5)
 300b9c2:	8391                	srli	a5,a5,0x4
 300b9c4:	8b85                	andi	a5,a5,1
 300b9c6:	0ff7f713          	andi	a4,a5,255
 300b9ca:	4785                	li	a5,1
 300b9cc:	02f70863          	beq	a4,a5,300b9fc <HAL_UART_IrqHandler+0xe6>
 300b9d0:	fec42783          	lw	a5,-20(s0)
 300b9d4:	439c                	lw	a5,0(a5)
 300b9d6:	43bc                	lw	a5,64(a5)
 300b9d8:	8399                	srli	a5,a5,0x6
 300b9da:	8b85                	andi	a5,a5,1
 300b9dc:	0ff7f713          	andi	a4,a5,255
 300b9e0:	4785                	li	a5,1
 300b9e2:	00f70d63          	beq	a4,a5,300b9fc <HAL_UART_IrqHandler+0xe6>
        (uartHandle->baseAddress->UART_MIS.BIT.rxfneis == 0x1)) {
 300b9e6:	fec42783          	lw	a5,-20(s0)
 300b9ea:	439c                	lw	a5,0(a5)
 300b9ec:	43bc                	lw	a5,64(a5)
 300b9ee:	83c5                	srli	a5,a5,0x11
 300b9f0:	8b85                	andi	a5,a5,1
 300b9f2:	0ff7f713          	andi	a4,a5,255
    if ((uartHandle->baseAddress->UART_MIS.BIT.rxmis == 0x01 || uartHandle->baseAddress->UART_MIS.BIT.rtmis == 0x01) ||
 300b9f6:	4785                	li	a5,1
 300b9f8:	00f71563          	bne	a4,a5,300ba02 <HAL_UART_IrqHandler+0xec>
        ReadITCallBack(uartHandle);
 300b9fc:	fec42503          	lw	a0,-20(s0)
 300ba00:	399d                	jal	ra,300b676 <ReadITCallBack>
    }
    /* when charter match interrupt is generated */
    if (uartHandle->baseAddress->UART_MIS.BIT.cmis == 0x01) {
 300ba02:	fec42783          	lw	a5,-20(s0)
 300ba06:	439c                	lw	a5,0(a5)
 300ba08:	43bc                	lw	a5,64(a5)
 300ba0a:	83d5                	srli	a5,a5,0x15
 300ba0c:	8b85                	andi	a5,a5,1
 300ba0e:	0ff7f713          	andi	a4,a5,255
 300ba12:	4785                	li	a5,1
 300ba14:	00f71663          	bne	a4,a5,300ba20 <HAL_UART_IrqHandler+0x10a>
        CharterMatchCallBack(uartHandle);
 300ba18:	fec42503          	lw	a0,-20(s0)
 300ba1c:	c06ff0ef          	jal	ra,300ae22 <CharterMatchCallBack>
    }
    /* when baud detect interrupt is generated */
    if (uartHandle->baseAddress->UART_MIS.BIT.abdcis == 0x01 || uartHandle->baseAddress->UART_MIS.BIT.abdeis == 0x01) {
 300ba20:	fec42783          	lw	a5,-20(s0)
 300ba24:	439c                	lw	a5,0(a5)
 300ba26:	43bc                	lw	a5,64(a5)
 300ba28:	83cd                	srli	a5,a5,0x13
 300ba2a:	8b85                	andi	a5,a5,1
 300ba2c:	0ff7f713          	andi	a4,a5,255
 300ba30:	4785                	li	a5,1
 300ba32:	00f70d63          	beq	a4,a5,300ba4c <HAL_UART_IrqHandler+0x136>
 300ba36:	fec42783          	lw	a5,-20(s0)
 300ba3a:	439c                	lw	a5,0(a5)
 300ba3c:	43bc                	lw	a5,64(a5)
 300ba3e:	83d1                	srli	a5,a5,0x14
 300ba40:	8b85                	andi	a5,a5,1
 300ba42:	0ff7f713          	andi	a4,a5,255
 300ba46:	4785                	li	a5,1
 300ba48:	00f71663          	bne	a4,a5,300ba54 <HAL_UART_IrqHandler+0x13e>
        BaudDetectCallBack(uartHandle);
 300ba4c:	fec42503          	lw	a0,-20(s0)
 300ba50:	af6ff0ef          	jal	ra,300ad46 <BaudDetectCallBack>
    }
    /* when error interrupt is generated */
    if ((uartHandle->baseAddress->UART_MIS.reg & 0x780) != 0) {
 300ba54:	fec42783          	lw	a5,-20(s0)
 300ba58:	439c                	lw	a5,0(a5)
 300ba5a:	43bc                	lw	a5,64(a5)
 300ba5c:	7807f793          	andi	a5,a5,1920
 300ba60:	c789                	beqz	a5,300ba6a <HAL_UART_IrqHandler+0x154>
        ErrorServiceCallback(uartHandle);
 300ba62:	fec42503          	lw	a0,-20(s0)
 300ba66:	339d                	jal	ra,300b7cc <ErrorServiceCallback>
    }
    return;
 300ba68:	0001                	nop
 300ba6a:	0001                	nop
}
 300ba6c:	50b2                	lw	ra,44(sp)
 300ba6e:	5422                	lw	s0,40(sp)
 300ba70:	6145                	addi	sp,sp,48
 300ba72:	8082                	ret

0300ba74 <AssertErrorLog.trans.9>:
 300ba74:	adef706f          	j	3002d52 <AssertErrorLog>

0300ba78 <HAL_UART_RegisterCallBack>:
  * @param pCallback pointer of the specified callbcak function, @ref UART_CallbackType
  * @retval BASE_StatusType: OK, ERROR.
  */
BASE_StatusType HAL_UART_RegisterCallBack(UART_Handle *uartHandle, UART_CallbackFun_Type typeID,
                                          UART_CallbackType pCallback)
{
 300ba78:	1101                	addi	sp,sp,-32
 300ba7a:	ce06                	sw	ra,28(sp)
 300ba7c:	cc22                	sw	s0,24(sp)
 300ba7e:	1000                	addi	s0,sp,32
 300ba80:	fea42623          	sw	a0,-20(s0)
 300ba84:	feb42423          	sw	a1,-24(s0)
 300ba88:	fec42223          	sw	a2,-28(s0)
    UART_ASSERT_PARAM(uartHandle != NULL);
 300ba8c:	fec42783          	lw	a5,-20(s0)
 300ba90:	eb89                	bnez	a5,300baa2 <HAL_UART_RegisterCallBack+0x2a>
 300ba92:	2f800593          	li	a1,760
 300ba96:	030127b7          	lui	a5,0x3012
 300ba9a:	e3878513          	addi	a0,a5,-456 # 3011e38 <g_crgIpMatch+0x5a0>
 300ba9e:	3fd9                	jal	ra,300ba74 <AssertErrorLog.trans.9>
 300baa0:	a001                	j	300baa0 <HAL_UART_RegisterCallBack+0x28>
    UART_ASSERT_PARAM(IsUARTInstance(uartHandle->baseAddress));
 300baa2:	fec42783          	lw	a5,-20(s0)
 300baa6:	4398                	lw	a4,0(a5)
 300baa8:	140007b7          	lui	a5,0x14000
 300baac:	02f70f63          	beq	a4,a5,300baea <HAL_UART_RegisterCallBack+0x72>
 300bab0:	fec42783          	lw	a5,-20(s0)
 300bab4:	4398                	lw	a4,0(a5)
 300bab6:	140017b7          	lui	a5,0x14001
 300baba:	02f70863          	beq	a4,a5,300baea <HAL_UART_RegisterCallBack+0x72>
 300babe:	fec42783          	lw	a5,-20(s0)
 300bac2:	4398                	lw	a4,0(a5)
 300bac4:	140027b7          	lui	a5,0x14002
 300bac8:	02f70163          	beq	a4,a5,300baea <HAL_UART_RegisterCallBack+0x72>
 300bacc:	fec42783          	lw	a5,-20(s0)
 300bad0:	4398                	lw	a4,0(a5)
 300bad2:	140037b7          	lui	a5,0x14003
 300bad6:	00f70a63          	beq	a4,a5,300baea <HAL_UART_RegisterCallBack+0x72>
 300bada:	2f900593          	li	a1,761
 300bade:	030127b7          	lui	a5,0x3012
 300bae2:	e3878513          	addi	a0,a5,-456 # 3011e38 <g_crgIpMatch+0x5a0>
 300bae6:	3779                	jal	ra,300ba74 <AssertErrorLog.trans.9>
 300bae8:	a001                	j	300bae8 <HAL_UART_RegisterCallBack+0x70>
    switch (typeID) {
 300baea:	fe842703          	lw	a4,-24(s0)
 300baee:	47a1                	li	a5,8
 300baf0:	08e7e363          	bltu	a5,a4,300bb76 <HAL_UART_RegisterCallBack+0xfe>
 300baf4:	fe842783          	lw	a5,-24(s0)
 300baf8:	00279713          	slli	a4,a5,0x2
 300bafc:	030127b7          	lui	a5,0x3012
 300bb00:	e5478793          	addi	a5,a5,-428 # 3011e54 <g_crgIpMatch+0x5bc>
 300bb04:	97ba                	add	a5,a5,a4
 300bb06:	439c                	lw	a5,0(a5)
 300bb08:	8782                	jr	a5
        case UART_WRITE_IT_FINISH:
            uartHandle->userCallBack.WriteItFinishCallBack = pCallback;     /* Write INT finish callback register */
 300bb0a:	fec42783          	lw	a5,-20(s0)
 300bb0e:	fe442703          	lw	a4,-28(s0)
 300bb12:	cbf8                	sw	a4,84(a5)
            break;
 300bb14:	a09d                	j	300bb7a <HAL_UART_RegisterCallBack+0x102>
        case UART_READ_IT_FINISH:
            uartHandle->userCallBack.ReadItFinishCallBack = pCallback;      /* Read INT finish callback register */
 300bb16:	fec42783          	lw	a5,-20(s0)
 300bb1a:	fe442703          	lw	a4,-28(s0)
 300bb1e:	cfb8                	sw	a4,88(a5)
            break;
 300bb20:	a8a9                	j	300bb7a <HAL_UART_RegisterCallBack+0x102>
        case UART_WRITE_DMA_FINISH:
            uartHandle->userCallBack.WriteDmaFinishCallBack = pCallback;    /* DMA write finish callback register */
 300bb22:	fec42783          	lw	a5,-20(s0)
 300bb26:	fe442703          	lw	a4,-28(s0)
 300bb2a:	cff8                	sw	a4,92(a5)
            break;
 300bb2c:	a0b9                	j	300bb7a <HAL_UART_RegisterCallBack+0x102>
        case UART_READ_DMA_FINISH:
            uartHandle->userCallBack.ReadDmaFinishCallBack = pCallback;     /* DMA read finish callback register */
 300bb2e:	fec42783          	lw	a5,-20(s0)
 300bb32:	fe442703          	lw	a4,-28(s0)
 300bb36:	d3b8                	sw	a4,96(a5)
            break;
 300bb38:	a089                	j	300bb7a <HAL_UART_RegisterCallBack+0x102>
        case UART_TRNS_IT_ERROR:
            uartHandle->userCallBack.TransmitItErrorCallBack = pCallback;   /* INT Trans error callback register */
 300bb3a:	fec42783          	lw	a5,-20(s0)
 300bb3e:	fe442703          	lw	a4,-28(s0)
 300bb42:	d3f8                	sw	a4,100(a5)
            break;
 300bb44:	a81d                	j	300bb7a <HAL_UART_RegisterCallBack+0x102>
        case UART_TRNS_DMA_ERROR:
            uartHandle->userCallBack.TransmitDmaErrorCallBack = pCallback;  /* DMA Trans error callback register */
 300bb46:	fec42783          	lw	a5,-20(s0)
 300bb4a:	fe442703          	lw	a4,-28(s0)
 300bb4e:	d7b8                	sw	a4,104(a5)
            break;
 300bb50:	a02d                	j	300bb7a <HAL_UART_RegisterCallBack+0x102>
        case UART_BAUD_DETECT_FINISH:
            uartHandle->userCallBack.BaudDetectSuccessCallBack = pCallback; /* Baud detect finish callback register */
 300bb52:	fec42783          	lw	a5,-20(s0)
 300bb56:	fe442703          	lw	a4,-28(s0)
 300bb5a:	d7f8                	sw	a4,108(a5)
            break;
 300bb5c:	a839                	j	300bb7a <HAL_UART_RegisterCallBack+0x102>
        case UART_BAUD_DETECT_ERROR:
            uartHandle->userCallBack.BaudDetectErrorCallBack = pCallback;   /* Baud detect error callback register */
 300bb5e:	fec42783          	lw	a5,-20(s0)
 300bb62:	fe442703          	lw	a4,-28(s0)
 300bb66:	dbb8                	sw	a4,112(a5)
            break;
 300bb68:	a809                	j	300bb7a <HAL_UART_RegisterCallBack+0x102>
        case UART_CHARACTER_MATCH:
            uartHandle->userCallBack.CharacterMatchCallBack = pCallback;    /* character match callback register */
 300bb6a:	fec42783          	lw	a5,-20(s0)
 300bb6e:	fe442703          	lw	a4,-28(s0)
 300bb72:	dbf8                	sw	a4,116(a5)
            break;
 300bb74:	a019                	j	300bb7a <HAL_UART_RegisterCallBack+0x102>
        default:
            return BASE_STATUS_ERROR;
 300bb76:	4785                	li	a5,1
 300bb78:	a011                	j	300bb7c <HAL_UART_RegisterCallBack+0x104>
    }
    return BASE_STATUS_OK;
 300bb7a:	4781                	li	a5,0
}
 300bb7c:	853e                	mv	a0,a5
 300bb7e:	40f2                	lw	ra,28(sp)
 300bb80:	4462                	lw	s0,24(sp)
 300bb82:	6105                	addi	sp,sp,32
 300bb84:	8082                	ret

0300bb86 <SecMemcpyError>:

/*
 * Handling errors
 */
SECUREC_INLINE errno_t SecMemcpyError(void *dest, size_t destMax, const void *src, size_t count)
{
 300bb86:	1101                	addi	sp,sp,-32
 300bb88:	ce06                	sw	ra,28(sp)
 300bb8a:	cc22                	sw	s0,24(sp)
 300bb8c:	1000                	addi	s0,sp,32
 300bb8e:	fea42623          	sw	a0,-20(s0)
 300bb92:	feb42423          	sw	a1,-24(s0)
 300bb96:	fec42223          	sw	a2,-28(s0)
 300bb9a:	fed42023          	sw	a3,-32(s0)
    if (destMax == 0 || destMax > SECUREC_MEM_MAX_LEN) {
 300bb9e:	fe842783          	lw	a5,-24(s0)
 300bba2:	c789                	beqz	a5,300bbac <SecMemcpyError+0x26>
 300bba4:	fe842783          	lw	a5,-24(s0)
 300bba8:	0007d563          	bgez	a5,300bbb2 <SecMemcpyError+0x2c>
        SECUREC_ERROR_INVALID_RANGE("memcpy_s");
        return ERANGE;
 300bbac:	02200793          	li	a5,34
 300bbb0:	a861                	j	300bc48 <SecMemcpyError+0xc2>
    }
    if (dest == NULL || src == NULL) {
 300bbb2:	fec42783          	lw	a5,-20(s0)
 300bbb6:	c781                	beqz	a5,300bbbe <SecMemcpyError+0x38>
 300bbb8:	fe442783          	lw	a5,-28(s0)
 300bbbc:	ef99                	bnez	a5,300bbda <SecMemcpyError+0x54>
        SECUREC_ERROR_INVALID_PARAMTER("memcpy_s");
        if (dest != NULL) {
 300bbbe:	fec42783          	lw	a5,-20(s0)
 300bbc2:	cb91                	beqz	a5,300bbd6 <SecMemcpyError+0x50>
            (void)SECUREC_MEMSET_FUNC_OPT(dest, 0, destMax);
 300bbc4:	fe842603          	lw	a2,-24(s0)
 300bbc8:	4581                	li	a1,0
 300bbca:	fec42503          	lw	a0,-20(s0)
 300bbce:	2051                	jal	ra,300bc52 <memset.trans.40>
            return EINVAL_AND_RESET;
 300bbd0:	09600793          	li	a5,150
 300bbd4:	a895                	j	300bc48 <SecMemcpyError+0xc2>
        }
        return EINVAL;
 300bbd6:	47d9                	li	a5,22
 300bbd8:	a885                	j	300bc48 <SecMemcpyError+0xc2>
    }
    if (count > destMax) {
 300bbda:	fe042703          	lw	a4,-32(s0)
 300bbde:	fe842783          	lw	a5,-24(s0)
 300bbe2:	00e7fb63          	bgeu	a5,a4,300bbf8 <SecMemcpyError+0x72>
        (void)SECUREC_MEMSET_FUNC_OPT(dest, 0, destMax);
 300bbe6:	fe842603          	lw	a2,-24(s0)
 300bbea:	4581                	li	a1,0
 300bbec:	fec42503          	lw	a0,-20(s0)
 300bbf0:	208d                	jal	ra,300bc52 <memset.trans.40>
        SECUREC_ERROR_INVALID_RANGE("memcpy_s");
        return ERANGE_AND_RESET;
 300bbf2:	0a200793          	li	a5,162
 300bbf6:	a889                	j	300bc48 <SecMemcpyError+0xc2>
    }
    if (SECUREC_MEMORY_IS_OVERLAP(dest, src, count)) {
 300bbf8:	fe442703          	lw	a4,-28(s0)
 300bbfc:	fec42783          	lw	a5,-20(s0)
 300bc00:	00f77b63          	bgeu	a4,a5,300bc16 <SecMemcpyError+0x90>
 300bc04:	fe442703          	lw	a4,-28(s0)
 300bc08:	fe042783          	lw	a5,-32(s0)
 300bc0c:	97ba                	add	a5,a5,a4
 300bc0e:	fec42703          	lw	a4,-20(s0)
 300bc12:	02f76163          	bltu	a4,a5,300bc34 <SecMemcpyError+0xae>
 300bc16:	fec42703          	lw	a4,-20(s0)
 300bc1a:	fe442783          	lw	a5,-28(s0)
 300bc1e:	02f77463          	bgeu	a4,a5,300bc46 <SecMemcpyError+0xc0>
 300bc22:	fec42703          	lw	a4,-20(s0)
 300bc26:	fe042783          	lw	a5,-32(s0)
 300bc2a:	97ba                	add	a5,a5,a4
 300bc2c:	fe442703          	lw	a4,-28(s0)
 300bc30:	00f77b63          	bgeu	a4,a5,300bc46 <SecMemcpyError+0xc0>
        (void)SECUREC_MEMSET_FUNC_OPT(dest, 0, destMax);
 300bc34:	fe842603          	lw	a2,-24(s0)
 300bc38:	4581                	li	a1,0
 300bc3a:	fec42503          	lw	a0,-20(s0)
 300bc3e:	2811                	jal	ra,300bc52 <memset.trans.40>
        SECUREC_ERROR_BUFFER_OVERLAP("memcpy_s");
        return EOVERLAP_AND_RESET;
 300bc40:	0b600793          	li	a5,182
 300bc44:	a011                	j	300bc48 <SecMemcpyError+0xc2>
    }
    /* Count is 0 or dest equal src also ret EOK */
    return EOK;
 300bc46:	4781                	li	a5,0
}
 300bc48:	853e                	mv	a0,a5
 300bc4a:	40f2                	lw	ra,28(sp)
 300bc4c:	4462                	lw	s0,24(sp)
 300bc4e:	6105                	addi	sp,sp,32
 300bc50:	8082                	ret

0300bc52 <memset.trans.40>:
 300bc52:	3830506f          	j	30117d4 <memset>

0300bc56 <memcpy_s>:
 *    if an error occurred, dest will be filled with 0.
 *    If the source and destination overlap, the behavior of memcpy_s is undefined.
 *    Use memmove_s to handle overlapping regions.
 */
errno_t memcpy_s(void *dest, size_t destMax, const void *src, size_t count)
{
 300bc56:	1101                	addi	sp,sp,-32
 300bc58:	ce06                	sw	ra,28(sp)
 300bc5a:	cc22                	sw	s0,24(sp)
 300bc5c:	1000                	addi	s0,sp,32
 300bc5e:	fea42623          	sw	a0,-20(s0)
 300bc62:	feb42423          	sw	a1,-24(s0)
 300bc66:	fec42223          	sw	a2,-28(s0)
 300bc6a:	fed42023          	sw	a3,-32(s0)
    if (SECUREC_MEMCPY_PARAM_OK(dest, destMax, src, count)) {
 300bc6e:	fe042703          	lw	a4,-32(s0)
 300bc72:	fe842783          	lw	a5,-24(s0)
 300bc76:	00e7b7b3          	sltu	a5,a5,a4
 300bc7a:	0017c793          	xori	a5,a5,1
 300bc7e:	9f81                	uxtb	a5
 300bc80:	cb89                	beqz	a5,300bc92 <memcpy_s+0x3c>
 300bc82:	fec42783          	lw	a5,-20(s0)
 300bc86:	00f037b3          	snez	a5,a5
 300bc8a:	9f81                	uxtb	a5
 300bc8c:	c399                	beqz	a5,300bc92 <memcpy_s+0x3c>
 300bc8e:	4785                	li	a5,1
 300bc90:	a011                	j	300bc94 <memcpy_s+0x3e>
 300bc92:	4781                	li	a5,0
 300bc94:	cb89                	beqz	a5,300bca6 <memcpy_s+0x50>
 300bc96:	fe442783          	lw	a5,-28(s0)
 300bc9a:	00f037b3          	snez	a5,a5
 300bc9e:	9f81                	uxtb	a5
 300bca0:	c399                	beqz	a5,300bca6 <memcpy_s+0x50>
 300bca2:	4785                	li	a5,1
 300bca4:	a011                	j	300bca8 <memcpy_s+0x52>
 300bca6:	4781                	li	a5,0
 300bca8:	cb91                	beqz	a5,300bcbc <memcpy_s+0x66>
 300bcaa:	fe842783          	lw	a5,-24(s0)
 300bcae:	fff7c793          	not	a5,a5
 300bcb2:	83fd                	srli	a5,a5,0x1f
 300bcb4:	9f81                	uxtb	a5
 300bcb6:	c399                	beqz	a5,300bcbc <memcpy_s+0x66>
 300bcb8:	4785                	li	a5,1
 300bcba:	a011                	j	300bcbe <memcpy_s+0x68>
 300bcbc:	4781                	li	a5,0
 300bcbe:	cb89                	beqz	a5,300bcd0 <memcpy_s+0x7a>
 300bcc0:	fe042783          	lw	a5,-32(s0)
 300bcc4:	00f037b3          	snez	a5,a5
 300bcc8:	9f81                	uxtb	a5
 300bcca:	c399                	beqz	a5,300bcd0 <memcpy_s+0x7a>
 300bccc:	4785                	li	a5,1
 300bcce:	a011                	j	300bcd2 <memcpy_s+0x7c>
 300bcd0:	4781                	li	a5,0
 300bcd2:	c3c9                	beqz	a5,300bd54 <memcpy_s+0xfe>
 300bcd4:	fe442703          	lw	a4,-28(s0)
 300bcd8:	fec42783          	lw	a5,-20(s0)
 300bcdc:	00f737b3          	sltu	a5,a4,a5
 300bce0:	9f81                	uxtb	a5
 300bce2:	c385                	beqz	a5,300bd02 <memcpy_s+0xac>
 300bce4:	fe442703          	lw	a4,-28(s0)
 300bce8:	fe042783          	lw	a5,-32(s0)
 300bcec:	97ba                	add	a5,a5,a4
 300bcee:	fec42703          	lw	a4,-20(s0)
 300bcf2:	00f737b3          	sltu	a5,a4,a5
 300bcf6:	0017c793          	xori	a5,a5,1
 300bcfa:	9f81                	uxtb	a5
 300bcfc:	c399                	beqz	a5,300bd02 <memcpy_s+0xac>
 300bcfe:	4785                	li	a5,1
 300bd00:	a011                	j	300bd04 <memcpy_s+0xae>
 300bd02:	4781                	li	a5,0
 300bd04:	eb95                	bnez	a5,300bd38 <memcpy_s+0xe2>
 300bd06:	fec42703          	lw	a4,-20(s0)
 300bd0a:	fe442783          	lw	a5,-28(s0)
 300bd0e:	00f737b3          	sltu	a5,a4,a5
 300bd12:	9f81                	uxtb	a5
 300bd14:	c385                	beqz	a5,300bd34 <memcpy_s+0xde>
 300bd16:	fec42703          	lw	a4,-20(s0)
 300bd1a:	fe042783          	lw	a5,-32(s0)
 300bd1e:	97ba                	add	a5,a5,a4
 300bd20:	fe442703          	lw	a4,-28(s0)
 300bd24:	00f737b3          	sltu	a5,a4,a5
 300bd28:	0017c793          	xori	a5,a5,1
 300bd2c:	9f81                	uxtb	a5
 300bd2e:	c399                	beqz	a5,300bd34 <memcpy_s+0xde>
 300bd30:	4785                	li	a5,1
 300bd32:	a011                	j	300bd36 <memcpy_s+0xe0>
 300bd34:	4781                	li	a5,0
 300bd36:	c399                	beqz	a5,300bd3c <memcpy_s+0xe6>
 300bd38:	4785                	li	a5,1
 300bd3a:	a011                	j	300bd3e <memcpy_s+0xe8>
 300bd3c:	4781                	li	a5,0
 300bd3e:	cb99                	beqz	a5,300bd54 <memcpy_s+0xfe>
        SECUREC_MEMCPY_WARP_OPT(dest, src, count);
 300bd40:	fe042603          	lw	a2,-32(s0)
 300bd44:	fe442583          	lw	a1,-28(s0)
 300bd48:	fec42503          	lw	a0,-20(s0)
 300bd4c:	726050ef          	jal	ra,3011472 <memcpy>
        return EOK;
 300bd50:	4781                	li	a5,0
 300bd52:	a819                	j	300bd68 <memcpy_s+0x112>
    }
    /* Meet some runtime violation, return error code */
    return SecMemcpyError(dest, destMax, src, count);
 300bd54:	fe042683          	lw	a3,-32(s0)
 300bd58:	fe442603          	lw	a2,-28(s0)
 300bd5c:	fe842583          	lw	a1,-24(s0)
 300bd60:	fec42503          	lw	a0,-20(s0)
 300bd64:	350d                	jal	ra,300bb86 <SecMemcpyError>
 300bd66:	87aa                	mv	a5,a0
}
 300bd68:	853e                	mv	a0,a5
 300bd6a:	40f2                	lw	ra,28(sp)
 300bd6c:	4462                	lw	s0,24(sp)
 300bd6e:	6105                	addi	sp,sp,32
 300bd70:	8082                	ret

0300bd72 <GPIO1_0_CallbackFunc>:
  * @retval None
  */


void GPIO1_0_CallbackFunc(void *param)
{
 300bd72:	1101                	addi	sp,sp,-32
 300bd74:	ce22                	sw	s0,28(sp)
 300bd76:	1000                	addi	s0,sp,32
 300bd78:	fea42623          	sw	a0,-20(s0)
    BASE_FUNC_UNUSED(param);
    if((g_button1State == 0) && (g_button1_count == 0))
 300bd7c:	cb61a783          	lw	a5,-842(gp) # 40005c0 <g_button1State>
 300bd80:	eb91                	bnez	a5,300bd94 <GPIO1_0_CallbackFunc+0x22>
 300bd82:	cbe1a783          	lw	a5,-834(gp) # 40005c8 <g_button1_count>
 300bd86:	e799                	bnez	a5,300bd94 <GPIO1_0_CallbackFunc+0x22>
    {
        //g_button1State = !g_button1State;
        g_button1State = 1;
 300bd88:	4705                	li	a4,1
 300bd8a:	cae1ab23          	sw	a4,-842(gp) # 40005c0 <g_button1State>
        g_button1_count = 1;    //在10ms定时中断里处理按键滤波业务逻辑
 300bd8e:	4705                	li	a4,1
 300bd90:	cae1af23          	sw	a4,-834(gp) # 40005c8 <g_button1_count>
    }
}
 300bd94:	0001                	nop
 300bd96:	4472                	lw	s0,28(sp)
 300bd98:	6105                	addi	sp,sp,32
 300bd9a:	8082                	ret

0300bd9c <GPIO1_1_CallbackFunc>:

void GPIO1_1_CallbackFunc(void *param)
{
 300bd9c:	1101                	addi	sp,sp,-32
 300bd9e:	ce22                	sw	s0,28(sp)
 300bda0:	1000                	addi	s0,sp,32
 300bda2:	fea42623          	sw	a0,-20(s0)
    BASE_FUNC_UNUSED(param);
   if((g_button2State == 0) && (g_button2_count == 0))
 300bda6:	cba1a783          	lw	a5,-838(gp) # 40005c4 <g_button2State>
 300bdaa:	eb91                	bnez	a5,300bdbe <GPIO1_1_CallbackFunc+0x22>
 300bdac:	cc21a783          	lw	a5,-830(gp) # 40005cc <g_button2_count>
 300bdb0:	e799                	bnez	a5,300bdbe <GPIO1_1_CallbackFunc+0x22>
   {
        //g_button2State = !g_button2State;
        g_button2State = 1;
 300bdb2:	4705                	li	a4,1
 300bdb4:	cae1ad23          	sw	a4,-838(gp) # 40005c4 <g_button2State>
        g_button2_count = 1;    //在10ms定时中断里处理按键滤波业务逻辑
 300bdb8:	4705                	li	a4,1
 300bdba:	cce1a123          	sw	a4,-830(gp) # 40005cc <g_button2_count>
   }
}
 300bdbe:	0001                	nop
 300bdc0:	4472                	lw	s0,28(sp)
 300bdc2:	6105                	addi	sp,sp,32
 300bdc4:	8082                	ret

0300bdc6 <CANWriteCallbackFunc>:
extern CAN_Handle g_can;
extern bool isRecv;
extern bool isWrite;
unsigned char message = '\0';

void CANWriteCallbackFunc(void* handle){
 300bdc6:	1101                	addi	sp,sp,-32
 300bdc8:	ce06                	sw	ra,28(sp)
 300bdca:	cc22                	sw	s0,24(sp)
 300bdcc:	1000                	addi	s0,sp,32
 300bdce:	fea42623          	sw	a0,-20(s0)
    DBG_PRINTF("Write Callback\r\n");
 300bdd2:	030127b7          	lui	a5,0x3012
 300bdd6:	e7878513          	addi	a0,a5,-392 # 3011e78 <g_crgIpMatch+0x5e0>
 300bdda:	2b99                	jal	ra,300c330 <DBG_UartPrintf.trans.12>
    BASE_FUNC_UNUSED(handle);
    isWrite = true;
 300bddc:	4705                	li	a4,1
 300bdde:	4ae18ba3          	sb	a4,1207(gp) # 4000dc1 <isWrite>
}
 300bde2:	0001                	nop
 300bde4:	40f2                	lw	ra,28(sp)
 300bde6:	4462                	lw	s0,24(sp)
 300bde8:	6105                	addi	sp,sp,32
 300bdea:	8082                	ret

0300bdec <CANReadCallbackFunc>:
void CANReadCallbackFunc(void* handle){
 300bdec:	1101                	addi	sp,sp,-32
 300bdee:	ce06                	sw	ra,28(sp)
 300bdf0:	cc22                	sw	s0,24(sp)
 300bdf2:	1000                	addi	s0,sp,32
 300bdf4:	fea42623          	sw	a0,-20(s0)
    DBG_PRINTF("Read Callback!\r\n");
 300bdf8:	030127b7          	lui	a5,0x3012
 300bdfc:	e8c78513          	addi	a0,a5,-372 # 3011e8c <g_crgIpMatch+0x5f4>
 300be00:	2b05                	jal	ra,300c330 <DBG_UartPrintf.trans.12>
    BASE_FUNC_UNUSED(handle);
    isRecv = true;
 300be02:	4705                	li	a4,1
 300be04:	4ae18b23          	sb	a4,1206(gp) # 4000dc0 <isRecv>
}
 300be08:	0001                	nop
 300be0a:	40f2                	lw	ra,28(sp)
 300be0c:	4462                	lw	s0,24(sp)
 300be0e:	6105                	addi	sp,sp,32
 300be10:	8082                	ret

0300be12 <ReceiveMsg>:


void ReceiveMsg(unsigned char* msg, unsigned int CANRxID){
 300be12:	7179                	addi	sp,sp,-48
 300be14:	d606                	sw	ra,44(sp)
 300be16:	d422                	sw	s0,40(sp)
 300be18:	1800                	addi	s0,sp,48
 300be1a:	fca42e23          	sw	a0,-36(s0)
 300be1e:	fcb42c23          	sw	a1,-40(s0)
    CAN_FilterConfigure rxFilter;
    g_can.rxFrame = &g_receiveFrame;
 300be22:	de218793          	addi	a5,gp,-542 # 40006ec <g_can>
 300be26:	cda18713          	addi	a4,gp,-806 # 40005e4 <g_receiveFrame>
 300be2a:	d398                	sw	a4,32(a5)
    rxFilter.receiveType = CAN_FILTERFRAME_STD_DATA;
 300be2c:	fe042223          	sw	zero,-28(s0)
    rxFilter.filterID = CANRxID;        /* 0x1014 and 0xFFFFF0FF constitute filtering rules */
 300be30:	fd842783          	lw	a5,-40(s0)
 300be34:	fef42423          	sw	a5,-24(s0)
    rxFilter.filterMask = 0x7FF;  /* 0xFFFFF0FF is filter ID mask */
 300be38:	7ff00793          	li	a5,2047
 300be3c:	fef42623          	sw	a5,-20(s0)
    HAL_CAN_ReadIT(&g_can, &g_receiveFrame, &rxFilter);
 300be40:	fe440793          	addi	a5,s0,-28
 300be44:	863e                	mv	a2,a5
 300be46:	cda18593          	addi	a1,gp,-806 # 40005e4 <g_receiveFrame>
 300be4a:	de218513          	addi	a0,gp,-542 # 40006ec <g_can>
 300be4e:	c1ef80ef          	jal	ra,300426c <HAL_CAN_ReadIT>
    msg = g_receiveFrame.frame;
 300be52:	ce618793          	addi	a5,gp,-794 # 40005f0 <g_receiveFrame+0xc>
 300be56:	fcf42e23          	sw	a5,-36(s0)
}
 300be5a:	0001                	nop
 300be5c:	50b2                	lw	ra,44(sp)
 300be5e:	5422                	lw	s0,40(sp)
 300be60:	6145                	addi	sp,sp,48
 300be62:	8082                	ret

0300be64 <TransmitMsg>:

void TransmitMsg(unsigned char* msg, unsigned int CANTxID){   /* Address for storing received frame data */
 300be64:	1101                	addi	sp,sp,-32
 300be66:	ce06                	sw	ra,28(sp)
 300be68:	cc22                	sw	s0,24(sp)
 300be6a:	1000                	addi	s0,sp,32
 300be6c:	fea42623          	sw	a0,-20(s0)
 300be70:	feb42423          	sw	a1,-24(s0)
    // DBG_PRINTF("CAN interrupt register \r\n");
    g_sendFrame.type = CAN_TYPEFRAME_STD_DATA; /* Transmit extended data frame */
 300be74:	cc618793          	addi	a5,gp,-826 # 40005d0 <g_sendFrame>
 300be78:	0007a023          	sw	zero,0(a5)
    g_sendFrame.CANId = CANTxID;       /* 0x1314 is ID of transmitted data frames */
 300be7c:	cc618793          	addi	a5,gp,-826 # 40005d0 <g_sendFrame>
 300be80:	fe842703          	lw	a4,-24(s0)
 300be84:	c798                	sw	a4,8(a5)
    g_sendFrame.dataLength = 1;       /* 1 is length of the sent frame */
 300be86:	cc618793          	addi	a5,gp,-826 # 40005d0 <g_sendFrame>
 300be8a:	4705                	li	a4,1
 300be8c:	c3d8                	sw	a4,4(a5)
    g_sendFrame.frame[0] = *msg;
 300be8e:	fec42783          	lw	a5,-20(s0)
 300be92:	2398                	lbu	a4,0(a5)
 300be94:	cc618793          	addi	a5,gp,-826 # 40005d0 <g_sendFrame>
 300be98:	a7d8                	sb	a4,12(a5)
    HAL_CAN_Write(&g_can, &g_sendFrame);
 300be9a:	cc618593          	addi	a1,gp,-826 # 40005d0 <g_sendFrame>
 300be9e:	de218513          	addi	a0,gp,-542 # 40006ec <g_can>
 300bea2:	d91f70ef          	jal	ra,3003c32 <HAL_CAN_Write>
}
 300bea6:	0001                	nop
 300bea8:	40f2                	lw	ra,28(sp)
 300beaa:	4462                	lw	s0,24(sp)
 300beac:	6105                	addi	sp,sp,32
 300beae:	8082                	ret

0300beb0 <UART2WriteInterruptCallback>:
unsigned char get_data;
bool Servo_flag = true;
bool flag = false;
short num = 0;

void UART2WriteInterruptCallback(void* handle){
 300beb0:	1101                	addi	sp,sp,-32
 300beb2:	ce22                	sw	s0,28(sp)
 300beb4:	1000                	addi	s0,sp,32
 300beb6:	fea42623          	sw	a0,-20(s0)
    BASE_FUNC_UNUSED(handle);
    TxInterruptFlag = true;
 300beba:	040007b7          	lui	a5,0x4000
 300bebe:	4705                	li	a4,1
 300bec0:	10e788a3          	sb	a4,273(a5) # 4000111 <TxInterruptFlag>
}
 300bec4:	0001                	nop
 300bec6:	4472                	lw	s0,28(sp)
 300bec8:	6105                	addi	sp,sp,32
 300beca:	8082                	ret

0300becc <UART2ReadInterruptCallback>:

void UART2ReadInterruptCallback(void* handle){
 300becc:	1101                	addi	sp,sp,-32
 300bece:	ce22                	sw	s0,28(sp)
 300bed0:	1000                	addi	s0,sp,32
 300bed2:	fea42623          	sw	a0,-20(s0)
    BASE_FUNC_UNUSED(handle);
    RxInterruptflag = true;
 300bed6:	040007b7          	lui	a5,0x4000
 300beda:	4705                	li	a4,1
 300bedc:	10e78823          	sb	a4,272(a5) # 4000110 <RxInterruptflag>
    flag = true;
 300bee0:	4705                	li	a4,1
 300bee2:	cee18723          	sb	a4,-786(gp) # 40005f8 <flag>
}
 300bee6:	0001                	nop
 300bee8:	4472                	lw	s0,28(sp)
 300beea:	6105                	addi	sp,sp,32
 300beec:	8082                	ret

0300beee <InitGearMotor>:
//编码器读取周期内最大差值
unsigned int g_maxEncodePidDeltaValue;
unsigned int g_maxEncodeAveDeltaValue;

void InitGearMotor(void)
{
 300beee:	1141                	addi	sp,sp,-16
 300bef0:	0061128b          	stmia	{ra,s0,s2-s3},(sp)
 300bef4:	0800                	addi	s0,sp,16
    pidRightMotor.motorSide  = MOTOR_RIGHT;    
 300bef6:	cf218793          	addi	a5,gp,-782 # 40005fc <pidRightMotor>
 300befa:	4705                	li	a4,1
 300befc:	c398                	sw	a4,0(a5)
    pidRightMotor.curNumber = 0;            /* 当前计数器 */
 300befe:	cf218793          	addi	a5,gp,-782 # 40005fc <pidRightMotor>
 300bf02:	0007a223          	sw	zero,4(a5)
    pidRightMotor.lastNumber = 0;           /* 上一次计数器 */
 300bf06:	cf218793          	addi	a5,gp,-782 # 40005fc <pidRightMotor>
 300bf0a:	0007a423          	sw	zero,8(a5)
    pidRightMotor.speedRps = 0;             /* 电机转速，单位每秒多少圈 */
 300bf0e:	cf218793          	addi	a5,gp,-782 # 40005fc <pidRightMotor>
 300bf12:	0007a623          	sw	zero,12(a5)
    pidRightMotor.speed = 0;                /* 电机速度，单位mm/s，由转速和轮胎直径计算 */
 300bf16:	cf218793          	addi	a5,gp,-782 # 40005fc <pidRightMotor>
 300bf1a:	0007a823          	sw	zero,16(a5)
    pidRightMotor.calPeriod = MOTOR_PID_CONTROL_PERIOD; 
 300bf1e:	cf218793          	addi	a5,gp,-782 # 40005fc <pidRightMotor>
 300bf22:	4729                	li	a4,10
 300bf24:	cbd8                	sw	a4,20(a5)

    pidLeftMotor.motorSide  = MOTOR_LEFT;    
 300bf26:	d0e18793          	addi	a5,gp,-754 # 4000618 <pidLeftMotor>
 300bf2a:	0007a023          	sw	zero,0(a5)
    pidLeftMotor.curNumber = 0;             /* 当前计数器 */
 300bf2e:	d0e18793          	addi	a5,gp,-754 # 4000618 <pidLeftMotor>
 300bf32:	0007a223          	sw	zero,4(a5)
    pidLeftMotor.lastNumber = 0;            /* 上一次计数器 */
 300bf36:	d0e18793          	addi	a5,gp,-754 # 4000618 <pidLeftMotor>
 300bf3a:	0007a423          	sw	zero,8(a5)
    pidLeftMotor.speedRps = 0;              /* 电机转速，单位每秒多少圈 */    
 300bf3e:	d0e18793          	addi	a5,gp,-754 # 4000618 <pidLeftMotor>
 300bf42:	0007a623          	sw	zero,12(a5)
    pidLeftMotor.speed = 0;                 /* 电机速度，单位mm/s，由转速和轮胎直径计算 */
 300bf46:	d0e18793          	addi	a5,gp,-754 # 4000618 <pidLeftMotor>
 300bf4a:	0007a823          	sw	zero,16(a5)
    pidLeftMotor.calPeriod = MOTOR_PID_CONTROL_PERIOD;    
 300bf4e:	d0e18793          	addi	a5,gp,-754 # 4000618 <pidLeftMotor>
 300bf52:	4729                	li	a4,10
 300bf54:	cbd8                	sw	a4,20(a5)


    aveRightMotor.motorSide  = MOTOR_RIGHT;    
 300bf56:	d2a18793          	addi	a5,gp,-726 # 4000634 <aveRightMotor>
 300bf5a:	4705                	li	a4,1
 300bf5c:	c398                	sw	a4,0(a5)
    aveRightMotor.curNumber = 0;            /* 当前计数器 */
 300bf5e:	d2a18793          	addi	a5,gp,-726 # 4000634 <aveRightMotor>
 300bf62:	0007a223          	sw	zero,4(a5)
    aveRightMotor.lastNumber = 0;           /* 上一次计数器 */
 300bf66:	d2a18793          	addi	a5,gp,-726 # 4000634 <aveRightMotor>
 300bf6a:	0007a423          	sw	zero,8(a5)
    aveRightMotor.speedRps = 0;             /* 电机转速，单位每秒多少圈 */
 300bf6e:	d2a18793          	addi	a5,gp,-726 # 4000634 <aveRightMotor>
 300bf72:	0007a623          	sw	zero,12(a5)
    aveRightMotor.speed = 0;                /* 电机速度，单位mm/s，由转速和轮胎直径计算 */
 300bf76:	d2a18793          	addi	a5,gp,-726 # 4000634 <aveRightMotor>
 300bf7a:	0007a823          	sw	zero,16(a5)
    aveRightMotor.calPeriod = EULER_CAR_DATA_SEND_PERIOD; 
 300bf7e:	d2a18793          	addi	a5,gp,-726 # 4000634 <aveRightMotor>
 300bf82:	06400713          	li	a4,100
 300bf86:	cbd8                	sw	a4,20(a5)

    aveLeftMotor.motorSide  = MOTOR_LEFT;    
 300bf88:	d4618793          	addi	a5,gp,-698 # 4000650 <aveLeftMotor>
 300bf8c:	0007a023          	sw	zero,0(a5)
    aveLeftMotor.curNumber = 0;             /* 当前计数器 */
 300bf90:	d4618793          	addi	a5,gp,-698 # 4000650 <aveLeftMotor>
 300bf94:	0007a223          	sw	zero,4(a5)
    aveLeftMotor.lastNumber = 0;            /* 上一次计数器 */
 300bf98:	d4618793          	addi	a5,gp,-698 # 4000650 <aveLeftMotor>
 300bf9c:	0007a423          	sw	zero,8(a5)
    aveLeftMotor.speedRps = 0;              /* 电机转速，单位每秒多少圈 */    
 300bfa0:	d4618793          	addi	a5,gp,-698 # 4000650 <aveLeftMotor>
 300bfa4:	0007a623          	sw	zero,12(a5)
    aveLeftMotor.speed = 0;                 /* 电机速度，单位mm/s，由转速和轮胎直径计算 */
 300bfa8:	d4618793          	addi	a5,gp,-698 # 4000650 <aveLeftMotor>
 300bfac:	0007a823          	sw	zero,16(a5)
    aveLeftMotor.calPeriod = EULER_CAR_DATA_SEND_PERIOD;    
 300bfb0:	d4618793          	addi	a5,gp,-698 # 4000650 <aveLeftMotor>
 300bfb4:	06400713          	li	a4,100
 300bfb8:	cbd8                	sw	a4,20(a5)


    //编码器在一个PID周期内最大差值，电机转速的2倍，主要用于容错处理
    g_maxEncodePidDeltaValue = (int)(g_motorMaxSpeed / MOTOR_TIRE_DIAMETER / PI * g_motorLineNum / (1000.0/MOTOR_PID_CONTROL_PERIOD) * 2.0);
 300bfba:	85a1a787          	flw	fa5,-1958(gp) # 4000164 <g_motorMaxSpeed>
 300bfbe:	20f78553          	fmv.s	fa0,fa5
 300bfc2:	2e8d                	jal	ra,300c334 <__extendsfdf2.trans.10>
 300bfc4:	87aa                	mv	a5,a0
 300bfc6:	882e                	mv	a6,a1
 300bfc8:	03012737          	lui	a4,0x3012
 300bfcc:	ef870713          	addi	a4,a4,-264 # 3011ef8 <g_crgIpMatch+0x660>
 300bfd0:	4310                	lw	a2,0(a4)
 300bfd2:	4354                	lw	a3,4(a4)
 300bfd4:	853e                	mv	a0,a5
 300bfd6:	85c2                	mv	a1,a6
 300bfd8:	2e91                	jal	ra,300c32c <__divdf3.trans.22>
 300bfda:	87aa                	mv	a5,a0
 300bfdc:	882e                	mv	a6,a1
 300bfde:	03012737          	lui	a4,0x3012
 300bfe2:	f0070713          	addi	a4,a4,-256 # 3011f00 <g_crgIpMatch+0x668>
 300bfe6:	4310                	lw	a2,0(a4)
 300bfe8:	4354                	lw	a3,4(a4)
 300bfea:	853e                	mv	a0,a5
 300bfec:	85c2                	mv	a1,a6
 300bfee:	2e3d                	jal	ra,300c32c <__divdf3.trans.22>
 300bff0:	87aa                	mv	a5,a0
 300bff2:	882e                	mv	a6,a1
 300bff4:	893e                	mv	s2,a5
 300bff6:	89c2                	mv	s3,a6
 300bff8:	8621a783          	lw	a5,-1950(gp) # 400016c <g_motorLineNum>
 300bffc:	853e                	mv	a0,a5
 300bffe:	261d                	jal	ra,300c324 <__floatunsidf.trans.45>
 300c000:	87aa                	mv	a5,a0
 300c002:	882e                	mv	a6,a1
 300c004:	863e                	mv	a2,a5
 300c006:	86c2                	mv	a3,a6
 300c008:	854a                	mv	a0,s2
 300c00a:	85ce                	mv	a1,s3
 300c00c:	2e31                	jal	ra,300c328 <__muldf3.trans.25>
 300c00e:	87aa                	mv	a5,a0
 300c010:	882e                	mv	a6,a1
 300c012:	03012737          	lui	a4,0x3012
 300c016:	f0870713          	addi	a4,a4,-248 # 3011f08 <g_crgIpMatch+0x670>
 300c01a:	4310                	lw	a2,0(a4)
 300c01c:	4354                	lw	a3,4(a4)
 300c01e:	853e                	mv	a0,a5
 300c020:	85c2                	mv	a1,a6
 300c022:	2629                	jal	ra,300c32c <__divdf3.trans.22>
 300c024:	87aa                	mv	a5,a0
 300c026:	882e                	mv	a6,a1
 300c028:	863e                	mv	a2,a5
 300c02a:	86c2                	mv	a3,a6
 300c02c:	853e                	mv	a0,a5
 300c02e:	85c2                	mv	a1,a6
 300c030:	064030ef          	jal	ra,300f094 <__adddf3>
 300c034:	87aa                	mv	a5,a0
 300c036:	882e                	mv	a6,a1
 300c038:	853e                	mv	a0,a5
 300c03a:	85c2                	mv	a1,a6
 300c03c:	6a5040ef          	jal	ra,3010ee0 <__fixdfsi>
 300c040:	87aa                	mv	a5,a0
 300c042:	873e                	mv	a4,a5
 300c044:	d6e1a123          	sw	a4,-670(gp) # 400066c <g_maxEncodePidDeltaValue>
    //编码器在一个底盘数据上报周期内最大差值，电机转速的2倍，主要用于容错处理
    g_maxEncodeAveDeltaValue = (int)(g_motorMaxSpeed / MOTOR_TIRE_DIAMETER / PI * g_motorLineNum / (1000.0/EULER_CAR_DATA_SEND_PERIOD) * 2.0);
 300c048:	85a1a787          	flw	fa5,-1958(gp) # 4000164 <g_motorMaxSpeed>
 300c04c:	20f78553          	fmv.s	fa0,fa5
 300c050:	24d5                	jal	ra,300c334 <__extendsfdf2.trans.10>
 300c052:	87aa                	mv	a5,a0
 300c054:	882e                	mv	a6,a1
 300c056:	03012737          	lui	a4,0x3012
 300c05a:	ef870713          	addi	a4,a4,-264 # 3011ef8 <g_crgIpMatch+0x660>
 300c05e:	4310                	lw	a2,0(a4)
 300c060:	4354                	lw	a3,4(a4)
 300c062:	853e                	mv	a0,a5
 300c064:	85c2                	mv	a1,a6
 300c066:	24d9                	jal	ra,300c32c <__divdf3.trans.22>
 300c068:	87aa                	mv	a5,a0
 300c06a:	882e                	mv	a6,a1
 300c06c:	03012737          	lui	a4,0x3012
 300c070:	f0070713          	addi	a4,a4,-256 # 3011f00 <g_crgIpMatch+0x668>
 300c074:	4310                	lw	a2,0(a4)
 300c076:	4354                	lw	a3,4(a4)
 300c078:	853e                	mv	a0,a5
 300c07a:	85c2                	mv	a1,a6
 300c07c:	2c45                	jal	ra,300c32c <__divdf3.trans.22>
 300c07e:	87aa                	mv	a5,a0
 300c080:	882e                	mv	a6,a1
 300c082:	893e                	mv	s2,a5
 300c084:	89c2                	mv	s3,a6
 300c086:	8621a783          	lw	a5,-1950(gp) # 400016c <g_motorLineNum>
 300c08a:	853e                	mv	a0,a5
 300c08c:	2c61                	jal	ra,300c324 <__floatunsidf.trans.45>
 300c08e:	87aa                	mv	a5,a0
 300c090:	882e                	mv	a6,a1
 300c092:	863e                	mv	a2,a5
 300c094:	86c2                	mv	a3,a6
 300c096:	854a                	mv	a0,s2
 300c098:	85ce                	mv	a1,s3
 300c09a:	2479                	jal	ra,300c328 <__muldf3.trans.25>
 300c09c:	87aa                	mv	a5,a0
 300c09e:	882e                	mv	a6,a1
 300c0a0:	03012737          	lui	a4,0x3012
 300c0a4:	f1070713          	addi	a4,a4,-240 # 3011f10 <g_crgIpMatch+0x678>
 300c0a8:	4310                	lw	a2,0(a4)
 300c0aa:	4354                	lw	a3,4(a4)
 300c0ac:	853e                	mv	a0,a5
 300c0ae:	85c2                	mv	a1,a6
 300c0b0:	2cb5                	jal	ra,300c32c <__divdf3.trans.22>
 300c0b2:	87aa                	mv	a5,a0
 300c0b4:	882e                	mv	a6,a1
 300c0b6:	863e                	mv	a2,a5
 300c0b8:	86c2                	mv	a3,a6
 300c0ba:	853e                	mv	a0,a5
 300c0bc:	85c2                	mv	a1,a6
 300c0be:	7d7020ef          	jal	ra,300f094 <__adddf3>
 300c0c2:	87aa                	mv	a5,a0
 300c0c4:	882e                	mv	a6,a1
 300c0c6:	853e                	mv	a0,a5
 300c0c8:	85c2                	mv	a1,a6
 300c0ca:	617040ef          	jal	ra,3010ee0 <__fixdfsi>
 300c0ce:	87aa                	mv	a5,a0
 300c0d0:	873e                	mv	a4,a5
 300c0d2:	d6e1a323          	sw	a4,-666(gp) # 4000670 <g_maxEncodeAveDeltaValue>

    //DBG_PRINTF("g_maxEncodeDeltaValue = %d\r\n", g_maxEncodeDeltaValue);
}
 300c0d6:	0001                	nop
 300c0d8:	0061028b          	ldmia	{ra,s0,s2-s3},(sp)
 300c0dc:	0141                	addi	sp,sp,16
 300c0de:	8082                	ret

0300c0e0 <QDM_CalMotorSpeed>:



void QDM_CalMotorSpeed(Gear_Motor_handle *pMotor)
{
 300c0e0:	7179                	addi	sp,sp,-48
 300c0e2:	02010293          	addi	t0,sp,32
 300c0e6:	0062928b          	stmia	{ra,s0,s2-s3},(t0)
 300c0ea:	1800                	addi	s0,sp,48
 300c0ec:	fca42e23          	sw	a0,-36(s0)
    unsigned int qdm_cnt, qdm_dir;
    unsigned int deltaValue;
    if(pMotor->motorSide == MOTOR_RIGHT )
 300c0f0:	fdc42783          	lw	a5,-36(s0)
 300c0f4:	4398                	lw	a4,0(a5)
 300c0f6:	4785                	li	a5,1
 300c0f8:	00f71d63          	bne	a4,a5,300c112 <QDM_CalMotorSpeed+0x32>
        HAL_QDM_ReadPosCountAndDir(&g_qdm0, &qdm_cnt, &qdm_dir);
 300c0fc:	fe440713          	addi	a4,s0,-28
 300c100:	fe840793          	addi	a5,s0,-24
 300c104:	863a                	mv	a2,a4
 300c106:	85be                	mv	a1,a5
 300c108:	e1e18513          	addi	a0,gp,-482 # 4000728 <g_qdm0>
 300c10c:	d3afe0ef          	jal	ra,300a646 <HAL_QDM_ReadPosCountAndDir>
 300c110:	a819                	j	300c126 <QDM_CalMotorSpeed+0x46>
    else    
        HAL_QDM_ReadPosCountAndDir(&g_qdm1, &qdm_cnt, &qdm_dir);
 300c112:	fe440713          	addi	a4,s0,-28
 300c116:	fe840793          	addi	a5,s0,-24
 300c11a:	863a                	mv	a2,a4
 300c11c:	85be                	mv	a1,a5
 300c11e:	eaa18513          	addi	a0,gp,-342 # 40007b4 <g_qdm1>
 300c122:	d24fe0ef          	jal	ra,300a646 <HAL_QDM_ReadPosCountAndDir>
    
    /* 计算车轮速度 */
    pMotor->curNumber = qdm_cnt;
 300c126:	fe842703          	lw	a4,-24(s0)
 300c12a:	fdc42783          	lw	a5,-36(s0)
 300c12e:	c3d8                	sw	a4,4(a5)
    if(qdm_dir == 1){ //电机正转
 300c130:	fe442703          	lw	a4,-28(s0)
 300c134:	4785                	li	a5,1
 300c136:	04f71363          	bne	a4,a5,300c17c <QDM_CalMotorSpeed+0x9c>
        if(pMotor->curNumber >= pMotor->lastNumber) {
 300c13a:	fdc42783          	lw	a5,-36(s0)
 300c13e:	43d8                	lw	a4,4(a5)
 300c140:	fdc42783          	lw	a5,-36(s0)
 300c144:	479c                	lw	a5,8(a5)
 300c146:	00f76d63          	bltu	a4,a5,300c160 <QDM_CalMotorSpeed+0x80>
             deltaValue = pMotor->curNumber - pMotor->lastNumber;
 300c14a:	fdc42783          	lw	a5,-36(s0)
 300c14e:	43d8                	lw	a4,4(a5)
 300c150:	fdc42783          	lw	a5,-36(s0)
 300c154:	479c                	lw	a5,8(a5)
 300c156:	40f707b3          	sub	a5,a4,a5
 300c15a:	fef42623          	sw	a5,-20(s0)
 300c15e:	a8b9                	j	300c1bc <QDM_CalMotorSpeed+0xdc>
        }else{ //过零点后的计算编码器差值 
             deltaValue = (pMotor->curNumber +g_motorLineNum) - pMotor->lastNumber; 
 300c160:	fdc42783          	lw	a5,-36(s0)
 300c164:	43d8                	lw	a4,4(a5)
 300c166:	8621a783          	lw	a5,-1950(gp) # 400016c <g_motorLineNum>
 300c16a:	973e                	add	a4,a4,a5
 300c16c:	fdc42783          	lw	a5,-36(s0)
 300c170:	479c                	lw	a5,8(a5)
 300c172:	40f707b3          	sub	a5,a4,a5
 300c176:	fef42623          	sw	a5,-20(s0)
 300c17a:	a089                	j	300c1bc <QDM_CalMotorSpeed+0xdc>
        }
    }else{  //电机反转
        if(pMotor->curNumber <= pMotor->lastNumber) {
 300c17c:	fdc42783          	lw	a5,-36(s0)
 300c180:	43d8                	lw	a4,4(a5)
 300c182:	fdc42783          	lw	a5,-36(s0)
 300c186:	479c                	lw	a5,8(a5)
 300c188:	00e7ed63          	bltu	a5,a4,300c1a2 <QDM_CalMotorSpeed+0xc2>
             deltaValue = pMotor->lastNumber - pMotor->curNumber;
 300c18c:	fdc42783          	lw	a5,-36(s0)
 300c190:	4798                	lw	a4,8(a5)
 300c192:	fdc42783          	lw	a5,-36(s0)
 300c196:	43dc                	lw	a5,4(a5)
 300c198:	40f707b3          	sub	a5,a4,a5
 300c19c:	fef42623          	sw	a5,-20(s0)
 300c1a0:	a831                	j	300c1bc <QDM_CalMotorSpeed+0xdc>
        }else{ //过零点后的计算编码器差值 
             deltaValue = (pMotor->lastNumber + g_motorLineNum) - pMotor->curNumber ; 
 300c1a2:	fdc42783          	lw	a5,-36(s0)
 300c1a6:	4798                	lw	a4,8(a5)
 300c1a8:	8621a783          	lw	a5,-1950(gp) # 400016c <g_motorLineNum>
 300c1ac:	973e                	add	a4,a4,a5
 300c1ae:	fdc42783          	lw	a5,-36(s0)
 300c1b2:	43dc                	lw	a5,4(a5)
 300c1b4:	40f707b3          	sub	a5,a4,a5
 300c1b8:	fef42623          	sw	a5,-20(s0)
        }
    }

    /* 电机正反转切换时，会出现编码器差值计算错误，设置编码器差值为0 */
    if(pMotor->calPeriod == MOTOR_PID_CONTROL_PERIOD){
 300c1bc:	fdc42783          	lw	a5,-36(s0)
 300c1c0:	4bd8                	lw	a4,20(a5)
 300c1c2:	47a9                	li	a5,10
 300c1c4:	02f71a63          	bne	a4,a5,300c1f8 <QDM_CalMotorSpeed+0x118>
        if(deltaValue > g_maxEncodePidDeltaValue) {
 300c1c8:	d621a783          	lw	a5,-670(gp) # 400066c <g_maxEncodePidDeltaValue>
 300c1cc:	fec42703          	lw	a4,-20(s0)
 300c1d0:	04e7fb63          	bgeu	a5,a4,300c226 <QDM_CalMotorSpeed+0x146>
             DBG_PRINTF("===Motor Encode Error = %d, motor side:%d, calculate period %dms===\r\n", deltaValue,pMotor->motorSide,pMotor->calPeriod);
 300c1d4:	fdc42783          	lw	a5,-36(s0)
 300c1d8:	4398                	lw	a4,0(a5)
 300c1da:	fdc42783          	lw	a5,-36(s0)
 300c1de:	4bdc                	lw	a5,20(a5)
 300c1e0:	86be                	mv	a3,a5
 300c1e2:	863a                	mv	a2,a4
 300c1e4:	fec42583          	lw	a1,-20(s0)
 300c1e8:	030127b7          	lui	a5,0x3012
 300c1ec:	eb078513          	addi	a0,a5,-336 # 3011eb0 <g_crgIpMatch+0x618>
 300c1f0:	2281                	jal	ra,300c330 <DBG_UartPrintf.trans.12>
             deltaValue = 0;
 300c1f2:	fe042623          	sw	zero,-20(s0)
 300c1f6:	a805                	j	300c226 <QDM_CalMotorSpeed+0x146>
        }
    }else{
        if(deltaValue > g_maxEncodeAveDeltaValue) {
 300c1f8:	d661a783          	lw	a5,-666(gp) # 4000670 <g_maxEncodeAveDeltaValue>
 300c1fc:	fec42703          	lw	a4,-20(s0)
 300c200:	02e7f363          	bgeu	a5,a4,300c226 <QDM_CalMotorSpeed+0x146>
             DBG_PRINTF("===Motor Encode Error = %d, motor side:%d, calculate period %dms===\r\n", deltaValue,pMotor->motorSide,pMotor->calPeriod);
 300c204:	fdc42783          	lw	a5,-36(s0)
 300c208:	4398                	lw	a4,0(a5)
 300c20a:	fdc42783          	lw	a5,-36(s0)
 300c20e:	4bdc                	lw	a5,20(a5)
 300c210:	86be                	mv	a3,a5
 300c212:	863a                	mv	a2,a4
 300c214:	fec42583          	lw	a1,-20(s0)
 300c218:	030127b7          	lui	a5,0x3012
 300c21c:	eb078513          	addi	a0,a5,-336 # 3011eb0 <g_crgIpMatch+0x618>
 300c220:	2a01                	jal	ra,300c330 <DBG_UartPrintf.trans.12>
             deltaValue = 0;
 300c222:	fe042623          	sw	zero,-20(s0)
        }       
    }


    /* 计算右轮电机每秒转速 */
    pMotor->speedRps = ((float)deltaValue * (1000.0 / (float)pMotor->calPeriod))/g_motorLineNum;   
 300c226:	fec42783          	lw	a5,-20(s0)
 300c22a:	d017f7d3          	fcvt.s.wu	fa5,a5
 300c22e:	20f78553          	fmv.s	fa0,fa5
 300c232:	2209                	jal	ra,300c334 <__extendsfdf2.trans.10>
 300c234:	892a                	mv	s2,a0
 300c236:	89ae                	mv	s3,a1
 300c238:	fdc42783          	lw	a5,-36(s0)
 300c23c:	4bdc                	lw	a5,20(a5)
 300c23e:	d017f7d3          	fcvt.s.wu	fa5,a5
 300c242:	20f78553          	fmv.s	fa0,fa5
 300c246:	20fd                	jal	ra,300c334 <__extendsfdf2.trans.10>
 300c248:	86aa                	mv	a3,a0
 300c24a:	872e                	mv	a4,a1
 300c24c:	030127b7          	lui	a5,0x3012
 300c250:	f1878793          	addi	a5,a5,-232 # 3011f18 <g_crgIpMatch+0x680>
 300c254:	8636                	mv	a2,a3
 300c256:	86ba                	mv	a3,a4
 300c258:	4388                	lw	a0,0(a5)
 300c25a:	43cc                	lw	a1,4(a5)
 300c25c:	28c1                	jal	ra,300c32c <__divdf3.trans.22>
 300c25e:	87aa                	mv	a5,a0
 300c260:	882e                	mv	a6,a1
 300c262:	863e                	mv	a2,a5
 300c264:	86c2                	mv	a3,a6
 300c266:	854a                	mv	a0,s2
 300c268:	85ce                	mv	a1,s3
 300c26a:	287d                	jal	ra,300c328 <__muldf3.trans.25>
 300c26c:	87aa                	mv	a5,a0
 300c26e:	882e                	mv	a6,a1
 300c270:	893e                	mv	s2,a5
 300c272:	89c2                	mv	s3,a6
 300c274:	8621a783          	lw	a5,-1950(gp) # 400016c <g_motorLineNum>
 300c278:	853e                	mv	a0,a5
 300c27a:	206d                	jal	ra,300c324 <__floatunsidf.trans.45>
 300c27c:	87aa                	mv	a5,a0
 300c27e:	882e                	mv	a6,a1
 300c280:	863e                	mv	a2,a5
 300c282:	86c2                	mv	a3,a6
 300c284:	854a                	mv	a0,s2
 300c286:	85ce                	mv	a1,s3
 300c288:	2055                	jal	ra,300c32c <__divdf3.trans.22>
 300c28a:	87aa                	mv	a5,a0
 300c28c:	882e                	mv	a6,a1
 300c28e:	853e                	mv	a0,a5
 300c290:	85c2                	mv	a1,a6
 300c292:	21a1                	jal	ra,300c6da <__truncdfsf2.trans.28>
 300c294:	20a507d3          	fmv.s	fa5,fa0
 300c298:	fdc42783          	lw	a5,-36(s0)
 300c29c:	e7dc                	fsw	fa5,12(a5)
    pMotor->speed = pMotor->speedRps * MOTOR_TIRE_DIAMETER * PI;
 300c29e:	fdc42783          	lw	a5,-36(s0)
 300c2a2:	67dc                	flw	fa5,12(a5)
 300c2a4:	20f78553          	fmv.s	fa0,fa5
 300c2a8:	2071                	jal	ra,300c334 <__extendsfdf2.trans.10>
 300c2aa:	87aa                	mv	a5,a0
 300c2ac:	882e                	mv	a6,a1
 300c2ae:	03012737          	lui	a4,0x3012
 300c2b2:	ef870713          	addi	a4,a4,-264 # 3011ef8 <g_crgIpMatch+0x660>
 300c2b6:	4310                	lw	a2,0(a4)
 300c2b8:	4354                	lw	a3,4(a4)
 300c2ba:	853e                	mv	a0,a5
 300c2bc:	85c2                	mv	a1,a6
 300c2be:	20ad                	jal	ra,300c328 <__muldf3.trans.25>
 300c2c0:	87aa                	mv	a5,a0
 300c2c2:	882e                	mv	a6,a1
 300c2c4:	03012737          	lui	a4,0x3012
 300c2c8:	f0070713          	addi	a4,a4,-256 # 3011f00 <g_crgIpMatch+0x668>
 300c2cc:	4310                	lw	a2,0(a4)
 300c2ce:	4354                	lw	a3,4(a4)
 300c2d0:	853e                	mv	a0,a5
 300c2d2:	85c2                	mv	a1,a6
 300c2d4:	2891                	jal	ra,300c328 <__muldf3.trans.25>
 300c2d6:	87aa                	mv	a5,a0
 300c2d8:	882e                	mv	a6,a1
 300c2da:	853e                	mv	a0,a5
 300c2dc:	85c2                	mv	a1,a6
 300c2de:	2ef5                	jal	ra,300c6da <__truncdfsf2.trans.28>
 300c2e0:	20a507d3          	fmv.s	fa5,fa0
 300c2e4:	fdc42783          	lw	a5,-36(s0)
 300c2e8:	eb9c                	fsw	fa5,16(a5)
    pMotor->lastNumber = pMotor->curNumber;
 300c2ea:	fdc42783          	lw	a5,-36(s0)
 300c2ee:	43d8                	lw	a4,4(a5)
 300c2f0:	fdc42783          	lw	a5,-36(s0)
 300c2f4:	c798                	sw	a4,8(a5)
    pMotor->deltaValue = deltaValue;
 300c2f6:	fdc42783          	lw	a5,-36(s0)
 300c2fa:	fec42703          	lw	a4,-20(s0)
 300c2fe:	cf98                	sw	a4,24(a5)
    if(qdm_dir == 0){   //电机反转
 300c300:	fe442783          	lw	a5,-28(s0)
 300c304:	eb89                	bnez	a5,300c316 <QDM_CalMotorSpeed+0x236>
        pMotor->speed = -pMotor->speed;
 300c306:	fdc42783          	lw	a5,-36(s0)
 300c30a:	6b9c                	flw	fa5,16(a5)
 300c30c:	20f797d3          	fneg.s	fa5,fa5
 300c310:	fdc42783          	lw	a5,-36(s0)
 300c314:	eb9c                	fsw	fa5,16(a5)
                                          g_TimerInterruptCount,qdm_cnt,pMotor->deltaValue,qdm_dir,pMotor->speedRps,pMotor->speed);
            }
        }
    }*/

}
 300c316:	0001                	nop
 300c318:	02010293          	addi	t0,sp,32
 300c31c:	0062828b          	ldmia	{ra,s0,s2-s3},(t0)
 300c320:	6145                	addi	sp,sp,48
 300c322:	8082                	ret

0300c324 <__floatunsidf.trans.45>:
 300c324:	47f0406f          	j	3010fa2 <__floatunsidf>

0300c328 <__muldf3.trans.25>:
 300c328:	5b50306f          	j	30100dc <__muldf3>

0300c32c <__divdf3.trans.22>:
 300c32c:	5aa0306f          	j	300f8d6 <__divdf3>

0300c330 <DBG_UartPrintf.trans.12>:
 300c330:	ebafa06f          	j	30069ea <DBG_UartPrintf>

0300c334 <__extendsfdf2.trans.10>:
 300c334:	4d50406f          	j	3011008 <__extendsfdf2>

0300c338 <data_transition>:

#define IS_SUPPORT_PID 1

/* 串口发送的数据进行赋值 */
static void data_transition(void)
{
 300c338:	7139                	addi	sp,sp,-64
 300c33a:	02010293          	addi	t0,sp,32
 300c33e:	07e2928b          	stmia	{ra,s0,s2-s7},(t0)
 300c342:	0080                	addi	s0,sp,64
    float A_Move_X,A_Move_Z;
  
    g_SendData.SensorStr.Frame_Header = FRAME_HEADER; //帧头
 300c344:	d6e18793          	addi	a5,gp,-658 # 4000678 <g_SendData>
 300c348:	07b00713          	li	a4,123
 300c34c:	af98                	sb	a4,24(a5)
    g_SendData.SensorStr.Frame_Tail = FRAME_TAIL;     //帧尾
 300c34e:	d6e18793          	addi	a5,gp,-658 # 4000678 <g_SendData>
 300c352:	07d00713          	li	a4,125
 300c356:	02e78723          	sb	a4,46(a5)

    //从各车轮当前速度求出三轴当前速度
    A_Move_X = (aveRightMotor.speed + aveLeftMotor.speed) / 2.0; //小车x轴速度，单位mm/s
 300c35a:	d2a18793          	addi	a5,gp,-726 # 4000634 <aveRightMotor>
 300c35e:	6b98                	flw	fa4,16(a5)
 300c360:	d4618793          	addi	a5,gp,-698 # 4000650 <aveLeftMotor>
 300c364:	6b9c                	flw	fa5,16(a5)
 300c366:	00f77753          	fadd.s	fa4,fa4,fa5
 300c36a:	030127b7          	lui	a5,0x3012
 300c36e:	1a87a787          	flw	fa5,424(a5) # 30121a8 <g_crgIpMatch+0x910>
 300c372:	18f777d3          	fdiv.s	fa5,fa4,fa5
 300c376:	fcf42c27          	fsw	fa5,-40(s0)
    A_Move_Z = (aveRightMotor.speed - aveLeftMotor.speed) / (EULERCAR_WHEEL_TRACK * 2.0) * 1000.0; //小车角速度, 单位mrad/s
 300c37a:	d2a18793          	addi	a5,gp,-726 # 4000634 <aveRightMotor>
 300c37e:	6b98                	flw	fa4,16(a5)
 300c380:	d4618793          	addi	a5,gp,-698 # 4000650 <aveLeftMotor>
 300c384:	6b9c                	flw	fa5,16(a5)
 300c386:	08f777d3          	fsub.s	fa5,fa4,fa5
 300c38a:	20f78553          	fmv.s	fa0,fa5
 300c38e:	375d                	jal	ra,300c334 <__extendsfdf2.trans.10>
 300c390:	87aa                	mv	a5,a0
 300c392:	882e                	mv	a6,a1
 300c394:	03012737          	lui	a4,0x3012
 300c398:	1b070713          	addi	a4,a4,432 # 30121b0 <g_crgIpMatch+0x918>
 300c39c:	4310                	lw	a2,0(a4)
 300c39e:	4354                	lw	a3,4(a4)
 300c3a0:	853e                	mv	a0,a5
 300c3a2:	85c2                	mv	a1,a6
 300c3a4:	3761                	jal	ra,300c32c <__divdf3.trans.22>
 300c3a6:	87aa                	mv	a5,a0
 300c3a8:	882e                	mv	a6,a1
 300c3aa:	03012737          	lui	a4,0x3012
 300c3ae:	1b870713          	addi	a4,a4,440 # 30121b8 <g_crgIpMatch+0x920>
 300c3b2:	4310                	lw	a2,0(a4)
 300c3b4:	4354                	lw	a3,4(a4)
 300c3b6:	853e                	mv	a0,a5
 300c3b8:	85c2                	mv	a1,a6
 300c3ba:	37bd                	jal	ra,300c328 <__muldf3.trans.25>
 300c3bc:	87aa                	mv	a5,a0
 300c3be:	882e                	mv	a6,a1
 300c3c0:	853e                	mv	a0,a5
 300c3c2:	85c2                	mv	a1,a6
 300c3c4:	2e19                	jal	ra,300c6da <__truncdfsf2.trans.28>
 300c3c6:	20a507d3          	fmv.s	fa5,fa0
 300c3ca:	fcf42a27          	fsw	fa5,-44(s0)

    g_SendData.SensorStr.X_speed = (short)(round(A_Move_X)); //小车x轴速度，单位mm/s
 300c3ce:	fd842507          	flw	fa0,-40(s0)
 300c3d2:	378d                	jal	ra,300c334 <__extendsfdf2.trans.10>
 300c3d4:	87aa                	mv	a5,a0
 300c3d6:	882e                	mv	a6,a1
 300c3d8:	853e                	mv	a0,a5
 300c3da:	85c2                	mv	a1,a6
 300c3dc:	77d040ef          	jal	ra,3011358 <round>
 300c3e0:	87aa                	mv	a5,a0
 300c3e2:	882e                	mv	a6,a1
 300c3e4:	853e                	mv	a0,a5
 300c3e6:	85c2                	mv	a1,a6
 300c3e8:	2f9040ef          	jal	ra,3010ee0 <__fixdfsi>
 300c3ec:	87aa                	mv	a5,a0
 300c3ee:	01079713          	slli	a4,a5,0x10
 300c3f2:	8741                	srai	a4,a4,0x10
 300c3f4:	d6e18793          	addi	a5,gp,-658 # 4000678 <g_SendData>
 300c3f8:	afba                	sh	a4,26(a5)
    g_SendData.SensorStr.Y_speed = 0;
 300c3fa:	d6e18793          	addi	a5,gp,-658 # 4000678 <g_SendData>
 300c3fe:	00079e23          	sh	zero,28(a5)
    g_SendData.SensorStr.Z_speed = (short)(round(A_Move_Z)); //小车角速度，单位mm/s
 300c402:	fd442507          	flw	fa0,-44(s0)
 300c406:	373d                	jal	ra,300c334 <__extendsfdf2.trans.10>
 300c408:	87aa                	mv	a5,a0
 300c40a:	882e                	mv	a6,a1
 300c40c:	853e                	mv	a0,a5
 300c40e:	85c2                	mv	a1,a6
 300c410:	749040ef          	jal	ra,3011358 <round>
 300c414:	87aa                	mv	a5,a0
 300c416:	882e                	mv	a6,a1
 300c418:	853e                	mv	a0,a5
 300c41a:	85c2                	mv	a1,a6
 300c41c:	2c5040ef          	jal	ra,3010ee0 <__fixdfsi>
 300c420:	87aa                	mv	a5,a0
 300c422:	01079713          	slli	a4,a5,0x10
 300c426:	8741                	srai	a4,a4,0x10
 300c428:	d6e18793          	addi	a5,gp,-658 # 4000678 <g_SendData>
 300c42c:	affa                	sh	a4,30(a5)

    DBG_PRINTF("ActualeftSpeed:%.2fmm/s,ActualRightSpeed:%.2fmm/s,A_Move_X=%.2fmm/s,A_Move_Z=%.2fmrad/s\r\n", 
                                                          aveLeftMotor.speed,aveRightMotor.speed,A_Move_X,A_Move_Z);
 300c42e:	d4618793          	addi	a5,gp,-698 # 4000650 <aveLeftMotor>
 300c432:	6b9c                	flw	fa5,16(a5)
    DBG_PRINTF("ActualeftSpeed:%.2fmm/s,ActualRightSpeed:%.2fmm/s,A_Move_X=%.2fmm/s,A_Move_Z=%.2fmrad/s\r\n", 
 300c434:	20f78553          	fmv.s	fa0,fa5
 300c438:	3df5                	jal	ra,300c334 <__extendsfdf2.trans.10>
 300c43a:	892a                	mv	s2,a0
 300c43c:	89ae                	mv	s3,a1
                                                          aveLeftMotor.speed,aveRightMotor.speed,A_Move_X,A_Move_Z);
 300c43e:	d2a18793          	addi	a5,gp,-726 # 4000634 <aveRightMotor>
 300c442:	6b9c                	flw	fa5,16(a5)
    DBG_PRINTF("ActualeftSpeed:%.2fmm/s,ActualRightSpeed:%.2fmm/s,A_Move_X=%.2fmm/s,A_Move_Z=%.2fmrad/s\r\n", 
 300c444:	20f78553          	fmv.s	fa0,fa5
 300c448:	35f5                	jal	ra,300c334 <__extendsfdf2.trans.10>
 300c44a:	8a2a                	mv	s4,a0
 300c44c:	8aae                	mv	s5,a1
 300c44e:	fd842507          	flw	fa0,-40(s0)
 300c452:	35cd                	jal	ra,300c334 <__extendsfdf2.trans.10>
 300c454:	8b2a                	mv	s6,a0
 300c456:	8bae                	mv	s7,a1
 300c458:	fd442507          	flw	fa0,-44(s0)
 300c45c:	3de1                	jal	ra,300c334 <__extendsfdf2.trans.10>
 300c45e:	87aa                	mv	a5,a0
 300c460:	882e                	mv	a6,a1
 300c462:	c03e                	sw	a5,0(sp)
 300c464:	c242                	sw	a6,4(sp)
 300c466:	885a                	mv	a6,s6
 300c468:	88de                	mv	a7,s7
 300c46a:	8752                	mv	a4,s4
 300c46c:	87d6                	mv	a5,s5
 300c46e:	864a                	mv	a2,s2
 300c470:	86ce                	mv	a3,s3
 300c472:	030125b7          	lui	a1,0x3012
 300c476:	f2058513          	addi	a0,a1,-224 # 3011f20 <g_crgIpMatch+0x688>
 300c47a:	3d5d                	jal	ra,300c330 <DBG_UartPrintf.trans.12>

    //加速度计三轴加速度
    g_SendData.SensorStr.Accelerometer.X_data = 1;  //加速度计Y轴转换到ROS坐标X轴
 300c47c:	d6e18793          	addi	a5,gp,-658 # 4000678 <g_SendData>
 300c480:	4705                	li	a4,1
 300c482:	b3ba                	sh	a4,34(a5)
    g_SendData.SensorStr.Accelerometer.Y_data = 1;  //加速度计X轴转换到ROS坐标Y轴
 300c484:	d6e18793          	addi	a5,gp,-658 # 4000678 <g_SendData>
 300c488:	4705                	li	a4,1
 300c48a:	b3da                	sh	a4,36(a5)
    g_SendData.SensorStr.Accelerometer.Z_data = 1;  //加速度计Z轴转换到ROS坐标Z轴
 300c48c:	d6e18793          	addi	a5,gp,-658 # 4000678 <g_SendData>
 300c490:	4705                	li	a4,1
 300c492:	b3fa                	sh	a4,38(a5)

    //角速度计三轴角速度
    g_SendData.SensorStr.Gyroscope.X_data = 2;     //角速度计Y轴转换到ROS坐标X轴
 300c494:	d6e18793          	addi	a5,gp,-658 # 4000678 <g_SendData>
 300c498:	4709                	li	a4,2
 300c49a:	b79a                	sh	a4,40(a5)
    g_SendData.SensorStr.Gyroscope.Y_data = 2;     //角速度计X轴转换到ROS坐标Y轴
 300c49c:	d6e18793          	addi	a5,gp,-658 # 4000678 <g_SendData>
 300c4a0:	4709                	li	a4,2
 300c4a2:	b7ba                	sh	a4,42(a5)
    if (g_MotorState == 0)
 300c4a4:	d6a1c783          	lbu	a5,-662(gp) # 4000674 <g_MotorState>
 300c4a8:	e791                	bnez	a5,300c4b4 <data_transition+0x17c>
        //如果电机控制位使能状态，那么正常发送Z轴角速度
        g_SendData.SensorStr.Gyroscope.Z_data = 1;
 300c4aa:	d6e18793          	addi	a5,gp,-658 # 4000678 <g_SendData>
 300c4ae:	4705                	li	a4,1
 300c4b0:	b7da                	sh	a4,44(a5)
 300c4b2:	a029                	j	300c4bc <data_transition+0x184>
    else
        //如果机器人是静止的（电机控制位失能），那么发送的Z轴角速度为0
        g_SendData.SensorStr.Gyroscope.Z_data = 0;
 300c4b4:	d6e18793          	addi	a5,gp,-658 # 4000678 <g_SendData>
 300c4b8:	02079623          	sh	zero,44(a5)

    //电池电压(这里将浮点数放大一千倍传输，相应的在接收端在接收到数据后也会缩小一千倍)
    g_SendData.SensorStr.Power_Voltage = 90;
 300c4bc:	d6e18793          	addi	a5,gp,-658 # 4000678 <g_SendData>
 300c4c0:	05a00713          	li	a4,90
 300c4c4:	b39a                	sh	a4,32(a5)

    g_SendData.buffer[0] = g_SendData.SensorStr.Frame_Header; // 帧头
 300c4c6:	d6e18793          	addi	a5,gp,-658 # 4000678 <g_SendData>
 300c4ca:	2f98                	lbu	a4,24(a5)
 300c4cc:	d6e18793          	addi	a5,gp,-658 # 4000678 <g_SendData>
 300c4d0:	a398                	sb	a4,0(a5)
    g_SendData.buffer[1] = g_MotorState;                      // 小车软件失能标志位
 300c4d2:	d6a1c703          	lbu	a4,-662(gp) # 4000674 <g_MotorState>
 300c4d6:	d6e18793          	addi	a5,gp,-658 # 4000678 <g_SendData>
 300c4da:	b398                	sb	a4,1(a5)

    //小车三轴速度,各轴都拆分为两个8位数据再发送
    g_SendData.buffer[2] = g_SendData.SensorStr.X_speed >> 8;
 300c4dc:	d6e18793          	addi	a5,gp,-658 # 4000678 <g_SendData>
 300c4e0:	01a79783          	lh	a5,26(a5)
 300c4e4:	87a1                	srai	a5,a5,0x8
 300c4e6:	07c2                	slli	a5,a5,0x10
 300c4e8:	87c1                	srai	a5,a5,0x10
 300c4ea:	0ff7f713          	andi	a4,a5,255
 300c4ee:	d6e18793          	addi	a5,gp,-658 # 4000678 <g_SendData>
 300c4f2:	a3b8                	sb	a4,2(a5)
    g_SendData.buffer[3] = g_SendData.SensorStr.X_speed;
 300c4f4:	d6e18793          	addi	a5,gp,-658 # 4000678 <g_SendData>
 300c4f8:	01a79783          	lh	a5,26(a5)
 300c4fc:	0ff7f713          	andi	a4,a5,255
 300c500:	d6e18793          	addi	a5,gp,-658 # 4000678 <g_SendData>
 300c504:	b3b8                	sb	a4,3(a5)
    g_SendData.buffer[4] = g_SendData.SensorStr.Y_speed >> 8;
 300c506:	d6e18793          	addi	a5,gp,-658 # 4000678 <g_SendData>
 300c50a:	01c79783          	lh	a5,28(a5)
 300c50e:	87a1                	srai	a5,a5,0x8
 300c510:	07c2                	slli	a5,a5,0x10
 300c512:	87c1                	srai	a5,a5,0x10
 300c514:	0ff7f713          	andi	a4,a5,255
 300c518:	d6e18793          	addi	a5,gp,-658 # 4000678 <g_SendData>
 300c51c:	a3d8                	sb	a4,4(a5)
    g_SendData.buffer[5] = g_SendData.SensorStr.Y_speed;
 300c51e:	d6e18793          	addi	a5,gp,-658 # 4000678 <g_SendData>
 300c522:	01c79783          	lh	a5,28(a5)
 300c526:	0ff7f713          	andi	a4,a5,255
 300c52a:	d6e18793          	addi	a5,gp,-658 # 4000678 <g_SendData>
 300c52e:	b3d8                	sb	a4,5(a5)
    g_SendData.buffer[6] = g_SendData.SensorStr.Z_speed >> 8;
 300c530:	d6e18793          	addi	a5,gp,-658 # 4000678 <g_SendData>
 300c534:	01e79783          	lh	a5,30(a5)
 300c538:	87a1                	srai	a5,a5,0x8
 300c53a:	07c2                	slli	a5,a5,0x10
 300c53c:	87c1                	srai	a5,a5,0x10
 300c53e:	0ff7f713          	andi	a4,a5,255
 300c542:	d6e18793          	addi	a5,gp,-658 # 4000678 <g_SendData>
 300c546:	a3f8                	sb	a4,6(a5)
    g_SendData.buffer[7] = g_SendData.SensorStr.Z_speed;
 300c548:	d6e18793          	addi	a5,gp,-658 # 4000678 <g_SendData>
 300c54c:	01e79783          	lh	a5,30(a5)
 300c550:	0ff7f713          	andi	a4,a5,255
 300c554:	d6e18793          	addi	a5,gp,-658 # 4000678 <g_SendData>
 300c558:	b3f8                	sb	a4,7(a5)

    //IMU加速度计三轴加速度,各轴都拆分为两个8位数据再发送
    g_SendData.buffer[8] = g_SendData.SensorStr.Accelerometer.X_data >> 8;
 300c55a:	d6e18793          	addi	a5,gp,-658 # 4000678 <g_SendData>
 300c55e:	02279783          	lh	a5,34(a5)
 300c562:	87a1                	srai	a5,a5,0x8
 300c564:	07c2                	slli	a5,a5,0x10
 300c566:	87c1                	srai	a5,a5,0x10
 300c568:	0ff7f713          	andi	a4,a5,255
 300c56c:	d6e18793          	addi	a5,gp,-658 # 4000678 <g_SendData>
 300c570:	a798                	sb	a4,8(a5)
    g_SendData.buffer[9] = g_SendData.SensorStr.Accelerometer.X_data;
 300c572:	d6e18793          	addi	a5,gp,-658 # 4000678 <g_SendData>
 300c576:	02279783          	lh	a5,34(a5)
 300c57a:	0ff7f713          	andi	a4,a5,255
 300c57e:	d6e18793          	addi	a5,gp,-658 # 4000678 <g_SendData>
 300c582:	b798                	sb	a4,9(a5)
    g_SendData.buffer[10] = g_SendData.SensorStr.Accelerometer.Y_data >> 8;
 300c584:	d6e18793          	addi	a5,gp,-658 # 4000678 <g_SendData>
 300c588:	02479783          	lh	a5,36(a5)
 300c58c:	87a1                	srai	a5,a5,0x8
 300c58e:	07c2                	slli	a5,a5,0x10
 300c590:	87c1                	srai	a5,a5,0x10
 300c592:	0ff7f713          	andi	a4,a5,255
 300c596:	d6e18793          	addi	a5,gp,-658 # 4000678 <g_SendData>
 300c59a:	a7b8                	sb	a4,10(a5)
    g_SendData.buffer[11] = g_SendData.SensorStr.Accelerometer.Y_data;
 300c59c:	d6e18793          	addi	a5,gp,-658 # 4000678 <g_SendData>
 300c5a0:	02479783          	lh	a5,36(a5)
 300c5a4:	0ff7f713          	andi	a4,a5,255
 300c5a8:	d6e18793          	addi	a5,gp,-658 # 4000678 <g_SendData>
 300c5ac:	b7b8                	sb	a4,11(a5)
    g_SendData.buffer[12] = g_SendData.SensorStr.Accelerometer.Z_data >> 8;
 300c5ae:	d6e18793          	addi	a5,gp,-658 # 4000678 <g_SendData>
 300c5b2:	02679783          	lh	a5,38(a5)
 300c5b6:	87a1                	srai	a5,a5,0x8
 300c5b8:	07c2                	slli	a5,a5,0x10
 300c5ba:	87c1                	srai	a5,a5,0x10
 300c5bc:	0ff7f713          	andi	a4,a5,255
 300c5c0:	d6e18793          	addi	a5,gp,-658 # 4000678 <g_SendData>
 300c5c4:	a7d8                	sb	a4,12(a5)
    g_SendData.buffer[13] = g_SendData.SensorStr.Accelerometer.Z_data;
 300c5c6:	d6e18793          	addi	a5,gp,-658 # 4000678 <g_SendData>
 300c5ca:	02679783          	lh	a5,38(a5)
 300c5ce:	0ff7f713          	andi	a4,a5,255
 300c5d2:	d6e18793          	addi	a5,gp,-658 # 4000678 <g_SendData>
 300c5d6:	b7d8                	sb	a4,13(a5)

    //IMU角速度计三轴角速度,各轴都拆分为两个8位数据再发送
    g_SendData.buffer[14] = g_SendData.SensorStr.Gyroscope.X_data >> 8;
 300c5d8:	d6e18793          	addi	a5,gp,-658 # 4000678 <g_SendData>
 300c5dc:	02879783          	lh	a5,40(a5)
 300c5e0:	87a1                	srai	a5,a5,0x8
 300c5e2:	07c2                	slli	a5,a5,0x10
 300c5e4:	87c1                	srai	a5,a5,0x10
 300c5e6:	0ff7f713          	andi	a4,a5,255
 300c5ea:	d6e18793          	addi	a5,gp,-658 # 4000678 <g_SendData>
 300c5ee:	a7f8                	sb	a4,14(a5)
    g_SendData.buffer[15] = g_SendData.SensorStr.Gyroscope.X_data;
 300c5f0:	d6e18793          	addi	a5,gp,-658 # 4000678 <g_SendData>
 300c5f4:	02879783          	lh	a5,40(a5)
 300c5f8:	0ff7f713          	andi	a4,a5,255
 300c5fc:	d6e18793          	addi	a5,gp,-658 # 4000678 <g_SendData>
 300c600:	b7f8                	sb	a4,15(a5)
    g_SendData.buffer[16] = g_SendData.SensorStr.Gyroscope.Y_data >> 8;
 300c602:	d6e18793          	addi	a5,gp,-658 # 4000678 <g_SendData>
 300c606:	02a79783          	lh	a5,42(a5)
 300c60a:	87a1                	srai	a5,a5,0x8
 300c60c:	07c2                	slli	a5,a5,0x10
 300c60e:	87c1                	srai	a5,a5,0x10
 300c610:	0ff7f713          	andi	a4,a5,255
 300c614:	d6e18793          	addi	a5,gp,-658 # 4000678 <g_SendData>
 300c618:	ab98                	sb	a4,16(a5)
    g_SendData.buffer[17] = g_SendData.SensorStr.Gyroscope.Y_data;
 300c61a:	d6e18793          	addi	a5,gp,-658 # 4000678 <g_SendData>
 300c61e:	02a79783          	lh	a5,42(a5)
 300c622:	0ff7f713          	andi	a4,a5,255
 300c626:	d6e18793          	addi	a5,gp,-658 # 4000678 <g_SendData>
 300c62a:	bb98                	sb	a4,17(a5)
    g_SendData.buffer[18] = g_SendData.SensorStr.Gyroscope.Z_data >> 8;
 300c62c:	d6e18793          	addi	a5,gp,-658 # 4000678 <g_SendData>
 300c630:	02c79783          	lh	a5,44(a5)
 300c634:	87a1                	srai	a5,a5,0x8
 300c636:	07c2                	slli	a5,a5,0x10
 300c638:	87c1                	srai	a5,a5,0x10
 300c63a:	0ff7f713          	andi	a4,a5,255
 300c63e:	d6e18793          	addi	a5,gp,-658 # 4000678 <g_SendData>
 300c642:	abb8                	sb	a4,18(a5)
    g_SendData.buffer[19] = g_SendData.SensorStr.Gyroscope.Z_data;
 300c644:	d6e18793          	addi	a5,gp,-658 # 4000678 <g_SendData>
 300c648:	02c79783          	lh	a5,44(a5)
 300c64c:	0ff7f713          	andi	a4,a5,255
 300c650:	d6e18793          	addi	a5,gp,-658 # 4000678 <g_SendData>
 300c654:	bbb8                	sb	a4,19(a5)

    //电池电压,拆分为两个8位数据发送
    g_SendData.buffer[20] = g_SendData.SensorStr.Power_Voltage >> 8;
 300c656:	d6e18793          	addi	a5,gp,-658 # 4000678 <g_SendData>
 300c65a:	02079783          	lh	a5,32(a5)
 300c65e:	87a1                	srai	a5,a5,0x8
 300c660:	07c2                	slli	a5,a5,0x10
 300c662:	87c1                	srai	a5,a5,0x10
 300c664:	0ff7f713          	andi	a4,a5,255
 300c668:	d6e18793          	addi	a5,gp,-658 # 4000678 <g_SendData>
 300c66c:	abd8                	sb	a4,20(a5)
    g_SendData.buffer[21] = g_SendData.SensorStr.Power_Voltage;
 300c66e:	d6e18793          	addi	a5,gp,-658 # 4000678 <g_SendData>
 300c672:	02079783          	lh	a5,32(a5)
 300c676:	0ff7f713          	andi	a4,a5,255
 300c67a:	d6e18793          	addi	a5,gp,-658 # 4000678 <g_SendData>
 300c67e:	bbd8                	sb	a4,21(a5)

    //数据校验位计算
    unsigned char check_sum = 0, k;
 300c680:	fc040fa3          	sb	zero,-33(s0)
    for (k = 0; k < 22; k++) {
 300c684:	fc040f23          	sb	zero,-34(s0)
 300c688:	a00d                	j	300c6aa <data_transition+0x372>
        check_sum = check_sum ^ g_SendData.buffer[k];
 300c68a:	fde44783          	lbu	a5,-34(s0)
 300c68e:	d6e18713          	addi	a4,gp,-658 # 4000678 <g_SendData>
 300c692:	97ba                	add	a5,a5,a4
 300c694:	2398                	lbu	a4,0(a5)
 300c696:	fdf44783          	lbu	a5,-33(s0)
 300c69a:	8fb9                	xor	a5,a5,a4
 300c69c:	fcf40fa3          	sb	a5,-33(s0)
    for (k = 0; k < 22; k++) {
 300c6a0:	fde44783          	lbu	a5,-34(s0)
 300c6a4:	0785                	addi	a5,a5,1
 300c6a6:	fcf40f23          	sb	a5,-34(s0)
 300c6aa:	fde44703          	lbu	a4,-34(s0)
 300c6ae:	47d5                	li	a5,21
 300c6b0:	fce7fde3          	bgeu	a5,a4,300c68a <data_transition+0x352>
    }
    g_SendData.buffer[22] = check_sum;
 300c6b4:	d6e18793          	addi	a5,gp,-658 # 4000678 <g_SendData>
 300c6b8:	fdf44703          	lbu	a4,-33(s0)
 300c6bc:	abf8                	sb	a4,22(a5)
    g_SendData.buffer[23] = g_SendData.SensorStr.Frame_Tail; //帧尾
 300c6be:	d6e18793          	addi	a5,gp,-658 # 4000678 <g_SendData>
 300c6c2:	02e7c703          	lbu	a4,46(a5)
 300c6c6:	d6e18793          	addi	a5,gp,-658 # 4000678 <g_SendData>
 300c6ca:	bbf8                	sb	a4,23(a5)
}
 300c6cc:	0001                	nop
 300c6ce:	02010293          	addi	t0,sp,32
 300c6d2:	07e2828b          	ldmia	{ra,s0,s2-s7},(t0)
 300c6d6:	6121                	addi	sp,sp,64
 300c6d8:	8082                	ret

0300c6da <__truncdfsf2.trans.28>:
 300c6da:	20d0406f          	j	30110e6 <__truncdfsf2>

0300c6de <UART3WriteInterruptCallback>:
    }
    DBG_PRINTF("  \r\n");
}

void UART3WriteInterruptCallback(void *handle)
{
 300c6de:	1101                	addi	sp,sp,-32
 300c6e0:	ce22                	sw	s0,28(sp)
 300c6e2:	1000                	addi	s0,sp,32
 300c6e4:	fea42623          	sw	a0,-20(s0)
    BASE_FUNC_UNUSED(handle);
    //DBG_PRINTF("\r\nUART Write Finish\r\n");
    g_TxInterruptFlag = true;
 300c6e8:	4705                	li	a4,1
 300c6ea:	80e184a3          	sb	a4,-2039(gp) # 4000113 <g_TxInterruptFlag>
    return;
 300c6ee:	0001                	nop
}
 300c6f0:	4472                	lw	s0,28(sp)
 300c6f2:	6105                	addi	sp,sp,32
 300c6f4:	8082                	ret

0300c6f6 <UART3ReadInterruptCallback>:

void UART3ReadInterruptCallback(void *handle)
{
 300c6f6:	1101                	addi	sp,sp,-32
 300c6f8:	ce22                	sw	s0,28(sp)
 300c6fa:	1000                	addi	s0,sp,32
 300c6fc:	fea42623          	sw	a0,-20(s0)
    BASE_FUNC_UNUSED(handle);
    g_RxInterruptflag = 1;
 300c700:	040007b7          	lui	a5,0x4000
 300c704:	4705                	li	a4,1
 300c706:	10e78923          	sb	a4,274(a5) # 4000112 <g_RxInterruptflag>
    return;
 300c70a:	0001                	nop
}
 300c70c:	4472                	lw	s0,28(sp)
 300c70e:	6105                	addi	sp,sp,32
 300c710:	8082                	ret

0300c712 <TIMER0_InterruptProcess>:

// 定时器10ms产生一个中断
void TIMER0_InterruptProcess(void *handle)
{
 300c712:	7179                	addi	sp,sp,-48
 300c714:	d606                	sw	ra,44(sp)
 300c716:	d422                	sw	s0,40(sp)
 300c718:	1800                	addi	s0,sp,48
 300c71a:	fca42e23          	sw	a0,-36(s0)
    BASE_StatusType ret;
    /* USER CODE BEGIN TIMER0_InterruptProcess */
    TIMER_Handle *timerHandle = (TIMER_Handle *)handle;
 300c71e:	fdc42783          	lw	a5,-36(s0)
 300c722:	fef42623          	sw	a5,-20(s0)
    BASE_FUNC_UNUSED(timerHandle);
    g_TimerInterruptCount++;
 300c726:	dc21a783          	lw	a5,-574(gp) # 40006cc <g_TimerInterruptCount>
 300c72a:	00178713          	addi	a4,a5,1
 300c72e:	dce1a123          	sw	a4,-574(gp) # 40006cc <g_TimerInterruptCount>

    //按键滤波，500毫秒内算一次按键
    if(g_button1_count > 0)
 300c732:	cbe1a783          	lw	a5,-834(gp) # 40005c8 <g_button1_count>
 300c736:	02f05063          	blez	a5,300c756 <TIMER0_InterruptProcess+0x44>
    {
        g_button1_count ++;
 300c73a:	cbe1a783          	lw	a5,-834(gp) # 40005c8 <g_button1_count>
 300c73e:	00178713          	addi	a4,a5,1
 300c742:	cae1af23          	sw	a4,-834(gp) # 40005c8 <g_button1_count>
        if(g_button1_count > 50){
 300c746:	cbe1a703          	lw	a4,-834(gp) # 40005c8 <g_button1_count>
 300c74a:	03200793          	li	a5,50
 300c74e:	00e7d463          	bge	a5,a4,300c756 <TIMER0_InterruptProcess+0x44>
           g_button1_count = 0;
 300c752:	ca01af23          	sw	zero,-834(gp) # 40005c8 <g_button1_count>
           //DBG_PRINTF("Button1 Count Reset 0\r\n");
        }
    }

    if(g_button2_count > 0)
 300c756:	cc21a783          	lw	a5,-830(gp) # 40005cc <g_button2_count>
 300c75a:	02f05063          	blez	a5,300c77a <TIMER0_InterruptProcess+0x68>
    {
        g_button2_count ++;
 300c75e:	cc21a783          	lw	a5,-830(gp) # 40005cc <g_button2_count>
 300c762:	00178713          	addi	a4,a5,1
 300c766:	cce1a123          	sw	a4,-830(gp) # 40005cc <g_button2_count>
        if(g_button2_count > 50){
 300c76a:	cc21a703          	lw	a4,-830(gp) # 40005cc <g_button2_count>
 300c76e:	03200793          	li	a5,50
 300c772:	00e7d463          	bge	a5,a4,300c77a <TIMER0_InterruptProcess+0x68>
           g_button2_count = 0;
 300c776:	cc01a123          	sw	zero,-830(gp) # 40005cc <g_button2_count>
           //DBG_PRINTF("Button2 Count Reset 0\r\n");
        }
    }

    //按设置周期上报底盘数据
    if ((g_TimerInterruptCount % (EULER_CAR_DATA_SEND_PERIOD/10)) == 0) {
 300c77a:	dc21a703          	lw	a4,-574(gp) # 40006cc <g_TimerInterruptCount>
 300c77e:	47a9                	li	a5,10
 300c780:	02f777b3          	remu	a5,a4,a5
 300c784:	e7b9                	bnez	a5,300c7d2 <TIMER0_InterruptProcess+0xc0>
        if (g_TxInterruptFlag) {
 300c786:	8091c783          	lbu	a5,-2039(gp) # 4000113 <g_TxInterruptFlag>
 300c78a:	9f81                	uxtb	a5
 300c78c:	c3b9                	beqz	a5,300c7d2 <TIMER0_InterruptProcess+0xc0>
            g_TxInterruptFlag = false;
 300c78e:	800184a3          	sb	zero,-2039(gp) # 4000113 <g_TxInterruptFlag>
            //获取小车要发送的数据
            QDM_CalMotorSpeed(&aveLeftMotor);    //计算左轮平均速度           
 300c792:	d4618513          	addi	a0,gp,-698 # 4000650 <aveLeftMotor>
 300c796:	28c9                	jal	ra,300c868 <QDM_CalMotorSpeed.trans.41>
            QDM_CalMotorSpeed(&aveRightMotor);   //计算右轮平均速度
 300c798:	d2a18513          	addi	a0,gp,-726 # 4000634 <aveRightMotor>
 300c79c:	20f1                	jal	ra,300c868 <QDM_CalMotorSpeed.trans.41>
            data_transition();
 300c79e:	3e69                	jal	ra,300c338 <data_transition>

            ret = HAL_UART_WriteIT(&g_uart3, g_SendData.buffer, SEND_DATA_SIZE);
 300c7a0:	4661                	li	a2,24
 300c7a2:	d6e18593          	addi	a1,gp,-658 # 4000678 <g_SendData>
 300c7a6:	12e18513          	addi	a0,gp,302 # 4000a38 <g_uart3>
 300c7aa:	b19fe0ef          	jal	ra,300b2c2 <HAL_UART_WriteIT>
 300c7ae:	fea42423          	sw	a0,-24(s0)
           
            if(ret == BASE_STATUS_OK) {
 300c7b2:	fe842783          	lw	a5,-24(s0)
 300c7b6:	cb81                	beqz	a5,300c7c6 <TIMER0_InterruptProcess+0xb4>
                //DBG_PRINTF("Data send OK, send count = %d\r\n",g_SendCount);
            }else{
                DBG_PRINTF("Data send error, code = %d\r\n",ret);
 300c7b8:	fe842583          	lw	a1,-24(s0)
 300c7bc:	030127b7          	lui	a5,0x3012
 300c7c0:	fc078513          	addi	a0,a5,-64 # 3011fc0 <g_crgIpMatch+0x728>
 300c7c4:	36b5                	jal	ra,300c330 <DBG_UartPrintf.trans.12>
            }
            g_SendCount++;
 300c7c6:	dc61a783          	lw	a5,-570(gp) # 40006d0 <g_SendCount>
 300c7ca:	00178713          	addi	a4,a5,1
 300c7ce:	dce1a323          	sw	a4,-570(gp) # 40006d0 <g_SendCount>
    }

    //每间隔10毫秒进行一次PID电机控制
    if (g_TimerInterruptCount % (MOTOR_PID_CONTROL_PERIOD / 10) == 0) {
         //获取小车运行实际速度
         QDM_CalMotorSpeed(&pidLeftMotor);    //计算一个PID周期内左轮速度           
 300c7d2:	d0e18513          	addi	a0,gp,-754 # 4000618 <pidLeftMotor>
 300c7d6:	2849                	jal	ra,300c868 <QDM_CalMotorSpeed.trans.41>
         QDM_CalMotorSpeed(&pidRightMotor);   //计算一个PID周期内右轮速度
 300c7d8:	cf218513          	addi	a0,gp,-782 # 40005fc <pidRightMotor>
 300c7dc:	2071                	jal	ra,300c868 <QDM_CalMotorSpeed.trans.41>
       
         g_pidEulerCarLeft.ActualSpeed = pidLeftMotor.speed;
 300c7de:	d0e18793          	addi	a5,gp,-754 # 4000618 <pidLeftMotor>
 300c7e2:	6b9c                	flw	fa5,16(a5)
 300c7e4:	4de18793          	addi	a5,gp,1246 # 4000de8 <g_pidEulerCarLeft>
 300c7e8:	e3dc                	fsw	fa5,4(a5)
         g_pidEulerCarRight.ActualSpeed = pidRightMotor.speed;
 300c7ea:	cf218793          	addi	a5,gp,-782 # 40005fc <pidRightMotor>
 300c7ee:	6b9c                	flw	fa5,16(a5)
 300c7f0:	4be18793          	addi	a5,gp,1214 # 4000dc8 <g_pidEulerCarRight>
 300c7f4:	e3dc                	fsw	fa5,4(a5)
         
         //如果上位机下发速度大于0.1mm/s，则启动PID控制
         if ((fabsf(modelCalLeftSpeed) > 0.1) || (fabsf(modelCalRightSpeed) > 0.1)) {
 300c7f6:	dda1a787          	flw	fa5,-550(gp) # 40006e4 <modelCalLeftSpeed>
 300c7fa:	20f78553          	fmv.s	fa0,fa5
 300c7fe:	2961                	jal	ra,300cc96 <fabsf.trans.24>
 300c800:	20a507d3          	fmv.s	fa5,fa0
 300c804:	20f78553          	fmv.s	fa0,fa5
 300c808:	3635                	jal	ra,300c334 <__extendsfdf2.trans.10>
 300c80a:	87aa                	mv	a5,a0
 300c80c:	882e                	mv	a6,a1
 300c80e:	03012737          	lui	a4,0x3012
 300c812:	1c070713          	addi	a4,a4,448 # 30121c0 <g_crgIpMatch+0x928>
 300c816:	4310                	lw	a2,0(a4)
 300c818:	4354                	lw	a3,4(a4)
 300c81a:	853e                	mv	a0,a5
 300c81c:	85c2                	mv	a1,a6
 300c81e:	756030ef          	jal	ra,300ff74 <__gedf2>
 300c822:	87aa                	mv	a5,a0
 300c824:	02f04c63          	bgtz	a5,300c85c <TIMER0_InterruptProcess+0x14a>
 300c828:	dde1a787          	flw	fa5,-546(gp) # 40006e8 <modelCalRightSpeed>
 300c82c:	20f78553          	fmv.s	fa0,fa5
 300c830:	219d                	jal	ra,300cc96 <fabsf.trans.24>
 300c832:	20a507d3          	fmv.s	fa5,fa0
 300c836:	20f78553          	fmv.s	fa0,fa5
 300c83a:	3ced                	jal	ra,300c334 <__extendsfdf2.trans.10>
 300c83c:	87aa                	mv	a5,a0
 300c83e:	882e                	mv	a6,a1
 300c840:	03012737          	lui	a4,0x3012
 300c844:	1c070713          	addi	a4,a4,448 # 30121c0 <g_crgIpMatch+0x928>
 300c848:	4310                	lw	a2,0(a4)
 300c84a:	4354                	lw	a3,4(a4)
 300c84c:	853e                	mv	a0,a5
 300c84e:	85c2                	mv	a1,a6
 300c850:	724030ef          	jal	ra,300ff74 <__gedf2>
 300c854:	87aa                	mv	a5,a0
 300c856:	00f04363          	bgtz	a5,300c85c <TIMER0_InterruptProcess+0x14a>
             Pid_Process();
         }
    }

}
 300c85a:	a011                	j	300c85e <TIMER0_InterruptProcess+0x14c>
             Pid_Process();
 300c85c:	2429                	jal	ra,300ca66 <Pid_Process>
}
 300c85e:	0001                	nop
 300c860:	50b2                	lw	ra,44(sp)
 300c862:	5422                	lw	s0,40(sp)
 300c864:	6145                	addi	sp,sp,48
 300c866:	8082                	ret

0300c868 <QDM_CalMotorSpeed.trans.41>:
 300c868:	879ff06f          	j	300c0e0 <QDM_CalMotorSpeed>

0300c86c <XYZ_transition>:

static float XYZ_transition(unsigned char High, unsigned char Low)
{
 300c86c:	7179                	addi	sp,sp,-48
 300c86e:	d622                	sw	s0,44(sp)
 300c870:	1800                	addi	s0,sp,48
 300c872:	87aa                	mv	a5,a0
 300c874:	872e                	mv	a4,a1
 300c876:	fcf40fa3          	sb	a5,-33(s0)
 300c87a:	87ba                	mv	a5,a4
 300c87c:	fcf40f23          	sb	a5,-34(s0)
    short transition = ((High << 8) + Low);                    //将高8位和低8位整合成一个16位的short型数据
 300c880:	fdf44783          	lbu	a5,-33(s0)
 300c884:	9fa1                	uxth	a5
 300c886:	07a2                	slli	a5,a5,0x8
 300c888:	01079713          	slli	a4,a5,0x10
 300c88c:	8341                	srli	a4,a4,0x10
 300c88e:	fde44783          	lbu	a5,-34(s0)
 300c892:	9fa1                	uxth	a5
 300c894:	97ba                	add	a5,a5,a4
 300c896:	9fa1                	uxth	a5
 300c898:	fef41723          	sh	a5,-18(s0)
    //return transition / 1000 + (transition % 1000) * 0.001;  //单位转换, mm/s->m/s
    return (float)transition;
 300c89c:	fee41783          	lh	a5,-18(s0)
 300c8a0:	d007f7d3          	fcvt.s.w	fa5,a5
}
 300c8a4:	20f78553          	fmv.s	fa0,fa5
 300c8a8:	5432                	lw	s0,44(sp)
 300c8aa:	6145                	addi	sp,sp,48
 300c8ac:	8082                	ret

0300c8ae <EulerCarSpeedCtrlLeft>:

int EulerCarSpeedCtrlLeft(float LeftSpeed)
{
 300c8ae:	7179                	addi	sp,sp,-48
 300c8b0:	d606                	sw	ra,44(sp)
 300c8b2:	d422                	sw	s0,40(sp)
 300c8b4:	1800                	addi	s0,sp,48
 300c8b6:	fca42e27          	fsw	fa0,-36(s0)

    unsigned int duty = (abs)((int)(LeftSpeed/g_motorMaxSpeed * 100)); 
 300c8ba:	85a1a787          	flw	fa5,-1958(gp) # 4000164 <g_motorMaxSpeed>
 300c8be:	fdc42707          	flw	fa4,-36(s0)
 300c8c2:	18f77753          	fdiv.s	fa4,fa4,fa5
 300c8c6:	030127b7          	lui	a5,0x3012
 300c8ca:	1c87a787          	flw	fa5,456(a5) # 30121c8 <g_crgIpMatch+0x930>
 300c8ce:	10f777d3          	fmul.s	fa5,fa4,fa5
 300c8d2:	c00797d3          	fcvt.w.s	a5,fa5,rtz
 300c8d6:	853e                	mv	a0,a5
 300c8d8:	391040ef          	jal	ra,3011468 <abs>
 300c8dc:	87aa                	mv	a5,a0
 300c8de:	fef42623          	sw	a5,-20(s0)
    if (duty > 99) {
 300c8e2:	fec42703          	lw	a4,-20(s0)
 300c8e6:	06300793          	li	a5,99
 300c8ea:	00e7f663          	bgeu	a5,a4,300c8f6 <EulerCarSpeedCtrlLeft+0x48>
        duty = 35;
 300c8ee:	02300793          	li	a5,35
 300c8f2:	fef42623          	sw	a5,-20(s0)
    }
    //DBG_PRINTF("left wheel duty:%d\r\n", duty);
    HAL_APT_SetPWMDutyByNumber(&g_apt1, duty);
 300c8f6:	fec42583          	lw	a1,-20(s0)
 300c8fa:	2de18513          	addi	a0,gp,734 # 4000be8 <g_apt1>
 300c8fe:	d81f50ef          	jal	ra,300267e <HAL_APT_SetPWMDutyByNumber>

    //如果电机小于0.1mm/s，则停止电机转动
    if (fabsf(LeftSpeed) < 0.1) {
 300c902:	fdc42507          	flw	fa0,-36(s0)
 300c906:	2e41                	jal	ra,300cc96 <fabsf.trans.24>
 300c908:	20a507d3          	fmv.s	fa5,fa0
 300c90c:	20f78553          	fmv.s	fa0,fa5
 300c910:	2679                	jal	ra,300cc9e <__extendsfdf2.trans.11>
 300c912:	87aa                	mv	a5,a0
 300c914:	882e                	mv	a6,a1
 300c916:	03012737          	lui	a4,0x3012
 300c91a:	1c070713          	addi	a4,a4,448 # 30121c0 <g_crgIpMatch+0x928>
 300c91e:	4310                	lw	a2,0(a4)
 300c920:	4354                	lw	a3,4(a4)
 300c922:	853e                	mv	a0,a5
 300c924:	85c2                	mv	a1,a6
 300c926:	26b5                	jal	ra,300cc92 <__ltdf2.trans.42>
 300c928:	87aa                	mv	a5,a0
 300c92a:	0007d763          	bgez	a5,300c938 <EulerCarSpeedCtrlLeft+0x8a>
        HAL_APT_StopModule(RUN_APT1);
 300c92e:	4509                	li	a0,2
 300c930:	d1ff50ef          	jal	ra,300264e <HAL_APT_StopModule>
        return 0;
 300c934:	4781                	li	a5,0
 300c936:	a0a9                	j	300c980 <EulerCarSpeedCtrlLeft+0xd2>
    }
    if (LeftSpeed > 0) {
 300c938:	fdc42787          	flw	fa5,-36(s0)
 300c93c:	f0000753          	fmv.w.x	fa4,zero
 300c940:	a0f717d3          	flt.s	a5,fa4,fa5
 300c944:	cf91                	beqz	a5,300c960 <EulerCarSpeedCtrlLeft+0xb2>
        User_APTPwmARecovery(g_apt1.baseAddress);  
 300c946:	2de18793          	addi	a5,gp,734 # 4000be8 <g_apt1>
 300c94a:	439c                	lw	a5,0(a5)
 300c94c:	853e                	mv	a0,a5
 300c94e:	0a2010ef          	jal	ra,300d9f0 <User_APTPwmARecovery>
        User_APTForcePWMBOutputLow(g_apt1.baseAddress);
 300c952:	2de18793          	addi	a5,gp,734 # 4000be8 <g_apt1>
 300c956:	439c                	lw	a5,0(a5)
 300c958:	853e                	mv	a0,a5
 300c95a:	060010ef          	jal	ra,300d9ba <User_APTForcePWMBOutputLow>
 300c95e:	a829                	j	300c978 <EulerCarSpeedCtrlLeft+0xca>
    } else {
        User_APTPwmBRecovery(g_apt1.baseAddress);
 300c960:	2de18793          	addi	a5,gp,734 # 4000be8 <g_apt1>
 300c964:	439c                	lw	a5,0(a5)
 300c966:	853e                	mv	a0,a5
 300c968:	0a8010ef          	jal	ra,300da10 <User_APTPwmBRecovery>
        User_APTForcePWMAOutputLow(g_apt1.baseAddress);
 300c96c:	2de18793          	addi	a5,gp,734 # 4000be8 <g_apt1>
 300c970:	439c                	lw	a5,0(a5)
 300c972:	853e                	mv	a0,a5
 300c974:	012010ef          	jal	ra,300d986 <User_APTForcePWMAOutputLow>
    }
    HAL_APT_StartModule(RUN_APT1);
 300c978:	4509                	li	a0,2
 300c97a:	ca9f50ef          	jal	ra,3002622 <HAL_APT_StartModule>
    //DBG_PRINTF("Left wheel set duty:%d, run ok!\r\n",duty);

    return 0;
 300c97e:	4781                	li	a5,0
}
 300c980:	853e                	mv	a0,a5
 300c982:	50b2                	lw	ra,44(sp)
 300c984:	5422                	lw	s0,40(sp)
 300c986:	6145                	addi	sp,sp,48
 300c988:	8082                	ret

0300c98a <EulerCarSpeedCtrlRight>:

int EulerCarSpeedCtrlRight(float rightSpeed)
{
 300c98a:	7179                	addi	sp,sp,-48
 300c98c:	d606                	sw	ra,44(sp)
 300c98e:	d422                	sw	s0,40(sp)
 300c990:	1800                	addi	s0,sp,48
 300c992:	fca42e27          	fsw	fa0,-36(s0)
    unsigned int duty = (abs)((int)(rightSpeed/g_motorMaxSpeed * 100));   
 300c996:	85a1a787          	flw	fa5,-1958(gp) # 4000164 <g_motorMaxSpeed>
 300c99a:	fdc42707          	flw	fa4,-36(s0)
 300c99e:	18f77753          	fdiv.s	fa4,fa4,fa5
 300c9a2:	030127b7          	lui	a5,0x3012
 300c9a6:	1c87a787          	flw	fa5,456(a5) # 30121c8 <g_crgIpMatch+0x930>
 300c9aa:	10f777d3          	fmul.s	fa5,fa4,fa5
 300c9ae:	c00797d3          	fcvt.w.s	a5,fa5,rtz
 300c9b2:	853e                	mv	a0,a5
 300c9b4:	2b5040ef          	jal	ra,3011468 <abs>
 300c9b8:	87aa                	mv	a5,a0
 300c9ba:	fef42623          	sw	a5,-20(s0)
    if (duty > 99) {
 300c9be:	fec42703          	lw	a4,-20(s0)
 300c9c2:	06300793          	li	a5,99
 300c9c6:	00e7f663          	bgeu	a5,a4,300c9d2 <EulerCarSpeedCtrlRight+0x48>
        duty = 35;
 300c9ca:	02300793          	li	a5,35
 300c9ce:	fef42623          	sw	a5,-20(s0)
    }
    HAL_APT_SetPWMDutyByNumber(&g_apt0, duty);
 300c9d2:	fec42583          	lw	a1,-20(s0)
 300c9d6:	27e18513          	addi	a0,gp,638 # 4000b88 <g_apt0>
 300c9da:	ca5f50ef          	jal	ra,300267e <HAL_APT_SetPWMDutyByNumber>

    //如果电机小于0.1mm/s，则停止电机转动
    if (fabsf(rightSpeed) < 0.1) {
 300c9de:	fdc42507          	flw	fa0,-36(s0)
 300c9e2:	2c55                	jal	ra,300cc96 <fabsf.trans.24>
 300c9e4:	20a507d3          	fmv.s	fa5,fa0
 300c9e8:	20f78553          	fmv.s	fa0,fa5
 300c9ec:	2c4d                	jal	ra,300cc9e <__extendsfdf2.trans.11>
 300c9ee:	87aa                	mv	a5,a0
 300c9f0:	882e                	mv	a6,a1
 300c9f2:	03012737          	lui	a4,0x3012
 300c9f6:	1c070713          	addi	a4,a4,448 # 30121c0 <g_crgIpMatch+0x928>
 300c9fa:	4310                	lw	a2,0(a4)
 300c9fc:	4354                	lw	a3,4(a4)
 300c9fe:	853e                	mv	a0,a5
 300ca00:	85c2                	mv	a1,a6
 300ca02:	2c41                	jal	ra,300cc92 <__ltdf2.trans.42>
 300ca04:	87aa                	mv	a5,a0
 300ca06:	0007d763          	bgez	a5,300ca14 <EulerCarSpeedCtrlRight+0x8a>
        HAL_APT_StopModule(RUN_APT0);
 300ca0a:	4505                	li	a0,1
 300ca0c:	c43f50ef          	jal	ra,300264e <HAL_APT_StopModule>
        return 0;
 300ca10:	4781                	li	a5,0
 300ca12:	a0a9                	j	300ca5c <EulerCarSpeedCtrlRight+0xd2>
    }
    if (rightSpeed > 0) { 
 300ca14:	fdc42787          	flw	fa5,-36(s0)
 300ca18:	f0000753          	fmv.w.x	fa4,zero
 300ca1c:	a0f717d3          	flt.s	a5,fa4,fa5
 300ca20:	cf91                	beqz	a5,300ca3c <EulerCarSpeedCtrlRight+0xb2>
        User_APTPwmARecovery(g_apt0.baseAddress); 
 300ca22:	27e18793          	addi	a5,gp,638 # 4000b88 <g_apt0>
 300ca26:	439c                	lw	a5,0(a5)
 300ca28:	853e                	mv	a0,a5
 300ca2a:	7c7000ef          	jal	ra,300d9f0 <User_APTPwmARecovery>
        User_APTForcePWMBOutputLow(g_apt0.baseAddress);
 300ca2e:	27e18793          	addi	a5,gp,638 # 4000b88 <g_apt0>
 300ca32:	439c                	lw	a5,0(a5)
 300ca34:	853e                	mv	a0,a5
 300ca36:	785000ef          	jal	ra,300d9ba <User_APTForcePWMBOutputLow>
 300ca3a:	a829                	j	300ca54 <EulerCarSpeedCtrlRight+0xca>
    } else {
        User_APTPwmBRecovery(g_apt0.baseAddress);
 300ca3c:	27e18793          	addi	a5,gp,638 # 4000b88 <g_apt0>
 300ca40:	439c                	lw	a5,0(a5)
 300ca42:	853e                	mv	a0,a5
 300ca44:	7cd000ef          	jal	ra,300da10 <User_APTPwmBRecovery>
        User_APTForcePWMAOutputLow(g_apt0.baseAddress);
 300ca48:	27e18793          	addi	a5,gp,638 # 4000b88 <g_apt0>
 300ca4c:	439c                	lw	a5,0(a5)
 300ca4e:	853e                	mv	a0,a5
 300ca50:	737000ef          	jal	ra,300d986 <User_APTForcePWMAOutputLow>
    }
    HAL_APT_StartModule(RUN_APT0);
 300ca54:	4505                	li	a0,1
 300ca56:	bcdf50ef          	jal	ra,3002622 <HAL_APT_StartModule>
    //DBG_PRINTF("Right wheel set duty:%d, run ok!\r\n",duty);

    return 0;
 300ca5a:	4781                	li	a5,0
}
 300ca5c:	853e                	mv	a0,a5
 300ca5e:	50b2                	lw	ra,44(sp)
 300ca60:	5422                	lw	s0,40(sp)
 300ca62:	6145                	addi	sp,sp,48
 300ca64:	8082                	ret

0300ca66 <Pid_Process>:

void Pid_Process(void)
{
 300ca66:	1101                	addi	sp,sp,-32
 300ca68:	ce06                	sw	ra,28(sp)
 300ca6a:	cc22                	sw	s0,24(sp)
 300ca6c:	1000                	addi	s0,sp,32
    float pidTargetSpeed;
    g_pid_count++;
 300ca6e:	4ba1a783          	lw	a5,1210(gp) # 4000dc4 <g_pid_count>
 300ca72:	00178713          	addi	a4,a5,1
 300ca76:	4ae1ad23          	sw	a4,1210(gp) # 4000dc4 <g_pid_count>

    /* 通过PID算法计算右轮目标速度 */
    pidTargetSpeed = Pid_Ctrl(&g_pidEulerCarRight);
 300ca7a:	4be18513          	addi	a0,gp,1214 # 4000dc8 <g_pidEulerCarRight>
 300ca7e:	03f000ef          	jal	ra,300d2bc <Pid_Ctrl>
 300ca82:	fea42627          	fsw	fa0,-20(s0)
    EulerCarSpeedCtrlRight(pidTargetSpeed);   
 300ca86:	fec42507          	flw	fa0,-20(s0)
 300ca8a:	3701                	jal	ra,300c98a <EulerCarSpeedCtrlRight>
    
    /* 通过PID算法计算左轮目标速度 */
    pidTargetSpeed = Pid_Ctrl(&g_pidEulerCarLeft);
 300ca8c:	4de18513          	addi	a0,gp,1246 # 4000de8 <g_pidEulerCarLeft>
 300ca90:	02d000ef          	jal	ra,300d2bc <Pid_Ctrl>
 300ca94:	fea42627          	fsw	fa0,-20(s0)
    EulerCarSpeedCtrlLeft(pidTargetSpeed); 
 300ca98:	fec42507          	flw	fa0,-20(s0)
 300ca9c:	3d09                	jal	ra,300c8ae <EulerCarSpeedCtrlLeft>
        DBG_PRINTF("N=%d,P=%.02f,I=%.02f,D=%.02f|L-SS:%.1f,AS:%.1f,err:%.1f,nr:%.1f,lr:%.1f,in:%.1f,TS:%.1f,dt:%d\r\n", 
                         g_pid_count,g_KP,g_KI,g_KD,g_pidEulerCarLeft.SetSpeed,
                         g_pidEulerCarLeft.ActualSpeed,g_pidEulerCarLeft.err,g_pidEulerCarLeft.err_next,g_pidEulerCarLeft.err_last,
                                   g_pidEulerCarLeft.IncSpeed,g_pidEulerCarLeft.TargetIncSpeed,g_pidEulerCarLeft.duty);
    } */
}
 300ca9e:	0001                	nop
 300caa0:	40f2                	lw	ra,28(sp)
 300caa2:	4462                	lw	s0,24(sp)
 300caa4:	6105                	addi	sp,sp,32
 300caa6:	8082                	ret

0300caa8 <recv_data_cal>:

void recv_data_cal(void)
{   
 300caa8:	1101                	addi	sp,sp,-32
 300caaa:	01010293          	addi	t0,sp,16
 300caae:	0062928b          	stmia	{ra,s0,s2-s3},(t0)
 300cab2:	1000                	addi	s0,sp,32
    float x_linear,z_angular;
    
    g_ReceiveData.ControlStr.X_speed = Move_X;
 300cab4:	dce1a787          	flw	fa5,-562(gp) # 40006d8 <Move_X>
 300cab8:	d9e18793          	addi	a5,gp,-610 # 40006a8 <g_ReceiveData>
 300cabc:	eb9c                	fsw	fa5,16(a5)
    g_ReceiveData.ControlStr.Y_speed = Move_Y;
 300cabe:	dd21a787          	flw	fa5,-558(gp) # 40006dc <Move_Y>
 300cac2:	d9e18793          	addi	a5,gp,-610 # 40006a8 <g_ReceiveData>
 300cac6:	ebdc                	fsw	fa5,20(a5)
    g_ReceiveData.ControlStr.Z_speed = Move_Z;
 300cac8:	dd61a787          	flw	fa5,-554(gp) # 40006e0 <Move_Z>
 300cacc:	d9e18793          	addi	a5,gp,-610 # 40006a8 <g_ReceiveData>
 300cad0:	ef9c                	fsw	fa5,24(a5)
    x_linear = g_ReceiveData.ControlStr.X_speed; 
 300cad2:	d9e18793          	addi	a5,gp,-610 # 40006a8 <g_ReceiveData>
 300cad6:	6b9c                	flw	fa5,16(a5)
 300cad8:	fef42627          	fsw	fa5,-20(s0)
    z_angular = g_ReceiveData.ControlStr.Z_speed;
 300cadc:	d9e18793          	addi	a5,gp,-610 # 40006a8 <g_ReceiveData>
 300cae0:	6f9c                	flw	fa5,24(a5)
 300cae2:	fef42427          	fsw	fa5,-24(s0)
    //DBG_PRINTF("x_speed:%.02f, Z_speed:%.02f\r\n", g_ReceiveData.ControlStr.X_speed, g_ReceiveData.ControlStr.Z_speed);
    //差分轮运动学模型求解
    modelCalLeftSpeed  = x_linear - z_angular * EULERCAR_WHEEL_TRACK / 2.0 / 1000.0;    //左轮速度，单位mm/s
 300cae6:	fec42507          	flw	fa0,-20(s0)
 300caea:	2a55                	jal	ra,300cc9e <__extendsfdf2.trans.11>
 300caec:	892a                	mv	s2,a0
 300caee:	89ae                	mv	s3,a1
 300caf0:	fe842507          	flw	fa0,-24(s0)
 300caf4:	226d                	jal	ra,300cc9e <__extendsfdf2.trans.11>
 300caf6:	87aa                	mv	a5,a0
 300caf8:	882e                	mv	a6,a1
 300cafa:	03012737          	lui	a4,0x3012
 300cafe:	1d070713          	addi	a4,a4,464 # 30121d0 <g_crgIpMatch+0x938>
 300cb02:	4310                	lw	a2,0(a4)
 300cb04:	4354                	lw	a3,4(a4)
 300cb06:	853e                	mv	a0,a5
 300cb08:	85c2                	mv	a1,a6
 300cb0a:	5d2030ef          	jal	ra,30100dc <__muldf3>
 300cb0e:	87aa                	mv	a5,a0
 300cb10:	882e                	mv	a6,a1
 300cb12:	03012737          	lui	a4,0x3012
 300cb16:	1d870713          	addi	a4,a4,472 # 30121d8 <g_crgIpMatch+0x940>
 300cb1a:	4310                	lw	a2,0(a4)
 300cb1c:	4354                	lw	a3,4(a4)
 300cb1e:	853e                	mv	a0,a5
 300cb20:	85c2                	mv	a1,a6
 300cb22:	2aa5                	jal	ra,300cc9a <__divdf3.trans.23>
 300cb24:	87aa                	mv	a5,a0
 300cb26:	882e                	mv	a6,a1
 300cb28:	03012737          	lui	a4,0x3012
 300cb2c:	1b870713          	addi	a4,a4,440 # 30121b8 <g_crgIpMatch+0x920>
 300cb30:	4310                	lw	a2,0(a4)
 300cb32:	4354                	lw	a3,4(a4)
 300cb34:	853e                	mv	a0,a5
 300cb36:	85c2                	mv	a1,a6
 300cb38:	228d                	jal	ra,300cc9a <__divdf3.trans.23>
 300cb3a:	87aa                	mv	a5,a0
 300cb3c:	882e                	mv	a6,a1
 300cb3e:	863e                	mv	a2,a5
 300cb40:	86c2                	mv	a3,a6
 300cb42:	854a                	mv	a0,s2
 300cb44:	85ce                	mv	a1,s3
 300cb46:	34d030ef          	jal	ra,3010692 <__subdf3>
 300cb4a:	87aa                	mv	a5,a0
 300cb4c:	882e                	mv	a6,a1
 300cb4e:	853e                	mv	a0,a5
 300cb50:	85c2                	mv	a1,a6
 300cb52:	3661                	jal	ra,300c6da <__truncdfsf2.trans.28>
 300cb54:	20a507d3          	fmv.s	fa5,fa0
 300cb58:	dcf1ad27          	fsw	fa5,-550(gp) # 40006e4 <modelCalLeftSpeed>
    modelCalRightSpeed = x_linear + z_angular * EULERCAR_WHEEL_TRACK / 2.0 / 1000.0;    //右轮速度，单位mm/s
 300cb5c:	fec42507          	flw	fa0,-20(s0)
 300cb60:	2a3d                	jal	ra,300cc9e <__extendsfdf2.trans.11>
 300cb62:	892a                	mv	s2,a0
 300cb64:	89ae                	mv	s3,a1
 300cb66:	fe842507          	flw	fa0,-24(s0)
 300cb6a:	2a15                	jal	ra,300cc9e <__extendsfdf2.trans.11>
 300cb6c:	87aa                	mv	a5,a0
 300cb6e:	882e                	mv	a6,a1
 300cb70:	03012737          	lui	a4,0x3012
 300cb74:	1d070713          	addi	a4,a4,464 # 30121d0 <g_crgIpMatch+0x938>
 300cb78:	4310                	lw	a2,0(a4)
 300cb7a:	4354                	lw	a3,4(a4)
 300cb7c:	853e                	mv	a0,a5
 300cb7e:	85c2                	mv	a1,a6
 300cb80:	55c030ef          	jal	ra,30100dc <__muldf3>
 300cb84:	87aa                	mv	a5,a0
 300cb86:	882e                	mv	a6,a1
 300cb88:	03012737          	lui	a4,0x3012
 300cb8c:	1d870713          	addi	a4,a4,472 # 30121d8 <g_crgIpMatch+0x940>
 300cb90:	4310                	lw	a2,0(a4)
 300cb92:	4354                	lw	a3,4(a4)
 300cb94:	853e                	mv	a0,a5
 300cb96:	85c2                	mv	a1,a6
 300cb98:	2209                	jal	ra,300cc9a <__divdf3.trans.23>
 300cb9a:	87aa                	mv	a5,a0
 300cb9c:	882e                	mv	a6,a1
 300cb9e:	03012737          	lui	a4,0x3012
 300cba2:	1b870713          	addi	a4,a4,440 # 30121b8 <g_crgIpMatch+0x920>
 300cba6:	4310                	lw	a2,0(a4)
 300cba8:	4354                	lw	a3,4(a4)
 300cbaa:	853e                	mv	a0,a5
 300cbac:	85c2                	mv	a1,a6
 300cbae:	20f5                	jal	ra,300cc9a <__divdf3.trans.23>
 300cbb0:	87aa                	mv	a5,a0
 300cbb2:	882e                	mv	a6,a1
 300cbb4:	863e                	mv	a2,a5
 300cbb6:	86c2                	mv	a3,a6
 300cbb8:	854a                	mv	a0,s2
 300cbba:	85ce                	mv	a1,s3
 300cbbc:	4d8020ef          	jal	ra,300f094 <__adddf3>
 300cbc0:	87aa                	mv	a5,a0
 300cbc2:	882e                	mv	a6,a1
 300cbc4:	853e                	mv	a0,a5
 300cbc6:	85c2                	mv	a1,a6
 300cbc8:	3e09                	jal	ra,300c6da <__truncdfsf2.trans.28>
 300cbca:	20a507d3          	fmv.s	fa5,fa0
 300cbce:	dcf1af27          	fsw	fa5,-546(gp) # 40006e8 <modelCalRightSpeed>
    DBG_PRINTF("modelCalLeftSpeed:%.2fmm/s, modelCalRightSpeed:%.2fmm/s\r\n", modelCalLeftSpeed, modelCalRightSpeed);
 300cbd2:	dda1a787          	flw	fa5,-550(gp) # 40006e4 <modelCalLeftSpeed>
 300cbd6:	20f78553          	fmv.s	fa0,fa5
 300cbda:	20d1                	jal	ra,300cc9e <__extendsfdf2.trans.11>
 300cbdc:	892a                	mv	s2,a0
 300cbde:	89ae                	mv	s3,a1
 300cbe0:	dde1a787          	flw	fa5,-546(gp) # 40006e8 <modelCalRightSpeed>
 300cbe4:	20f78553          	fmv.s	fa0,fa5
 300cbe8:	285d                	jal	ra,300cc9e <__extendsfdf2.trans.11>
 300cbea:	87aa                	mv	a5,a0
 300cbec:	882e                	mv	a6,a1
 300cbee:	873e                	mv	a4,a5
 300cbf0:	87c2                	mv	a5,a6
 300cbf2:	864a                	mv	a2,s2
 300cbf4:	86ce                	mv	a3,s3
 300cbf6:	030125b7          	lui	a1,0x3012
 300cbfa:	fe058513          	addi	a0,a1,-32 # 3011fe0 <g_crgIpMatch+0x748>
 300cbfe:	2979                	jal	ra,300d09c <DBG_UartPrintf.trans.13>
   
    //将上位机设置轮速存到PID控制结构体
    g_pidEulerCarLeft.SetSpeed = modelCalLeftSpeed;
 300cc00:	dda1a787          	flw	fa5,-550(gp) # 40006e4 <modelCalLeftSpeed>
 300cc04:	4de18793          	addi	a5,gp,1246 # 4000de8 <g_pidEulerCarLeft>
 300cc08:	e39c                	fsw	fa5,0(a5)
    g_pidEulerCarRight.SetSpeed = modelCalRightSpeed;
 300cc0a:	dde1a787          	flw	fa5,-546(gp) # 40006e8 <modelCalRightSpeed>
 300cc0e:	4be18793          	addi	a5,gp,1214 # 4000dc8 <g_pidEulerCarRight>
 300cc12:	e39c                	fsw	fa5,0(a5)

    //如果上位机下发速度小于0.1mm/s，小车停止运动
    if((fabsf(modelCalLeftSpeed) < 0.1) && (fabsf(modelCalRightSpeed) < 0.1))
 300cc14:	dda1a787          	flw	fa5,-550(gp) # 40006e4 <modelCalLeftSpeed>
 300cc18:	20f78553          	fmv.s	fa0,fa5
 300cc1c:	28ad                	jal	ra,300cc96 <fabsf.trans.24>
 300cc1e:	20a507d3          	fmv.s	fa5,fa0
 300cc22:	20f78553          	fmv.s	fa0,fa5
 300cc26:	28a5                	jal	ra,300cc9e <__extendsfdf2.trans.11>
 300cc28:	87aa                	mv	a5,a0
 300cc2a:	882e                	mv	a6,a1
 300cc2c:	03012737          	lui	a4,0x3012
 300cc30:	1c070713          	addi	a4,a4,448 # 30121c0 <g_crgIpMatch+0x928>
 300cc34:	4310                	lw	a2,0(a4)
 300cc36:	4354                	lw	a3,4(a4)
 300cc38:	853e                	mv	a0,a5
 300cc3a:	85c2                	mv	a1,a6
 300cc3c:	2899                	jal	ra,300cc92 <__ltdf2.trans.42>
 300cc3e:	87aa                	mv	a5,a0
 300cc40:	0007c363          	bltz	a5,300cc46 <recv_data_cal+0x19e>
    {
        EulerCarSpeedCtrlRight(0);
        EulerCarSpeedCtrlLeft(0);
        //DBG_PRINTF("EulerCar stoped!!!\r\n");
    }
}
 300cc44:	a081                	j	300cc84 <recv_data_cal+0x1dc>
    if((fabsf(modelCalLeftSpeed) < 0.1) && (fabsf(modelCalRightSpeed) < 0.1))
 300cc46:	dde1a787          	flw	fa5,-546(gp) # 40006e8 <modelCalRightSpeed>
 300cc4a:	20f78553          	fmv.s	fa0,fa5
 300cc4e:	20a1                	jal	ra,300cc96 <fabsf.trans.24>
 300cc50:	20a507d3          	fmv.s	fa5,fa0
 300cc54:	20f78553          	fmv.s	fa0,fa5
 300cc58:	2099                	jal	ra,300cc9e <__extendsfdf2.trans.11>
 300cc5a:	87aa                	mv	a5,a0
 300cc5c:	882e                	mv	a6,a1
 300cc5e:	03012737          	lui	a4,0x3012
 300cc62:	1c070713          	addi	a4,a4,448 # 30121c0 <g_crgIpMatch+0x928>
 300cc66:	4310                	lw	a2,0(a4)
 300cc68:	4354                	lw	a3,4(a4)
 300cc6a:	853e                	mv	a0,a5
 300cc6c:	85c2                	mv	a1,a6
 300cc6e:	2015                	jal	ra,300cc92 <__ltdf2.trans.42>
 300cc70:	87aa                	mv	a5,a0
 300cc72:	0007c363          	bltz	a5,300cc78 <recv_data_cal+0x1d0>
}
 300cc76:	a039                	j	300cc84 <recv_data_cal+0x1dc>
        EulerCarSpeedCtrlRight(0);
 300cc78:	f0000553          	fmv.w.x	fa0,zero
 300cc7c:	3339                	jal	ra,300c98a <EulerCarSpeedCtrlRight>
        EulerCarSpeedCtrlLeft(0);
 300cc7e:	f0000553          	fmv.w.x	fa0,zero
 300cc82:	3135                	jal	ra,300c8ae <EulerCarSpeedCtrlLeft>
}
 300cc84:	0001                	nop
 300cc86:	01010293          	addi	t0,sp,16
 300cc8a:	0062828b          	ldmia	{ra,s0,s2-s3},(t0)
 300cc8e:	6105                	addi	sp,sp,32
 300cc90:	8082                	ret

0300cc92 <__ltdf2.trans.42>:
 300cc92:	3960306f          	j	3010028 <__ledf2>

0300cc96 <fabsf.trans.24>:
 300cc96:	6ae0406f          	j	3011344 <fabsf>

0300cc9a <__divdf3.trans.23>:
 300cc9a:	43d0206f          	j	300f8d6 <__divdf3>

0300cc9e <__extendsfdf2.trans.11>:
 300cc9e:	36a0406f          	j	3011008 <__extendsfdf2>

0300cca2 <UART3_INTRxSimultaneously>:

void UART3_INTRxSimultaneously(void)
{
 300cca2:	715d                	addi	sp,sp,-80
 300cca4:	03010293          	addi	t0,sp,48
 300cca8:	03e2968b          	stmia	{ra,s0-s6},(t0)
 300ccac:	0880                	addi	s0,sp,80
    float tmp_X,tmp_Y,tmp_Z; 
    unsigned char k,Usart_Receive,check_sum;

    while (1) {
        if (g_RxInterruptflag) {
 300ccae:	040007b7          	lui	a5,0x4000
 300ccb2:	1127c783          	lbu	a5,274(a5) # 4000112 <g_RxInterruptflag>
 300ccb6:	9f81                	uxtb	a5
 300ccb8:	24078e63          	beqz	a5,300cf14 <UART3_INTRxSimultaneously+0x272>
            g_RxInterruptflag = false;
 300ccbc:	040007b7          	lui	a5,0x4000
 300ccc0:	10078923          	sb	zero,274(a5) # 4000112 <g_RxInterruptflag>
            HAL_UART_ReadIT(&g_uart3, &Usart_Receive, 1); // 读取数据
 300ccc4:	fcf40793          	addi	a5,s0,-49
 300ccc8:	4605                	li	a2,1
 300ccca:	85be                	mv	a1,a5
 300cccc:	12e18513          	addi	a0,gp,302 # 4000a38 <g_uart3>
 300ccd0:	875fe0ef          	jal	ra,300b544 <HAL_UART_ReadIT>
            g_ReceiveData.buffer[g_ReceiveDataCount] = Usart_Receive;
 300ccd4:	dbe1c783          	lbu	a5,-578(gp) # 40006c8 <g_ReceiveDataCount>
 300ccd8:	86be                	mv	a3,a5
 300ccda:	fcf44703          	lbu	a4,-49(s0)
 300ccde:	d9e18793          	addi	a5,gp,-610 # 40006a8 <g_ReceiveData>
 300cce2:	97b6                	add	a5,a5,a3
 300cce4:	a398                	sb	a4,0(a5)
            //确保数组第一个数据为FRAME_HEADER
            if (Usart_Receive == FRAME_HEADER || g_ReceiveDataCount > 0) {
 300cce6:	fcf44703          	lbu	a4,-49(s0)
 300ccea:	07b00793          	li	a5,123
 300ccee:	00f70563          	beq	a4,a5,300ccf8 <UART3_INTRxSimultaneously+0x56>
 300ccf2:	dbe1c783          	lbu	a5,-578(gp) # 40006c8 <g_ReceiveDataCount>
 300ccf6:	cb89                	beqz	a5,300cd08 <UART3_INTRxSimultaneously+0x66>
                g_ReceiveDataCount++;
 300ccf8:	dbe1c783          	lbu	a5,-578(gp) # 40006c8 <g_ReceiveDataCount>
 300ccfc:	0785                	addi	a5,a5,1
 300ccfe:	0ff7f713          	andi	a4,a5,255
 300cd02:	dae18f23          	sb	a4,-578(gp) # 40006c8 <g_ReceiveDataCount>
 300cd06:	a019                	j	300cd0c <UART3_INTRxSimultaneously+0x6a>
            }
            else {
                g_ReceiveDataCount = 0;
 300cd08:	da018f23          	sb	zero,-578(gp) # 40006c8 <g_ReceiveDataCount>
            }
            // 验证数据包的长度
            if (g_ReceiveDataCount == RECEIVE_DATA_SIZE) {
 300cd0c:	dbe1c703          	lbu	a4,-578(gp) # 40006c8 <g_ReceiveDataCount>
 300cd10:	47ad                	li	a5,11
 300cd12:	20f71163          	bne	a4,a5,300cf14 <UART3_INTRxSimultaneously+0x272>
                g_ReceiveDataCount = 0; //为串口数据重新填入数组做准备
 300cd16:	da018f23          	sb	zero,-578(gp) # 40006c8 <g_ReceiveDataCount>
                //验证数据包的帧尾
                if (g_ReceiveData.buffer[10] == FRAME_TAIL) {
 300cd1a:	d9e18793          	addi	a5,gp,-610 # 40006a8 <g_ReceiveData>
 300cd1e:	27b8                	lbu	a4,10(a5)
 300cd20:	07d00793          	li	a5,125
 300cd24:	1ef71863          	bne	a4,a5,300cf14 <UART3_INTRxSimultaneously+0x272>
                    check_sum = 0;
 300cd28:	fc040f23          	sb	zero,-34(s0)
                    for (k = 0; k < 9; k++) {
 300cd2c:	fc040fa3          	sb	zero,-33(s0)
 300cd30:	a00d                	j	300cd52 <UART3_INTRxSimultaneously+0xb0>
                        check_sum = check_sum ^ g_ReceiveData.buffer[k];
 300cd32:	fdf44783          	lbu	a5,-33(s0)
 300cd36:	d9e18713          	addi	a4,gp,-610 # 40006a8 <g_ReceiveData>
 300cd3a:	97ba                	add	a5,a5,a4
 300cd3c:	2398                	lbu	a4,0(a5)
 300cd3e:	fde44783          	lbu	a5,-34(s0)
 300cd42:	8fb9                	xor	a5,a5,a4
 300cd44:	fcf40f23          	sb	a5,-34(s0)
                    for (k = 0; k < 9; k++) {
 300cd48:	fdf44783          	lbu	a5,-33(s0)
 300cd4c:	0785                	addi	a5,a5,1
 300cd4e:	fcf40fa3          	sb	a5,-33(s0)
 300cd52:	fdf44703          	lbu	a4,-33(s0)
 300cd56:	47a1                	li	a5,8
 300cd58:	fce7fde3          	bgeu	a5,a4,300cd32 <UART3_INTRxSimultaneously+0x90>
                    }
                    //数据异或位校验计算，模式0是发送数据校验
                    if (g_ReceiveData.buffer[9] == check_sum) {  
 300cd5c:	d9e18793          	addi	a5,gp,-610 # 40006a8 <g_ReceiveData>
 300cd60:	379c                	lbu	a5,9(a5)
 300cd62:	fde44703          	lbu	a4,-34(s0)
 300cd66:	1af71763          	bne	a4,a5,300cf14 <UART3_INTRxSimultaneously+0x272>
                        g_RecvCount++;
 300cd6a:	dca1a783          	lw	a5,-566(gp) # 40006d4 <g_RecvCount>
 300cd6e:	00178713          	addi	a4,a5,1
 300cd72:	dce1a523          	sw	a4,-566(gp) # 40006d4 <g_RecvCount>
                        //从串口数据求三轴目标速度， 单位mm/s
                        tmp_X = XYZ_transition(g_ReceiveData.buffer[3], g_ReceiveData.buffer[4]);
 300cd76:	d9e18793          	addi	a5,gp,-610 # 40006a8 <g_ReceiveData>
 300cd7a:	33b8                	lbu	a4,3(a5)
 300cd7c:	d9e18793          	addi	a5,gp,-610 # 40006a8 <g_ReceiveData>
 300cd80:	23dc                	lbu	a5,4(a5)
 300cd82:	85be                	mv	a1,a5
 300cd84:	853a                	mv	a0,a4
 300cd86:	34dd                	jal	ra,300c86c <XYZ_transition>
 300cd88:	fca42c27          	fsw	fa0,-40(s0)
                        tmp_Y = XYZ_transition(g_ReceiveData.buffer[5], g_ReceiveData.buffer[6]);
 300cd8c:	d9e18793          	addi	a5,gp,-610 # 40006a8 <g_ReceiveData>
 300cd90:	33d8                	lbu	a4,5(a5)
 300cd92:	d9e18793          	addi	a5,gp,-610 # 40006a8 <g_ReceiveData>
 300cd96:	23fc                	lbu	a5,6(a5)
 300cd98:	85be                	mv	a1,a5
 300cd9a:	853a                	mv	a0,a4
 300cd9c:	3cc1                	jal	ra,300c86c <XYZ_transition>
 300cd9e:	fca42a27          	fsw	fa0,-44(s0)
                        tmp_Z = XYZ_transition(g_ReceiveData.buffer[7], g_ReceiveData.buffer[8]);
 300cda2:	d9e18793          	addi	a5,gp,-610 # 40006a8 <g_ReceiveData>
 300cda6:	33f8                	lbu	a4,7(a5)
 300cda8:	d9e18793          	addi	a5,gp,-610 # 40006a8 <g_ReceiveData>
 300cdac:	279c                	lbu	a5,8(a5)
 300cdae:	85be                	mv	a1,a5
 300cdb0:	853a                	mv	a0,a4
 300cdb2:	3c6d                	jal	ra,300c86c <XYZ_transition>
 300cdb4:	fca42827          	fsw	fa0,-48(s0)
                        //合法性检查，设置速度必须小于当前电机支持的最高速度
                        if( (fabsf(tmp_X) < g_motorMaxSpeed) && (fabsf(tmp_Y) < g_motorMaxSpeed) && (fabsf(tmp_Z) < MOTOR_MAX_ANGULAR_SPEED) ) {  
 300cdb8:	fd842507          	flw	fa0,-40(s0)
 300cdbc:	3de9                	jal	ra,300cc96 <fabsf.trans.24>
 300cdbe:	20a50753          	fmv.s	fa4,fa0
 300cdc2:	85a1a787          	flw	fa5,-1958(gp) # 4000164 <g_motorMaxSpeed>
 300cdc6:	a0f717d3          	flt.s	a5,fa4,fa5
 300cdca:	cbd9                	beqz	a5,300ce60 <UART3_INTRxSimultaneously+0x1be>
 300cdcc:	fd442507          	flw	fa0,-44(s0)
 300cdd0:	35d9                	jal	ra,300cc96 <fabsf.trans.24>
 300cdd2:	20a50753          	fmv.s	fa4,fa0
 300cdd6:	85a1a787          	flw	fa5,-1958(gp) # 4000164 <g_motorMaxSpeed>
 300cdda:	a0f717d3          	flt.s	a5,fa4,fa5
 300cdde:	c3c9                	beqz	a5,300ce60 <UART3_INTRxSimultaneously+0x1be>
 300cde0:	fd042507          	flw	fa0,-48(s0)
 300cde4:	3d4d                	jal	ra,300cc96 <fabsf.trans.24>
 300cde6:	20a50753          	fmv.s	fa4,fa0
 300cdea:	030127b7          	lui	a5,0x3012
 300cdee:	1e07a787          	flw	fa5,480(a5) # 30121e0 <g_crgIpMatch+0x948>
 300cdf2:	a0f717d3          	flt.s	a5,fa4,fa5
 300cdf6:	c7ad                	beqz	a5,300ce60 <UART3_INTRxSimultaneously+0x1be>
                            Move_X = tmp_X;
 300cdf8:	fd842787          	flw	fa5,-40(s0)
 300cdfc:	dcf1a727          	fsw	fa5,-562(gp) # 40006d8 <Move_X>
                            Move_Y = tmp_Y;
 300ce00:	fd442787          	flw	fa5,-44(s0)
 300ce04:	dcf1a927          	fsw	fa5,-558(gp) # 40006dc <Move_Y>
                            Move_Z = tmp_Z;
 300ce08:	fd042787          	flw	fa5,-48(s0)
 300ce0c:	dcf1ab27          	fsw	fa5,-554(gp) # 40006e0 <Move_Z>
                            DBG_PRINTF("\r\ng_TimerCount=%d,g_RecvCount=%d,Move_X=%.2fmm/s,Move_Y=%.2fmm/s,Move_Z=%.2fmrad/s\r\n",
 300ce10:	dc21a483          	lw	s1,-574(gp) # 40006cc <g_TimerInterruptCount>
 300ce14:	dca1ab03          	lw	s6,-566(gp) # 40006d4 <g_RecvCount>
 300ce18:	dce1a787          	flw	fa5,-562(gp) # 40006d8 <Move_X>
 300ce1c:	20f78553          	fmv.s	fa0,fa5
 300ce20:	3dbd                	jal	ra,300cc9e <__extendsfdf2.trans.11>
 300ce22:	892a                	mv	s2,a0
 300ce24:	89ae                	mv	s3,a1
 300ce26:	dd21a787          	flw	fa5,-558(gp) # 40006dc <Move_Y>
 300ce2a:	20f78553          	fmv.s	fa0,fa5
 300ce2e:	3d85                	jal	ra,300cc9e <__extendsfdf2.trans.11>
 300ce30:	8a2a                	mv	s4,a0
 300ce32:	8aae                	mv	s5,a1
 300ce34:	dd61a787          	flw	fa5,-554(gp) # 40006e0 <Move_Z>
 300ce38:	20f78553          	fmv.s	fa0,fa5
 300ce3c:	358d                	jal	ra,300cc9e <__extendsfdf2.trans.11>
 300ce3e:	87aa                	mv	a5,a0
 300ce40:	882e                	mv	a6,a1
 300ce42:	c03e                	sw	a5,0(sp)
 300ce44:	c242                	sw	a6,4(sp)
 300ce46:	8852                	mv	a6,s4
 300ce48:	88d6                	mv	a7,s5
 300ce4a:	874a                	mv	a4,s2
 300ce4c:	87ce                	mv	a5,s3
 300ce4e:	865a                	mv	a2,s6
 300ce50:	85a6                	mv	a1,s1
 300ce52:	030126b7          	lui	a3,0x3012
 300ce56:	01c68513          	addi	a0,a3,28 # 301201c <g_crgIpMatch+0x784>
 300ce5a:	2489                	jal	ra,300d09c <DBG_UartPrintf.trans.13>
                                                                              g_TimerInterruptCount,g_RecvCount, Move_X, Move_Y, Move_Z);
                            recv_data_cal();
 300ce5c:	31b1                	jal	ra,300caa8 <recv_data_cal>
 300ce5e:	a85d                	j	300cf14 <UART3_INTRxSimultaneously+0x272>
						}
                        else{
                            DBG_PRINTF("\r\ng_TimerCount=%d,g_RecvCount=%d",g_TimerInterruptCount,g_RecvCount);
 300ce60:	dc21a703          	lw	a4,-574(gp) # 40006cc <g_TimerInterruptCount>
 300ce64:	dca1a783          	lw	a5,-566(gp) # 40006d4 <g_RecvCount>
 300ce68:	863e                	mv	a2,a5
 300ce6a:	85ba                	mv	a1,a4
 300ce6c:	030127b7          	lui	a5,0x3012
 300ce70:	07478513          	addi	a0,a5,116 # 3012074 <g_crgIpMatch+0x7dc>
 300ce74:	2425                	jal	ra,300d09c <DBG_UartPrintf.trans.13>
                            if((fabsf(tmp_X) > g_motorMaxSpeed) || (fabsf(tmp_Y) > g_motorMaxSpeed))
 300ce76:	fd842507          	flw	fa0,-40(s0)
 300ce7a:	3d31                	jal	ra,300cc96 <fabsf.trans.24>
 300ce7c:	20a50753          	fmv.s	fa4,fa0
 300ce80:	85a1a787          	flw	fa5,-1958(gp) # 4000164 <g_motorMaxSpeed>
 300ce84:	a0e797d3          	flt.s	a5,fa5,fa4
 300ce88:	eb99                	bnez	a5,300ce9e <UART3_INTRxSimultaneously+0x1fc>
 300ce8a:	fd442507          	flw	fa0,-44(s0)
 300ce8e:	3521                	jal	ra,300cc96 <fabsf.trans.24>
 300ce90:	20a50753          	fmv.s	fa4,fa0
 300ce94:	85a1a787          	flw	fa5,-1958(gp) # 4000164 <g_motorMaxSpeed>
 300ce98:	a0e797d3          	flt.s	a5,fa5,fa4
 300ce9c:	cf8d                	beqz	a5,300ced6 <UART3_INTRxSimultaneously+0x234>
                                DBG_PRINTF("\r\nLinear speed set error: X=%.2fmm/s Y=%.2fmm/s, must less %.2fmm/s\r\n", tmp_X, tmp_Y,g_motorMaxSpeed);
 300ce9e:	fd842507          	flw	fa0,-40(s0)
 300cea2:	3bf5                	jal	ra,300cc9e <__extendsfdf2.trans.11>
 300cea4:	892a                	mv	s2,a0
 300cea6:	89ae                	mv	s3,a1
 300cea8:	fd442507          	flw	fa0,-44(s0)
 300ceac:	3bcd                	jal	ra,300cc9e <__extendsfdf2.trans.11>
 300ceae:	8a2a                	mv	s4,a0
 300ceb0:	8aae                	mv	s5,a1
 300ceb2:	85a1a787          	flw	fa5,-1958(gp) # 4000164 <g_motorMaxSpeed>
 300ceb6:	20f78553          	fmv.s	fa0,fa5
 300ceba:	33d5                	jal	ra,300cc9e <__extendsfdf2.trans.11>
 300cebc:	87aa                	mv	a5,a0
 300cebe:	882e                	mv	a6,a1
 300cec0:	88c2                	mv	a7,a6
 300cec2:	883e                	mv	a6,a5
 300cec4:	8752                	mv	a4,s4
 300cec6:	87d6                	mv	a5,s5
 300cec8:	864a                	mv	a2,s2
 300ceca:	86ce                	mv	a3,s3
 300cecc:	030125b7          	lui	a1,0x3012
 300ced0:	09858513          	addi	a0,a1,152 # 3012098 <g_crgIpMatch+0x800>
 300ced4:	22e1                	jal	ra,300d09c <DBG_UartPrintf.trans.13>
                            if((fabsf(tmp_Z) > MOTOR_MAX_ANGULAR_SPEED))
 300ced6:	fd042507          	flw	fa0,-48(s0)
 300ceda:	3b75                	jal	ra,300cc96 <fabsf.trans.24>
 300cedc:	20a50753          	fmv.s	fa4,fa0
 300cee0:	030127b7          	lui	a5,0x3012
 300cee4:	1e07a787          	flw	fa5,480(a5) # 30121e0 <g_crgIpMatch+0x948>
 300cee8:	a0e797d3          	flt.s	a5,fa5,fa4
 300ceec:	c785                	beqz	a5,300cf14 <UART3_INTRxSimultaneously+0x272>
                                DBG_PRINTF("\r\nAngular speed set error: Z=%.2fmrad/s, must less %.1fmrad/s\r\n", tmp_Z, MOTOR_MAX_ANGULAR_SPEED);
 300ceee:	fd042507          	flw	fa0,-48(s0)
 300cef2:	3375                	jal	ra,300cc9e <__extendsfdf2.trans.11>
 300cef4:	862a                	mv	a2,a0
 300cef6:	86ae                	mv	a3,a1
 300cef8:	030127b7          	lui	a5,0x3012
 300cefc:	1e878793          	addi	a5,a5,488 # 30121e8 <g_crgIpMatch+0x950>
 300cf00:	0047a803          	lw	a6,4(a5)
 300cf04:	439c                	lw	a5,0(a5)
 300cf06:	873e                	mv	a4,a5
 300cf08:	87c2                	mv	a5,a6
 300cf0a:	030125b7          	lui	a1,0x3012
 300cf0e:	0e058513          	addi	a0,a1,224 # 30120e0 <g_crgIpMatch+0x848>
 300cf12:	2269                	jal	ra,300d09c <DBG_UartPrintf.trans.13>
                    }
                }
            }
        }

        ReceiveMsg(&ServoMsg, RxID);
 300cf14:	28700593          	li	a1,647
 300cf18:	4b818513          	addi	a0,gp,1208 # 4000dc2 <ServoMsg>
 300cf1c:	ef7fe0ef          	jal	ra,300be12 <ReceiveMsg>
        if(isRecv){
 300cf20:	4b61c783          	lbu	a5,1206(gp) # 4000dc0 <isRecv>
 300cf24:	c3c9                	beqz	a5,300cfa6 <UART3_INTRxSimultaneously+0x304>
            DBG_PRINTF("Receieved!\r\n");
 300cf26:	030127b7          	lui	a5,0x3012
 300cf2a:	12078513          	addi	a0,a5,288 # 3012120 <g_crgIpMatch+0x888>
 300cf2e:	22bd                	jal	ra,300d09c <DBG_UartPrintf.trans.13>
            isRecv = false;
 300cf30:	4a018b23          	sb	zero,1206(gp) # 4000dc0 <isRecv>
            HAL_GPIO_SetValue(&g_gpio2, GPIO_PIN_5, GPIO_LOW_LEVEL);
 300cf34:	4601                	li	a2,0
 300cf36:	02000593          	li	a1,32
 300cf3a:	42618513          	addi	a0,gp,1062 # 4000d30 <g_gpio2>
 300cf3e:	24f5                	jal	ra,300d22a <HAL_GPIO_SetValue.trans.34>
            if((ServoMsg & 1) == 0){
 300cf40:	4b81c783          	lbu	a5,1208(gp) # 4000dc2 <ServoMsg>
 300cf44:	8b85                	andi	a5,a5,1
 300cf46:	eb91                	bnez	a5,300cf5a <UART3_INTRxSimultaneously+0x2b8>
                ServoMsg = 0x00;
 300cf48:	4a018c23          	sb	zero,1208(gp) # 4000dc2 <ServoMsg>
                lift(); 
 300cf4c:	2a91                	jal	ra,300d0a0 <lift>
                DBG_PRINTF("Lifting Blocks!\r\n");
 300cf4e:	030127b7          	lui	a5,0x3012
 300cf52:	13078513          	addi	a0,a5,304 # 3012130 <g_crgIpMatch+0x898>
 300cf56:	2299                	jal	ra,300d09c <DBG_UartPrintf.trans.13>
 300cf58:	a831                	j	300cf74 <UART3_INTRxSimultaneously+0x2d2>
            }
            else if((ServoMsg & 1) == 1){
 300cf5a:	4b81c783          	lbu	a5,1208(gp) # 4000dc2 <ServoMsg>
 300cf5e:	8b85                	andi	a5,a5,1
 300cf60:	cb91                	beqz	a5,300cf74 <UART3_INTRxSimultaneously+0x2d2>
                ServoMsg = 1 << 1;
 300cf62:	4709                	li	a4,2
 300cf64:	4ae18c23          	sb	a4,1208(gp) # 4000dc2 <ServoMsg>
                lay();
 300cf68:	2ab9                	jal	ra,300d0c6 <lay>
                DBG_PRINTF("Laying blocks\r\n");
 300cf6a:	030127b7          	lui	a5,0x3012
 300cf6e:	14478513          	addi	a0,a5,324 # 3012144 <g_crgIpMatch+0x8ac>
 300cf72:	222d                	jal	ra,300d09c <DBG_UartPrintf.trans.13>
            }
            ServoMsg = (ServoMsg << 1) | 1;    // 第7位表示动作类型: 0表示举起 1表示放下. 第八位表示动作是否完成: 1表示完成 0表示失败
 300cf74:	4b81c783          	lbu	a5,1208(gp) # 4000dc2 <ServoMsg>
 300cf78:	0786                	slli	a5,a5,0x1
 300cf7a:	07e2                	slli	a5,a5,0x18
 300cf7c:	87e1                	srai	a5,a5,0x18
 300cf7e:	0017e793          	ori	a5,a5,1
 300cf82:	07e2                	slli	a5,a5,0x18
 300cf84:	87e1                	srai	a5,a5,0x18
 300cf86:	0ff7f713          	andi	a4,a5,255
 300cf8a:	4ae18c23          	sb	a4,1208(gp) # 4000dc2 <ServoMsg>
            TransmitMsg(&ServoMsg, TxID);
 300cf8e:	18700593          	li	a1,391
 300cf92:	4b818513          	addi	a0,gp,1208 # 4000dc2 <ServoMsg>
 300cf96:	ecffe0ef          	jal	ra,300be64 <TransmitMsg>
            
            HAL_GPIO_SetValue(&g_gpio2, GPIO_PIN_5, GPIO_HIGH_LEVEL);
 300cf9a:	4605                	li	a2,1
 300cf9c:	02000593          	li	a1,32
 300cfa0:	42618513          	addi	a0,gp,1062 # 4000d30 <g_gpio2>
 300cfa4:	2459                	jal	ra,300d22a <HAL_GPIO_SetValue.trans.34>
        }

        //检测按键是否按下，修改PID参数
        if (g_button1State == 1) {
 300cfa6:	cb61a703          	lw	a4,-842(gp) # 40005c0 <g_button1State>
 300cfaa:	4785                	li	a5,1
 300cfac:	06f71a63          	bne	a4,a5,300d020 <UART3_INTRxSimultaneously+0x37e>
            g_button1State = 0;
 300cfb0:	ca01ab23          	sw	zero,-842(gp) # 40005c0 <g_button1State>
            g_KP = g_KP + g_KP_Step;
 300cfb4:	8661a707          	flw	fa4,-1946(gp) # 4000170 <g_KP>
 300cfb8:	86e1a787          	flw	fa5,-1938(gp) # 4000178 <g_KP_Step>
 300cfbc:	00f777d3          	fadd.s	fa5,fa4,fa5
 300cfc0:	86f1a327          	fsw	fa5,-1946(gp) # 4000170 <g_KP>
            DBG_PRINTF("Button1 Evnet, g_KP + %f\r\n",g_KP_Step);            
 300cfc4:	86e1a787          	flw	fa5,-1938(gp) # 4000178 <g_KP_Step>
 300cfc8:	20f78553          	fmv.s	fa0,fa5
 300cfcc:	39c9                	jal	ra,300cc9e <__extendsfdf2.trans.11>
 300cfce:	87aa                	mv	a5,a0
 300cfd0:	882e                	mv	a6,a1
 300cfd2:	863e                	mv	a2,a5
 300cfd4:	86c2                	mv	a3,a6
 300cfd6:	030127b7          	lui	a5,0x3012
 300cfda:	15478513          	addi	a0,a5,340 # 3012154 <g_crgIpMatch+0x8bc>
 300cfde:	287d                	jal	ra,300d09c <DBG_UartPrintf.trans.13>
            DBG_PRINTF("g_KP=%f g_KI=%f g_KD=%f\r\n", g_KP, g_KI, g_KD);
 300cfe0:	8661a787          	flw	fa5,-1946(gp) # 4000170 <g_KP>
 300cfe4:	20f78553          	fmv.s	fa0,fa5
 300cfe8:	395d                	jal	ra,300cc9e <__extendsfdf2.trans.11>
 300cfea:	892a                	mv	s2,a0
 300cfec:	89ae                	mv	s3,a1
 300cfee:	86a1a787          	flw	fa5,-1942(gp) # 4000174 <g_KI>
 300cff2:	20f78553          	fmv.s	fa0,fa5
 300cff6:	3165                	jal	ra,300cc9e <__extendsfdf2.trans.11>
 300cff8:	8a2a                	mv	s4,a0
 300cffa:	8aae                	mv	s5,a1
 300cffc:	4fe1a787          	flw	fa5,1278(gp) # 4000e08 <g_KD>
 300d000:	20f78553          	fmv.s	fa0,fa5
 300d004:	3969                	jal	ra,300cc9e <__extendsfdf2.trans.11>
 300d006:	87aa                	mv	a5,a0
 300d008:	882e                	mv	a6,a1
 300d00a:	88c2                	mv	a7,a6
 300d00c:	883e                	mv	a6,a5
 300d00e:	8752                	mv	a4,s4
 300d010:	87d6                	mv	a5,s5
 300d012:	864a                	mv	a2,s2
 300d014:	86ce                	mv	a3,s3
 300d016:	030125b7          	lui	a1,0x3012
 300d01a:	17058513          	addi	a0,a1,368 # 3012170 <g_crgIpMatch+0x8d8>
 300d01e:	28bd                	jal	ra,300d09c <DBG_UartPrintf.trans.13>
        }
        
        if (g_button2State == 1) {
 300d020:	cba1a703          	lw	a4,-838(gp) # 40005c4 <g_button2State>
 300d024:	4785                	li	a5,1
 300d026:	c8f714e3          	bne	a4,a5,300ccae <UART3_INTRxSimultaneously+0xc>
            g_button2State = 0;
 300d02a:	ca01ad23          	sw	zero,-838(gp) # 40005c4 <g_button2State>
            g_KI = g_KI + g_KI_Step;           
 300d02e:	86a1a707          	flw	fa4,-1942(gp) # 4000174 <g_KI>
 300d032:	8721a787          	flw	fa5,-1934(gp) # 400017c <g_KI_Step>
 300d036:	00f777d3          	fadd.s	fa5,fa4,fa5
 300d03a:	86f1a527          	fsw	fa5,-1942(gp) # 4000174 <g_KI>
            DBG_PRINTF("Button2 Evnet, g_KI + %f\r\n",g_KI_Step);               
 300d03e:	8721a787          	flw	fa5,-1934(gp) # 400017c <g_KI_Step>
 300d042:	20f78553          	fmv.s	fa0,fa5
 300d046:	39a1                	jal	ra,300cc9e <__extendsfdf2.trans.11>
 300d048:	87aa                	mv	a5,a0
 300d04a:	882e                	mv	a6,a1
 300d04c:	863e                	mv	a2,a5
 300d04e:	86c2                	mv	a3,a6
 300d050:	030127b7          	lui	a5,0x3012
 300d054:	18c78513          	addi	a0,a5,396 # 301218c <g_crgIpMatch+0x8f4>
 300d058:	2091                	jal	ra,300d09c <DBG_UartPrintf.trans.13>
            DBG_PRINTF("g_KP=%f g_KI=%f g_KD=%f\r\n", g_KP, g_KI, g_KD);
 300d05a:	8661a787          	flw	fa5,-1946(gp) # 4000170 <g_KP>
 300d05e:	20f78553          	fmv.s	fa0,fa5
 300d062:	3935                	jal	ra,300cc9e <__extendsfdf2.trans.11>
 300d064:	892a                	mv	s2,a0
 300d066:	89ae                	mv	s3,a1
 300d068:	86a1a787          	flw	fa5,-1942(gp) # 4000174 <g_KI>
 300d06c:	20f78553          	fmv.s	fa0,fa5
 300d070:	313d                	jal	ra,300cc9e <__extendsfdf2.trans.11>
 300d072:	8a2a                	mv	s4,a0
 300d074:	8aae                	mv	s5,a1
 300d076:	4fe1a787          	flw	fa5,1278(gp) # 4000e08 <g_KD>
 300d07a:	20f78553          	fmv.s	fa0,fa5
 300d07e:	3105                	jal	ra,300cc9e <__extendsfdf2.trans.11>
 300d080:	87aa                	mv	a5,a0
 300d082:	882e                	mv	a6,a1
 300d084:	88c2                	mv	a7,a6
 300d086:	883e                	mv	a6,a5
 300d088:	8752                	mv	a4,s4
 300d08a:	87d6                	mv	a5,s5
 300d08c:	864a                	mv	a2,s2
 300d08e:	86ce                	mv	a3,s3
 300d090:	030125b7          	lui	a1,0x3012
 300d094:	17058513          	addi	a0,a1,368 # 3012170 <g_crgIpMatch+0x8d8>
 300d098:	2011                	jal	ra,300d09c <DBG_UartPrintf.trans.13>
    while (1) {
 300d09a:	b911                	j	300ccae <UART3_INTRxSimultaneously+0xc>

0300d09c <DBG_UartPrintf.trans.13>:
 300d09c:	94ff906f          	j	30069ea <DBG_UartPrintf>

0300d0a0 <lift>:
#include "grab.h"


void lift(void){
 300d0a0:	1141                	addi	sp,sp,-16
 300d0a2:	c606                	sw	ra,12(sp)
 300d0a4:	c422                	sw	s0,8(sp)
 300d0a6:	0800                	addi	s0,sp,16
    _close(100, 650);
 300d0a8:	28a00593          	li	a1,650
 300d0ac:	06400513          	li	a0,100
 300d0b0:	29ed                	jal	ra,300d5aa <_close>
    up(50, 650);
 300d0b2:	28a00593          	li	a1,650
 300d0b6:	03200513          	li	a0,50
 300d0ba:	29a9                	jal	ra,300d514 <up>
}
 300d0bc:	0001                	nop
 300d0be:	40b2                	lw	ra,12(sp)
 300d0c0:	4422                	lw	s0,8(sp)
 300d0c2:	0141                	addi	sp,sp,16
 300d0c4:	8082                	ret

0300d0c6 <lay>:


void lay(void){
 300d0c6:	1141                	addi	sp,sp,-16
 300d0c8:	c606                	sw	ra,12(sp)
 300d0ca:	c422                	sw	s0,8(sp)
 300d0cc:	0800                	addi	s0,sp,16
    down(50, 350);
 300d0ce:	15e00593          	li	a1,350
 300d0d2:	03200513          	li	a0,50
 300d0d6:	2985                	jal	ra,300d546 <down>
    open(30, 500);
 300d0d8:	1f400593          	li	a1,500
 300d0dc:	4579                	li	a0,30
 300d0de:	2969                	jal	ra,300d578 <open>
 300d0e0:	0001                	nop
 300d0e2:	40b2                	lw	ra,12(sp)
 300d0e4:	4422                	lw	s0,8(sp)
 300d0e6:	0141                	addi	sp,sp,16
 300d0e8:	8082                	ret

0300d0ea <main>:
bool Action = 1;  // 1 表示放下; 0表示举起
/* 建议用户定义全局变量、结构体、宏定义或函数声明等 */
/* USER CODE END 1 */

int main(void)
{
 300d0ea:	1101                	addi	sp,sp,-32
 300d0ec:	00810293          	addi	t0,sp,8
 300d0f0:	01e2928b          	stmia	{ra,s0,s2-s5},(t0)
 300d0f4:	1000                	addi	s0,sp,32
    SystemInit();
 300d0f6:	747010ef          	jal	ra,300f03c <SystemInit>
    InitGearMotor();
 300d0fa:	df5fe0ef          	jal	ra,300beee <InitGearMotor>
    Pid_Init();
 300d0fe:	2a05                	jal	ra,300d22e <Pid_Init>
    ssd1306_Init();
 300d100:	2529                	jal	ra,300d70a <ssd1306_Init>
    // HAL_GPT_Start(&g_gpt0);
    // HAL_GPT_Start(&g_gpt1);
    
    DBG_PRINTF("==============================================================\r\n");
 300d102:	030127b7          	lui	a5,0x3012
 300d106:	1f078513          	addi	a0,a5,496 # 30121f0 <g_crgIpMatch+0x958>
 300d10a:	3f49                	jal	ra,300d09c <DBG_UartPrintf.trans.13>
    DBG_PRINTF("                • EulerCar Controller 1.0 •                   \r\n");
 300d10c:	030127b7          	lui	a5,0x3012
 300d110:	23478513          	addi	a0,a5,564 # 3012234 <g_crgIpMatch+0x99c>
 300d114:	3761                	jal	ra,300d09c <DBG_UartPrintf.trans.13>
    DBG_PRINTF("                                                              \r\n");
 300d116:	030127b7          	lui	a5,0x3012
 300d11a:	27c78513          	addi	a0,a5,636 # 301227c <g_crgIpMatch+0x9e4>
 300d11e:	3fbd                	jal	ra,300d09c <DBG_UartPrintf.trans.13>
    DBG_PRINTF("  ➤ System Information:                                      \r\n");
 300d120:	030127b7          	lui	a5,0x3012
 300d124:	2c078513          	addi	a0,a5,704 # 30122c0 <g_crgIpMatch+0xa28>
 300d128:	3f95                	jal	ra,300d09c <DBG_UartPrintf.trans.13>
    DBG_PRINTF("      • Motor Type:%s\r\n",g_motorTypeStr[g_curMotorType]);
 300d12a:	85e1a703          	lw	a4,-1954(gp) # 4000168 <g_curMotorType>
 300d12e:	47d1                	li	a5,20
 300d130:	02f70733          	mul	a4,a4,a5
 300d134:	040007b7          	lui	a5,0x4000
 300d138:	11478793          	addi	a5,a5,276 # 4000114 <g_motorTypeStr>
 300d13c:	97ba                	add	a5,a5,a4
 300d13e:	85be                	mv	a1,a5
 300d140:	030127b7          	lui	a5,0x3012
 300d144:	30478513          	addi	a0,a5,772 # 3012304 <g_crgIpMatch+0xa6c>
 300d148:	3f91                	jal	ra,300d09c <DBG_UartPrintf.trans.13>
    DBG_PRINTF("      • Motor Encode Line Number:%05d\r\n",g_motorLineNum);
 300d14a:	8621a783          	lw	a5,-1950(gp) # 400016c <g_motorLineNum>
 300d14e:	85be                	mv	a1,a5
 300d150:	030127b7          	lui	a5,0x3012
 300d154:	32078513          	addi	a0,a5,800 # 3012320 <g_crgIpMatch+0xa88>
 300d158:	3791                	jal	ra,300d09c <DBG_UartPrintf.trans.13>
    DBG_PRINTF("      • Motor Max Speed:%.02fmm/s\r\n", g_motorMaxSpeed);
 300d15a:	85a1a787          	flw	fa5,-1958(gp) # 4000164 <g_motorMaxSpeed>
 300d15e:	20f78553          	fmv.s	fa0,fa5
 300d162:	3e35                	jal	ra,300cc9e <__extendsfdf2.trans.11>
 300d164:	87aa                	mv	a5,a0
 300d166:	882e                	mv	a6,a1
 300d168:	863e                	mv	a2,a5
 300d16a:	86c2                	mv	a3,a6
 300d16c:	030127b7          	lui	a5,0x3012
 300d170:	34c78513          	addi	a0,a5,844 # 301234c <g_crgIpMatch+0xab4>
 300d174:	3725                	jal	ra,300d09c <DBG_UartPrintf.trans.13>
    DBG_PRINTF("      • EulerCar Data Send Period:%dms,%dHZ\r\n", EULER_CAR_DATA_SEND_PERIOD, 1000/EULER_CAR_DATA_SEND_PERIOD);
 300d176:	4629                	li	a2,10
 300d178:	06400593          	li	a1,100
 300d17c:	030127b7          	lui	a5,0x3012
 300d180:	37478513          	addi	a0,a5,884 # 3012374 <g_crgIpMatch+0xadc>
 300d184:	3f21                	jal	ra,300d09c <DBG_UartPrintf.trans.13>
    DBG_PRINTF("                                                              \r\n");                                    
 300d186:	030127b7          	lui	a5,0x3012
 300d18a:	27c78513          	addi	a0,a5,636 # 301227c <g_crgIpMatch+0x9e4>
 300d18e:	3739                	jal	ra,300d09c <DBG_UartPrintf.trans.13>
    DBG_PRINTF("  ➤ PID Information:                                         \r\n");
 300d190:	030127b7          	lui	a5,0x3012
 300d194:	3a478513          	addi	a0,a5,932 # 30123a4 <g_crgIpMatch+0xb0c>
 300d198:	3711                	jal	ra,300d09c <DBG_UartPrintf.trans.13>
    DBG_PRINTF("      • KP:%.02f    • KI:%.02f    • KD:%.02f\r\n",g_KP,g_KI,g_KD);
 300d19a:	8661a787          	flw	fa5,-1946(gp) # 4000170 <g_KP>
 300d19e:	20f78553          	fmv.s	fa0,fa5
 300d1a2:	3cf5                	jal	ra,300cc9e <__extendsfdf2.trans.11>
 300d1a4:	892a                	mv	s2,a0
 300d1a6:	89ae                	mv	s3,a1
 300d1a8:	86a1a787          	flw	fa5,-1942(gp) # 4000174 <g_KI>
 300d1ac:	20f78553          	fmv.s	fa0,fa5
 300d1b0:	34fd                	jal	ra,300cc9e <__extendsfdf2.trans.11>
 300d1b2:	8a2a                	mv	s4,a0
 300d1b4:	8aae                	mv	s5,a1
 300d1b6:	4fe1a787          	flw	fa5,1278(gp) # 4000e08 <g_KD>
 300d1ba:	20f78553          	fmv.s	fa0,fa5
 300d1be:	34c5                	jal	ra,300cc9e <__extendsfdf2.trans.11>
 300d1c0:	87aa                	mv	a5,a0
 300d1c2:	882e                	mv	a6,a1
 300d1c4:	88c2                	mv	a7,a6
 300d1c6:	883e                	mv	a6,a5
 300d1c8:	8752                	mv	a4,s4
 300d1ca:	87d6                	mv	a5,s5
 300d1cc:	864a                	mv	a2,s2
 300d1ce:	86ce                	mv	a3,s3
 300d1d0:	030125b7          	lui	a1,0x3012
 300d1d4:	3e858513          	addi	a0,a1,1000 # 30123e8 <g_crgIpMatch+0xb50>
 300d1d8:	35d1                	jal	ra,300d09c <DBG_UartPrintf.trans.13>
    DBG_PRINTF("      • PID Control Period:%dms\r\n",MOTOR_PID_CONTROL_PERIOD);
 300d1da:	45a9                	li	a1,10
 300d1dc:	030127b7          	lui	a5,0x3012
 300d1e0:	42078513          	addi	a0,a5,1056 # 3012420 <g_crgIpMatch+0xb88>
 300d1e4:	3d65                	jal	ra,300d09c <DBG_UartPrintf.trans.13>
    DBG_PRINTF("==============================================================\r\n");
 300d1e6:	030127b7          	lui	a5,0x3012
 300d1ea:	1f078513          	addi	a0,a5,496 # 30121f0 <g_crgIpMatch+0x958>
 300d1ee:	357d                	jal	ra,300d09c <DBG_UartPrintf.trans.13>
    DBG_PRINTF("EulerCar MCU init success!!!\r\n");
 300d1f0:	030127b7          	lui	a5,0x3012
 300d1f4:	44478513          	addi	a0,a5,1092 # 3012444 <g_crgIpMatch+0xbac>
 300d1f8:	3555                	jal	ra,300d09c <DBG_UartPrintf.trans.13>
    HAL_TIMER_Start(&g_timer0);
 300d1fa:	00618513          	addi	a0,gp,6 # 4000910 <g_timer0>
 300d1fe:	82bfd0ef          	jal	ra,300aa28 <HAL_TIMER_Start>
    DBG_PRINTF("TIMER start\r\n");
 300d202:	030127b7          	lui	a5,0x3012
 300d206:	46478513          	addi	a0,a5,1124 # 3012464 <g_crgIpMatch+0xbcc>
 300d20a:	3d49                	jal	ra,300d09c <DBG_UartPrintf.trans.13>
    // InitButtonFunction();
    // test_can();
    HAL_GPIO_SetValue(&g_gpio2, GPIO_PIN_6, GPIO_LOW_LEVEL);
 300d20c:	4601                	li	a2,0
 300d20e:	04000593          	li	a1,64
 300d212:	42618513          	addi	a0,gp,1062 # 4000d30 <g_gpio2>
 300d216:	2811                	jal	ra,300d22a <HAL_GPIO_SetValue.trans.34>
    UART3_INTRxSimultaneously();
 300d218:	3469                	jal	ra,300cca2 <UART3_INTRxSimultaneously>
    // test_uart();
    /* USER CODE END 5 */
    return BASE_STATUS_OK;
 300d21a:	4781                	li	a5,0
}
 300d21c:	853e                	mv	a0,a5
 300d21e:	00810293          	addi	t0,sp,8
 300d222:	01e2828b          	ldmia	{ra,s0,s2-s5},(t0)
 300d226:	6105                	addi	sp,sp,32
 300d228:	8082                	ret

0300d22a <HAL_GPIO_SetValue.trans.34>:
 300d22a:	894fa06f          	j	30072be <HAL_GPIO_SetValue>

0300d22e <Pid_Init>:
float g_KP_Step  = 0.1;
float g_KI_Step  = 0.1;
float g_KD_Step  = 0;

void Pid_Init(void)
{
 300d22e:	1141                	addi	sp,sp,-16
 300d230:	c622                	sw	s0,12(sp)
 300d232:	0800                	addi	s0,sp,16
    g_pidEulerCarRight.SetSpeed = 0;
 300d234:	4be18793          	addi	a5,gp,1214 # 4000dc8 <g_pidEulerCarRight>
 300d238:	0007a023          	sw	zero,0(a5)
    g_pidEulerCarRight.ActualSpeed = 0;
 300d23c:	4be18793          	addi	a5,gp,1214 # 4000dc8 <g_pidEulerCarRight>
 300d240:	0007a223          	sw	zero,4(a5)
    g_pidEulerCarRight.duty = 0;       
 300d244:	4be18793          	addi	a5,gp,1214 # 4000dc8 <g_pidEulerCarRight>
 300d248:	0007ae23          	sw	zero,28(a5)
    g_pidEulerCarRight.err = 0;
 300d24c:	4be18793          	addi	a5,gp,1214 # 4000dc8 <g_pidEulerCarRight>
 300d250:	0007a423          	sw	zero,8(a5)
    g_pidEulerCarRight.err_next = 0;
 300d254:	4be18793          	addi	a5,gp,1214 # 4000dc8 <g_pidEulerCarRight>
 300d258:	0007a623          	sw	zero,12(a5)
    g_pidEulerCarRight.err_last = 0;
 300d25c:	4be18793          	addi	a5,gp,1214 # 4000dc8 <g_pidEulerCarRight>
 300d260:	0007a823          	sw	zero,16(a5)
    g_pidEulerCarRight.IncSpeed = 0; 
 300d264:	4be18793          	addi	a5,gp,1214 # 4000dc8 <g_pidEulerCarRight>
 300d268:	0007aa23          	sw	zero,20(a5)
    g_pidEulerCarRight.TargetIncSpeed = 0; 
 300d26c:	4be18793          	addi	a5,gp,1214 # 4000dc8 <g_pidEulerCarRight>
 300d270:	0007ac23          	sw	zero,24(a5)
    //DBG_PRINTF("pid right init success\r\n");

    g_pidEulerCarLeft.SetSpeed = 0;
 300d274:	4de18793          	addi	a5,gp,1246 # 4000de8 <g_pidEulerCarLeft>
 300d278:	0007a023          	sw	zero,0(a5)
    g_pidEulerCarLeft.ActualSpeed = 0;
 300d27c:	4de18793          	addi	a5,gp,1246 # 4000de8 <g_pidEulerCarLeft>
 300d280:	0007a223          	sw	zero,4(a5)
    g_pidEulerCarLeft.duty = 0;   
 300d284:	4de18793          	addi	a5,gp,1246 # 4000de8 <g_pidEulerCarLeft>
 300d288:	0007ae23          	sw	zero,28(a5)
    g_pidEulerCarLeft.err = 0;
 300d28c:	4de18793          	addi	a5,gp,1246 # 4000de8 <g_pidEulerCarLeft>
 300d290:	0007a423          	sw	zero,8(a5)
    g_pidEulerCarLeft.err_next = 0;
 300d294:	4de18793          	addi	a5,gp,1246 # 4000de8 <g_pidEulerCarLeft>
 300d298:	0007a623          	sw	zero,12(a5)
    g_pidEulerCarLeft.err_last = 0;
 300d29c:	4de18793          	addi	a5,gp,1246 # 4000de8 <g_pidEulerCarLeft>
 300d2a0:	0007a823          	sw	zero,16(a5)
    g_pidEulerCarLeft.IncSpeed = 0; 
 300d2a4:	4de18793          	addi	a5,gp,1246 # 4000de8 <g_pidEulerCarLeft>
 300d2a8:	0007aa23          	sw	zero,20(a5)
    g_pidEulerCarLeft.TargetIncSpeed = 0; 
 300d2ac:	4de18793          	addi	a5,gp,1246 # 4000de8 <g_pidEulerCarLeft>
 300d2b0:	0007ac23          	sw	zero,24(a5)
    //DBG_PRINTF("pid left init success\r\n");
}
 300d2b4:	0001                	nop
 300d2b6:	4432                	lw	s0,12(sp)
 300d2b8:	0141                	addi	sp,sp,16
 300d2ba:	8082                	ret

0300d2bc <Pid_Ctrl>:


float Pid_Ctrl(PidEulerCar *pMotor)
{
 300d2bc:	7179                	addi	sp,sp,-48
 300d2be:	d606                	sw	ra,44(sp)
 300d2c0:	d422                	sw	s0,40(sp)
 300d2c2:	1800                	addi	s0,sp,48
 300d2c4:	fca42e23          	sw	a0,-36(s0)
    float IncrementSpeed;
    unsigned int duty;
   
    //计算当前误差
    pMotor->err = pMotor->SetSpeed - pMotor->ActualSpeed;
 300d2c8:	fdc42783          	lw	a5,-36(s0)
 300d2cc:	6398                	flw	fa4,0(a5)
 300d2ce:	fdc42783          	lw	a5,-36(s0)
 300d2d2:	63dc                	flw	fa5,4(a5)
 300d2d4:	08f777d3          	fsub.s	fa5,fa4,fa5
 300d2d8:	fdc42783          	lw	a5,-36(s0)
 300d2dc:	e79c                	fsw	fa5,8(a5)
  
    //增量式PID算法计算出增量，越接近目标速度，增量越接近零
    //增量式PID算法参数设定策略，先确定KI，再调KP，最后式KD
    IncrementSpeed =  g_KP * (pMotor->err - pMotor->err_next)
 300d2de:	fdc42783          	lw	a5,-36(s0)
 300d2e2:	6798                	flw	fa4,8(a5)
 300d2e4:	fdc42783          	lw	a5,-36(s0)
 300d2e8:	67dc                	flw	fa5,12(a5)
 300d2ea:	08f77753          	fsub.s	fa4,fa4,fa5
 300d2ee:	8661a787          	flw	fa5,-1946(gp) # 4000170 <g_KP>
 300d2f2:	10f77753          	fmul.s	fa4,fa4,fa5
                    + g_KI * pMotor->err 
 300d2f6:	fdc42783          	lw	a5,-36(s0)
 300d2fa:	6794                	flw	fa3,8(a5)
 300d2fc:	86a1a787          	flw	fa5,-1942(gp) # 4000174 <g_KI>
 300d300:	10f6f7d3          	fmul.s	fa5,fa3,fa5
 300d304:	00f77753          	fadd.s	fa4,fa4,fa5
                    + g_KD * (pMotor->err - 2 * pMotor->err_next + pMotor->err_last);
 300d308:	fdc42783          	lw	a5,-36(s0)
 300d30c:	6794                	flw	fa3,8(a5)
 300d30e:	fdc42783          	lw	a5,-36(s0)
 300d312:	67dc                	flw	fa5,12(a5)
 300d314:	00f7f7d3          	fadd.s	fa5,fa5,fa5
 300d318:	08f6f6d3          	fsub.s	fa3,fa3,fa5
 300d31c:	fdc42783          	lw	a5,-36(s0)
 300d320:	6b9c                	flw	fa5,16(a5)
 300d322:	00f6f6d3          	fadd.s	fa3,fa3,fa5
 300d326:	4fe1a787          	flw	fa5,1278(gp) # 4000e08 <g_KD>
 300d32a:	10f6f7d3          	fmul.s	fa5,fa3,fa5
    IncrementSpeed =  g_KP * (pMotor->err - pMotor->err_next)
 300d32e:	00f777d3          	fadd.s	fa5,fa4,fa5
 300d332:	fef42427          	fsw	fa5,-24(s0)

    pMotor->TargetIncSpeed =  pMotor->TargetIncSpeed + IncrementSpeed;
 300d336:	fdc42783          	lw	a5,-36(s0)
 300d33a:	6f98                	flw	fa4,24(a5)
 300d33c:	fe842787          	flw	fa5,-24(s0)
 300d340:	00f777d3          	fadd.s	fa5,fa4,fa5
 300d344:	fdc42783          	lw	a5,-36(s0)
 300d348:	ef9c                	fsw	fa5,24(a5)
    pMotor->IncSpeed = IncrementSpeed;
 300d34a:	fdc42783          	lw	a5,-36(s0)
 300d34e:	fe842787          	flw	fa5,-24(s0)
 300d352:	ebdc                	fsw	fa5,20(a5)

    //限制幅度
    if(pMotor->SetSpeed > 0){
 300d354:	fdc42783          	lw	a5,-36(s0)
 300d358:	639c                	flw	fa5,0(a5)
 300d35a:	f0000753          	fmv.w.x	fa4,zero
 300d35e:	a0f717d3          	flt.s	a5,fa4,fa5
 300d362:	cb95                	beqz	a5,300d396 <Pid_Ctrl+0xda>
        if (pMotor->TargetIncSpeed > g_motorMaxSpeed){
 300d364:	fdc42783          	lw	a5,-36(s0)
 300d368:	6f98                	flw	fa4,24(a5)
 300d36a:	85a1a787          	flw	fa5,-1958(gp) # 4000164 <g_motorMaxSpeed>
 300d36e:	a0e797d3          	flt.s	a5,fa5,fa4
 300d372:	c791                	beqz	a5,300d37e <Pid_Ctrl+0xc2>
            pMotor->TargetIncSpeed = g_motorMaxSpeed;
 300d374:	85a1a787          	flw	fa5,-1958(gp) # 4000164 <g_motorMaxSpeed>
 300d378:	fdc42783          	lw	a5,-36(s0)
 300d37c:	ef9c                	fsw	fa5,24(a5)
        }
        if (pMotor->TargetIncSpeed < 0){
 300d37e:	fdc42783          	lw	a5,-36(s0)
 300d382:	6f9c                	flw	fa5,24(a5)
 300d384:	f0000753          	fmv.w.x	fa4,zero
 300d388:	a0e797d3          	flt.s	a5,fa5,fa4
 300d38c:	c789                	beqz	a5,300d396 <Pid_Ctrl+0xda>
            pMotor->TargetIncSpeed = 0;
 300d38e:	fdc42783          	lw	a5,-36(s0)
 300d392:	0007ac23          	sw	zero,24(a5)
        }
    }

    if(pMotor->SetSpeed < 0){
 300d396:	fdc42783          	lw	a5,-36(s0)
 300d39a:	639c                	flw	fa5,0(a5)
 300d39c:	f0000753          	fmv.w.x	fa4,zero
 300d3a0:	a0e797d3          	flt.s	a5,fa5,fa4
 300d3a4:	cf95                	beqz	a5,300d3e0 <Pid_Ctrl+0x124>
        if (pMotor->TargetIncSpeed < -g_motorMaxSpeed){
 300d3a6:	fdc42783          	lw	a5,-36(s0)
 300d3aa:	6f98                	flw	fa4,24(a5)
 300d3ac:	85a1a787          	flw	fa5,-1958(gp) # 4000164 <g_motorMaxSpeed>
 300d3b0:	20f797d3          	fneg.s	fa5,fa5
 300d3b4:	a0f717d3          	flt.s	a5,fa4,fa5
 300d3b8:	cb81                	beqz	a5,300d3c8 <Pid_Ctrl+0x10c>
            pMotor->TargetIncSpeed = -g_motorMaxSpeed;
 300d3ba:	85a1a787          	flw	fa5,-1958(gp) # 4000164 <g_motorMaxSpeed>
 300d3be:	20f797d3          	fneg.s	fa5,fa5
 300d3c2:	fdc42783          	lw	a5,-36(s0)
 300d3c6:	ef9c                	fsw	fa5,24(a5)
        }
        if (pMotor->TargetIncSpeed > 0){
 300d3c8:	fdc42783          	lw	a5,-36(s0)
 300d3cc:	6f9c                	flw	fa5,24(a5)
 300d3ce:	f0000753          	fmv.w.x	fa4,zero
 300d3d2:	a0f717d3          	flt.s	a5,fa4,fa5
 300d3d6:	c789                	beqz	a5,300d3e0 <Pid_Ctrl+0x124>
            pMotor->TargetIncSpeed = 0;
 300d3d8:	fdc42783          	lw	a5,-36(s0)
 300d3dc:	0007ac23          	sw	zero,24(a5)
        }
    }
     
    //电机需要设置的占空比
    duty = (abs)((int)(pMotor->TargetIncSpeed/g_motorMaxSpeed * 100.0));   
 300d3e0:	fdc42783          	lw	a5,-36(s0)
 300d3e4:	6f98                	flw	fa4,24(a5)
 300d3e6:	85a1a787          	flw	fa5,-1958(gp) # 4000164 <g_motorMaxSpeed>
 300d3ea:	18f777d3          	fdiv.s	fa5,fa4,fa5
 300d3ee:	20f78553          	fmv.s	fa0,fa5
 300d3f2:	417030ef          	jal	ra,3011008 <__extendsfdf2>
 300d3f6:	87aa                	mv	a5,a0
 300d3f8:	882e                	mv	a6,a1
 300d3fa:	03012737          	lui	a4,0x3012
 300d3fe:	47870713          	addi	a4,a4,1144 # 3012478 <g_crgIpMatch+0xbe0>
 300d402:	4310                	lw	a2,0(a4)
 300d404:	4354                	lw	a3,4(a4)
 300d406:	853e                	mv	a0,a5
 300d408:	85c2                	mv	a1,a6
 300d40a:	4d3020ef          	jal	ra,30100dc <__muldf3>
 300d40e:	87aa                	mv	a5,a0
 300d410:	882e                	mv	a6,a1
 300d412:	853e                	mv	a0,a5
 300d414:	85c2                	mv	a1,a6
 300d416:	2cb030ef          	jal	ra,3010ee0 <__fixdfsi>
 300d41a:	87aa                	mv	a5,a0
 300d41c:	853e                	mv	a0,a5
 300d41e:	04a040ef          	jal	ra,3011468 <abs>
 300d422:	87aa                	mv	a5,a0
 300d424:	fef42623          	sw	a5,-20(s0)
    if (duty > 99) {
 300d428:	fec42703          	lw	a4,-20(s0)
 300d42c:	06300793          	li	a5,99
 300d430:	00e7f663          	bgeu	a5,a4,300d43c <Pid_Ctrl+0x180>
        duty = 99;
 300d434:	06300793          	li	a5,99
 300d438:	fef42623          	sw	a5,-20(s0)
    }
    pMotor->duty = duty;
 300d43c:	fdc42783          	lw	a5,-36(s0)
 300d440:	fec42703          	lw	a4,-20(s0)
 300d444:	cfd8                	sw	a4,28(a5)

    pMotor->err_last = pMotor->err_next;
 300d446:	fdc42783          	lw	a5,-36(s0)
 300d44a:	67dc                	flw	fa5,12(a5)
 300d44c:	fdc42783          	lw	a5,-36(s0)
 300d450:	eb9c                	fsw	fa5,16(a5)
    pMotor->err_next = pMotor->err;
 300d452:	fdc42783          	lw	a5,-36(s0)
 300d456:	679c                	flw	fa5,8(a5)
 300d458:	fdc42783          	lw	a5,-36(s0)
 300d45c:	e7dc                	fsw	fa5,12(a5)

    return pMotor->TargetIncSpeed;
 300d45e:	fdc42783          	lw	a5,-36(s0)
 300d462:	6f9c                	flw	fa5,24(a5)
}
 300d464:	20f78553          	fmv.s	fa0,fa5
 300d468:	50b2                	lw	ra,44(sp)
 300d46a:	5422                	lw	s0,40(sp)
 300d46c:	6145                	addi	sp,sp,48
 300d46e:	8082                	ret

0300d470 <set_duty>:
#include "pwm.h"
#include "uart.h"
#include "debug.h"


void set_duty(GPT_Handle* gpt_handle, int duty){
 300d470:	1101                	addi	sp,sp,-32
 300d472:	ce06                	sw	ra,28(sp)
 300d474:	cc22                	sw	s0,24(sp)
 300d476:	1000                	addi	s0,sp,32
 300d478:	fea42623          	sw	a0,-20(s0)
 300d47c:	feb42423          	sw	a1,-24(s0)
    // unsigned int period = HAL_GPT_GetCountPeriod(gpt_handle);
    HAL_GPT_GetConfig(gpt_handle);
 300d480:	fec42503          	lw	a0,-20(s0)
 300d484:	af1fa0ef          	jal	ra,3007f74 <HAL_GPT_GetConfig>
    gpt_handle->refA0.refAction = GPT_ACTION_OUTPUT_HIGH;
 300d488:	fec42783          	lw	a5,-20(s0)
 300d48c:	4709                	li	a4,2
 300d48e:	cb98                	sw	a4,16(a5)
    gpt_handle->refA0.refdot = 1;
 300d490:	fec42783          	lw	a5,-20(s0)
 300d494:	4705                	li	a4,1
 300d496:	c7d8                	sw	a4,12(a5)
    gpt_handle->refB0.refAction = GPT_ACTION_OUTPUT_LOW;
 300d498:	fec42783          	lw	a5,-20(s0)
 300d49c:	4705                	li	a4,1
 300d49e:	cf98                	sw	a4,24(a5)
    gpt_handle->refB0.refdot = duty;
 300d4a0:	fe842703          	lw	a4,-24(s0)
 300d4a4:	fec42783          	lw	a5,-20(s0)
 300d4a8:	cbd8                	sw	a4,20(a5)
    HAL_GPT_Config(gpt_handle);
 300d4aa:	fec42503          	lw	a0,-20(s0)
 300d4ae:	fbafa0ef          	jal	ra,3007c68 <HAL_GPT_Config>
}
 300d4b2:	0001                	nop
 300d4b4:	40f2                	lw	ra,28(sp)
 300d4b6:	4462                	lw	s0,24(sp)
 300d4b8:	6105                	addi	sp,sp,32
 300d4ba:	8082                	ret

0300d4bc <Rotate>:
//     BASE_FUNC_DELAY_MS(time);
//     HAL_GPT_Stop(gpt_handle);
// }


void Rotate(GPT_Handle* gpt_handle, unsigned short time,  unsigned short duty){
 300d4bc:	1101                	addi	sp,sp,-32
 300d4be:	ce06                	sw	ra,28(sp)
 300d4c0:	cc22                	sw	s0,24(sp)
 300d4c2:	1000                	addi	s0,sp,32
 300d4c4:	fea42623          	sw	a0,-20(s0)
 300d4c8:	87ae                	mv	a5,a1
 300d4ca:	8732                	mv	a4,a2
 300d4cc:	fef41523          	sh	a5,-22(s0)
 300d4d0:	87ba                	mv	a5,a4
 300d4d2:	fef41423          	sh	a5,-24(s0)
    DBG_PRINTF("CLOCKWISE\r\n");
 300d4d6:	030127b7          	lui	a5,0x3012
 300d4da:	48078513          	addi	a0,a5,1152 # 3012480 <g_crgIpMatch+0xbe8>
 300d4de:	3e7d                	jal	ra,300d09c <DBG_UartPrintf.trans.13>
    set_duty(gpt_handle, duty); //350
 300d4e0:	fe845783          	lhu	a5,-24(s0)
 300d4e4:	85be                	mv	a1,a5
 300d4e6:	fec42503          	lw	a0,-20(s0)
 300d4ea:	3759                	jal	ra,300d470 <set_duty>
    HAL_GPT_Start(gpt_handle);
 300d4ec:	fec42503          	lw	a0,-20(s0)
 300d4f0:	e5efa0ef          	jal	ra,3007b4e <HAL_GPT_Start>
    BASE_FUNC_DELAY_MS(time);
 300d4f4:	fea45783          	lhu	a5,-22(s0)
 300d4f8:	3e800593          	li	a1,1000
 300d4fc:	853e                	mv	a0,a5
 300d4fe:	963f50ef          	jal	ra,3002e60 <BASE_FUNC_Delay>
    HAL_GPT_Stop(gpt_handle);
 300d502:	fec42503          	lw	a0,-20(s0)
 300d506:	ed6fa0ef          	jal	ra,3007bdc <HAL_GPT_Stop>
}
 300d50a:	0001                	nop
 300d50c:	40f2                	lw	ra,28(sp)
 300d50e:	4462                	lw	s0,24(sp)
 300d510:	6105                	addi	sp,sp,32
 300d512:	8082                	ret

0300d514 <up>:

void up(unsigned short time, unsigned short duty){
 300d514:	1101                	addi	sp,sp,-32
 300d516:	ce06                	sw	ra,28(sp)
 300d518:	cc22                	sw	s0,24(sp)
 300d51a:	1000                	addi	s0,sp,32
 300d51c:	87aa                	mv	a5,a0
 300d51e:	872e                	mv	a4,a1
 300d520:	fef41723          	sh	a5,-18(s0)
 300d524:	87ba                	mv	a5,a4
 300d526:	fef41623          	sh	a5,-20(s0)
    Rotate(&g_gpt2, time, duty);
 300d52a:	fec45703          	lhu	a4,-20(s0)
 300d52e:	fee45783          	lhu	a5,-18(s0)
 300d532:	863a                	mv	a2,a4
 300d534:	85be                	mv	a1,a5
 300d536:	f9e18513          	addi	a0,gp,-98 # 40008a8 <g_gpt2>
 300d53a:	3749                	jal	ra,300d4bc <Rotate>
}
 300d53c:	0001                	nop
 300d53e:	40f2                	lw	ra,28(sp)
 300d540:	4462                	lw	s0,24(sp)
 300d542:	6105                	addi	sp,sp,32
 300d544:	8082                	ret

0300d546 <down>:

void down(unsigned short time, unsigned short duty){
 300d546:	1101                	addi	sp,sp,-32
 300d548:	ce06                	sw	ra,28(sp)
 300d54a:	cc22                	sw	s0,24(sp)
 300d54c:	1000                	addi	s0,sp,32
 300d54e:	87aa                	mv	a5,a0
 300d550:	872e                	mv	a4,a1
 300d552:	fef41723          	sh	a5,-18(s0)
 300d556:	87ba                	mv	a5,a4
 300d558:	fef41623          	sh	a5,-20(s0)
    Rotate(&g_gpt2, time, duty);
 300d55c:	fec45703          	lhu	a4,-20(s0)
 300d560:	fee45783          	lhu	a5,-18(s0)
 300d564:	863a                	mv	a2,a4
 300d566:	85be                	mv	a1,a5
 300d568:	f9e18513          	addi	a0,gp,-98 # 40008a8 <g_gpt2>
 300d56c:	3f81                	jal	ra,300d4bc <Rotate>
}
 300d56e:	0001                	nop
 300d570:	40f2                	lw	ra,28(sp)
 300d572:	4462                	lw	s0,24(sp)
 300d574:	6105                	addi	sp,sp,32
 300d576:	8082                	ret

0300d578 <open>:

void open(unsigned short time, unsigned short duty){
 300d578:	1101                	addi	sp,sp,-32
 300d57a:	ce06                	sw	ra,28(sp)
 300d57c:	cc22                	sw	s0,24(sp)
 300d57e:	1000                	addi	s0,sp,32
 300d580:	87aa                	mv	a5,a0
 300d582:	872e                	mv	a4,a1
 300d584:	fef41723          	sh	a5,-18(s0)
 300d588:	87ba                	mv	a5,a4
 300d58a:	fef41623          	sh	a5,-20(s0)
    Rotate(&g_gpt0, time, duty);
 300d58e:	fec45703          	lhu	a4,-20(s0)
 300d592:	fee45783          	lhu	a5,-18(s0)
 300d596:	863a                	mv	a2,a4
 300d598:	85be                	mv	a1,a5
 300d59a:	f3618513          	addi	a0,gp,-202 # 4000840 <g_gpt0>
 300d59e:	3f39                	jal	ra,300d4bc <Rotate>
}
 300d5a0:	0001                	nop
 300d5a2:	40f2                	lw	ra,28(sp)
 300d5a4:	4462                	lw	s0,24(sp)
 300d5a6:	6105                	addi	sp,sp,32
 300d5a8:	8082                	ret

0300d5aa <_close>:

void _close(unsigned short time, unsigned short duty){
 300d5aa:	1101                	addi	sp,sp,-32
 300d5ac:	ce06                	sw	ra,28(sp)
 300d5ae:	cc22                	sw	s0,24(sp)
 300d5b0:	1000                	addi	s0,sp,32
 300d5b2:	87aa                	mv	a5,a0
 300d5b4:	872e                	mv	a4,a1
 300d5b6:	fef41723          	sh	a5,-18(s0)
 300d5ba:	87ba                	mv	a5,a4
 300d5bc:	fef41623          	sh	a5,-20(s0)
    Rotate(&g_gpt0, time, duty);
 300d5c0:	fec45703          	lhu	a4,-20(s0)
 300d5c4:	fee45783          	lhu	a5,-18(s0)
 300d5c8:	863a                	mv	a2,a4
 300d5ca:	85be                	mv	a1,a5
 300d5cc:	f3618513          	addi	a0,gp,-202 # 4000840 <g_gpt0>
 300d5d0:	35f5                	jal	ra,300d4bc <Rotate>
 300d5d2:	0001                	nop
 300d5d4:	40f2                	lw	ra,28(sp)
 300d5d6:	4462                	lw	s0,24(sp)
 300d5d8:	6105                	addi	sp,sp,32
 300d5da:	8082                	ret

0300d5dc <ssd1306_Reset>:
#define SSD1306_MASK_CONT (0x1 << 7)
#define DOUBLE 2


void ssd1306_Reset(void)
{
 300d5dc:	1141                	addi	sp,sp,-16
 300d5de:	c622                	sw	s0,12(sp)
 300d5e0:	0800                	addi	s0,sp,16
    /* for I2C - do nothing */
}
 300d5e2:	0001                	nop
 300d5e4:	4432                	lw	s0,12(sp)
 300d5e6:	0141                	addi	sp,sp,16
 300d5e8:	8082                	ret

0300d5ea <ssd1306_SendData>:

static uint32_t ssd1306_SendData(uint8_t* buffer, uint32_t size)
{
 300d5ea:	7179                	addi	sp,sp,-48
 300d5ec:	d606                	sw	ra,44(sp)
 300d5ee:	d422                	sw	s0,40(sp)
 300d5f0:	1800                	addi	s0,sp,48
 300d5f2:	fca42e23          	sw	a0,-36(s0)
 300d5f6:	fcb42c23          	sw	a1,-40(s0)
    uint16_t dev_addr = I2C_SLAVE2_ADDR;
 300d5fa:	07800793          	li	a5,120
 300d5fe:	fef41723          	sh	a5,-18(s0)
    uint32_t retval = HAL_I2C_MasterWriteBlocking(&g_i2c1, dev_addr, buffer, size, 10000);
 300d602:	fee45583          	lhu	a1,-18(s0)
 300d606:	6789                	lui	a5,0x2
 300d608:	71078713          	addi	a4,a5,1808 # 2710 <__bss_size__+0x167c>
 300d60c:	fd842683          	lw	a3,-40(s0)
 300d610:	fdc42603          	lw	a2,-36(s0)
 300d614:	21618513          	addi	a0,gp,534 # 4000b20 <g_i2c1>
 300d618:	967fb0ef          	jal	ra,3008f7e <HAL_I2C_MasterWriteBlocking>
 300d61c:	fea42423          	sw	a0,-24(s0)
    if (retval != BASE_STATUS_OK) {
 300d620:	fe842783          	lw	a5,-24(s0)
 300d624:	c385                	beqz	a5,300d644 <ssd1306_SendData+0x5a>
        DBG_PRINTF("I2cWrite(0x%X) failed, 0x%X!\n", buffer[1], retval);
 300d626:	fdc42783          	lw	a5,-36(s0)
 300d62a:	0785                	addi	a5,a5,1
 300d62c:	239c                	lbu	a5,0(a5)
 300d62e:	fe842603          	lw	a2,-24(s0)
 300d632:	85be                	mv	a1,a5
 300d634:	030127b7          	lui	a5,0x3012
 300d638:	48c78513          	addi	a0,a5,1164 # 301248c <g_crgIpMatch+0xbf4>
 300d63c:	3485                	jal	ra,300d09c <DBG_UartPrintf.trans.13>
        return retval;
 300d63e:	fe842783          	lw	a5,-24(s0)
 300d642:	a011                	j	300d646 <ssd1306_SendData+0x5c>
    }
    return 0;
 300d644:	4781                	li	a5,0
}
 300d646:	853e                	mv	a0,a5
 300d648:	50b2                	lw	ra,44(sp)
 300d64a:	5422                	lw	s0,40(sp)
 300d64c:	6145                	addi	sp,sp,48
 300d64e:	8082                	ret

0300d650 <ssd1306_WiteByte>:

static uint32_t ssd1306_WiteByte(uint8_t regAddr, uint8_t byte)
{
 300d650:	7179                	addi	sp,sp,-48
 300d652:	d606                	sw	ra,44(sp)
 300d654:	d422                	sw	s0,40(sp)
 300d656:	1800                	addi	s0,sp,48
 300d658:	87aa                	mv	a5,a0
 300d65a:	872e                	mv	a4,a1
 300d65c:	fcf40fa3          	sb	a5,-33(s0)
 300d660:	87ba                	mv	a5,a4
 300d662:	fcf40f23          	sb	a5,-34(s0)
    uint8_t buffer[] = {regAddr, byte};
 300d666:	fdf44783          	lbu	a5,-33(s0)
 300d66a:	fef40623          	sb	a5,-20(s0)
 300d66e:	fde44783          	lbu	a5,-34(s0)
 300d672:	fef406a3          	sb	a5,-19(s0)
    return ssd1306_SendData(buffer, sizeof(buffer));
 300d676:	fec40793          	addi	a5,s0,-20
 300d67a:	4589                	li	a1,2
 300d67c:	853e                	mv	a0,a5
 300d67e:	37b5                	jal	ra,300d5ea <ssd1306_SendData>
 300d680:	87aa                	mv	a5,a0
}
 300d682:	853e                	mv	a0,a5
 300d684:	50b2                	lw	ra,44(sp)
 300d686:	5422                	lw	s0,40(sp)
 300d688:	6145                	addi	sp,sp,48
 300d68a:	8082                	ret

0300d68c <ssd1306_WriteCommand>:

// Send a byte to the command register
void ssd1306_WriteCommand(uint8_t byte)
{
 300d68c:	1101                	addi	sp,sp,-32
 300d68e:	ce06                	sw	ra,28(sp)
 300d690:	cc22                	sw	s0,24(sp)
 300d692:	1000                	addi	s0,sp,32
 300d694:	87aa                	mv	a5,a0
 300d696:	fef407a3          	sb	a5,-17(s0)
    ssd1306_WiteByte(SSD1306_CTRL_CMD, byte);
 300d69a:	fef44783          	lbu	a5,-17(s0)
 300d69e:	85be                	mv	a1,a5
 300d6a0:	4501                	li	a0,0
 300d6a2:	377d                	jal	ra,300d650 <ssd1306_WiteByte>
}
 300d6a4:	0001                	nop
 300d6a6:	40f2                	lw	ra,28(sp)
 300d6a8:	4462                	lw	s0,24(sp)
 300d6aa:	6105                	addi	sp,sp,32
 300d6ac:	8082                	ret

0300d6ae <ssd1306_Init_CMD>:
    }
    return ret;
}

void ssd1306_Init_CMD(void)
{
 300d6ae:	1141                	addi	sp,sp,-16
 300d6b0:	c606                	sw	ra,12(sp)
 300d6b2:	c422                	sw	s0,8(sp)
 300d6b4:	0800                	addi	s0,sp,16
    ssd1306_WriteCommand(0xA4); // 0xa4,Output follows RAM content;0xa5,Output ignores RAM content
 300d6b6:	0a400513          	li	a0,164
 300d6ba:	3fc9                	jal	ra,300d68c <ssd1306_WriteCommand>

    ssd1306_WriteCommand(0xD3); // -set display offset - CHECK
 300d6bc:	0d300513          	li	a0,211
 300d6c0:	37f1                	jal	ra,300d68c <ssd1306_WriteCommand>
    ssd1306_WriteCommand(0x00); // -not offset
 300d6c2:	4501                	li	a0,0
 300d6c4:	37e1                	jal	ra,300d68c <ssd1306_WriteCommand>

    ssd1306_WriteCommand(0xD5); // --set display clock divide ratio/oscillator frequency
 300d6c6:	0d500513          	li	a0,213
 300d6ca:	37c9                	jal	ra,300d68c <ssd1306_WriteCommand>
    ssd1306_WriteCommand(0xF0); // --set divide ratio
 300d6cc:	0f000513          	li	a0,240
 300d6d0:	3f75                	jal	ra,300d68c <ssd1306_WriteCommand>

    ssd1306_WriteCommand(0xD9); // --set pre-charge period
 300d6d2:	0d900513          	li	a0,217
 300d6d6:	3f5d                	jal	ra,300d68c <ssd1306_WriteCommand>
    ssd1306_WriteCommand(0x11); // 0x22 by default
 300d6d8:	4545                	li	a0,17
 300d6da:	3f4d                	jal	ra,300d68c <ssd1306_WriteCommand>

    ssd1306_WriteCommand(0xDA); // --set com pins hardware configuration - CHECK
 300d6dc:	0da00513          	li	a0,218
 300d6e0:	3775                	jal	ra,300d68c <ssd1306_WriteCommand>
#if (SSD1306_HEIGHT == 32)
    ssd1306_WriteCommand(0x02);
#elif (SSD1306_HEIGHT == 64)
    ssd1306_WriteCommand(0x12);
 300d6e2:	4549                	li	a0,18
 300d6e4:	3765                	jal	ra,300d68c <ssd1306_WriteCommand>
    ssd1306_WriteCommand(0x12);
#else
#error "Only 32, 64, or 128 lines of height are supported!"
#endif

    ssd1306_WriteCommand(0xDB); // --set vcomh
 300d6e6:	0db00513          	li	a0,219
 300d6ea:	374d                	jal	ra,300d68c <ssd1306_WriteCommand>
    ssd1306_WriteCommand(0x30); // 0x20,0.77xVcc, 0x30,0.83xVcc
 300d6ec:	03000513          	li	a0,48
 300d6f0:	3f71                	jal	ra,300d68c <ssd1306_WriteCommand>

    ssd1306_WriteCommand(0x8D); // --set DC-DC enable
 300d6f2:	08d00513          	li	a0,141
 300d6f6:	3f59                	jal	ra,300d68c <ssd1306_WriteCommand>
    ssd1306_WriteCommand(0x14); //
 300d6f8:	4551                	li	a0,20
 300d6fa:	3f49                	jal	ra,300d68c <ssd1306_WriteCommand>
    ssd1306_SetDisplayOn(1); // --turn on SSD1306 panel
 300d6fc:	4505                	li	a0,1
 300d6fe:	2c25                	jal	ra,300d936 <ssd1306_SetDisplayOn>
}
 300d700:	0001                	nop
 300d702:	40b2                	lw	ra,12(sp)
 300d704:	4422                	lw	s0,8(sp)
 300d706:	0141                	addi	sp,sp,16
 300d708:	8082                	ret

0300d70a <ssd1306_Init>:

// Initialize the oled screen
void ssd1306_Init(void)
{
 300d70a:	1141                	addi	sp,sp,-16
 300d70c:	c606                	sw	ra,12(sp)
 300d70e:	c422                	sw	s0,8(sp)
 300d710:	0800                	addi	s0,sp,16
    // Reset OLED
    ssd1306_Reset();
 300d712:	35e9                	jal	ra,300d5dc <ssd1306_Reset>

    // Wait for the screen to boot
    BASE_FUNC_DELAY_MS(10); // 10000us  The delay here is very important
 300d714:	3e800593          	li	a1,1000
 300d718:	4529                	li	a0,10
 300d71a:	f46f50ef          	jal	ra,3002e60 <BASE_FUNC_Delay>

    // Init OLED
    ssd1306_SetDisplayOn(0); // display off
 300d71e:	4501                	li	a0,0
 300d720:	2c19                	jal	ra,300d936 <ssd1306_SetDisplayOn>

    ssd1306_WriteCommand(0x20); // Set Memory Addressing Mode
 300d722:	02000513          	li	a0,32
 300d726:	379d                	jal	ra,300d68c <ssd1306_WriteCommand>
    ssd1306_WriteCommand(0x00); // 00b,Horizontal Addressing Mode; 01b,Vertical Addressing Mode;
 300d728:	4501                	li	a0,0
 300d72a:	378d                	jal	ra,300d68c <ssd1306_WriteCommand>
                                // 10b,Page Addressing Mode (RESET); 11b,Invalid

    ssd1306_WriteCommand(0xB0); // Set Page Start Address for Page Addressing Mode,0-7
 300d72c:	0b000513          	li	a0,176
 300d730:	3fb1                	jal	ra,300d68c <ssd1306_WriteCommand>

#ifdef SSD1306_MIRROR_VERT
    ssd1306_WriteCommand(0xC0); // Mirror vertically
#else
    ssd1306_WriteCommand(0xC8); // Set COM Output Scan Direction
 300d732:	0c800513          	li	a0,200
 300d736:	3f99                	jal	ra,300d68c <ssd1306_WriteCommand>
#endif

    ssd1306_WriteCommand(0x00); // ---set low column address
 300d738:	4501                	li	a0,0
 300d73a:	3f89                	jal	ra,300d68c <ssd1306_WriteCommand>
    ssd1306_WriteCommand(0x10); // ---set high column address
 300d73c:	4541                	li	a0,16
 300d73e:	37b9                	jal	ra,300d68c <ssd1306_WriteCommand>

    ssd1306_WriteCommand(0x40); // --set start line address - CHECK
 300d740:	04000513          	li	a0,64
 300d744:	37a1                	jal	ra,300d68c <ssd1306_WriteCommand>

    ssd1306_SetContrast(0xFF);
 300d746:	0ff00513          	li	a0,255
 300d74a:	2a75                	jal	ra,300d906 <ssd1306_SetContrast>

#ifdef SSD1306_MIRROR_HORIZ
    ssd1306_WriteCommand(0xA0); // Mirror horizontally
#else
    ssd1306_WriteCommand(0xA1); // --set segment re-map 0 to 127 - CHECK
 300d74c:	0a100513          	li	a0,161
 300d750:	3f35                	jal	ra,300d68c <ssd1306_WriteCommand>
#endif

#ifdef SSD1306_INVERSE_COLOR
    ssd1306_WriteCommand(0xA7); // --set inverse color
#else
    ssd1306_WriteCommand(0xA6); // --set normal color
 300d752:	0a600513          	li	a0,166
 300d756:	3f1d                	jal	ra,300d68c <ssd1306_WriteCommand>
// Set multiplex ratio.
#if (SSD1306_HEIGHT == 128)
    // Found in the Luma Python lib for SH1106.
    ssd1306_WriteCommand(0xFF);
#else
    ssd1306_WriteCommand(0xA8); // --set multiplex ratio(1 to 64) - CHECK
 300d758:	0a800513          	li	a0,168
 300d75c:	3f05                	jal	ra,300d68c <ssd1306_WriteCommand>
#endif

#if (SSD1306_HEIGHT == 32)
    ssd1306_WriteCommand(0x1F); //
#elif (SSD1306_HEIGHT == 64)
    ssd1306_WriteCommand(0x3F); //
 300d75e:	03f00513          	li	a0,63
 300d762:	372d                	jal	ra,300d68c <ssd1306_WriteCommand>
#elif (SSD1306_HEIGHT == 128)
    ssd1306_WriteCommand(0x3F); // Seems to work for 128px high displays too.
#else
#error "Only 32, 64, or 128 lines of height are supported!"
#endif
    ssd1306_Init_CMD();
 300d764:	37a9                	jal	ra,300d6ae <ssd1306_Init_CMD>
    // Clear screen
    ssd1306_Fill(Black);
 300d766:	4501                	li	a0,0
 300d768:	280d                	jal	ra,300d79a <ssd1306_Fill>

    // Flush buffer to screen
    ssd1306_UpdateScreen();
 300d76a:	28b5                	jal	ra,300d7e6 <ssd1306_UpdateScreen>

    // Set default values for screen object
    SSD1306.CurrentX = 0;
 300d76c:	040017b7          	lui	a5,0x4001
 300d770:	20c78793          	addi	a5,a5,524 # 400120c <SSD1306>
 300d774:	00079023          	sh	zero,0(a5)
    SSD1306.CurrentY = 0;
 300d778:	040017b7          	lui	a5,0x4001
 300d77c:	20c78793          	addi	a5,a5,524 # 400120c <SSD1306>
 300d780:	00079123          	sh	zero,2(a5)

    SSD1306.Initialized = 1;
 300d784:	040017b7          	lui	a5,0x4001
 300d788:	20c78793          	addi	a5,a5,524 # 400120c <SSD1306>
 300d78c:	4705                	li	a4,1
 300d78e:	b3d8                	sb	a4,5(a5)
}
 300d790:	0001                	nop
 300d792:	40b2                	lw	ra,12(sp)
 300d794:	4422                	lw	s0,8(sp)
 300d796:	0141                	addi	sp,sp,16
 300d798:	8082                	ret

0300d79a <ssd1306_Fill>:



// Fill the whole screen with the given color
void ssd1306_Fill(SSD1306_COLOR color)
{
 300d79a:	7179                	addi	sp,sp,-48
 300d79c:	d622                	sw	s0,44(sp)
 300d79e:	1800                	addi	s0,sp,48
 300d7a0:	fca42e23          	sw	a0,-36(s0)
    /* Set memory */
    uint32_t i;

    for (i = 0; i < sizeof(SSD1306_Buffer); i++) {
 300d7a4:	fe042623          	sw	zero,-20(s0)
 300d7a8:	a02d                	j	300d7d2 <ssd1306_Fill+0x38>
        SSD1306_Buffer[i] = (color == Black) ? 0x00 : 0xFF;
 300d7aa:	fdc42783          	lw	a5,-36(s0)
 300d7ae:	e399                	bnez	a5,300d7b4 <ssd1306_Fill+0x1a>
 300d7b0:	4781                	li	a5,0
 300d7b2:	a019                	j	300d7b8 <ssd1306_Fill+0x1e>
 300d7b4:	0ff00793          	li	a5,255
 300d7b8:	04001737          	lui	a4,0x4001
 300d7bc:	e0c70693          	addi	a3,a4,-500 # 4000e0c <SSD1306_Buffer>
 300d7c0:	fec42703          	lw	a4,-20(s0)
 300d7c4:	9736                	add	a4,a4,a3
 300d7c6:	a31c                	sb	a5,0(a4)
    for (i = 0; i < sizeof(SSD1306_Buffer); i++) {
 300d7c8:	fec42783          	lw	a5,-20(s0)
 300d7cc:	0785                	addi	a5,a5,1
 300d7ce:	fef42623          	sw	a5,-20(s0)
 300d7d2:	fec42703          	lw	a4,-20(s0)
 300d7d6:	3ff00793          	li	a5,1023
 300d7da:	fce7f8e3          	bgeu	a5,a4,300d7aa <ssd1306_Fill+0x10>
    }
}
 300d7de:	0001                	nop
 300d7e0:	5432                	lw	s0,44(sp)
 300d7e2:	6145                	addi	sp,sp,48
 300d7e4:	8082                	ret

0300d7e6 <ssd1306_UpdateScreen>:

// Write the screenbuffer with changed to the screen
void ssd1306_UpdateScreen(void)
{
 300d7e6:	bc010113          	addi	sp,sp,-1088
 300d7ea:	42112e23          	sw	ra,1084(sp)
 300d7ee:	42812c23          	sw	s0,1080(sp)
 300d7f2:	44010413          	addi	s0,sp,1088
    //
    //  * 32px   ==  4 pages
    //  * 64px   ==  8 pages
    //  * 128px  ==  16 pages

    uint8_t cmd[] = {
 300d7f6:	02100793          	li	a5,33
 300d7fa:	fcf40e23          	sb	a5,-36(s0)
 300d7fe:	fc040ea3          	sb	zero,-35(s0)
 300d802:	07f00793          	li	a5,127
 300d806:	fcf40f23          	sb	a5,-34(s0)
 300d80a:	02200793          	li	a5,34
 300d80e:	fcf40fa3          	sb	a5,-33(s0)
 300d812:	fe040023          	sb	zero,-32(s0)
 300d816:	479d                	li	a5,7
 300d818:	fef400a3          	sb	a5,-31(s0)
        0X7F,   // 列终止地址 127
        0X22,   // 设置页起始和结束地址
        0X00,   // 页起始地址 0
        0X07,   // 页终止地址 7
    };
    uint32_t count = 0;
 300d81c:	fe042623          	sw	zero,-20(s0)
    uint8_t data[sizeof(cmd) * DOUBLE + SSD1306_BUFFER_SIZE + 1] = {};
 300d820:	bcc40793          	addi	a5,s0,-1076
 300d824:	40d00713          	li	a4,1037
 300d828:	863a                	mv	a2,a4
 300d82a:	4581                	li	a1,0
 300d82c:	853e                	mv	a0,a5
 300d82e:	7a7030ef          	jal	ra,30117d4 <memset>

    // copy cmd
    for (uint32_t i = 0; i < sizeof(cmd) / sizeof(cmd[0]); i++) {
 300d832:	fe042423          	sw	zero,-24(s0)
 300d836:	a0a9                	j	300d880 <ssd1306_UpdateScreen+0x9a>
        data[count++] = SSD1306_CTRL_CMD | SSD1306_MASK_CONT;
 300d838:	fec42783          	lw	a5,-20(s0)
 300d83c:	00178713          	addi	a4,a5,1
 300d840:	fee42623          	sw	a4,-20(s0)
 300d844:	ff040713          	addi	a4,s0,-16
 300d848:	97ba                	add	a5,a5,a4
 300d84a:	f8000713          	li	a4,-128
 300d84e:	bce78e23          	sb	a4,-1060(a5)
        data[count++] = cmd[i];
 300d852:	fec42783          	lw	a5,-20(s0)
 300d856:	00178713          	addi	a4,a5,1
 300d85a:	fee42623          	sw	a4,-20(s0)
 300d85e:	fe842703          	lw	a4,-24(s0)
 300d862:	ff040693          	addi	a3,s0,-16
 300d866:	9736                	add	a4,a4,a3
 300d868:	fec74703          	lbu	a4,-20(a4)
 300d86c:	ff040693          	addi	a3,s0,-16
 300d870:	97b6                	add	a5,a5,a3
 300d872:	bce78e23          	sb	a4,-1060(a5)
    for (uint32_t i = 0; i < sizeof(cmd) / sizeof(cmd[0]); i++) {
 300d876:	fe842783          	lw	a5,-24(s0)
 300d87a:	0785                	addi	a5,a5,1
 300d87c:	fef42423          	sw	a5,-24(s0)
 300d880:	fe842703          	lw	a4,-24(s0)
 300d884:	4795                	li	a5,5
 300d886:	fae7f9e3          	bgeu	a5,a4,300d838 <ssd1306_UpdateScreen+0x52>
    }

    // copy frame data
    data[count++] = SSD1306_CTRL_DATA;
 300d88a:	fec42783          	lw	a5,-20(s0)
 300d88e:	00178713          	addi	a4,a5,1
 300d892:	fee42623          	sw	a4,-20(s0)
 300d896:	ff040713          	addi	a4,s0,-16
 300d89a:	97ba                	add	a5,a5,a4
 300d89c:	04000713          	li	a4,64
 300d8a0:	bce78e23          	sb	a4,-1060(a5)
    memcpy_s(&data[count], SSD1306_BUFFER_SIZE + 1, SSD1306_Buffer, SSD1306_BUFFER_SIZE);
 300d8a4:	bcc40713          	addi	a4,s0,-1076
 300d8a8:	fec42783          	lw	a5,-20(s0)
 300d8ac:	973e                	add	a4,a4,a5
 300d8ae:	40000693          	li	a3,1024
 300d8b2:	040017b7          	lui	a5,0x4001
 300d8b6:	e0c78613          	addi	a2,a5,-500 # 4000e0c <SSD1306_Buffer>
 300d8ba:	40100593          	li	a1,1025
 300d8be:	853a                	mv	a0,a4
 300d8c0:	b96fe0ef          	jal	ra,300bc56 <memcpy_s>
    count += sizeof(SSD1306_Buffer);
 300d8c4:	fec42783          	lw	a5,-20(s0)
 300d8c8:	40078793          	addi	a5,a5,1024
 300d8cc:	fef42623          	sw	a5,-20(s0)

    // send to i2c bus
    uint32_t retval = ssd1306_SendData(data, count);
 300d8d0:	bcc40793          	addi	a5,s0,-1076
 300d8d4:	fec42583          	lw	a1,-20(s0)
 300d8d8:	853e                	mv	a0,a5
 300d8da:	3b01                	jal	ra,300d5ea <ssd1306_SendData>
 300d8dc:	fea42223          	sw	a0,-28(s0)
    if (retval != 0) {
 300d8e0:	fe442783          	lw	a5,-28(s0)
 300d8e4:	cb89                	beqz	a5,300d8f6 <ssd1306_UpdateScreen+0x110>
        DBG_PRINTF("ssd1306_UpdateScreen send frame data filed: %d!\r\n", retval);
 300d8e6:	fe442583          	lw	a1,-28(s0)
 300d8ea:	030127b7          	lui	a5,0x3012
 300d8ee:	4ac78513          	addi	a0,a5,1196 # 30124ac <g_crgIpMatch+0xc14>
 300d8f2:	8f8f90ef          	jal	ra,30069ea <DBG_UartPrintf>
    }
}
 300d8f6:	0001                	nop
 300d8f8:	43c12083          	lw	ra,1084(sp)
 300d8fc:	43812403          	lw	s0,1080(sp)
 300d900:	44010113          	addi	sp,sp,1088
 300d904:	8082                	ret

0300d906 <ssd1306_SetContrast>:
        }
    }
}

void ssd1306_SetContrast(const uint8_t value)
{
 300d906:	7179                	addi	sp,sp,-48
 300d908:	d606                	sw	ra,44(sp)
 300d90a:	d422                	sw	s0,40(sp)
 300d90c:	1800                	addi	s0,sp,48
 300d90e:	87aa                	mv	a5,a0
 300d910:	fcf40fa3          	sb	a5,-33(s0)
    const uint8_t kSetContrastControlRegister = 0x81;
 300d914:	f8100793          	li	a5,-127
 300d918:	fef407a3          	sb	a5,-17(s0)
    ssd1306_WriteCommand(kSetContrastControlRegister);
 300d91c:	fef44783          	lbu	a5,-17(s0)
 300d920:	853e                	mv	a0,a5
 300d922:	33ad                	jal	ra,300d68c <ssd1306_WriteCommand>
    ssd1306_WriteCommand(value);
 300d924:	fdf44783          	lbu	a5,-33(s0)
 300d928:	853e                	mv	a0,a5
 300d92a:	338d                	jal	ra,300d68c <ssd1306_WriteCommand>
}
 300d92c:	0001                	nop
 300d92e:	50b2                	lw	ra,44(sp)
 300d930:	5422                	lw	s0,40(sp)
 300d932:	6145                	addi	sp,sp,48
 300d934:	8082                	ret

0300d936 <ssd1306_SetDisplayOn>:

void ssd1306_SetDisplayOn(const uint8_t on)
{
 300d936:	7179                	addi	sp,sp,-48
 300d938:	d606                	sw	ra,44(sp)
 300d93a:	d422                	sw	s0,40(sp)
 300d93c:	1800                	addi	s0,sp,48
 300d93e:	87aa                	mv	a5,a0
 300d940:	fcf40fa3          	sb	a5,-33(s0)
    uint8_t value;
    if (on) {
 300d944:	fdf44783          	lbu	a5,-33(s0)
 300d948:	cf81                	beqz	a5,300d960 <ssd1306_SetDisplayOn+0x2a>
        value = 0xAF;   // Display on
 300d94a:	faf00793          	li	a5,-81
 300d94e:	fef407a3          	sb	a5,-17(s0)
        SSD1306.DisplayOn = 1;
 300d952:	040017b7          	lui	a5,0x4001
 300d956:	20c78793          	addi	a5,a5,524 # 400120c <SSD1306>
 300d95a:	4705                	li	a4,1
 300d95c:	a3f8                	sb	a4,6(a5)
 300d95e:	a819                	j	300d974 <ssd1306_SetDisplayOn+0x3e>
    } else {
        value = 0xAE;   // Display off
 300d960:	fae00793          	li	a5,-82
 300d964:	fef407a3          	sb	a5,-17(s0)
        SSD1306.DisplayOn = 0;
 300d968:	040017b7          	lui	a5,0x4001
 300d96c:	20c78793          	addi	a5,a5,524 # 400120c <SSD1306>
 300d970:	00078323          	sb	zero,6(a5)
    }
    ssd1306_WriteCommand(value);
 300d974:	fef44783          	lbu	a5,-17(s0)
 300d978:	853e                	mv	a0,a5
 300d97a:	3b09                	jal	ra,300d68c <ssd1306_WriteCommand>
}
 300d97c:	0001                	nop
 300d97e:	50b2                	lw	ra,44(sp)
 300d980:	5422                	lw	s0,40(sp)
 300d982:	6145                	addi	sp,sp,48
 300d984:	8082                	ret

0300d986 <User_APTForcePWMAOutputLow>:

unsigned int g_testCount = 0;
unsigned int g_testNum = 0;

void User_APTForcePWMAOutputLow(APT_RegStruct *aptx)
{
 300d986:	1101                	addi	sp,sp,-32
 300d988:	ce22                	sw	s0,28(sp)
 300d98a:	1000                	addi	s0,sp,32
 300d98c:	fea42623          	sw	a0,-20(s0)
    /* Enable force output. */


    aptx->PG_OUT_FRC.BIT.rg_pga_frc_act = APT_PWM_CONTINUOUS_ACTION_LOW; /* if not invert, set low */
 300d990:	fec42703          	lw	a4,-20(s0)
 300d994:	11472783          	lw	a5,276(a4)
 300d998:	9bf1                	andi	a5,a5,-4
 300d99a:	0017e793          	ori	a5,a5,1
 300d99e:	10f72a23          	sw	a5,276(a4)
    aptx->PG_OUT_FRC.BIT.rg_pga_frc_en = BASE_CFG_ENABLE;
 300d9a2:	fec42703          	lw	a4,-20(s0)
 300d9a6:	11472783          	lw	a5,276(a4)
 300d9aa:	0047e793          	ori	a5,a5,4
 300d9ae:	10f72a23          	sw	a5,276(a4)
    /* if PWMA invert */
    return;
 300d9b2:	0001                	nop
}
 300d9b4:	4472                	lw	s0,28(sp)
 300d9b6:	6105                	addi	sp,sp,32
 300d9b8:	8082                	ret

0300d9ba <User_APTForcePWMBOutputLow>:

void User_APTForcePWMBOutputLow(APT_RegStruct *aptx)
{
 300d9ba:	1101                	addi	sp,sp,-32
 300d9bc:	ce22                	sw	s0,28(sp)
 300d9be:	1000                	addi	s0,sp,32
 300d9c0:	fea42623          	sw	a0,-20(s0)
    aptx->PG_OUT_FRC.BIT.rg_pgb_frc_act = APT_PWM_CONTINUOUS_ACTION_HIGH; /* if not invert, set low */
 300d9c4:	fec42703          	lw	a4,-20(s0)
 300d9c8:	11472783          	lw	a5,276(a4)
 300d9cc:	fcf7f793          	andi	a5,a5,-49
 300d9d0:	0207e793          	ori	a5,a5,32
 300d9d4:	10f72a23          	sw	a5,276(a4)
   /* Enable force output. */
    aptx->PG_OUT_FRC.BIT.rg_pgb_frc_en = BASE_CFG_ENABLE;
 300d9d8:	fec42703          	lw	a4,-20(s0)
 300d9dc:	11472783          	lw	a5,276(a4)
 300d9e0:	0407e793          	ori	a5,a5,64
 300d9e4:	10f72a23          	sw	a5,276(a4)
    return;
 300d9e8:	0001                	nop
}
 300d9ea:	4472                	lw	s0,28(sp)
 300d9ec:	6105                	addi	sp,sp,32
 300d9ee:	8082                	ret

0300d9f0 <User_APTPwmARecovery>:


void User_APTPwmARecovery(APT_RegStruct *aptx)
{
 300d9f0:	1101                	addi	sp,sp,-32
 300d9f2:	ce22                	sw	s0,28(sp)
 300d9f4:	1000                	addi	s0,sp,32
 300d9f6:	fea42623          	sw	a0,-20(s0)
    /* Enable force output. */
    aptx->PG_OUT_FRC.BIT.rg_pga_frc_en = BASE_CFG_DISABLE;
 300d9fa:	fec42703          	lw	a4,-20(s0)
 300d9fe:	11472783          	lw	a5,276(a4)
 300da02:	9bed                	andi	a5,a5,-5
 300da04:	10f72a23          	sw	a5,276(a4)
    return;
 300da08:	0001                	nop
}
 300da0a:	4472                	lw	s0,28(sp)
 300da0c:	6105                	addi	sp,sp,32
 300da0e:	8082                	ret

0300da10 <User_APTPwmBRecovery>:

void User_APTPwmBRecovery(APT_RegStruct *aptx)
{
 300da10:	1101                	addi	sp,sp,-32
 300da12:	ce22                	sw	s0,28(sp)
 300da14:	1000                	addi	s0,sp,32
 300da16:	fea42623          	sw	a0,-20(s0)
    /* Enable force output. */
    aptx->PG_OUT_FRC.BIT.rg_pgb_frc_en = BASE_CFG_DISABLE;
 300da1a:	fec42703          	lw	a4,-20(s0)
 300da1e:	11472783          	lw	a5,276(a4)
 300da22:	fbf7f793          	andi	a5,a5,-65
 300da26:	10f72a23          	sw	a5,276(a4)
    return;
 300da2a:	0001                	nop
}
 300da2c:	4472                	lw	s0,28(sp)
 300da2e:	6105                	addi	sp,sp,32
 300da30:	8082                	ret

0300da32 <CRG_Config>:
#define UART0_BAND_RATE 115200
#define UART2_BAND_RATE 115200
#define UART3_BAND_RATE 9600

BASE_StatusType CRG_Config(CRG_CoreClkSelect *coreClkSelect)
{
 300da32:	715d                	addi	sp,sp,-80
 300da34:	c686                	sw	ra,76(sp)
 300da36:	c4a2                	sw	s0,72(sp)
 300da38:	0880                	addi	s0,sp,80
 300da3a:	faa42e23          	sw	a0,-68(s0)
    CRG_Handle crg;
    crg.baseAddress     = CRG;
 300da3e:	100007b7          	lui	a5,0x10000
 300da42:	fcf42423          	sw	a5,-56(s0)
    crg.pllRefClkSelect = CRG_PLL_REF_CLK_SELECT_HOSC;
 300da46:	fc042623          	sw	zero,-52(s0)
    crg.pllPreDiv       = CRG_PLL_PREDIV_4;
 300da4a:	478d                	li	a5,3
 300da4c:	fcf42823          	sw	a5,-48(s0)
    crg.pllFbDiv        = 48; /* PLL Multiplier 48 */
 300da50:	03000793          	li	a5,48
 300da54:	fcf42a23          	sw	a5,-44(s0)
    crg.pllPostDiv      = CRG_PLL_POSTDIV_2;
 300da58:	4785                	li	a5,1
 300da5a:	fcf42c23          	sw	a5,-40(s0)
    crg.coreClkSelect   = CRG_CORE_CLK_SELECT_PLL;
 300da5e:	4789                	li	a5,2
 300da60:	fef42023          	sw	a5,-32(s0)
    crg.handleEx.pllPostDiv2   = CRG_PLL_POSTDIV2_3;
 300da64:	4789                	li	a5,2
 300da66:	fef42223          	sw	a5,-28(s0)
    crg.handleEx.clk1MSelect   = CRG_1M_CLK_SELECT_HOSC;
 300da6a:	fe042423          	sw	zero,-24(s0)
    crg.handleEx.clk1MDiv = (25 - 1); /* The 1 MHz freq is equal to the input clock frequency / (clk_1m_div + 1). */
 300da6e:	47e1                	li	a5,24
 300da70:	fef42623          	sw	a5,-20(s0)

    if (HAL_CRG_Init(&crg) != BASE_STATUS_OK) {
 300da74:	fc840793          	addi	a5,s0,-56
 300da78:	853e                	mv	a0,a5
 300da7a:	fb9f60ef          	jal	ra,3004a32 <HAL_CRG_Init>
 300da7e:	87aa                	mv	a5,a0
 300da80:	c399                	beqz	a5,300da86 <CRG_Config+0x54>
        return BASE_STATUS_ERROR;
 300da82:	4785                	li	a5,1
 300da84:	a039                	j	300da92 <CRG_Config+0x60>
    }
    *coreClkSelect = crg.coreClkSelect;
 300da86:	fe042703          	lw	a4,-32(s0)
 300da8a:	fbc42783          	lw	a5,-68(s0)
 300da8e:	c398                	sw	a4,0(a5)
    return BASE_STATUS_OK;
 300da90:	4781                	li	a5,0
}
 300da92:	853e                	mv	a0,a5
 300da94:	40b6                	lw	ra,76(sp)
 300da96:	4426                	lw	s0,72(sp)
 300da98:	6161                	addi	sp,sp,80
 300da9a:	8082                	ret

0300da9c <ADC0_Init>:

static void ADC0_Init(void)
{
 300da9c:	7179                	addi	sp,sp,-48
 300da9e:	d606                	sw	ra,44(sp)
 300daa0:	d422                	sw	s0,40(sp)
 300daa2:	1800                	addi	s0,sp,48
    HAL_CRG_IpEnableSet(ADC0_BASE, IP_CLK_ENABLE);
 300daa4:	4585                	li	a1,1
 300daa6:	18000537          	lui	a0,0x18000
 300daaa:	2301                	jal	ra,300dfaa <HAL_CRG_IpEnableSet.trans.20>
    HAL_CRG_IpClkSelectSet(ADC0_BASE, CRG_ADC_CLK_ASYN_PLL_DIV);
 300daac:	4589                	li	a1,2
 300daae:	18000537          	lui	a0,0x18000
 300dab2:	e28f70ef          	jal	ra,30050da <HAL_CRG_IpClkSelectSet>
    HAL_CRG_IpClkDivSet(ADC0_BASE, CRG_ADC_DIV_1);
 300dab6:	4581                	li	a1,0
 300dab8:	18000537          	lui	a0,0x18000
 300dabc:	ed0f70ef          	jal	ra,300518c <HAL_CRG_IpClkDivSet>

    g_adc0.baseAddress = ADC0;
 300dac0:	33e18793          	addi	a5,gp,830 # 4000c48 <g_adc0>
 300dac4:	18000737          	lui	a4,0x18000
 300dac8:	c398                	sw	a4,0(a5)
    g_adc0.socPriority = ADC_PRIMODE_ALL_ROUND;
 300daca:	33e18793          	addi	a5,gp,830 # 4000c48 <g_adc0>
 300dace:	0007a223          	sw	zero,4(a5) # 10000004 <RAM_END+0xbff8004>

    HAL_ADC_Init(&g_adc0);
 300dad2:	33e18513          	addi	a0,gp,830 # 4000c48 <g_adc0>
 300dad6:	bbff30ef          	jal	ra,3001694 <HAL_ADC_Init>

    SOC_Param socParam = {0};
 300dada:	fc042e23          	sw	zero,-36(s0)
 300dade:	fe042023          	sw	zero,-32(s0)
 300dae2:	fe042223          	sw	zero,-28(s0)
 300dae6:	fe042423          	sw	zero,-24(s0)
 300daea:	fe042623          	sw	zero,-20(s0)
    socParam.adcInput = ADC_CH_ADCINA12; /* PIN10(ADC AIN12) */
 300daee:	47b1                	li	a5,12
 300daf0:	fcf42e23          	sw	a5,-36(s0)
    socParam.sampleTotalTime = ADC_SOCSAMPLE_5CLK; /* adc sample total time 5 adc_clk */
 300daf4:	fe042023          	sw	zero,-32(s0)
    socParam.trigSource = ADC_TRIGSOC_SOFT;
 300daf8:	fe042223          	sw	zero,-28(s0)
    socParam.continueMode = BASE_CFG_DISABLE;
 300dafc:	fe040423          	sb	zero,-24(s0)
    socParam.finishMode = ADC_SOCFINISH_NONE;
 300db00:	4785                	li	a5,1
 300db02:	fef42623          	sw	a5,-20(s0)
    HAL_ADC_ConfigureSoc(&g_adc0, ADC_SOC_NUM1, &socParam);
 300db06:	fdc40793          	addi	a5,s0,-36
 300db0a:	863e                	mv	a2,a5
 300db0c:	4585                	li	a1,1
 300db0e:	33e18513          	addi	a0,gp,830 # 4000c48 <g_adc0>
 300db12:	c37f30ef          	jal	ra,3001748 <HAL_ADC_ConfigureSoc>
}
 300db16:	0001                	nop
 300db18:	50b2                	lw	ra,44(sp)
 300db1a:	5422                	lw	s0,40(sp)
 300db1c:	6145                	addi	sp,sp,48
 300db1e:	8082                	ret

0300db20 <APT0_Init>:

static void APT0_Init(void)
{
 300db20:	1141                	addi	sp,sp,-16
 300db22:	c606                	sw	ra,12(sp)
 300db24:	c422                	sw	s0,8(sp)
 300db26:	0800                	addi	s0,sp,16
    HAL_CRG_IpEnableSet(APT0_BASE, IP_CLK_ENABLE);
 300db28:	4585                	li	a1,1
 300db2a:	14a00537          	lui	a0,0x14a00
 300db2e:	29b5                	jal	ra,300dfaa <HAL_CRG_IpEnableSet.trans.20>

    g_apt0.baseAddress = APT0;
 300db30:	27e18793          	addi	a5,gp,638 # 4000b88 <g_apt0>
 300db34:	14a00737          	lui	a4,0x14a00
 300db38:	c398                	sw	a4,0(a5)

    /* Clock Settings */
    g_apt0.waveform.dividerFactor = 1 - 1;
 300db3a:	27e18793          	addi	a5,gp,638 # 4000b88 <g_apt0>
 300db3e:	00079a23          	sh	zero,20(a5)
    /* Timer Settings */
    g_apt0.waveform.timerPeriod = 1500;
 300db42:	27e18793          	addi	a5,gp,638 # 4000b88 <g_apt0>
 300db46:	5dc00713          	li	a4,1500
 300db4a:	abfa                	sh	a4,22(a5)
    g_apt0.waveform.cntMode = APT_COUNT_MODE_UP_DOWN;
 300db4c:	27e18793          	addi	a5,gp,638 # 4000b88 <g_apt0>
 300db50:	4709                	li	a4,2
 300db52:	cb98                	sw	a4,16(a5)

    /* Wave Form */
    g_apt0.waveform.basicType = APT_PWM_BASIC_A_HIGH_B_LOW;
 300db54:	27e18793          	addi	a5,gp,638 # 4000b88 <g_apt0>
 300db58:	0007a223          	sw	zero,4(a5)
    g_apt0.waveform.chAOutType = APT_PWM_OUT_BASIC_TYPE;
 300db5c:	27e18793          	addi	a5,gp,638 # 4000b88 <g_apt0>
 300db60:	0007a423          	sw	zero,8(a5)
    g_apt0.waveform.chBOutType = APT_PWM_OUT_BASIC_TYPE;
 300db64:	27e18793          	addi	a5,gp,638 # 4000b88 <g_apt0>
 300db68:	0007a623          	sw	zero,12(a5)
    g_apt0.waveform.divInitVal = 0;
 300db6c:	27e18793          	addi	a5,gp,638 # 4000b88 <g_apt0>
 300db70:	00079c23          	sh	zero,24(a5)
    g_apt0.waveform.cntInitVal = 0;
 300db74:	27e18793          	addi	a5,gp,638 # 4000b88 <g_apt0>
 300db78:	00079d23          	sh	zero,26(a5)
    g_apt0.waveform.cntCmpLeftEdge = 250;
 300db7c:	27e18793          	addi	a5,gp,638 # 4000b88 <g_apt0>
 300db80:	0fa00713          	li	a4,250
 300db84:	afda                	sh	a4,28(a5)
    g_apt0.waveform.cntCmpRightEdge = 250;
 300db86:	27e18793          	addi	a5,gp,638 # 4000b88 <g_apt0>
 300db8a:	0fa00713          	li	a4,250
 300db8e:	affa                	sh	a4,30(a5)
    g_apt0.waveform.cntCmpLoadMode = APT_BUFFER_DISABLE;
 300db90:	27e18793          	addi	a5,gp,638 # 4000b88 <g_apt0>
 300db94:	0207a023          	sw	zero,32(a5)
    g_apt0.waveform.cntCmpLoadEvt = APT_COMPARE_LOAD_EVENT_ZERO;
 300db98:	27e18793          	addi	a5,gp,638 # 4000b88 <g_apt0>
 300db9c:	4705                	li	a4,1
 300db9e:	d3d8                	sw	a4,36(a5)
    g_apt0.waveform.deadBandCnt = 10;
 300dba0:	27e18793          	addi	a5,gp,638 # 4000b88 <g_apt0>
 300dba4:	4729                	li	a4,10
 300dba6:	b79a                	sh	a4,40(a5)

    HAL_APT_PWMInit(&g_apt0);
 300dba8:	27e18513          	addi	a0,gp,638 # 4000b88 <g_apt0>
 300dbac:	8b5f40ef          	jal	ra,3002460 <HAL_APT_PWMInit>
}
 300dbb0:	0001                	nop
 300dbb2:	40b2                	lw	ra,12(sp)
 300dbb4:	4422                	lw	s0,8(sp)
 300dbb6:	0141                	addi	sp,sp,16
 300dbb8:	8082                	ret

0300dbba <APT1_Init>:

static void APT1_Init(void)
{
 300dbba:	1141                	addi	sp,sp,-16
 300dbbc:	c606                	sw	ra,12(sp)
 300dbbe:	c422                	sw	s0,8(sp)
 300dbc0:	0800                	addi	s0,sp,16
    HAL_CRG_IpEnableSet(APT1_BASE, IP_CLK_ENABLE);
 300dbc2:	4585                	li	a1,1
 300dbc4:	14a01537          	lui	a0,0x14a01
 300dbc8:	26cd                	jal	ra,300dfaa <HAL_CRG_IpEnableSet.trans.20>

    g_apt1.baseAddress = APT1;
 300dbca:	2de18793          	addi	a5,gp,734 # 4000be8 <g_apt1>
 300dbce:	14a01737          	lui	a4,0x14a01
 300dbd2:	c398                	sw	a4,0(a5)

    /* Clock Settings */
    g_apt1.waveform.dividerFactor = 1 - 1;
 300dbd4:	2de18793          	addi	a5,gp,734 # 4000be8 <g_apt1>
 300dbd8:	00079a23          	sh	zero,20(a5)
    /* Timer Settings */
    g_apt1.waveform.timerPeriod = 1500;
 300dbdc:	2de18793          	addi	a5,gp,734 # 4000be8 <g_apt1>
 300dbe0:	5dc00713          	li	a4,1500
 300dbe4:	abfa                	sh	a4,22(a5)
    g_apt1.waveform.cntMode = APT_COUNT_MODE_UP_DOWN;
 300dbe6:	2de18793          	addi	a5,gp,734 # 4000be8 <g_apt1>
 300dbea:	4709                	li	a4,2
 300dbec:	cb98                	sw	a4,16(a5)

    /* Wave Form */
    g_apt1.waveform.basicType = APT_PWM_BASIC_A_HIGH_B_LOW;
 300dbee:	2de18793          	addi	a5,gp,734 # 4000be8 <g_apt1>
 300dbf2:	0007a223          	sw	zero,4(a5)
    g_apt1.waveform.chAOutType = APT_PWM_OUT_BASIC_TYPE;
 300dbf6:	2de18793          	addi	a5,gp,734 # 4000be8 <g_apt1>
 300dbfa:	0007a423          	sw	zero,8(a5)
    g_apt1.waveform.chBOutType = APT_PWM_OUT_BASIC_TYPE;
 300dbfe:	2de18793          	addi	a5,gp,734 # 4000be8 <g_apt1>
 300dc02:	0007a623          	sw	zero,12(a5)
    g_apt1.waveform.divInitVal = 0;
 300dc06:	2de18793          	addi	a5,gp,734 # 4000be8 <g_apt1>
 300dc0a:	00079c23          	sh	zero,24(a5)
    g_apt1.waveform.cntInitVal = 0;
 300dc0e:	2de18793          	addi	a5,gp,734 # 4000be8 <g_apt1>
 300dc12:	00079d23          	sh	zero,26(a5)
    g_apt1.waveform.cntCmpLeftEdge = 250;
 300dc16:	2de18793          	addi	a5,gp,734 # 4000be8 <g_apt1>
 300dc1a:	0fa00713          	li	a4,250
 300dc1e:	afda                	sh	a4,28(a5)
    g_apt1.waveform.cntCmpRightEdge = 250;
 300dc20:	2de18793          	addi	a5,gp,734 # 4000be8 <g_apt1>
 300dc24:	0fa00713          	li	a4,250
 300dc28:	affa                	sh	a4,30(a5)
    g_apt1.waveform.cntCmpLoadMode = APT_BUFFER_DISABLE;
 300dc2a:	2de18793          	addi	a5,gp,734 # 4000be8 <g_apt1>
 300dc2e:	0207a023          	sw	zero,32(a5)
    g_apt1.waveform.cntCmpLoadEvt = APT_COMPARE_LOAD_EVENT_ZERO;
 300dc32:	2de18793          	addi	a5,gp,734 # 4000be8 <g_apt1>
 300dc36:	4705                	li	a4,1
 300dc38:	d3d8                	sw	a4,36(a5)
    g_apt1.waveform.deadBandCnt = 10;
 300dc3a:	2de18793          	addi	a5,gp,734 # 4000be8 <g_apt1>
 300dc3e:	4729                	li	a4,10
 300dc40:	b79a                	sh	a4,40(a5)

    HAL_APT_PWMInit(&g_apt1);
 300dc42:	2de18513          	addi	a0,gp,734 # 4000be8 <g_apt1>
 300dc46:	81bf40ef          	jal	ra,3002460 <HAL_APT_PWMInit>
}
 300dc4a:	0001                	nop
 300dc4c:	40b2                	lw	ra,12(sp)
 300dc4e:	4422                	lw	s0,8(sp)
 300dc50:	0141                	addi	sp,sp,16
 300dc52:	8082                	ret

0300dc54 <CAN_Init>:

static void CAN_Init(void){
 300dc54:	1141                	addi	sp,sp,-16
 300dc56:	c606                	sw	ra,12(sp)
 300dc58:	c422                	sw	s0,8(sp)
 300dc5a:	0800                	addi	s0,sp,16
    HAL_CRG_IpEnableSet(CAN_BASE, IP_CLK_ENABLE);
 300dc5c:	4585                	li	a1,1
 300dc5e:	14600537          	lui	a0,0x14600
 300dc62:	26a1                	jal	ra,300dfaa <HAL_CRG_IpEnableSet.trans.20>

    g_can.baseAddress = CAN;
 300dc64:	de218793          	addi	a5,gp,-542 # 40006ec <g_can>
 300dc68:	14600737          	lui	a4,0x14600
 300dc6c:	c398                	sw	a4,0(a5)

    g_can.typeMode = CAN_MODE_NORMAL;
 300dc6e:	de218793          	addi	a5,gp,-542 # 40006ec <g_can>
 300dc72:	0007a223          	sw	zero,4(a5)
    g_can.seg1Phase = CAN_SEG1_5TQ;
 300dc76:	de218793          	addi	a5,gp,-542 # 40006ec <g_can>
 300dc7a:	4715                	li	a4,5
 300dc7c:	c7d8                	sw	a4,12(a5)
    g_can.seg2Phase = CAN_SEG2_4TQ;
 300dc7e:	de218793          	addi	a5,gp,-542 # 40006ec <g_can>
 300dc82:	4711                	li	a4,4
 300dc84:	cb98                	sw	a4,16(a5)
    g_can.sjw = CAN_SJW_1TQ; // 2
 300dc86:	de218793          	addi	a5,gp,-542 # 40006ec <g_can>
 300dc8a:	4705                	li	a4,1
 300dc8c:	cf98                	sw	a4,24(a5)
    g_can.prescalser = 5;  /* 25 is frequency division coefficient */
 300dc8e:	de218793          	addi	a5,gp,-542 # 40006ec <g_can>
 300dc92:	4715                	li	a4,5
 300dc94:	cbd8                	sw	a4,20(a5)
    g_can.rxFIFODepth = 4;  /* A maximum of 4 packet objects are in RX FIFO */ 
 300dc96:	de218793          	addi	a5,gp,-542 # 40006ec <g_can>
 300dc9a:	4711                	li	a4,4
 300dc9c:	d798                	sw	a4,40(a5)
    g_can.autoRetrans = BASE_CFG_ENABLE;
 300dc9e:	de218793          	addi	a5,gp,-542 # 40006ec <g_can>
 300dca2:	4705                	li	a4,1
 300dca4:	02e78623          	sb	a4,44(a5)
    HAL_CAN_Init(&g_can);
 300dca8:	de218513          	addi	a0,gp,-542 # 40006ec <g_can>
 300dcac:	c77f50ef          	jal	ra,3003922 <HAL_CAN_Init>

    HAL_CAN_RegisterCallBack(&g_can, CAN_WRITE_FINISH, (CAN_CallbackType)CANWriteCallbackFunc);
 300dcb0:	0300c7b7          	lui	a5,0x300c
 300dcb4:	dc678613          	addi	a2,a5,-570 # 300bdc6 <CANWriteCallbackFunc>
 300dcb8:	4581                	li	a1,0
 300dcba:	de218513          	addi	a0,gp,-542 # 40006ec <g_can>
 300dcbe:	2889                	jal	ra,300dd10 <HAL_CAN_RegisterCallBack.trans.46>
    HAL_CAN_RegisterCallBack(&g_can, CAN_READ_FINISH, (CAN_CallbackType)CANReadCallbackFunc);
 300dcc0:	0300c7b7          	lui	a5,0x300c
 300dcc4:	dec78613          	addi	a2,a5,-532 # 300bdec <CANReadCallbackFunc>
 300dcc8:	4585                	li	a1,1
 300dcca:	de218513          	addi	a0,gp,-542 # 40006ec <g_can>
 300dcce:	2089                	jal	ra,300dd10 <HAL_CAN_RegisterCallBack.trans.46>
    HAL_CAN_RegisterCallBack(&g_can, CAN_TRNS_ERROR, (CAN_CallbackType)CANTransCallbackFunc);
 300dcd0:	0300e7b7          	lui	a5,0x300e
 300dcd4:	d1478613          	addi	a2,a5,-748 # 300dd14 <CANTransCallbackFunc>
 300dcd8:	4589                	li	a1,2
 300dcda:	de218513          	addi	a0,gp,-542 # 40006ec <g_can>
 300dcde:	280d                	jal	ra,300dd10 <HAL_CAN_RegisterCallBack.trans.46>

    IRQ_Register(IRQ_CAN, HAL_CAN_IrqHandler, &g_can);
 300dce0:	de218613          	addi	a2,gp,-542 # 40006ec <g_can>
 300dce4:	030047b7          	lui	a5,0x3004
 300dce8:	4c078593          	addi	a1,a5,1216 # 30044c0 <HAL_CAN_IrqHandler>
 300dcec:	02e00513          	li	a0,46
 300dcf0:	a7ef50ef          	jal	ra,3002f6e <IRQ_Register>
    IRQ_SetPriority(IRQ_CAN, 2);
 300dcf4:	4589                	li	a1,2
 300dcf6:	02e00513          	li	a0,46
 300dcfa:	a8ff50ef          	jal	ra,3003788 <IRQ_SetPriority>
    IRQ_EnableN(IRQ_CAN);
 300dcfe:	02e00513          	li	a0,46
 300dd02:	af2f50ef          	jal	ra,3002ff4 <IRQ_EnableN>
}
 300dd06:	0001                	nop
 300dd08:	40b2                	lw	ra,12(sp)
 300dd0a:	4422                	lw	s0,8(sp)
 300dd0c:	0141                	addi	sp,sp,16
 300dd0e:	8082                	ret

0300dd10 <HAL_CAN_RegisterCallBack.trans.46>:
 300dd10:	8b3f606f          	j	30045c2 <HAL_CAN_RegisterCallBack>

0300dd14 <CANTransCallbackFunc>:

__weak void CANReadCallbackFunc(void* handle){
    BASE_FUNC_UNUSED(handle);
}

__weak void CANTransCallbackFunc(void* handle){
 300dd14:	1101                	addi	sp,sp,-32
 300dd16:	ce22                	sw	s0,28(sp)
 300dd18:	1000                	addi	s0,sp,32
 300dd1a:	fea42623          	sw	a0,-20(s0)
    BASE_FUNC_UNUSED(handle);
}
 300dd1e:	0001                	nop
 300dd20:	4472                	lw	s0,28(sp)
 300dd22:	6105                	addi	sp,sp,32
 300dd24:	8082                	ret

0300dd26 <GPIO_Init>:

static void GPIO_Init(void)
{
 300dd26:	1141                	addi	sp,sp,-16
 300dd28:	c606                	sw	ra,12(sp)
 300dd2a:	c422                	sw	s0,8(sp)
 300dd2c:	0800                	addi	s0,sp,16
    HAL_CRG_IpEnableSet(GPIO1_BASE, IP_CLK_ENABLE);
 300dd2e:	4585                	li	a1,1
 300dd30:	14501537          	lui	a0,0x14501
 300dd34:	2c9d                	jal	ra,300dfaa <HAL_CRG_IpEnableSet.trans.20>
    g_gpio1.baseAddress = GPIO1;
 300dd36:	3de18793          	addi	a5,gp,990 # 4000ce8 <g_gpio1>
 300dd3a:	14501737          	lui	a4,0x14501
 300dd3e:	c398                	sw	a4,0(a5)

    g_gpio1.pins = GPIO_PIN_0 | GPIO_PIN_1;
 300dd40:	3de18793          	addi	a5,gp,990 # 4000ce8 <g_gpio1>
 300dd44:	470d                	li	a4,3
 300dd46:	c3d8                	sw	a4,4(a5)
    HAL_GPIO_Init(&g_gpio1);
 300dd48:	3de18513          	addi	a0,gp,990 # 4000ce8 <g_gpio1>
 300dd4c:	2a05                	jal	ra,300de7c <HAL_GPIO_Init.trans.47>
    HAL_GPIO_SetDirection(&g_gpio1, g_gpio1.pins, GPIO_INPUT_MODE);
 300dd4e:	3de18793          	addi	a5,gp,990 # 4000ce8 <g_gpio1>
 300dd52:	43dc                	lw	a5,4(a5)
 300dd54:	4601                	li	a2,0
 300dd56:	85be                	mv	a1,a5
 300dd58:	3de18513          	addi	a0,gp,990 # 4000ce8 <g_gpio1>
 300dd5c:	2a31                	jal	ra,300de78 <HAL_GPIO_SetDirection.trans.48>
    HAL_GPIO_SetValue(&g_gpio1, g_gpio1.pins, GPIO_LOW_LEVEL);
 300dd5e:	3de18793          	addi	a5,gp,990 # 4000ce8 <g_gpio1>
 300dd62:	43dc                	lw	a5,4(a5)
 300dd64:	4601                	li	a2,0
 300dd66:	85be                	mv	a1,a5
 300dd68:	3de18513          	addi	a0,gp,990 # 4000ce8 <g_gpio1>
 300dd6c:	2a11                	jal	ra,300de80 <HAL_GPIO_SetValue.trans.35>
    HAL_GPIO_SetIrqType(&g_gpio1, g_gpio1.pins, GPIO_INT_TYPE_RISE_EDGE);
 300dd6e:	3de18793          	addi	a5,gp,990 # 4000ce8 <g_gpio1>
 300dd72:	43dc                	lw	a5,4(a5)
 300dd74:	4605                	li	a2,1
 300dd76:	85be                	mv	a1,a5
 300dd78:	3de18513          	addi	a0,gp,990 # 4000ce8 <g_gpio1>
 300dd7c:	28e5                	jal	ra,300de74 <HAL_GPIO_SetIrqType.trans.49>

    HAL_CRG_IpEnableSet(GPIO2_BASE, IP_CLK_ENABLE);
 300dd7e:	4585                	li	a1,1
 300dd80:	14502537          	lui	a0,0x14502
 300dd84:	241d                	jal	ra,300dfaa <HAL_CRG_IpEnableSet.trans.20>
    g_gpio2.baseAddress = GPIO2;
 300dd86:	42618793          	addi	a5,gp,1062 # 4000d30 <g_gpio2>
 300dd8a:	14502737          	lui	a4,0x14502
 300dd8e:	c398                	sw	a4,0(a5)

    g_gpio2.pins = GPIO_PIN_5 | GPIO_PIN_6 | GPIO_PIN_7;
 300dd90:	42618793          	addi	a5,gp,1062 # 4000d30 <g_gpio2>
 300dd94:	0e000713          	li	a4,224
 300dd98:	c3d8                	sw	a4,4(a5)
    HAL_GPIO_Init(&g_gpio2);
 300dd9a:	42618513          	addi	a0,gp,1062 # 4000d30 <g_gpio2>
 300dd9e:	28f9                	jal	ra,300de7c <HAL_GPIO_Init.trans.47>
    HAL_GPIO_SetDirection(&g_gpio2, g_gpio2.pins, GPIO_OUTPUT_MODE);
 300dda0:	42618793          	addi	a5,gp,1062 # 4000d30 <g_gpio2>
 300dda4:	43dc                	lw	a5,4(a5)
 300dda6:	4605                	li	a2,1
 300dda8:	85be                	mv	a1,a5
 300ddaa:	42618513          	addi	a0,gp,1062 # 4000d30 <g_gpio2>
 300ddae:	20e9                	jal	ra,300de78 <HAL_GPIO_SetDirection.trans.48>
    HAL_GPIO_SetValue(&g_gpio2, g_gpio2.pins, GPIO_HIGH_LEVEL);
 300ddb0:	42618793          	addi	a5,gp,1062 # 4000d30 <g_gpio2>
 300ddb4:	43dc                	lw	a5,4(a5)
 300ddb6:	4605                	li	a2,1
 300ddb8:	85be                	mv	a1,a5
 300ddba:	42618513          	addi	a0,gp,1062 # 4000d30 <g_gpio2>
 300ddbe:	20c9                	jal	ra,300de80 <HAL_GPIO_SetValue.trans.35>
    HAL_GPIO_SetIrqType(&g_gpio2, g_gpio2.pins, GPIO_INT_TYPE_NONE);
 300ddc0:	42618793          	addi	a5,gp,1062 # 4000d30 <g_gpio2>
 300ddc4:	43dc                	lw	a5,4(a5)
 300ddc6:	4615                	li	a2,5
 300ddc8:	85be                	mv	a1,a5
 300ddca:	42618513          	addi	a0,gp,1062 # 4000d30 <g_gpio2>
 300ddce:	205d                	jal	ra,300de74 <HAL_GPIO_SetIrqType.trans.49>

    HAL_CRG_IpEnableSet(GPIO5_BASE, IP_CLK_ENABLE);
 300ddd0:	4585                	li	a1,1
 300ddd2:	14505537          	lui	a0,0x14505
 300ddd6:	2ad1                	jal	ra,300dfaa <HAL_CRG_IpEnableSet.trans.20>
    g_gpio5.baseAddress = GPIO5;
 300ddd8:	46e18793          	addi	a5,gp,1134 # 4000d78 <g_gpio5>
 300dddc:	14505737          	lui	a4,0x14505
 300dde0:	c398                	sw	a4,0(a5)

    g_gpio5.pins = GPIO_PIN_1;
 300dde2:	46e18793          	addi	a5,gp,1134 # 4000d78 <g_gpio5>
 300dde6:	4709                	li	a4,2
 300dde8:	c3d8                	sw	a4,4(a5)
    HAL_GPIO_Init(&g_gpio5);
 300ddea:	46e18513          	addi	a0,gp,1134 # 4000d78 <g_gpio5>
 300ddee:	2079                	jal	ra,300de7c <HAL_GPIO_Init.trans.47>
    HAL_GPIO_SetDirection(&g_gpio5, g_gpio5.pins, GPIO_OUTPUT_MODE);
 300ddf0:	46e18793          	addi	a5,gp,1134 # 4000d78 <g_gpio5>
 300ddf4:	43dc                	lw	a5,4(a5)
 300ddf6:	4605                	li	a2,1
 300ddf8:	85be                	mv	a1,a5
 300ddfa:	46e18513          	addi	a0,gp,1134 # 4000d78 <g_gpio5>
 300ddfe:	28ad                	jal	ra,300de78 <HAL_GPIO_SetDirection.trans.48>
    HAL_GPIO_SetValue(&g_gpio5, g_gpio5.pins, GPIO_LOW_LEVEL);
 300de00:	46e18793          	addi	a5,gp,1134 # 4000d78 <g_gpio5>
 300de04:	43dc                	lw	a5,4(a5)
 300de06:	4601                	li	a2,0
 300de08:	85be                	mv	a1,a5
 300de0a:	46e18513          	addi	a0,gp,1134 # 4000d78 <g_gpio5>
 300de0e:	288d                	jal	ra,300de80 <HAL_GPIO_SetValue.trans.35>
    HAL_GPIO_SetIrqType(&g_gpio5, g_gpio5.pins, GPIO_INT_TYPE_NONE);
 300de10:	46e18793          	addi	a5,gp,1134 # 4000d78 <g_gpio5>
 300de14:	43dc                	lw	a5,4(a5)
 300de16:	4615                	li	a2,5
 300de18:	85be                	mv	a1,a5
 300de1a:	46e18513          	addi	a0,gp,1134 # 4000d78 <g_gpio5>
 300de1e:	2899                	jal	ra,300de74 <HAL_GPIO_SetIrqType.trans.49>

    HAL_GPIO_RegisterCallBack(&g_gpio1, GPIO_PIN_0, GPIO1_0_CallbackFunc);
 300de20:	0300c7b7          	lui	a5,0x300c
 300de24:	d7278613          	addi	a2,a5,-654 # 300bd72 <GPIO1_0_CallbackFunc>
 300de28:	4585                	li	a1,1
 300de2a:	3de18513          	addi	a0,gp,990 # 4000ce8 <g_gpio1>
 300de2e:	acdf90ef          	jal	ra,30078fa <HAL_GPIO_RegisterCallBack>
    HAL_GPIO_RegisterCallBack(&g_gpio1, GPIO_PIN_1, GPIO1_1_CallbackFunc);
 300de32:	0300c7b7          	lui	a5,0x300c
 300de36:	d9c78613          	addi	a2,a5,-612 # 300bd9c <GPIO1_1_CallbackFunc>
 300de3a:	4589                	li	a1,2
 300de3c:	3de18513          	addi	a0,gp,990 # 4000ce8 <g_gpio1>
 300de40:	abbf90ef          	jal	ra,30078fa <HAL_GPIO_RegisterCallBack>
    IRQ_Register(IRQ_GPIO1, HAL_GPIO_IrqHandler, &g_gpio1);
 300de44:	3de18613          	addi	a2,gp,990 # 4000ce8 <g_gpio1>
 300de48:	030077b7          	lui	a5,0x3007
 300de4c:	7f078593          	addi	a1,a5,2032 # 30077f0 <HAL_GPIO_IrqHandler>
 300de50:	06e00513          	li	a0,110
 300de54:	91af50ef          	jal	ra,3002f6e <IRQ_Register>
    IRQ_SetPriority(IRQ_GPIO1, 1); /* set gpio1 interrupt priority to 1, 1~15 */
 300de58:	4585                	li	a1,1
 300de5a:	06e00513          	li	a0,110
 300de5e:	92bf50ef          	jal	ra,3003788 <IRQ_SetPriority>
    IRQ_EnableN(IRQ_GPIO1); /* gpio interrupt enable */
 300de62:	06e00513          	li	a0,110
 300de66:	98ef50ef          	jal	ra,3002ff4 <IRQ_EnableN>

    return;
 300de6a:	0001                	nop
}
 300de6c:	40b2                	lw	ra,12(sp)
 300de6e:	4422                	lw	s0,8(sp)
 300de70:	0141                	addi	sp,sp,16
 300de72:	8082                	ret

0300de74 <HAL_GPIO_SetIrqType.trans.49>:
 300de74:	e68f906f          	j	30074dc <HAL_GPIO_SetIrqType>

0300de78 <HAL_GPIO_SetDirection.trans.48>:
 300de78:	b5ef906f          	j	30071d6 <HAL_GPIO_SetDirection>

0300de7c <HAL_GPIO_Init.trans.47>:
 300de7c:	a74f906f          	j	30070f0 <HAL_GPIO_Init>

0300de80 <HAL_GPIO_SetValue.trans.35>:
 300de80:	c3ef906f          	j	30072be <HAL_GPIO_SetValue>

0300de84 <GPT0_Init>:

static void GPT0_Init(void)
{
 300de84:	1141                	addi	sp,sp,-16
 300de86:	c606                	sw	ra,12(sp)
 300de88:	c422                	sw	s0,8(sp)
 300de8a:	0800                	addi	s0,sp,16
    HAL_CRG_IpEnableSet(GPT0_BASE, IP_CLK_ENABLE);
 300de8c:	4585                	li	a1,1
 300de8e:	14700537          	lui	a0,0x14700
 300de92:	2a21                	jal	ra,300dfaa <HAL_CRG_IpEnableSet.trans.20>

    g_gpt0.baseAddress = GPT0;
 300de94:	f3618793          	addi	a5,gp,-202 # 4000840 <g_gpt0>
 300de98:	14700737          	lui	a4,0x14700
 300de9c:	c398                	sw	a4,0(a5)
    g_gpt0.clockDiv = 500 - 1;  /* 1000 is the internal frequency division of GPT */
 300de9e:	f3618793          	addi	a5,gp,-202 # 4000840 <g_gpt0>
 300dea2:	1f300713          	li	a4,499
 300dea6:	c798                	sw	a4,8(a5)
    g_gpt0.period = 1000;  /* 2996 is the number of GPT counting cycles. */
 300dea8:	f3618793          	addi	a5,gp,-202 # 4000840 <g_gpt0>
 300deac:	3e800713          	li	a4,1000
 300deb0:	cfd8                	sw	a4,28(a5)
    g_gpt0.refA0.refdot = 1;  /* 1 is the value of PWM reference point A. */
 300deb2:	f3618793          	addi	a5,gp,-202 # 4000840 <g_gpt0>
 300deb6:	4705                	li	a4,1
 300deb8:	c7d8                	sw	a4,12(a5)
    g_gpt0.refA0.refAction = GPT_ACTION_OUTPUT_HIGH;  /* GPT Action High */
 300deba:	f3618793          	addi	a5,gp,-202 # 4000840 <g_gpt0>
 300debe:	4709                	li	a4,2
 300dec0:	cb98                	sw	a4,16(a5)
    g_gpt0.refB0.refdot = 76;  /* 76 is the value of PWM reference point B. */
 300dec2:	f3618793          	addi	a5,gp,-202 # 4000840 <g_gpt0>
 300dec6:	04c00713          	li	a4,76
 300deca:	cbd8                	sw	a4,20(a5)
    g_gpt0.refB0.refAction = GPT_ACTION_OUTPUT_LOW; /* GPT Action Low */
 300decc:	f3618793          	addi	a5,gp,-202 # 4000840 <g_gpt0>
 300ded0:	4705                	li	a4,1
 300ded2:	cf98                	sw	a4,24(a5)
    g_gpt0.bufLoad = BASE_CFG_ENABLE;
 300ded4:	f3618793          	addi	a5,gp,-202 # 4000840 <g_gpt0>
 300ded8:	4705                	li	a4,1
 300deda:	02e782a3          	sb	a4,37(a5)
    g_gpt0.pwmKeep = BASE_CFG_ENABLE;
 300dede:	f3618793          	addi	a5,gp,-202 # 4000840 <g_gpt0>
 300dee2:	4705                	li	a4,1
 300dee4:	02e78223          	sb	a4,36(a5)
    g_gpt0.handleEx.periodIntEnable = BASE_CFG_DISABLE;
 300dee8:	f3618793          	addi	a5,gp,-202 # 4000840 <g_gpt0>
 300deec:	02078823          	sb	zero,48(a5)
    g_gpt0.handleEx.outputFinIntEnable = BASE_CFG_DISABLE;
 300def0:	f3618793          	addi	a5,gp,-202 # 4000840 <g_gpt0>
 300def4:	020788a3          	sb	zero,49(a5)
    g_gpt0.triggleAdcOutFinish = BASE_CFG_DISABLE;
 300def8:	f3618793          	addi	a5,gp,-202 # 4000840 <g_gpt0>
 300defc:	020783a3          	sb	zero,39(a5)
    g_gpt0.triggleAdcPeriod = BASE_CFG_DISABLE;
 300df00:	f3618793          	addi	a5,gp,-202 # 4000840 <g_gpt0>
 300df04:	02078323          	sb	zero,38(a5)

    HAL_GPT_Init(&g_gpt0);
 300df08:	f3618513          	addi	a0,gp,-202 # 4000840 <g_gpt0>
 300df0c:	22e1                	jal	ra,300e0d4 <HAL_GPT_Init.trans.44>
}
 300df0e:	0001                	nop
 300df10:	40b2                	lw	ra,12(sp)
 300df12:	4422                	lw	s0,8(sp)
 300df14:	0141                	addi	sp,sp,16
 300df16:	8082                	ret

0300df18 <GPT1_Init>:

static void GPT1_Init(void)
{
 300df18:	1141                	addi	sp,sp,-16
 300df1a:	c606                	sw	ra,12(sp)
 300df1c:	c422                	sw	s0,8(sp)
 300df1e:	0800                	addi	s0,sp,16
    HAL_CRG_IpEnableSet(GPT1_BASE, IP_CLK_ENABLE);
 300df20:	4585                	li	a1,1
 300df22:	14701537          	lui	a0,0x14701
 300df26:	2051                	jal	ra,300dfaa <HAL_CRG_IpEnableSet.trans.20>

    g_gpt1.baseAddress = GPT1;
 300df28:	f6a18793          	addi	a5,gp,-150 # 4000874 <g_gpt1>
 300df2c:	14701737          	lui	a4,0x14701
 300df30:	c398                	sw	a4,0(a5)
    g_gpt1.clockDiv = 500 - 1;  /* 1000 is the internal frequency division of GPT */
 300df32:	f6a18793          	addi	a5,gp,-150 # 4000874 <g_gpt1>
 300df36:	1f300713          	li	a4,499
 300df3a:	c798                	sw	a4,8(a5)
    g_gpt1.period = 1000 - 1;  /* 49999 is the number of GPT counting cycles. */
 300df3c:	f6a18793          	addi	a5,gp,-150 # 4000874 <g_gpt1>
 300df40:	3e700713          	li	a4,999
 300df44:	cfd8                	sw	a4,28(a5)
    g_gpt1.refA0.refdot = 1;  /* 10000 is the value of PWM reference point A. */
 300df46:	f6a18793          	addi	a5,gp,-150 # 4000874 <g_gpt1>
 300df4a:	4705                	li	a4,1
 300df4c:	c7d8                	sw	a4,12(a5)
    g_gpt1.refA0.refAction = GPT_ACTION_OUTPUT_HIGH;  /* GPT Action High */
 300df4e:	f6a18793          	addi	a5,gp,-150 # 4000874 <g_gpt1>
 300df52:	4709                	li	a4,2
 300df54:	cb98                	sw	a4,16(a5)
    g_gpt1.refB0.refdot = 2;  /* 30000 is the value of PWM reference point B. */
 300df56:	f6a18793          	addi	a5,gp,-150 # 4000874 <g_gpt1>
 300df5a:	4709                	li	a4,2
 300df5c:	cbd8                	sw	a4,20(a5)
    g_gpt1.refB0.refAction = GPT_ACTION_OUTPUT_LOW; /* GPT Action Low */
 300df5e:	f6a18793          	addi	a5,gp,-150 # 4000874 <g_gpt1>
 300df62:	4705                	li	a4,1
 300df64:	cf98                	sw	a4,24(a5)
    g_gpt1.bufLoad = BASE_CFG_ENABLE;
 300df66:	f6a18793          	addi	a5,gp,-150 # 4000874 <g_gpt1>
 300df6a:	4705                	li	a4,1
 300df6c:	02e782a3          	sb	a4,37(a5)
    g_gpt1.pwmKeep = BASE_CFG_ENABLE;
 300df70:	f6a18793          	addi	a5,gp,-150 # 4000874 <g_gpt1>
 300df74:	4705                	li	a4,1
 300df76:	02e78223          	sb	a4,36(a5)
    g_gpt1.handleEx.periodIntEnable = BASE_CFG_DISABLE;
 300df7a:	f6a18793          	addi	a5,gp,-150 # 4000874 <g_gpt1>
 300df7e:	02078823          	sb	zero,48(a5)
    g_gpt1.handleEx.outputFinIntEnable = BASE_CFG_DISABLE;
 300df82:	f6a18793          	addi	a5,gp,-150 # 4000874 <g_gpt1>
 300df86:	020788a3          	sb	zero,49(a5)
    g_gpt1.triggleAdcOutFinish = BASE_CFG_DISABLE;
 300df8a:	f6a18793          	addi	a5,gp,-150 # 4000874 <g_gpt1>
 300df8e:	020783a3          	sb	zero,39(a5)
    g_gpt1.triggleAdcPeriod = BASE_CFG_DISABLE;
 300df92:	f6a18793          	addi	a5,gp,-150 # 4000874 <g_gpt1>
 300df96:	02078323          	sb	zero,38(a5)

    HAL_GPT_Init(&g_gpt1);
 300df9a:	f6a18513          	addi	a0,gp,-150 # 4000874 <g_gpt1>
 300df9e:	2a1d                	jal	ra,300e0d4 <HAL_GPT_Init.trans.44>
}
 300dfa0:	0001                	nop
 300dfa2:	40b2                	lw	ra,12(sp)
 300dfa4:	4422                	lw	s0,8(sp)
 300dfa6:	0141                	addi	sp,sp,16
 300dfa8:	8082                	ret

0300dfaa <HAL_CRG_IpEnableSet.trans.20>:
 300dfaa:	85cf706f          	j	3005006 <HAL_CRG_IpEnableSet>

0300dfae <GPT2_Init>:

static void GPT2_Init(void)
{
 300dfae:	1141                	addi	sp,sp,-16
 300dfb0:	c606                	sw	ra,12(sp)
 300dfb2:	c422                	sw	s0,8(sp)
 300dfb4:	0800                	addi	s0,sp,16
    HAL_CRG_IpEnableSet(GPT2_BASE, IP_CLK_ENABLE);
 300dfb6:	4585                	li	a1,1
 300dfb8:	14702537          	lui	a0,0x14702
 300dfbc:	37fd                	jal	ra,300dfaa <HAL_CRG_IpEnableSet.trans.20>

    g_gpt2.baseAddress = GPT2;
 300dfbe:	f9e18793          	addi	a5,gp,-98 # 40008a8 <g_gpt2>
 300dfc2:	14702737          	lui	a4,0x14702
 300dfc6:	c398                	sw	a4,0(a5)
    g_gpt2.clockDiv = 500 - 1;  /* 1000 is the internal frequency division of GPT */
 300dfc8:	f9e18793          	addi	a5,gp,-98 # 40008a8 <g_gpt2>
 300dfcc:	1f300713          	li	a4,499
 300dfd0:	c798                	sw	a4,8(a5)
    g_gpt2.period = 1000 - 1;  /* 49999 is the number of GPT counting cycles. */
 300dfd2:	f9e18793          	addi	a5,gp,-98 # 40008a8 <g_gpt2>
 300dfd6:	3e700713          	li	a4,999
 300dfda:	cfd8                	sw	a4,28(a5)
    g_gpt2.refA0.refdot = 1;  /* 10000 is the value of PWM reference point A. */
 300dfdc:	f9e18793          	addi	a5,gp,-98 # 40008a8 <g_gpt2>
 300dfe0:	4705                	li	a4,1
 300dfe2:	c7d8                	sw	a4,12(a5)
    g_gpt2.refA0.refAction = GPT_ACTION_OUTPUT_HIGH;  /* GPT Action High */
 300dfe4:	f9e18793          	addi	a5,gp,-98 # 40008a8 <g_gpt2>
 300dfe8:	4709                	li	a4,2
 300dfea:	cb98                	sw	a4,16(a5)
    g_gpt2.refB0.refdot = 2;  /* 30000 is the value of PWM reference point B. */
 300dfec:	f9e18793          	addi	a5,gp,-98 # 40008a8 <g_gpt2>
 300dff0:	4709                	li	a4,2
 300dff2:	cbd8                	sw	a4,20(a5)
    g_gpt2.refB0.refAction = GPT_ACTION_OUTPUT_LOW; /* GPT Action Low */
 300dff4:	f9e18793          	addi	a5,gp,-98 # 40008a8 <g_gpt2>
 300dff8:	4705                	li	a4,1
 300dffa:	cf98                	sw	a4,24(a5)
    g_gpt2.bufLoad = BASE_CFG_ENABLE;
 300dffc:	f9e18793          	addi	a5,gp,-98 # 40008a8 <g_gpt2>
 300e000:	4705                	li	a4,1
 300e002:	02e782a3          	sb	a4,37(a5)
    g_gpt2.pwmKeep = BASE_CFG_ENABLE;
 300e006:	f9e18793          	addi	a5,gp,-98 # 40008a8 <g_gpt2>
 300e00a:	4705                	li	a4,1
 300e00c:	02e78223          	sb	a4,36(a5)
    g_gpt2.handleEx.periodIntEnable = BASE_CFG_DISABLE;
 300e010:	f9e18793          	addi	a5,gp,-98 # 40008a8 <g_gpt2>
 300e014:	02078823          	sb	zero,48(a5)
    g_gpt2.handleEx.outputFinIntEnable = BASE_CFG_DISABLE;
 300e018:	f9e18793          	addi	a5,gp,-98 # 40008a8 <g_gpt2>
 300e01c:	020788a3          	sb	zero,49(a5)
    g_gpt2.triggleAdcOutFinish = BASE_CFG_DISABLE;
 300e020:	f9e18793          	addi	a5,gp,-98 # 40008a8 <g_gpt2>
 300e024:	020783a3          	sb	zero,39(a5)
    g_gpt2.triggleAdcPeriod = BASE_CFG_DISABLE;
 300e028:	f9e18793          	addi	a5,gp,-98 # 40008a8 <g_gpt2>
 300e02c:	02078323          	sb	zero,38(a5)

    HAL_GPT_Init(&g_gpt2);
 300e030:	f9e18513          	addi	a0,gp,-98 # 40008a8 <g_gpt2>
 300e034:	2045                	jal	ra,300e0d4 <HAL_GPT_Init.trans.44>
}
 300e036:	0001                	nop
 300e038:	40b2                	lw	ra,12(sp)
 300e03a:	4422                	lw	s0,8(sp)
 300e03c:	0141                	addi	sp,sp,16
 300e03e:	8082                	ret

0300e040 <GPT3_Init>:

static void GPT3_Init(void)
{
 300e040:	1141                	addi	sp,sp,-16
 300e042:	c606                	sw	ra,12(sp)
 300e044:	c422                	sw	s0,8(sp)
 300e046:	0800                	addi	s0,sp,16
    HAL_CRG_IpEnableSet(GPT3_BASE, IP_CLK_ENABLE);
 300e048:	4585                	li	a1,1
 300e04a:	14703537          	lui	a0,0x14703
 300e04e:	3fb1                	jal	ra,300dfaa <HAL_CRG_IpEnableSet.trans.20>

    g_gpt3.baseAddress = GPT3;
 300e050:	fd218793          	addi	a5,gp,-46 # 40008dc <g_gpt3>
 300e054:	14703737          	lui	a4,0x14703
 300e058:	c398                	sw	a4,0(a5)
    g_gpt3.clockDiv = 500 - 1;  /* 1000 is the internal frequency division of GPT */
 300e05a:	fd218793          	addi	a5,gp,-46 # 40008dc <g_gpt3>
 300e05e:	1f300713          	li	a4,499
 300e062:	c798                	sw	a4,8(a5)
    g_gpt3.period = 1000 - 1;  /* 300 is the number of GPT counting cycles. */
 300e064:	fd218793          	addi	a5,gp,-46 # 40008dc <g_gpt3>
 300e068:	3e700713          	li	a4,999
 300e06c:	cfd8                	sw	a4,28(a5)
    g_gpt3.refA0.refdot = 1;  /* 100 is the value of PWM reference point A. */
 300e06e:	fd218793          	addi	a5,gp,-46 # 40008dc <g_gpt3>
 300e072:	4705                	li	a4,1
 300e074:	c7d8                	sw	a4,12(a5)
    g_gpt3.refA0.refAction = GPT_ACTION_OUTPUT_HIGH;  /* GPT Action High */
 300e076:	fd218793          	addi	a5,gp,-46 # 40008dc <g_gpt3>
 300e07a:	4709                	li	a4,2
 300e07c:	cb98                	sw	a4,16(a5)
    g_gpt3.refB0.refdot = 200;  /* 200 is the value of PWM reference point B. */
 300e07e:	fd218793          	addi	a5,gp,-46 # 40008dc <g_gpt3>
 300e082:	0c800713          	li	a4,200
 300e086:	cbd8                	sw	a4,20(a5)
    g_gpt3.refB0.refAction = GPT_ACTION_OUTPUT_LOW; /* GPT Action Low */
 300e088:	fd218793          	addi	a5,gp,-46 # 40008dc <g_gpt3>
 300e08c:	4705                	li	a4,1
 300e08e:	cf98                	sw	a4,24(a5)
    g_gpt3.bufLoad = BASE_CFG_ENABLE;
 300e090:	fd218793          	addi	a5,gp,-46 # 40008dc <g_gpt3>
 300e094:	4705                	li	a4,1
 300e096:	02e782a3          	sb	a4,37(a5)
    g_gpt3.pwmKeep = BASE_CFG_ENABLE;
 300e09a:	fd218793          	addi	a5,gp,-46 # 40008dc <g_gpt3>
 300e09e:	4705                	li	a4,1
 300e0a0:	02e78223          	sb	a4,36(a5)
    g_gpt3.handleEx.periodIntEnable = BASE_CFG_DISABLE;
 300e0a4:	fd218793          	addi	a5,gp,-46 # 40008dc <g_gpt3>
 300e0a8:	02078823          	sb	zero,48(a5)
    g_gpt3.handleEx.outputFinIntEnable = BASE_CFG_DISABLE;
 300e0ac:	fd218793          	addi	a5,gp,-46 # 40008dc <g_gpt3>
 300e0b0:	020788a3          	sb	zero,49(a5)
    g_gpt3.triggleAdcOutFinish = BASE_CFG_DISABLE;
 300e0b4:	fd218793          	addi	a5,gp,-46 # 40008dc <g_gpt3>
 300e0b8:	020783a3          	sb	zero,39(a5)
    g_gpt3.triggleAdcPeriod = BASE_CFG_DISABLE;
 300e0bc:	fd218793          	addi	a5,gp,-46 # 40008dc <g_gpt3>
 300e0c0:	02078323          	sb	zero,38(a5)

    HAL_GPT_Init(&g_gpt3);
 300e0c4:	fd218513          	addi	a0,gp,-46 # 40008dc <g_gpt3>
 300e0c8:	2031                	jal	ra,300e0d4 <HAL_GPT_Init.trans.44>
}
 300e0ca:	0001                	nop
 300e0cc:	40b2                	lw	ra,12(sp)
 300e0ce:	4422                	lw	s0,8(sp)
 300e0d0:	0141                	addi	sp,sp,16
 300e0d2:	8082                	ret

0300e0d4 <HAL_GPT_Init.trans.44>:
 300e0d4:	9edf906f          	j	3007ac0 <HAL_GPT_Init>

0300e0d8 <I2C0_Init>:

static void I2C0_Init(void)
{
 300e0d8:	1141                	addi	sp,sp,-16
 300e0da:	c606                	sw	ra,12(sp)
 300e0dc:	c422                	sw	s0,8(sp)
 300e0de:	0800                	addi	s0,sp,16
    HAL_CRG_IpEnableSet(I2C0_BASE, IP_CLK_ENABLE);
 300e0e0:	4585                	li	a1,1
 300e0e2:	14100537          	lui	a0,0x14100
 300e0e6:	35d1                	jal	ra,300dfaa <HAL_CRG_IpEnableSet.trans.20>
    HAL_CRG_IpClkSelectSet(I2C0_BASE, CRG_AHB_CLK_NO_PREDV);
 300e0e8:	4581                	li	a1,0
 300e0ea:	14100537          	lui	a0,0x14100
 300e0ee:	29e1                	jal	ra,300e5c6 <HAL_CRG_IpClkSelectSet.trans.29>

    g_i2c0.baseAddress = I2C0;
 300e0f0:	1ae18793          	addi	a5,gp,430 # 4000ab8 <g_i2c0>
 300e0f4:	14100737          	lui	a4,0x14100
 300e0f8:	c398                	sw	a4,0(a5)

    g_i2c0.functionMode = I2C_MODE_SELECT_MASTER_ONLY;
 300e0fa:	1ae18793          	addi	a5,gp,430 # 4000ab8 <g_i2c0>
 300e0fe:	4705                	li	a4,1
 300e100:	c3d8                	sw	a4,4(a5)
    g_i2c0.addrMode = I2C_7_BITS;
 300e102:	1ae18793          	addi	a5,gp,430 # 4000ab8 <g_i2c0>
 300e106:	0007a423          	sw	zero,8(a5)
    g_i2c0.sdaHoldTime = 10;
 300e10a:	1ae18793          	addi	a5,gp,430 # 4000ab8 <g_i2c0>
 300e10e:	4729                	li	a4,10
 300e110:	cb98                	sw	a4,16(a5)
    g_i2c0.freq = 400000;
 300e112:	1ae18793          	addi	a5,gp,430 # 4000ab8 <g_i2c0>
 300e116:	00062737          	lui	a4,0x62
 300e11a:	a8070713          	addi	a4,a4,-1408 # 61a80 <FLASH_SIZE+0x41a84>
 300e11e:	cbd8                	sw	a4,20(a5)
    g_i2c0.transferBuff = NULL;
 300e120:	1ae18793          	addi	a5,gp,430 # 4000ab8 <g_i2c0>
 300e124:	0207a023          	sw	zero,32(a5)
    g_i2c0.ignoreAckFlag = BASE_CFG_DISABLE;
 300e128:	1ae18793          	addi	a5,gp,430 # 4000ab8 <g_i2c0>
 300e12c:	0007ac23          	sw	zero,24(a5)
    g_i2c0.handleEx.spikeFilterTime = 0;
 300e130:	1ae18793          	addi	a5,gp,430 # 4000ab8 <g_i2c0>
 300e134:	0407ac23          	sw	zero,88(a5)
    g_i2c0.handleEx.sdaDelayTime = 0;
 300e138:	1ae18793          	addi	a5,gp,430 # 4000ab8 <g_i2c0>
 300e13c:	0407ae23          	sw	zero,92(a5)
    g_i2c0.timeout = 10000;
 300e140:	1ae18793          	addi	a5,gp,430 # 4000ab8 <g_i2c0>
 300e144:	6709                	lui	a4,0x2
 300e146:	71070713          	addi	a4,a4,1808 # 2710 <__bss_size__+0x167c>
 300e14a:	d7d8                	sw	a4,44(a5)
    g_i2c0.state = I2C_STATE_RESET;
 300e14c:	1ae18793          	addi	a5,gp,430 # 4000ab8 <g_i2c0>
 300e150:	0407a223          	sw	zero,68(a5)
    HAL_I2C_Init(&g_i2c0);
 300e154:	1ae18513          	addi	a0,gp,430 # 4000ab8 <g_i2c0>
 300e158:	b43fa0ef          	jal	ra,3008c9a <HAL_I2C_Init>
}
 300e15c:	0001                	nop
 300e15e:	40b2                	lw	ra,12(sp)
 300e160:	4422                	lw	s0,8(sp)
 300e162:	0141                	addi	sp,sp,16
 300e164:	8082                	ret

0300e166 <I2C1_Init>:

static void I2C1_Init(void)
{
 300e166:	1141                	addi	sp,sp,-16
 300e168:	c606                	sw	ra,12(sp)
 300e16a:	c422                	sw	s0,8(sp)
 300e16c:	0800                	addi	s0,sp,16
    HAL_CRG_IpEnableSet(I2C1_BASE, IP_CLK_ENABLE);
 300e16e:	4585                	li	a1,1
 300e170:	14101537          	lui	a0,0x14101
 300e174:	3d1d                	jal	ra,300dfaa <HAL_CRG_IpEnableSet.trans.20>
    HAL_CRG_IpClkSelectSet(I2C1_BASE, CRG_AHB_CLK_NO_PREDV);
 300e176:	4581                	li	a1,0
 300e178:	14101537          	lui	a0,0x14101
 300e17c:	21a9                	jal	ra,300e5c6 <HAL_CRG_IpClkSelectSet.trans.29>

    g_i2c1.baseAddress = I2C1;
 300e17e:	21618793          	addi	a5,gp,534 # 4000b20 <g_i2c1>
 300e182:	14101737          	lui	a4,0x14101
 300e186:	c398                	sw	a4,0(a5)

    g_i2c1.functionMode = I2C_MODE_SELECT_MASTER_ONLY;
 300e188:	21618793          	addi	a5,gp,534 # 4000b20 <g_i2c1>
 300e18c:	4705                	li	a4,1
 300e18e:	c3d8                	sw	a4,4(a5)
    g_i2c1.addrMode = I2C_7_BITS;
 300e190:	21618793          	addi	a5,gp,534 # 4000b20 <g_i2c1>
 300e194:	0007a423          	sw	zero,8(a5)
    g_i2c1.sdaHoldTime = 10;
 300e198:	21618793          	addi	a5,gp,534 # 4000b20 <g_i2c1>
 300e19c:	4729                	li	a4,10
 300e19e:	cb98                	sw	a4,16(a5)
    g_i2c1.freq = 200000;
 300e1a0:	21618793          	addi	a5,gp,534 # 4000b20 <g_i2c1>
 300e1a4:	00031737          	lui	a4,0x31
 300e1a8:	d4070713          	addi	a4,a4,-704 # 30d40 <FLASH_SIZE+0x10d44>
 300e1ac:	cbd8                	sw	a4,20(a5)
    g_i2c1.transferBuff = NULL;
 300e1ae:	21618793          	addi	a5,gp,534 # 4000b20 <g_i2c1>
 300e1b2:	0207a023          	sw	zero,32(a5)
    g_i2c1.ignoreAckFlag = BASE_CFG_DISABLE;
 300e1b6:	21618793          	addi	a5,gp,534 # 4000b20 <g_i2c1>
 300e1ba:	0007ac23          	sw	zero,24(a5)
    g_i2c1.handleEx.spikeFilterTime = 0;
 300e1be:	21618793          	addi	a5,gp,534 # 4000b20 <g_i2c1>
 300e1c2:	0407ac23          	sw	zero,88(a5)
    g_i2c1.handleEx.sdaDelayTime = 0;
 300e1c6:	21618793          	addi	a5,gp,534 # 4000b20 <g_i2c1>
 300e1ca:	0407ae23          	sw	zero,92(a5)
    g_i2c1.timeout = 10000;
 300e1ce:	21618793          	addi	a5,gp,534 # 4000b20 <g_i2c1>
 300e1d2:	6709                	lui	a4,0x2
 300e1d4:	71070713          	addi	a4,a4,1808 # 2710 <__bss_size__+0x167c>
 300e1d8:	d7d8                	sw	a4,44(a5)
    g_i2c1.state = I2C_STATE_RESET;
 300e1da:	21618793          	addi	a5,gp,534 # 4000b20 <g_i2c1>
 300e1de:	0407a223          	sw	zero,68(a5)
    HAL_I2C_Init(&g_i2c1);
 300e1e2:	21618513          	addi	a0,gp,534 # 4000b20 <g_i2c1>
 300e1e6:	ab5fa0ef          	jal	ra,3008c9a <HAL_I2C_Init>
}
 300e1ea:	0001                	nop
 300e1ec:	40b2                	lw	ra,12(sp)
 300e1ee:	4422                	lw	s0,8(sp)
 300e1f0:	0141                	addi	sp,sp,16
 300e1f2:	8082                	ret

0300e1f4 <QDM0PTUCycleCallback>:

__weak void QDM0PTUCycleCallback(void *handle)
{
 300e1f4:	1101                	addi	sp,sp,-32
 300e1f6:	ce22                	sw	s0,28(sp)
 300e1f8:	1000                	addi	s0,sp,32
 300e1fa:	fea42623          	sw	a0,-20(s0)
    BASE_FUNC_UNUSED(handle);
    /* USER CODE BEGIN QDM0_TSU_CYCLE */
    /* USER CODE END QDM0_TSU_CYCLE */
}
 300e1fe:	0001                	nop
 300e200:	4472                	lw	s0,28(sp)
 300e202:	6105                	addi	sp,sp,32
 300e204:	8082                	ret

0300e206 <QDM0ZIndexLockedCallback>:

__weak void QDM0ZIndexLockedCallback(void *handle)
{
 300e206:	1101                	addi	sp,sp,-32
 300e208:	ce22                	sw	s0,28(sp)
 300e20a:	1000                	addi	s0,sp,32
 300e20c:	fea42623          	sw	a0,-20(s0)
    BASE_FUNC_UNUSED(handle);
    /* USER CODE BEGIN QDM0_INDEX_LOCKED */
    /* USER CODE END QDM0_INDEX_LOCKED */
}
 300e210:	0001                	nop
 300e212:	4472                	lw	s0,28(sp)
 300e214:	6105                	addi	sp,sp,32
 300e216:	8082                	ret

0300e218 <QDM0QuadraturePhaseErrorCallback>:

__weak void QDM0QuadraturePhaseErrorCallback(void *handle)
{
 300e218:	1101                	addi	sp,sp,-32
 300e21a:	ce22                	sw	s0,28(sp)
 300e21c:	1000                	addi	s0,sp,32
 300e21e:	fea42623          	sw	a0,-20(s0)
    BASE_FUNC_UNUSED(handle);
    /* USER CODE QDM0_PHASE_ERROR */
    /* USER CODE QDM0_PHASE_ERROR */
}
 300e222:	0001                	nop
 300e224:	4472                	lw	s0,28(sp)
 300e226:	6105                	addi	sp,sp,32
 300e228:	8082                	ret

0300e22a <QDM0_Init>:

static void QDM0_Init(void)
{
 300e22a:	1141                	addi	sp,sp,-16
 300e22c:	c606                	sw	ra,12(sp)
 300e22e:	c422                	sw	s0,8(sp)
 300e230:	0800                	addi	s0,sp,16
    HAL_CRG_IpEnableSet(QDM0_BASE, IP_CLK_ENABLE);
 300e232:	4585                	li	a1,1
 300e234:	14c00537          	lui	a0,0x14c00
 300e238:	3b8d                	jal	ra,300dfaa <HAL_CRG_IpEnableSet.trans.20>

    g_qdm0.baseAddress = QDM0_BASE;
 300e23a:	e1e18793          	addi	a5,gp,-482 # 4000728 <g_qdm0>
 300e23e:	14c00737          	lui	a4,0x14c00
 300e242:	c398                	sw	a4,0(a5)

    /* emulation config */
    g_qdm0.emuMode = QDM_EMULATION_MODE_STOP_IMMEDIATELY;
 300e244:	e1e18793          	addi	a5,gp,-482 # 4000728 <g_qdm0>
 300e248:	0007a223          	sw	zero,4(a5)
    /* input config */
    g_qdm0.ctrlConfig.decoderMode = QDM_QUADRATURE_COUNT;
 300e24c:	e1e18793          	addi	a5,gp,-482 # 4000728 <g_qdm0>
 300e250:	0007aa23          	sw	zero,20(a5)
    g_qdm0.ctrlConfig.polarity = 0;
 300e254:	e1e18793          	addi	a5,gp,-482 # 4000728 <g_qdm0>
 300e258:	0207a423          	sw	zero,40(a5)
    g_qdm0.ctrlConfig.resolution = QDM_1X_RESOLUTION;
 300e25c:	e1e18793          	addi	a5,gp,-482 # 4000728 <g_qdm0>
 300e260:	0007ac23          	sw	zero,24(a5)
    g_qdm0.ctrlConfig.trgLockMode = QDM_TRG_BY_CYCLE;
 300e264:	e1e18793          	addi	a5,gp,-482 # 4000728 <g_qdm0>
 300e268:	4705                	li	a4,1
 300e26a:	cfd8                	sw	a4,28(a5)
    g_qdm0.ctrlConfig.swap = QDM_SWAP_DISABLE;
 300e26c:	e1e18793          	addi	a5,gp,-482 # 4000728 <g_qdm0>
 300e270:	0207a223          	sw	zero,36(a5)
    g_qdm0.ctrlConfig.ptuMode = QDM_PTU_MODE_CYCLE;
 300e274:	e1e18793          	addi	a5,gp,-482 # 4000728 <g_qdm0>
 300e278:	0207a023          	sw	zero,32(a5)
    /* filter config */
    g_qdm0.inputFilter.qdmAFilterLevel = 0;
 300e27c:	e1e18793          	addi	a5,gp,-482 # 4000728 <g_qdm0>
 300e280:	0007a423          	sw	zero,8(a5)
    g_qdm0.inputFilter.qdmBFilterLevel = 0;
 300e284:	e1e18793          	addi	a5,gp,-482 # 4000728 <g_qdm0>
 300e288:	0007a623          	sw	zero,12(a5)
    g_qdm0.inputFilter.qdmZFilterLevel = 0;
 300e28c:	e1e18793          	addi	a5,gp,-482 # 4000728 <g_qdm0>
 300e290:	0007a823          	sw	zero,16(a5)
    /* other config */
    g_qdm0.lock_mode = QDM_LOCK_RESERVE;
 300e294:	e1e18793          	addi	a5,gp,-482 # 4000728 <g_qdm0>
 300e298:	0607a023          	sw	zero,96(a5)
    g_qdm0.pcntMode = QDM_PCNT_MODE_BY_DIR;
 300e29c:	e1e18793          	addi	a5,gp,-482 # 4000728 <g_qdm0>
 300e2a0:	0207a623          	sw	zero,44(a5)
    //g_qdm0.pcntRstMode = QDM_PCNT_RST_BY_PTU;
    g_qdm0.pcntRstMode = QDM_PCNT_RST_OVF; // 单独调试脉冲数
 300e2a4:	e1e18793          	addi	a5,gp,-482 # 4000728 <g_qdm0>
 300e2a8:	4705                	li	a4,1
 300e2aa:	db98                	sw	a4,48(a5)
    g_qdm0.pcntIdxInitMode = QDM_IDX_INIT_DISABLE;
 300e2ac:	e1e18793          	addi	a5,gp,-482 # 4000728 <g_qdm0>
 300e2b0:	0207aa23          	sw	zero,52(a5)
    g_qdm0.qcMax = 4294967295;
 300e2b4:	e1e18793          	addi	a5,gp,-482 # 4000728 <g_qdm0>
 300e2b8:	577d                	li	a4,-1
 300e2ba:	c7f8                	sw	a4,76(a5)
    g_qdm0.subModeEn = true;
 300e2bc:	e1e18793          	addi	a5,gp,-482 # 4000728 <g_qdm0>
 300e2c0:	4705                	li	a4,1
 300e2c2:	02e78c23          	sb	a4,56(a5)
    g_qdm0.tsuPrescaler = 0;
 300e2c6:	e1e18793          	addi	a5,gp,-482 # 4000728 <g_qdm0>
 300e2ca:	0207ae23          	sw	zero,60(a5)
    g_qdm0.cevtPrescaler = QDM_CEVT_PRESCALER_DIVI1;
 300e2ce:	e1e18793          	addi	a5,gp,-482 # 4000728 <g_qdm0>
 300e2d2:	0407a023          	sw	zero,64(a5)
    //g_qdm0.posMax = 4294967295;
    g_qdm0.posMax = g_motorLineNum;    
 300e2d6:	8621a703          	lw	a4,-1950(gp) # 400016c <g_motorLineNum>
 300e2da:	e1e18793          	addi	a5,gp,-482 # 4000728 <g_qdm0>
 300e2de:	c7b8                	sw	a4,72(a5)
    g_qdm0.posInit = 0;
 300e2e0:	e1e18793          	addi	a5,gp,-482 # 4000728 <g_qdm0>
 300e2e4:	0407a223          	sw	zero,68(a5)
    g_qdm0.period = 150000000;
 300e2e8:	e1e18793          	addi	a5,gp,-482 # 4000728 <g_qdm0>
 300e2ec:	08f0d737          	lui	a4,0x8f0d
 300e2f0:	18070713          	addi	a4,a4,384 # 8f0d180 <RAM_END+0x4f05180>
 300e2f4:	cbb8                	sw	a4,80(a5)

    g_qdm0.motorLineNum = g_motorLineNum;  /* 设置编码器线数 */      
 300e2f6:	8621a783          	lw	a5,-1950(gp) # 400016c <g_motorLineNum>
 300e2fa:	873e                	mv	a4,a5
 300e2fc:	e1e18793          	addi	a5,gp,-482 # 4000728 <g_qdm0>
 300e300:	cfb8                	sw	a4,88(a5)
    //DBG_PRINTF("g_qdm0.motorLineNum:%d\r\n", g_qdm0.motorLineNum);
    g_qdm0.interruptEn = QDM_INT_WATCHDOG | 
 300e302:	e1e18793          	addi	a5,gp,-482 # 4000728 <g_qdm0>
 300e306:	30400713          	li	a4,772
 300e30a:	cbf8                	sw	a4,84(a5)
        QDM_INT_INDEX_EVNT_LATCH | 
        QDM_INT_UNIT_TIME_OUT;

    HAL_QDM_Init(&g_qdm0);
 300e30c:	e1e18513          	addi	a0,gp,-482 # 4000728 <g_qdm0>
 300e310:	a02fc0ef          	jal	ra,300a512 <HAL_QDM_Init>

    HAL_QDM_RegisterCallback(&g_qdm0, QDM_TSU_CYCLE, QDM0PTUCycleCallback);
 300e314:	0300e7b7          	lui	a5,0x300e
 300e318:	1f478613          	addi	a2,a5,500 # 300e1f4 <QDM0PTUCycleCallback>
 300e31c:	4581                	li	a1,0
 300e31e:	e1e18513          	addi	a0,gp,-482 # 4000728 <g_qdm0>
 300e322:	22e9                	jal	ra,300e4ec <HAL_QDM_RegisterCallback.trans.36>
    HAL_QDM_RegisterCallback(&g_qdm0, QDM_INDEX_LOCKED, QDM0ZIndexLockedCallback);
 300e324:	0300e7b7          	lui	a5,0x300e
 300e328:	20678613          	addi	a2,a5,518 # 300e206 <QDM0ZIndexLockedCallback>
 300e32c:	4589                	li	a1,2
 300e32e:	e1e18513          	addi	a0,gp,-482 # 4000728 <g_qdm0>
 300e332:	2a6d                	jal	ra,300e4ec <HAL_QDM_RegisterCallback.trans.36>
    HAL_QDM_RegisterCallback(&g_qdm0, QDM_PHASE_ERROR, QDM0QuadraturePhaseErrorCallback);
 300e334:	0300e7b7          	lui	a5,0x300e
 300e338:	21878613          	addi	a2,a5,536 # 300e218 <QDM0QuadraturePhaseErrorCallback>
 300e33c:	4591                	li	a1,4
 300e33e:	e1e18513          	addi	a0,gp,-482 # 4000728 <g_qdm0>
 300e342:	226d                	jal	ra,300e4ec <HAL_QDM_RegisterCallback.trans.36>
    IRQ_Register(IRQ_QDM0, HAL_QDM_IrqHandler, &g_qdm0);
 300e344:	e1e18613          	addi	a2,gp,-482 # 4000728 <g_qdm0>
 300e348:	0300a7b7          	lui	a5,0x300a
 300e34c:	28678593          	addi	a1,a5,646 # 300a286 <HAL_QDM_IrqHandler>
 300e350:	04900513          	li	a0,73
 300e354:	506000ef          	jal	ra,300e85a <IRQ_Register.trans.30>
    IRQ_SetPriority(IRQ_QDM0, 1);
 300e358:	4585                	li	a1,1
 300e35a:	04900513          	li	a0,73
 300e35e:	4f8000ef          	jal	ra,300e856 <IRQ_SetPriority.trans.31>
    IRQ_EnableN(IRQ_QDM0);
 300e362:	04900513          	li	a0,73
 300e366:	21f5                	jal	ra,300e852 <IRQ_EnableN.trans.32>
}
 300e368:	0001                	nop
 300e36a:	40b2                	lw	ra,12(sp)
 300e36c:	4422                	lw	s0,8(sp)
 300e36e:	0141                	addi	sp,sp,16
 300e370:	8082                	ret

0300e372 <QDM1PTUCycleCallback>:

__weak void QDM1PTUCycleCallback(void *handle)
{
 300e372:	1101                	addi	sp,sp,-32
 300e374:	ce22                	sw	s0,28(sp)
 300e376:	1000                	addi	s0,sp,32
 300e378:	fea42623          	sw	a0,-20(s0)
    BASE_FUNC_UNUSED(handle);
    /* USER CODE BEGIN QDM1_TSU_CYCLE */
    /* USER CODE END QDM1_TSU_CYCLE */
}
 300e37c:	0001                	nop
 300e37e:	4472                	lw	s0,28(sp)
 300e380:	6105                	addi	sp,sp,32
 300e382:	8082                	ret

0300e384 <QDM1ZIndexLockedCallback>:

__weak void QDM1ZIndexLockedCallback(void *handle)
{
 300e384:	1101                	addi	sp,sp,-32
 300e386:	ce22                	sw	s0,28(sp)
 300e388:	1000                	addi	s0,sp,32
 300e38a:	fea42623          	sw	a0,-20(s0)
    BASE_FUNC_UNUSED(handle);
    /* USER CODE BEGIN QDM1_INDEX_LOCKED */
    /* USER CODE END QDM1_INDEX_LOCKED */
}
 300e38e:	0001                	nop
 300e390:	4472                	lw	s0,28(sp)
 300e392:	6105                	addi	sp,sp,32
 300e394:	8082                	ret

0300e396 <QDM1QuadraturePhaseErrorCallback>:

__weak void QDM1QuadraturePhaseErrorCallback(void *handle)
{
 300e396:	1101                	addi	sp,sp,-32
 300e398:	ce22                	sw	s0,28(sp)
 300e39a:	1000                	addi	s0,sp,32
 300e39c:	fea42623          	sw	a0,-20(s0)
    BASE_FUNC_UNUSED(handle);
    /* USER CODE QDM1_PHASE_ERROR */
    /* USER CODE QDM1_PHASE_ERROR */
}
 300e3a0:	0001                	nop
 300e3a2:	4472                	lw	s0,28(sp)
 300e3a4:	6105                	addi	sp,sp,32
 300e3a6:	8082                	ret

0300e3a8 <QDM1_Init>:

static void QDM1_Init(void)
{
 300e3a8:	1141                	addi	sp,sp,-16
 300e3aa:	c606                	sw	ra,12(sp)
 300e3ac:	c422                	sw	s0,8(sp)
 300e3ae:	0800                	addi	s0,sp,16
    HAL_CRG_IpEnableSet(QDM1_BASE, IP_CLK_ENABLE);
 300e3b0:	4585                	li	a1,1
 300e3b2:	14c01537          	lui	a0,0x14c01
 300e3b6:	3ed5                	jal	ra,300dfaa <HAL_CRG_IpEnableSet.trans.20>

    g_qdm1.baseAddress = QDM1_BASE;
 300e3b8:	eaa18793          	addi	a5,gp,-342 # 40007b4 <g_qdm1>
 300e3bc:	14c01737          	lui	a4,0x14c01
 300e3c0:	c398                	sw	a4,0(a5)

    /* emulation config */
    g_qdm1.emuMode = QDM_EMULATION_MODE_STOP_IMMEDIATELY;
 300e3c2:	eaa18793          	addi	a5,gp,-342 # 40007b4 <g_qdm1>
 300e3c6:	0007a223          	sw	zero,4(a5)
    /* input config */
    g_qdm1.ctrlConfig.decoderMode = QDM_QUADRATURE_COUNT;
 300e3ca:	eaa18793          	addi	a5,gp,-342 # 40007b4 <g_qdm1>
 300e3ce:	0007aa23          	sw	zero,20(a5)
    g_qdm1.ctrlConfig.polarity = 0;
 300e3d2:	eaa18793          	addi	a5,gp,-342 # 40007b4 <g_qdm1>
 300e3d6:	0207a423          	sw	zero,40(a5)
    g_qdm1.ctrlConfig.resolution = QDM_1X_RESOLUTION; /* 1倍频：只统计A相上升沿，4倍频：统计A、B两项上升沿和下降沿 */
 300e3da:	eaa18793          	addi	a5,gp,-342 # 40007b4 <g_qdm1>
 300e3de:	0007ac23          	sw	zero,24(a5)
    g_qdm1.ctrlConfig.trgLockMode = QDM_TRG_BY_CYCLE;
 300e3e2:	eaa18793          	addi	a5,gp,-342 # 40007b4 <g_qdm1>
 300e3e6:	4705                	li	a4,1
 300e3e8:	cfd8                	sw	a4,28(a5)
    g_qdm1.ctrlConfig.swap = QDM_SWAP_DISABLE;
 300e3ea:	eaa18793          	addi	a5,gp,-342 # 40007b4 <g_qdm1>
 300e3ee:	0207a223          	sw	zero,36(a5)
    g_qdm1.ctrlConfig.ptuMode = QDM_PTU_MODE_CYCLE;
 300e3f2:	eaa18793          	addi	a5,gp,-342 # 40007b4 <g_qdm1>
 300e3f6:	0207a023          	sw	zero,32(a5)
    /* filter config */
    g_qdm1.inputFilter.qdmAFilterLevel = 0;
 300e3fa:	eaa18793          	addi	a5,gp,-342 # 40007b4 <g_qdm1>
 300e3fe:	0007a423          	sw	zero,8(a5)
    g_qdm1.inputFilter.qdmBFilterLevel = 0;
 300e402:	eaa18793          	addi	a5,gp,-342 # 40007b4 <g_qdm1>
 300e406:	0007a623          	sw	zero,12(a5)
    g_qdm1.inputFilter.qdmZFilterLevel = 0;
 300e40a:	eaa18793          	addi	a5,gp,-342 # 40007b4 <g_qdm1>
 300e40e:	0007a823          	sw	zero,16(a5)
    /* other config */
    g_qdm1.lock_mode = QDM_LOCK_RESERVE;
 300e412:	eaa18793          	addi	a5,gp,-342 # 40007b4 <g_qdm1>
 300e416:	0607a023          	sw	zero,96(a5)
    g_qdm1.pcntMode = QDM_PCNT_MODE_BY_DIR;
 300e41a:	eaa18793          	addi	a5,gp,-342 # 40007b4 <g_qdm1>
 300e41e:	0207a623          	sw	zero,44(a5)
    //g_qdm1.pcntRstMode = QDM_PCNT_RST_BY_PTU;
    g_qdm1.pcntRstMode = QDM_PCNT_RST_OVF;
 300e422:	eaa18793          	addi	a5,gp,-342 # 40007b4 <g_qdm1>
 300e426:	4705                	li	a4,1
 300e428:	db98                	sw	a4,48(a5)
    g_qdm1.pcntIdxInitMode = QDM_IDX_INIT_DISABLE;
 300e42a:	eaa18793          	addi	a5,gp,-342 # 40007b4 <g_qdm1>
 300e42e:	0207aa23          	sw	zero,52(a5)
    g_qdm1.qcMax = 4294967295;
 300e432:	eaa18793          	addi	a5,gp,-342 # 40007b4 <g_qdm1>
 300e436:	577d                	li	a4,-1
 300e438:	c7f8                	sw	a4,76(a5)
    g_qdm1.subModeEn = true;
 300e43a:	eaa18793          	addi	a5,gp,-342 # 40007b4 <g_qdm1>
 300e43e:	4705                	li	a4,1
 300e440:	02e78c23          	sb	a4,56(a5)
    g_qdm1.tsuPrescaler = 0U;
 300e444:	eaa18793          	addi	a5,gp,-342 # 40007b4 <g_qdm1>
 300e448:	0207ae23          	sw	zero,60(a5)
    g_qdm1.cevtPrescaler = QDM_CEVT_PRESCALER_DIVI1;
 300e44c:	eaa18793          	addi	a5,gp,-342 # 40007b4 <g_qdm1>
 300e450:	0407a023          	sw	zero,64(a5)
    //g_qdm1.posMax = 4294967295;
    g_qdm1.posMax = g_motorLineNum;
 300e454:	8621a703          	lw	a4,-1950(gp) # 400016c <g_motorLineNum>
 300e458:	eaa18793          	addi	a5,gp,-342 # 40007b4 <g_qdm1>
 300e45c:	c7b8                	sw	a4,72(a5)
    g_qdm1.posInit = 0;
 300e45e:	eaa18793          	addi	a5,gp,-342 # 40007b4 <g_qdm1>
 300e462:	0407a223          	sw	zero,68(a5)
    g_qdm1.period = 150000000;
 300e466:	eaa18793          	addi	a5,gp,-342 # 40007b4 <g_qdm1>
 300e46a:	08f0d737          	lui	a4,0x8f0d
 300e46e:	18070713          	addi	a4,a4,384 # 8f0d180 <RAM_END+0x4f05180>
 300e472:	cbb8                	sw	a4,80(a5)

    g_qdm1.motorLineNum = g_motorLineNum;   /* 设置编码器线数 */
 300e474:	8621a783          	lw	a5,-1950(gp) # 400016c <g_motorLineNum>
 300e478:	873e                	mv	a4,a5
 300e47a:	eaa18793          	addi	a5,gp,-342 # 40007b4 <g_qdm1>
 300e47e:	cfb8                	sw	a4,88(a5)
    //DBG_PRINTF("g_qdm0.motorLineNum:%d\r\n", g_qdm0.motorLineNum);

    g_qdm1.interruptEn = QDM_INT_WATCHDOG | 
 300e480:	eaa18793          	addi	a5,gp,-342 # 40007b4 <g_qdm1>
 300e484:	30400713          	li	a4,772
 300e488:	cbf8                	sw	a4,84(a5)
        QDM_INT_INDEX_EVNT_LATCH | 
        QDM_INT_UNIT_TIME_OUT;

    HAL_QDM_Init(&g_qdm1);
 300e48a:	eaa18513          	addi	a0,gp,-342 # 40007b4 <g_qdm1>
 300e48e:	884fc0ef          	jal	ra,300a512 <HAL_QDM_Init>

    HAL_QDM_RegisterCallback(&g_qdm1, QDM_TSU_CYCLE, QDM1PTUCycleCallback);
 300e492:	0300e7b7          	lui	a5,0x300e
 300e496:	37278613          	addi	a2,a5,882 # 300e372 <QDM1PTUCycleCallback>
 300e49a:	4581                	li	a1,0
 300e49c:	eaa18513          	addi	a0,gp,-342 # 40007b4 <g_qdm1>
 300e4a0:	20b1                	jal	ra,300e4ec <HAL_QDM_RegisterCallback.trans.36>
    HAL_QDM_RegisterCallback(&g_qdm1, QDM_INDEX_LOCKED, QDM1ZIndexLockedCallback);
 300e4a2:	0300e7b7          	lui	a5,0x300e
 300e4a6:	38478613          	addi	a2,a5,900 # 300e384 <QDM1ZIndexLockedCallback>
 300e4aa:	4589                	li	a1,2
 300e4ac:	eaa18513          	addi	a0,gp,-342 # 40007b4 <g_qdm1>
 300e4b0:	2835                	jal	ra,300e4ec <HAL_QDM_RegisterCallback.trans.36>
    HAL_QDM_RegisterCallback(&g_qdm1, QDM_PHASE_ERROR, QDM1QuadraturePhaseErrorCallback);
 300e4b2:	0300e7b7          	lui	a5,0x300e
 300e4b6:	39678613          	addi	a2,a5,918 # 300e396 <QDM1QuadraturePhaseErrorCallback>
 300e4ba:	4591                	li	a1,4
 300e4bc:	eaa18513          	addi	a0,gp,-342 # 40007b4 <g_qdm1>
 300e4c0:	2035                	jal	ra,300e4ec <HAL_QDM_RegisterCallback.trans.36>
    IRQ_Register(IRQ_QDM1, HAL_QDM_IrqHandler, &g_qdm1);
 300e4c2:	eaa18613          	addi	a2,gp,-342 # 40007b4 <g_qdm1>
 300e4c6:	0300a7b7          	lui	a5,0x300a
 300e4ca:	28678593          	addi	a1,a5,646 # 300a286 <HAL_QDM_IrqHandler>
 300e4ce:	04a00513          	li	a0,74
 300e4d2:	2661                	jal	ra,300e85a <IRQ_Register.trans.30>
    IRQ_SetPriority(IRQ_QDM1, 1);
 300e4d4:	4585                	li	a1,1
 300e4d6:	04a00513          	li	a0,74
 300e4da:	2eb5                	jal	ra,300e856 <IRQ_SetPriority.trans.31>
    IRQ_EnableN(IRQ_QDM1);
 300e4dc:	04a00513          	li	a0,74
 300e4e0:	2e8d                	jal	ra,300e852 <IRQ_EnableN.trans.32>
}
 300e4e2:	0001                	nop
 300e4e4:	40b2                	lw	ra,12(sp)
 300e4e6:	4422                	lw	s0,8(sp)
 300e4e8:	0141                	addi	sp,sp,16
 300e4ea:	8082                	ret

0300e4ec <HAL_QDM_RegisterCallback.trans.36>:
 300e4ec:	fa3fb06f          	j	300a48e <HAL_QDM_RegisterCallback>

0300e4f0 <TIMER0_Init>:
    /* USER CODE BEGIN TIMER0_InterruptProcess */
    /* USER CODE END TIMER0_InterruptProcess */
}

static void TIMER0_Init(void)
{
 300e4f0:	1101                	addi	sp,sp,-32
 300e4f2:	ce06                	sw	ra,28(sp)
 300e4f4:	cc22                	sw	s0,24(sp)
 300e4f6:	1000                	addi	s0,sp,32

    HAL_CRG_IpEnableSet(TIMER0_BASE, IP_CLK_ENABLE);
 300e4f8:	4585                	li	a1,1
 300e4fa:	14300537          	lui	a0,0x14300
 300e4fe:	3475                	jal	ra,300dfaa <HAL_CRG_IpEnableSet.trans.20>
    HAL_CRG_IpClkSelectSet(TIMER0_BASE, CRG_AHB_CLK_NO_PREDV);
 300e500:	4581                	li	a1,0
 300e502:	14300537          	lui	a0,0x14300
 300e506:	20c1                	jal	ra,300e5c6 <HAL_CRG_IpClkSelectSet.trans.29>

    unsigned int load = (HAL_CRG_GetIpFreq((void *)TIMER0) / (1u << (TIMERPRESCALER_NO_DIV * 4)) / 1000000u) * 10000;
 300e508:	14300537          	lui	a0,0x14300
 300e50c:	a0bf60ef          	jal	ra,3004f16 <HAL_CRG_GetIpFreq>
 300e510:	872a                	mv	a4,a0
 300e512:	000f47b7          	lui	a5,0xf4
 300e516:	24078793          	addi	a5,a5,576 # f4240 <FLASH_SIZE+0xd4244>
 300e51a:	02f75733          	divu	a4,a4,a5
 300e51e:	6789                	lui	a5,0x2
 300e520:	71078793          	addi	a5,a5,1808 # 2710 <__bss_size__+0x167c>
 300e524:	02f707b3          	mul	a5,a4,a5
 300e528:	fef42623          	sw	a5,-20(s0)

    g_timer0.baseAddress = TIMER0;
 300e52c:	00618793          	addi	a5,gp,6 # 4000910 <g_timer0>
 300e530:	14300737          	lui	a4,0x14300
 300e534:	c398                	sw	a4,0(a5)
    g_timer0.load        = load - 1; /* Set timer value immediately */
 300e536:	fec42783          	lw	a5,-20(s0)
 300e53a:	fff78713          	addi	a4,a5,-1
 300e53e:	00618793          	addi	a5,gp,6 # 4000910 <g_timer0>
 300e542:	cbd8                	sw	a4,20(a5)
    g_timer0.bgLoad      = load - 1; /* Set timer value */
 300e544:	fec42783          	lw	a5,-20(s0)
 300e548:	fff78713          	addi	a4,a5,-1
 300e54c:	00618793          	addi	a5,gp,6 # 4000910 <g_timer0>
 300e550:	cf98                	sw	a4,24(a5)
    g_timer0.mode        = TIMER_MODE_RUN_PERIODIC; /* Run in period mode */
 300e552:	00618793          	addi	a5,gp,6 # 4000910 <g_timer0>
 300e556:	4705                	li	a4,1
 300e558:	c798                	sw	a4,8(a5)
    g_timer0.prescaler   = TIMERPRESCALER_NO_DIV; /* Don't frequency division */
 300e55a:	00618793          	addi	a5,gp,6 # 4000910 <g_timer0>
 300e55e:	0007a623          	sw	zero,12(a5)
    g_timer0.size        = TIMER_SIZE_32BIT; /* 1 for 32bit, 0 for 16bit */
 300e562:	00618793          	addi	a5,gp,6 # 4000910 <g_timer0>
 300e566:	4705                	li	a4,1
 300e568:	cb98                	sw	a4,16(a5)
    g_timer0.interruptEn = BASE_CFG_ENABLE;
 300e56a:	00618793          	addi	a5,gp,6 # 4000910 <g_timer0>
 300e56e:	4705                	li	a4,1
 300e570:	afd8                	sb	a4,28(a5)
    g_timer0.adcSocReqEnable = BASE_CFG_DISABLE;
 300e572:	00618793          	addi	a5,gp,6 # 4000910 <g_timer0>
 300e576:	00078ea3          	sb	zero,29(a5)
    g_timer0.dmaReqEnable = BASE_CFG_DISABLE;
 300e57a:	00618793          	addi	a5,gp,6 # 4000910 <g_timer0>
 300e57e:	00078f23          	sb	zero,30(a5)
    HAL_TIMER_Init(&g_timer0);
 300e582:	00618513          	addi	a0,gp,6 # 4000910 <g_timer0>
 300e586:	a50fc0ef          	jal	ra,300a7d6 <HAL_TIMER_Init>
    IRQ_Register(IRQ_TIMER0, HAL_TIMER_IrqHandler, &g_timer0);
 300e58a:	00618613          	addi	a2,gp,6 # 4000910 <g_timer0>
 300e58e:	0300b7b7          	lui	a5,0x300b
 300e592:	aaa78593          	addi	a1,a5,-1366 # 300aaaa <HAL_TIMER_IrqHandler>
 300e596:	02000513          	li	a0,32
 300e59a:	24c1                	jal	ra,300e85a <IRQ_Register.trans.30>

    HAL_TIMER_RegisterCallback(&g_timer0, TIMER_PERIOD_FIN, TIMER0_InterruptProcess);
 300e59c:	0300c7b7          	lui	a5,0x300c
 300e5a0:	71278613          	addi	a2,a5,1810 # 300c712 <TIMER0_InterruptProcess>
 300e5a4:	4581                	li	a1,0
 300e5a6:	00618513          	addi	a0,gp,6 # 4000910 <g_timer0>
 300e5aa:	de8fc0ef          	jal	ra,300ab92 <HAL_TIMER_RegisterCallback>
    IRQ_SetPriority(IRQ_TIMER0, 1);
 300e5ae:	4585                	li	a1,1
 300e5b0:	02000513          	li	a0,32
 300e5b4:	244d                	jal	ra,300e856 <IRQ_SetPriority.trans.31>
    IRQ_EnableN(IRQ_TIMER0);
 300e5b6:	02000513          	li	a0,32
 300e5ba:	2c61                	jal	ra,300e852 <IRQ_EnableN.trans.32>
}
 300e5bc:	0001                	nop
 300e5be:	40f2                	lw	ra,28(sp)
 300e5c0:	4462                	lw	s0,24(sp)
 300e5c2:	6105                	addi	sp,sp,32
 300e5c4:	8082                	ret

0300e5c6 <HAL_CRG_IpClkSelectSet.trans.29>:
 300e5c6:	b15f606f          	j	30050da <HAL_CRG_IpClkSelectSet>

0300e5ca <UART0_Init>:

static void UART0_Init(void)
{
 300e5ca:	1141                	addi	sp,sp,-16
 300e5cc:	c606                	sw	ra,12(sp)
 300e5ce:	c422                	sw	s0,8(sp)
 300e5d0:	0800                	addi	s0,sp,16
    HAL_CRG_IpEnableSet(UART0_BASE, IP_CLK_ENABLE);
 300e5d2:	4585                	li	a1,1
 300e5d4:	14000537          	lui	a0,0x14000
 300e5d8:	2459                	jal	ra,300e85e <HAL_CRG_IpEnableSet.trans.21>
    HAL_CRG_IpClkSelectSet(UART0_BASE, CRG_AHB_CLK_NO_PREDV);
 300e5da:	4581                	li	a1,0
 300e5dc:	14000537          	lui	a0,0x14000
 300e5e0:	37dd                	jal	ra,300e5c6 <HAL_CRG_IpClkSelectSet.trans.29>

    g_uart0.baseAddress = UART0;
 300e5e2:	02e18793          	addi	a5,gp,46 # 4000938 <g_uart0>
 300e5e6:	14000737          	lui	a4,0x14000
 300e5ea:	c398                	sw	a4,0(a5)

    g_uart0.baudRate = UART0_BAND_RATE;
 300e5ec:	02e18793          	addi	a5,gp,46 # 4000938 <g_uart0>
 300e5f0:	6771                	lui	a4,0x1c
 300e5f2:	20070713          	addi	a4,a4,512 # 1c200 <RAM_SIZE+0x17200>
 300e5f6:	c3d8                	sw	a4,4(a5)
    g_uart0.dataLength = UART_DATALENGTH_8BIT;
 300e5f8:	02e18793          	addi	a5,gp,46 # 4000938 <g_uart0>
 300e5fc:	470d                	li	a4,3
 300e5fe:	c798                	sw	a4,8(a5)
    g_uart0.stopBits = UART_STOPBITS_ONE;
 300e600:	02e18793          	addi	a5,gp,46 # 4000938 <g_uart0>
 300e604:	0007a623          	sw	zero,12(a5)
    g_uart0.parity = UART_PARITY_NONE;
 300e608:	02e18793          	addi	a5,gp,46 # 4000938 <g_uart0>
 300e60c:	4711                	li	a4,4
 300e60e:	cb98                	sw	a4,16(a5)
    g_uart0.txMode = UART_MODE_BLOCKING;
 300e610:	02e18793          	addi	a5,gp,46 # 4000938 <g_uart0>
 300e614:	0007aa23          	sw	zero,20(a5)
    g_uart0.rxMode = UART_MODE_BLOCKING;
 300e618:	02e18793          	addi	a5,gp,46 # 4000938 <g_uart0>
 300e61c:	0007ac23          	sw	zero,24(a5)
    g_uart0.fifoMode = BASE_CFG_ENABLE;
 300e620:	02e18793          	addi	a5,gp,46 # 4000938 <g_uart0>
 300e624:	4705                	li	a4,1
 300e626:	02e78623          	sb	a4,44(a5)
    g_uart0.fifoTxThr = UART_FIFODEPTH_SIZE8;
 300e62a:	02e18793          	addi	a5,gp,46 # 4000938 <g_uart0>
 300e62e:	4721                	li	a4,8
 300e630:	db98                	sw	a4,48(a5)
    g_uart0.fifoRxThr = UART_FIFODEPTH_SIZE8;
 300e632:	02e18793          	addi	a5,gp,46 # 4000938 <g_uart0>
 300e636:	4721                	li	a4,8
 300e638:	dbd8                	sw	a4,52(a5)
    g_uart0.hwFlowCtr = BASE_CFG_DISABLE;
 300e63a:	02e18793          	addi	a5,gp,46 # 4000938 <g_uart0>
 300e63e:	0207ac23          	sw	zero,56(a5)
    g_uart0.handleEx.overSampleMultiple = UART_OVERSAMPLING_16X;
 300e642:	02e18793          	addi	a5,gp,46 # 4000938 <g_uart0>
 300e646:	0607ac23          	sw	zero,120(a5)
    g_uart0.handleEx.msbFirst = BASE_CFG_DISABLE;   
 300e64a:	02e18793          	addi	a5,gp,46 # 4000938 <g_uart0>
 300e64e:	06078e23          	sb	zero,124(a5)
    HAL_UART_Init(&g_uart0);
 300e652:	02e18513          	addi	a0,gp,46 # 4000938 <g_uart0>
 300e656:	2ad5                	jal	ra,300e84a <HAL_UART_Init.trans.50>
}
 300e658:	0001                	nop
 300e65a:	40b2                	lw	ra,12(sp)
 300e65c:	4422                	lw	s0,8(sp)
 300e65e:	0141                	addi	sp,sp,16
 300e660:	8082                	ret

0300e662 <UART2InterruptErrorCallback>:

__weak void UART2InterruptErrorCallback(void *handle)
{
 300e662:	1101                	addi	sp,sp,-32
 300e664:	ce22                	sw	s0,28(sp)
 300e666:	1000                	addi	s0,sp,32
 300e668:	fea42623          	sw	a0,-20(s0)
    BASE_FUNC_UNUSED(handle);
    /* USER CODE BEGIN UART2_TRNS_IT_ERROR */
    /* USER CODE END UART2_TRNS_IT_ERROR */
}
 300e66c:	0001                	nop
 300e66e:	4472                	lw	s0,28(sp)
 300e670:	6105                	addi	sp,sp,32
 300e672:	8082                	ret

0300e674 <UART2_Init>:
    /* USER CODE BEGIN UART2_READ_IT_FINISH */
    /* USER CODE END UART2_READ_IT_FINISH */
}

static void UART2_Init(void)
{
 300e674:	1141                	addi	sp,sp,-16
 300e676:	c606                	sw	ra,12(sp)
 300e678:	c422                	sw	s0,8(sp)
 300e67a:	0800                	addi	s0,sp,16
    HAL_CRG_IpEnableSet(UART2_BASE, IP_CLK_ENABLE);
 300e67c:	4585                	li	a1,1
 300e67e:	14002537          	lui	a0,0x14002
 300e682:	2af1                	jal	ra,300e85e <HAL_CRG_IpEnableSet.trans.21>
    HAL_CRG_IpClkSelectSet(UART2_BASE, CRG_AHB_CLK_NO_PREDV);
 300e684:	4581                	li	a1,0
 300e686:	14002537          	lui	a0,0x14002
 300e68a:	3f35                	jal	ra,300e5c6 <HAL_CRG_IpClkSelectSet.trans.29>

    g_uart2.baseAddress = UART2;
 300e68c:	0ae18793          	addi	a5,gp,174 # 40009b8 <g_uart2>
 300e690:	14002737          	lui	a4,0x14002
 300e694:	c398                	sw	a4,0(a5)

    g_uart2.baudRate = UART2_BAND_RATE;
 300e696:	0ae18793          	addi	a5,gp,174 # 40009b8 <g_uart2>
 300e69a:	6771                	lui	a4,0x1c
 300e69c:	20070713          	addi	a4,a4,512 # 1c200 <RAM_SIZE+0x17200>
 300e6a0:	c3d8                	sw	a4,4(a5)
    g_uart2.dataLength = UART_DATALENGTH_8BIT;
 300e6a2:	0ae18793          	addi	a5,gp,174 # 40009b8 <g_uart2>
 300e6a6:	470d                	li	a4,3
 300e6a8:	c798                	sw	a4,8(a5)
    g_uart2.stopBits = UART_STOPBITS_ONE;
 300e6aa:	0ae18793          	addi	a5,gp,174 # 40009b8 <g_uart2>
 300e6ae:	0007a623          	sw	zero,12(a5)
    g_uart2.parity = UART_PARITY_NONE;
 300e6b2:	0ae18793          	addi	a5,gp,174 # 40009b8 <g_uart2>
 300e6b6:	4711                	li	a4,4
 300e6b8:	cb98                	sw	a4,16(a5)
    g_uart2.txMode = UART_MODE_INTERRUPT;
 300e6ba:	0ae18793          	addi	a5,gp,174 # 40009b8 <g_uart2>
 300e6be:	4705                	li	a4,1
 300e6c0:	cbd8                	sw	a4,20(a5)
    g_uart2.rxMode = UART_MODE_INTERRUPT;
 300e6c2:	0ae18793          	addi	a5,gp,174 # 40009b8 <g_uart2>
 300e6c6:	4705                	li	a4,1
 300e6c8:	cf98                	sw	a4,24(a5)
    g_uart2.fifoMode = BASE_CFG_ENABLE;
 300e6ca:	0ae18793          	addi	a5,gp,174 # 40009b8 <g_uart2>
 300e6ce:	4705                	li	a4,1
 300e6d0:	02e78623          	sb	a4,44(a5)
    g_uart2.fifoTxThr = UART_FIFODEPTH_SIZE4;
 300e6d4:	0ae18793          	addi	a5,gp,174 # 40009b8 <g_uart2>
 300e6d8:	4711                	li	a4,4
 300e6da:	db98                	sw	a4,48(a5)
    g_uart2.fifoRxThr = UART_FIFODEPTH_SIZE4;
 300e6dc:	0ae18793          	addi	a5,gp,174 # 40009b8 <g_uart2>
 300e6e0:	4711                	li	a4,4
 300e6e2:	dbd8                	sw	a4,52(a5)
    g_uart2.hwFlowCtr = BASE_CFG_DISABLE;
 300e6e4:	0ae18793          	addi	a5,gp,174 # 40009b8 <g_uart2>
 300e6e8:	0207ac23          	sw	zero,56(a5)
    g_uart2.handleEx.overSampleMultiple = UART_OVERSAMPLING_16X;
 300e6ec:	0ae18793          	addi	a5,gp,174 # 40009b8 <g_uart2>
 300e6f0:	0607ac23          	sw	zero,120(a5)
    g_uart2.handleEx.msbFirst = BASE_CFG_DISABLE;   
 300e6f4:	0ae18793          	addi	a5,gp,174 # 40009b8 <g_uart2>
 300e6f8:	06078e23          	sb	zero,124(a5)
    HAL_UART_Init(&g_uart2);
 300e6fc:	0ae18513          	addi	a0,gp,174 # 40009b8 <g_uart2>
 300e700:	22a9                	jal	ra,300e84a <HAL_UART_Init.trans.50>
    HAL_UART_RegisterCallBack(&g_uart2, UART_TRNS_IT_ERROR, (UART_CallbackType)UART2InterruptErrorCallback);
 300e702:	0300e7b7          	lui	a5,0x300e
 300e706:	66278613          	addi	a2,a5,1634 # 300e662 <UART2InterruptErrorCallback>
 300e70a:	4591                	li	a1,4
 300e70c:	0ae18513          	addi	a0,gp,174 # 40009b8 <g_uart2>
 300e710:	2a3d                	jal	ra,300e84e <HAL_UART_RegisterCallBack.trans.37>
    HAL_UART_RegisterCallBack(&g_uart2, UART_WRITE_IT_FINISH, (UART_CallbackType)UART2WriteInterruptCallback);
 300e712:	0300c7b7          	lui	a5,0x300c
 300e716:	eb078613          	addi	a2,a5,-336 # 300beb0 <UART2WriteInterruptCallback>
 300e71a:	4581                	li	a1,0
 300e71c:	0ae18513          	addi	a0,gp,174 # 40009b8 <g_uart2>
 300e720:	223d                	jal	ra,300e84e <HAL_UART_RegisterCallBack.trans.37>
    HAL_UART_RegisterCallBack(&g_uart2, UART_READ_IT_FINISH, (UART_CallbackType)UART2ReadInterruptCallback);
 300e722:	0300c7b7          	lui	a5,0x300c
 300e726:	ecc78613          	addi	a2,a5,-308 # 300becc <UART2ReadInterruptCallback>
 300e72a:	4585                	li	a1,1
 300e72c:	0ae18513          	addi	a0,gp,174 # 40009b8 <g_uart2>
 300e730:	2a39                	jal	ra,300e84e <HAL_UART_RegisterCallBack.trans.37>

    IRQ_Register(IRQ_UART2, HAL_UART_IrqHandler, &g_uart2);
 300e732:	0ae18613          	addi	a2,gp,174 # 40009b8 <g_uart2>
 300e736:	0300c7b7          	lui	a5,0x300c
 300e73a:	91678593          	addi	a1,a5,-1770 # 300b916 <HAL_UART_IrqHandler>
 300e73e:	4579                	li	a0,30
 300e740:	2a29                	jal	ra,300e85a <IRQ_Register.trans.30>
    IRQ_SetPriority(IRQ_UART2, 1);
 300e742:	4585                	li	a1,1
 300e744:	4579                	li	a0,30
 300e746:	2a01                	jal	ra,300e856 <IRQ_SetPriority.trans.31>
    IRQ_EnableN(IRQ_UART2);
 300e748:	4579                	li	a0,30
 300e74a:	2221                	jal	ra,300e852 <IRQ_EnableN.trans.32>
}
 300e74c:	0001                	nop
 300e74e:	40b2                	lw	ra,12(sp)
 300e750:	4422                	lw	s0,8(sp)
 300e752:	0141                	addi	sp,sp,16
 300e754:	8082                	ret

0300e756 <UART3InterruptErrorCallback>:

__weak void UART3InterruptErrorCallback(void *handle)
{
 300e756:	1101                	addi	sp,sp,-32
 300e758:	ce22                	sw	s0,28(sp)
 300e75a:	1000                	addi	s0,sp,32
 300e75c:	fea42623          	sw	a0,-20(s0)
    BASE_FUNC_UNUSED(handle);
    /* USER CODE BEGIN UART3InterruptErrorCallback */
    /* USER CODE END UART3InterruptErrorCallback */
}
 300e760:	0001                	nop
 300e762:	4472                	lw	s0,28(sp)
 300e764:	6105                	addi	sp,sp,32
 300e766:	8082                	ret

0300e768 <UART3_Init>:
    /* USER CODE BEGIN UART3ReadInterruptCallback */
    /* USER CODE END UART3ReadInterruptCallback */
}

static void UART3_Init(void)
{
 300e768:	1141                	addi	sp,sp,-16
 300e76a:	c606                	sw	ra,12(sp)
 300e76c:	c422                	sw	s0,8(sp)
 300e76e:	0800                	addi	s0,sp,16
    HAL_CRG_IpEnableSet(UART3_BASE, IP_CLK_ENABLE);
 300e770:	4585                	li	a1,1
 300e772:	14003537          	lui	a0,0x14003
 300e776:	20e5                	jal	ra,300e85e <HAL_CRG_IpEnableSet.trans.21>
    HAL_CRG_IpClkSelectSet(UART3_BASE, CRG_AHB_CLK_NO_PREDV);
 300e778:	4581                	li	a1,0
 300e77a:	14003537          	lui	a0,0x14003
 300e77e:	35a1                	jal	ra,300e5c6 <HAL_CRG_IpClkSelectSet.trans.29>

    g_uart3.baseAddress = UART3;
 300e780:	12e18793          	addi	a5,gp,302 # 4000a38 <g_uart3>
 300e784:	14003737          	lui	a4,0x14003
 300e788:	c398                	sw	a4,0(a5)

    g_uart3.baudRate = UART3_BAND_RATE;
 300e78a:	12e18793          	addi	a5,gp,302 # 4000a38 <g_uart3>
 300e78e:	6709                	lui	a4,0x2
 300e790:	58070713          	addi	a4,a4,1408 # 2580 <__bss_size__+0x14ec>
 300e794:	c3d8                	sw	a4,4(a5)
    g_uart3.dataLength = UART_DATALENGTH_8BIT;
 300e796:	12e18793          	addi	a5,gp,302 # 4000a38 <g_uart3>
 300e79a:	470d                	li	a4,3
 300e79c:	c798                	sw	a4,8(a5)
    g_uart3.stopBits = UART_STOPBITS_ONE;
 300e79e:	12e18793          	addi	a5,gp,302 # 4000a38 <g_uart3>
 300e7a2:	0007a623          	sw	zero,12(a5)
    g_uart3.parity = UART_PARITY_NONE;
 300e7a6:	12e18793          	addi	a5,gp,302 # 4000a38 <g_uart3>
 300e7aa:	4711                	li	a4,4
 300e7ac:	cb98                	sw	a4,16(a5)
    g_uart3.txMode = UART_MODE_INTERRUPT;
 300e7ae:	12e18793          	addi	a5,gp,302 # 4000a38 <g_uart3>
 300e7b2:	4705                	li	a4,1
 300e7b4:	cbd8                	sw	a4,20(a5)
    g_uart3.rxMode = UART_MODE_INTERRUPT;
 300e7b6:	12e18793          	addi	a5,gp,302 # 4000a38 <g_uart3>
 300e7ba:	4705                	li	a4,1
 300e7bc:	cf98                	sw	a4,24(a5)
    g_uart3.fifoMode = BASE_CFG_ENABLE;
 300e7be:	12e18793          	addi	a5,gp,302 # 4000a38 <g_uart3>
 300e7c2:	4705                	li	a4,1
 300e7c4:	02e78623          	sb	a4,44(a5)
    g_uart3.fifoTxThr = UART_FIFODEPTH_SIZE4;
 300e7c8:	12e18793          	addi	a5,gp,302 # 4000a38 <g_uart3>
 300e7cc:	4711                	li	a4,4
 300e7ce:	db98                	sw	a4,48(a5)
    g_uart3.fifoRxThr = UART_FIFODEPTH_SIZE4;
 300e7d0:	12e18793          	addi	a5,gp,302 # 4000a38 <g_uart3>
 300e7d4:	4711                	li	a4,4
 300e7d6:	dbd8                	sw	a4,52(a5)
    g_uart3.hwFlowCtr = BASE_CFG_DISABLE;
 300e7d8:	12e18793          	addi	a5,gp,302 # 4000a38 <g_uart3>
 300e7dc:	0207ac23          	sw	zero,56(a5)
    g_uart3.handleEx.overSampleMultiple = UART_OVERSAMPLING_16X;
 300e7e0:	12e18793          	addi	a5,gp,302 # 4000a38 <g_uart3>
 300e7e4:	0607ac23          	sw	zero,120(a5)
    g_uart3.handleEx.msbFirst = BASE_CFG_DISABLE;   
 300e7e8:	12e18793          	addi	a5,gp,302 # 4000a38 <g_uart3>
 300e7ec:	06078e23          	sb	zero,124(a5)
    HAL_UART_Init(&g_uart3);
 300e7f0:	12e18513          	addi	a0,gp,302 # 4000a38 <g_uart3>
 300e7f4:	2899                	jal	ra,300e84a <HAL_UART_Init.trans.50>
    HAL_UART_RegisterCallBack(&g_uart3, UART_TRNS_IT_ERROR, (UART_CallbackType)UART3InterruptErrorCallback);
 300e7f6:	0300e7b7          	lui	a5,0x300e
 300e7fa:	75678613          	addi	a2,a5,1878 # 300e756 <UART3InterruptErrorCallback>
 300e7fe:	4591                	li	a1,4
 300e800:	12e18513          	addi	a0,gp,302 # 4000a38 <g_uart3>
 300e804:	20a9                	jal	ra,300e84e <HAL_UART_RegisterCallBack.trans.37>
    HAL_UART_RegisterCallBack(&g_uart3, UART_WRITE_IT_FINISH, (UART_CallbackType)UART3WriteInterruptCallback);
 300e806:	0300c7b7          	lui	a5,0x300c
 300e80a:	6de78613          	addi	a2,a5,1758 # 300c6de <UART3WriteInterruptCallback>
 300e80e:	4581                	li	a1,0
 300e810:	12e18513          	addi	a0,gp,302 # 4000a38 <g_uart3>
 300e814:	282d                	jal	ra,300e84e <HAL_UART_RegisterCallBack.trans.37>
    HAL_UART_RegisterCallBack(&g_uart3, UART_READ_IT_FINISH, (UART_CallbackType)UART3ReadInterruptCallback);
 300e816:	0300c7b7          	lui	a5,0x300c
 300e81a:	6f678613          	addi	a2,a5,1782 # 300c6f6 <UART3ReadInterruptCallback>
 300e81e:	4585                	li	a1,1
 300e820:	12e18513          	addi	a0,gp,302 # 4000a38 <g_uart3>
 300e824:	202d                	jal	ra,300e84e <HAL_UART_RegisterCallBack.trans.37>

    IRQ_Register(IRQ_UART3, HAL_UART_IrqHandler, &g_uart3);
 300e826:	12e18613          	addi	a2,gp,302 # 4000a38 <g_uart3>
 300e82a:	0300c7b7          	lui	a5,0x300c
 300e82e:	91678593          	addi	a1,a5,-1770 # 300b916 <HAL_UART_IrqHandler>
 300e832:	456d                	li	a0,27
 300e834:	201d                	jal	ra,300e85a <IRQ_Register.trans.30>
    IRQ_SetPriority(IRQ_UART3, 1);
 300e836:	4585                	li	a1,1
 300e838:	456d                	li	a0,27
 300e83a:	2831                	jal	ra,300e856 <IRQ_SetPriority.trans.31>
    IRQ_EnableN(IRQ_UART3);
 300e83c:	456d                	li	a0,27
 300e83e:	2811                	jal	ra,300e852 <IRQ_EnableN.trans.32>
}
 300e840:	0001                	nop
 300e842:	40b2                	lw	ra,12(sp)
 300e844:	4422                	lw	s0,8(sp)
 300e846:	0141                	addi	sp,sp,16
 300e848:	8082                	ret

0300e84a <HAL_UART_Init.trans.50>:
 300e84a:	ebafc06f          	j	300af04 <HAL_UART_Init>

0300e84e <HAL_UART_RegisterCallBack.trans.37>:
 300e84e:	a2afd06f          	j	300ba78 <HAL_UART_RegisterCallBack>

0300e852 <IRQ_EnableN.trans.32>:
 300e852:	fa2f406f          	j	3002ff4 <IRQ_EnableN>

0300e856 <IRQ_SetPriority.trans.31>:
 300e856:	f33f406f          	j	3003788 <IRQ_SetPriority>

0300e85a <IRQ_Register.trans.30>:
 300e85a:	f14f406f          	j	3002f6e <IRQ_Register>

0300e85e <HAL_CRG_IpEnableSet.trans.21>:
 300e85e:	fa8f606f          	j	3005006 <HAL_CRG_IpEnableSet>

0300e862 <IOConfig>:

static void IOConfig(void)
{
 300e862:	1141                	addi	sp,sp,-16
 300e864:	c606                	sw	ra,12(sp)
 300e866:	c422                	sw	s0,8(sp)
 300e868:	0800                	addi	s0,sp,16
    HAL_IOCMG_SetPinAltFuncMode(GPIO2_2_AS_UART0_TXD);  /* Check function selection */
 300e86a:	018007b7          	lui	a5,0x1800
 300e86e:	23278513          	addi	a0,a5,562 # 1800232 <FLASH_SIZE+0x17e0236>
 300e872:	b83fa0ef          	jal	ra,30093f4 <HAL_IOCMG_SetPinAltFuncMode>
    HAL_IOCMG_SetPinPullMode(GPIO2_2_AS_UART0_TXD, PULL_NONE);  /* Pull-up and pull-down */
 300e876:	4581                	li	a1,0
 300e878:	018007b7          	lui	a5,0x1800
 300e87c:	23278513          	addi	a0,a5,562 # 1800232 <FLASH_SIZE+0x17e0236>
 300e880:	baffa0ef          	jal	ra,300942e <HAL_IOCMG_SetPinPullMode>
    HAL_IOCMG_SetPinSchmidtMode(GPIO2_2_AS_UART0_TXD, SCHMIDT_DISABLE);  /* Schmitt input on/off */
 300e884:	4581                	li	a1,0
 300e886:	018007b7          	lui	a5,0x1800
 300e88a:	23278513          	addi	a0,a5,562 # 1800232 <FLASH_SIZE+0x17e0236>
 300e88e:	bedfa0ef          	jal	ra,300947a <HAL_IOCMG_SetPinSchmidtMode>
    HAL_IOCMG_SetPinLevelShiftRate(GPIO2_2_AS_UART0_TXD, LEVEL_SHIFT_RATE_SLOW);  /* Output drive capability */
 300e892:	4585                	li	a1,1
 300e894:	018007b7          	lui	a5,0x1800
 300e898:	23278513          	addi	a0,a5,562 # 1800232 <FLASH_SIZE+0x17e0236>
 300e89c:	c2bfa0ef          	jal	ra,30094c6 <HAL_IOCMG_SetPinLevelShiftRate>
    HAL_IOCMG_SetPinDriveRate(GPIO2_2_AS_UART0_TXD, DRIVER_RATE_2);  /* Output signal edge fast/slow */
 300e8a0:	4589                	li	a1,2
 300e8a2:	018007b7          	lui	a5,0x1800
 300e8a6:	23278513          	addi	a0,a5,562 # 1800232 <FLASH_SIZE+0x17e0236>
 300e8aa:	c69fa0ef          	jal	ra,3009512 <HAL_IOCMG_SetPinDriveRate>

    HAL_IOCMG_SetPinAltFuncMode(GPIO2_3_AS_UART0_RXD);  /* Check function selection */
 300e8ae:	018407b7          	lui	a5,0x1840
 300e8b2:	23278513          	addi	a0,a5,562 # 1840232 <FLASH_SIZE+0x1820236>
 300e8b6:	b3ffa0ef          	jal	ra,30093f4 <HAL_IOCMG_SetPinAltFuncMode>
    HAL_IOCMG_SetPinPullMode(GPIO2_3_AS_UART0_RXD, PULL_NONE);  /* Pull-up and pull-down */
 300e8ba:	4581                	li	a1,0
 300e8bc:	018407b7          	lui	a5,0x1840
 300e8c0:	23278513          	addi	a0,a5,562 # 1840232 <FLASH_SIZE+0x1820236>
 300e8c4:	b6bfa0ef          	jal	ra,300942e <HAL_IOCMG_SetPinPullMode>
    HAL_IOCMG_SetPinSchmidtMode(GPIO2_3_AS_UART0_RXD, SCHMIDT_DISABLE);  /* Schmitt input on/off */
 300e8c8:	4581                	li	a1,0
 300e8ca:	018407b7          	lui	a5,0x1840
 300e8ce:	23278513          	addi	a0,a5,562 # 1840232 <FLASH_SIZE+0x1820236>
 300e8d2:	ba9fa0ef          	jal	ra,300947a <HAL_IOCMG_SetPinSchmidtMode>
    HAL_IOCMG_SetPinLevelShiftRate(GPIO2_3_AS_UART0_RXD, LEVEL_SHIFT_RATE_SLOW);  /* Output drive capability */
 300e8d6:	4585                	li	a1,1
 300e8d8:	018407b7          	lui	a5,0x1840
 300e8dc:	23278513          	addi	a0,a5,562 # 1840232 <FLASH_SIZE+0x1820236>
 300e8e0:	be7fa0ef          	jal	ra,30094c6 <HAL_IOCMG_SetPinLevelShiftRate>
    HAL_IOCMG_SetPinDriveRate(GPIO2_3_AS_UART0_RXD, DRIVER_RATE_2);  /* Output signal edge fast/slow */
 300e8e4:	4589                	li	a1,2
 300e8e6:	018407b7          	lui	a5,0x1840
 300e8ea:	23278513          	addi	a0,a5,562 # 1840232 <FLASH_SIZE+0x1820236>
 300e8ee:	c25fa0ef          	jal	ra,3009512 <HAL_IOCMG_SetPinDriveRate>

    HAL_IOCMG_SetPinAltFuncMode(GPIO3_0_AS_APT0_PWMA);  /* Check function selection */
 300e8f2:	014807b7          	lui	a5,0x1480
 300e8f6:	23178513          	addi	a0,a5,561 # 1480231 <FLASH_SIZE+0x1460235>
 300e8fa:	afbfa0ef          	jal	ra,30093f4 <HAL_IOCMG_SetPinAltFuncMode>
    HAL_IOCMG_SetPinPullMode(GPIO3_0_AS_APT0_PWMA, PULL_NONE);  /* Pull-up and pull-down */
 300e8fe:	4581                	li	a1,0
 300e900:	014807b7          	lui	a5,0x1480
 300e904:	23178513          	addi	a0,a5,561 # 1480231 <FLASH_SIZE+0x1460235>
 300e908:	b27fa0ef          	jal	ra,300942e <HAL_IOCMG_SetPinPullMode>
    HAL_IOCMG_SetPinSchmidtMode(GPIO3_0_AS_APT0_PWMA, SCHMIDT_DISABLE);  /* Schmitt input on/off */
 300e90c:	4581                	li	a1,0
 300e90e:	014807b7          	lui	a5,0x1480
 300e912:	23178513          	addi	a0,a5,561 # 1480231 <FLASH_SIZE+0x1460235>
 300e916:	b65fa0ef          	jal	ra,300947a <HAL_IOCMG_SetPinSchmidtMode>
    HAL_IOCMG_SetPinLevelShiftRate(GPIO3_0_AS_APT0_PWMA, LEVEL_SHIFT_RATE_SLOW);  /* Output drive capability */
 300e91a:	4585                	li	a1,1
 300e91c:	014807b7          	lui	a5,0x1480
 300e920:	23178513          	addi	a0,a5,561 # 1480231 <FLASH_SIZE+0x1460235>
 300e924:	ba3fa0ef          	jal	ra,30094c6 <HAL_IOCMG_SetPinLevelShiftRate>
    HAL_IOCMG_SetPinDriveRate(GPIO3_0_AS_APT0_PWMA, DRIVER_RATE_2);  /* Output signal edge fast/slow */
 300e928:	4589                	li	a1,2
 300e92a:	014807b7          	lui	a5,0x1480
 300e92e:	23178513          	addi	a0,a5,561 # 1480231 <FLASH_SIZE+0x1460235>
 300e932:	be1fa0ef          	jal	ra,3009512 <HAL_IOCMG_SetPinDriveRate>

    HAL_IOCMG_SetPinAltFuncMode(GPIO4_0_AS_APT0_PWMB);  /* Check function selection */
 300e936:	015407b7          	lui	a5,0x1540
 300e93a:	23178513          	addi	a0,a5,561 # 1540231 <FLASH_SIZE+0x1520235>
 300e93e:	ab7fa0ef          	jal	ra,30093f4 <HAL_IOCMG_SetPinAltFuncMode>
    HAL_IOCMG_SetPinPullMode(GPIO4_0_AS_APT0_PWMB, PULL_NONE);  /* Pull-up and pull-down */
 300e942:	4581                	li	a1,0
 300e944:	015407b7          	lui	a5,0x1540
 300e948:	23178513          	addi	a0,a5,561 # 1540231 <FLASH_SIZE+0x1520235>
 300e94c:	ae3fa0ef          	jal	ra,300942e <HAL_IOCMG_SetPinPullMode>
    HAL_IOCMG_SetPinSchmidtMode(GPIO4_0_AS_APT0_PWMB, SCHMIDT_DISABLE);  /* Schmitt input on/off */
 300e950:	4581                	li	a1,0
 300e952:	015407b7          	lui	a5,0x1540
 300e956:	23178513          	addi	a0,a5,561 # 1540231 <FLASH_SIZE+0x1520235>
 300e95a:	b21fa0ef          	jal	ra,300947a <HAL_IOCMG_SetPinSchmidtMode>
    HAL_IOCMG_SetPinLevelShiftRate(GPIO4_0_AS_APT0_PWMB, LEVEL_SHIFT_RATE_SLOW);  /* Output drive capability */
 300e95e:	4585                	li	a1,1
 300e960:	015407b7          	lui	a5,0x1540
 300e964:	23178513          	addi	a0,a5,561 # 1540231 <FLASH_SIZE+0x1520235>
 300e968:	b5ffa0ef          	jal	ra,30094c6 <HAL_IOCMG_SetPinLevelShiftRate>
    HAL_IOCMG_SetPinDriveRate(GPIO4_0_AS_APT0_PWMB, DRIVER_RATE_2);  /* Output signal edge fast/slow */
 300e96c:	4589                	li	a1,2
 300e96e:	015407b7          	lui	a5,0x1540
 300e972:	23178513          	addi	a0,a5,561 # 1540231 <FLASH_SIZE+0x1520235>
 300e976:	b9dfa0ef          	jal	ra,3009512 <HAL_IOCMG_SetPinDriveRate>

    HAL_IOCMG_SetPinAltFuncMode(GPIO3_1_AS_APT1_PWMA);  /* Check function selection */
 300e97a:	014c07b7          	lui	a5,0x14c0
 300e97e:	23178513          	addi	a0,a5,561 # 14c0231 <FLASH_SIZE+0x14a0235>
 300e982:	a73fa0ef          	jal	ra,30093f4 <HAL_IOCMG_SetPinAltFuncMode>
    HAL_IOCMG_SetPinPullMode(GPIO3_1_AS_APT1_PWMA, PULL_NONE);  /* Pull-up and pull-down */
 300e986:	4581                	li	a1,0
 300e988:	014c07b7          	lui	a5,0x14c0
 300e98c:	23178513          	addi	a0,a5,561 # 14c0231 <FLASH_SIZE+0x14a0235>
 300e990:	a9ffa0ef          	jal	ra,300942e <HAL_IOCMG_SetPinPullMode>
    HAL_IOCMG_SetPinSchmidtMode(GPIO3_1_AS_APT1_PWMA, SCHMIDT_DISABLE);  /* Schmitt input on/off */
 300e994:	4581                	li	a1,0
 300e996:	014c07b7          	lui	a5,0x14c0
 300e99a:	23178513          	addi	a0,a5,561 # 14c0231 <FLASH_SIZE+0x14a0235>
 300e99e:	addfa0ef          	jal	ra,300947a <HAL_IOCMG_SetPinSchmidtMode>
    HAL_IOCMG_SetPinLevelShiftRate(GPIO3_1_AS_APT1_PWMA, LEVEL_SHIFT_RATE_SLOW);  /* Output drive capability */
 300e9a2:	4585                	li	a1,1
 300e9a4:	014c07b7          	lui	a5,0x14c0
 300e9a8:	23178513          	addi	a0,a5,561 # 14c0231 <FLASH_SIZE+0x14a0235>
 300e9ac:	b1bfa0ef          	jal	ra,30094c6 <HAL_IOCMG_SetPinLevelShiftRate>
    HAL_IOCMG_SetPinDriveRate(GPIO3_1_AS_APT1_PWMA, DRIVER_RATE_2);  /* Output signal edge fast/slow */
 300e9b0:	4589                	li	a1,2
 300e9b2:	014c07b7          	lui	a5,0x14c0
 300e9b6:	23178513          	addi	a0,a5,561 # 14c0231 <FLASH_SIZE+0x14a0235>
 300e9ba:	b59fa0ef          	jal	ra,3009512 <HAL_IOCMG_SetPinDriveRate>

    HAL_IOCMG_SetPinAltFuncMode(GPIO4_1_AS_APT1_PWMB);  /* Check function selection */
 300e9be:	015c07b7          	lui	a5,0x15c0
 300e9c2:	23178513          	addi	a0,a5,561 # 15c0231 <FLASH_SIZE+0x15a0235>
 300e9c6:	a2ffa0ef          	jal	ra,30093f4 <HAL_IOCMG_SetPinAltFuncMode>
    HAL_IOCMG_SetPinPullMode(GPIO4_1_AS_APT1_PWMB, PULL_NONE);  /* Pull-up and pull-down */
 300e9ca:	4581                	li	a1,0
 300e9cc:	015c07b7          	lui	a5,0x15c0
 300e9d0:	23178513          	addi	a0,a5,561 # 15c0231 <FLASH_SIZE+0x15a0235>
 300e9d4:	a5bfa0ef          	jal	ra,300942e <HAL_IOCMG_SetPinPullMode>
    HAL_IOCMG_SetPinSchmidtMode(GPIO4_1_AS_APT1_PWMB, SCHMIDT_DISABLE);  /* Schmitt input on/off */
 300e9d8:	4581                	li	a1,0
 300e9da:	015c07b7          	lui	a5,0x15c0
 300e9de:	23178513          	addi	a0,a5,561 # 15c0231 <FLASH_SIZE+0x15a0235>
 300e9e2:	a99fa0ef          	jal	ra,300947a <HAL_IOCMG_SetPinSchmidtMode>
    HAL_IOCMG_SetPinLevelShiftRate(GPIO4_1_AS_APT1_PWMB, LEVEL_SHIFT_RATE_SLOW);  /* Output drive capability */
 300e9e6:	4585                	li	a1,1
 300e9e8:	015c07b7          	lui	a5,0x15c0
 300e9ec:	23178513          	addi	a0,a5,561 # 15c0231 <FLASH_SIZE+0x15a0235>
 300e9f0:	ad7fa0ef          	jal	ra,30094c6 <HAL_IOCMG_SetPinLevelShiftRate>
    HAL_IOCMG_SetPinDriveRate(GPIO4_1_AS_APT1_PWMB, DRIVER_RATE_2);  /* Output signal edge fast/slow */
 300e9f4:	4589                	li	a1,2
 300e9f6:	015c07b7          	lui	a5,0x15c0
 300e9fa:	23178513          	addi	a0,a5,561 # 15c0231 <FLASH_SIZE+0x15a0235>
 300e9fe:	b15fa0ef          	jal	ra,3009512 <HAL_IOCMG_SetPinDriveRate>

    HAL_IOCMG_SetPinAltFuncMode(GPIO2_0_AS_QDM1_A);  /* Check function selection */
 300ea02:	017807b7          	lui	a5,0x1780
 300ea06:	23578513          	addi	a0,a5,565 # 1780235 <FLASH_SIZE+0x1760239>
 300ea0a:	9ebfa0ef          	jal	ra,30093f4 <HAL_IOCMG_SetPinAltFuncMode>
    HAL_IOCMG_SetPinPullMode(GPIO2_0_AS_QDM1_A, PULL_NONE);  /* Pull-up and pull-down */
 300ea0e:	4581                	li	a1,0
 300ea10:	017807b7          	lui	a5,0x1780
 300ea14:	23578513          	addi	a0,a5,565 # 1780235 <FLASH_SIZE+0x1760239>
 300ea18:	a17fa0ef          	jal	ra,300942e <HAL_IOCMG_SetPinPullMode>
    HAL_IOCMG_SetPinSchmidtMode(GPIO2_0_AS_QDM1_A, SCHMIDT_DISABLE);  /* Schmitt input on/off */
 300ea1c:	4581                	li	a1,0
 300ea1e:	017807b7          	lui	a5,0x1780
 300ea22:	23578513          	addi	a0,a5,565 # 1780235 <FLASH_SIZE+0x1760239>
 300ea26:	a55fa0ef          	jal	ra,300947a <HAL_IOCMG_SetPinSchmidtMode>
    HAL_IOCMG_SetPinLevelShiftRate(GPIO2_0_AS_QDM1_A, LEVEL_SHIFT_RATE_SLOW);  /* Output drive capability */
 300ea2a:	4585                	li	a1,1
 300ea2c:	017807b7          	lui	a5,0x1780
 300ea30:	23578513          	addi	a0,a5,565 # 1780235 <FLASH_SIZE+0x1760239>
 300ea34:	a93fa0ef          	jal	ra,30094c6 <HAL_IOCMG_SetPinLevelShiftRate>
    HAL_IOCMG_SetPinDriveRate(GPIO2_0_AS_QDM1_A, DRIVER_RATE_2);  /* Output signal edge fast/slow */
 300ea38:	4589                	li	a1,2
 300ea3a:	017807b7          	lui	a5,0x1780
 300ea3e:	23578513          	addi	a0,a5,565 # 1780235 <FLASH_SIZE+0x1760239>
 300ea42:	ad1fa0ef          	jal	ra,3009512 <HAL_IOCMG_SetPinDriveRate>

    HAL_IOCMG_SetPinAltFuncMode(GPIO2_1_AS_QDM1_B);  /* Check function selection */
 300ea46:	017c07b7          	lui	a5,0x17c0
 300ea4a:	23578513          	addi	a0,a5,565 # 17c0235 <FLASH_SIZE+0x17a0239>
 300ea4e:	9a7fa0ef          	jal	ra,30093f4 <HAL_IOCMG_SetPinAltFuncMode>
    HAL_IOCMG_SetPinPullMode(GPIO2_1_AS_QDM1_B, PULL_NONE);  /* Pull-up and pull-down */
 300ea52:	4581                	li	a1,0
 300ea54:	017c07b7          	lui	a5,0x17c0
 300ea58:	23578513          	addi	a0,a5,565 # 17c0235 <FLASH_SIZE+0x17a0239>
 300ea5c:	9d3fa0ef          	jal	ra,300942e <HAL_IOCMG_SetPinPullMode>
    HAL_IOCMG_SetPinSchmidtMode(GPIO2_1_AS_QDM1_B, SCHMIDT_DISABLE);  /* Schmitt input on/off */
 300ea60:	4581                	li	a1,0
 300ea62:	017c07b7          	lui	a5,0x17c0
 300ea66:	23578513          	addi	a0,a5,565 # 17c0235 <FLASH_SIZE+0x17a0239>
 300ea6a:	a11fa0ef          	jal	ra,300947a <HAL_IOCMG_SetPinSchmidtMode>
    HAL_IOCMG_SetPinLevelShiftRate(GPIO2_1_AS_QDM1_B, LEVEL_SHIFT_RATE_SLOW);  /* Output drive capability */
 300ea6e:	4585                	li	a1,1
 300ea70:	017c07b7          	lui	a5,0x17c0
 300ea74:	23578513          	addi	a0,a5,565 # 17c0235 <FLASH_SIZE+0x17a0239>
 300ea78:	a4ffa0ef          	jal	ra,30094c6 <HAL_IOCMG_SetPinLevelShiftRate>
    HAL_IOCMG_SetPinDriveRate(GPIO2_1_AS_QDM1_B, DRIVER_RATE_2);  /* Output signal edge fast/slow */
 300ea7c:	4589                	li	a1,2
 300ea7e:	017c07b7          	lui	a5,0x17c0
 300ea82:	23578513          	addi	a0,a5,565 # 17c0235 <FLASH_SIZE+0x17a0239>
 300ea86:	a8dfa0ef          	jal	ra,3009512 <HAL_IOCMG_SetPinDriveRate>

    HAL_IOCMG_SetPinAltFuncMode(GPIO5_0_AS_QDM1_INDEX);  /* Check function selection */
 300ea8a:	001007b7          	lui	a5,0x100
 300ea8e:	23578513          	addi	a0,a5,565 # 100235 <FLASH_SIZE+0xe0239>
 300ea92:	963fa0ef          	jal	ra,30093f4 <HAL_IOCMG_SetPinAltFuncMode>
    HAL_IOCMG_SetPinPullMode(GPIO5_0_AS_QDM1_INDEX, PULL_NONE);  /* Pull-up and pull-down */
 300ea96:	4581                	li	a1,0
 300ea98:	001007b7          	lui	a5,0x100
 300ea9c:	23578513          	addi	a0,a5,565 # 100235 <FLASH_SIZE+0xe0239>
 300eaa0:	98ffa0ef          	jal	ra,300942e <HAL_IOCMG_SetPinPullMode>
    HAL_IOCMG_SetPinSchmidtMode(GPIO5_0_AS_QDM1_INDEX, SCHMIDT_DISABLE);  /* Schmitt input on/off */
 300eaa4:	4581                	li	a1,0
 300eaa6:	001007b7          	lui	a5,0x100
 300eaaa:	23578513          	addi	a0,a5,565 # 100235 <FLASH_SIZE+0xe0239>
 300eaae:	9cdfa0ef          	jal	ra,300947a <HAL_IOCMG_SetPinSchmidtMode>
    HAL_IOCMG_SetPinLevelShiftRate(GPIO5_0_AS_QDM1_INDEX, LEVEL_SHIFT_RATE_SLOW);  /* Output drive capability */
 300eab2:	4585                	li	a1,1
 300eab4:	001007b7          	lui	a5,0x100
 300eab8:	23578513          	addi	a0,a5,565 # 100235 <FLASH_SIZE+0xe0239>
 300eabc:	a0bfa0ef          	jal	ra,30094c6 <HAL_IOCMG_SetPinLevelShiftRate>
    HAL_IOCMG_SetPinDriveRate(GPIO5_0_AS_QDM1_INDEX, DRIVER_RATE_2);  /* Output signal edge fast/slow */
 300eac0:	4589                	li	a1,2
 300eac2:	001007b7          	lui	a5,0x100
 300eac6:	23578513          	addi	a0,a5,565 # 100235 <FLASH_SIZE+0xe0239>
 300eaca:	a49fa0ef          	jal	ra,3009512 <HAL_IOCMG_SetPinDriveRate>

    HAL_IOCMG_SetPinAltFuncMode(GPIO1_7_AS_I2C1_SCL);  /* Check function selection */
 300eace:	013007b7          	lui	a5,0x1300
 300ead2:	23278513          	addi	a0,a5,562 # 1300232 <FLASH_SIZE+0x12e0236>
 300ead6:	91ffa0ef          	jal	ra,30093f4 <HAL_IOCMG_SetPinAltFuncMode>
    HAL_IOCMG_SetPinPullMode(GPIO1_7_AS_I2C1_SCL, PULL_NONE);  /* Pull-up and pull-down */
 300eada:	4581                	li	a1,0
 300eadc:	013007b7          	lui	a5,0x1300
 300eae0:	23278513          	addi	a0,a5,562 # 1300232 <FLASH_SIZE+0x12e0236>
 300eae4:	94bfa0ef          	jal	ra,300942e <HAL_IOCMG_SetPinPullMode>
    HAL_IOCMG_SetPinSchmidtMode(GPIO1_7_AS_I2C1_SCL, SCHMIDT_DISABLE);  /* Schmitt input on/off */
 300eae8:	4581                	li	a1,0
 300eaea:	013007b7          	lui	a5,0x1300
 300eaee:	23278513          	addi	a0,a5,562 # 1300232 <FLASH_SIZE+0x12e0236>
 300eaf2:	53e000ef          	jal	ra,300f030 <HAL_IOCMG_SetPinSchmidtMode.trans.16>
    HAL_IOCMG_SetPinLevelShiftRate(GPIO1_7_AS_I2C1_SCL, LEVEL_SHIFT_RATE_SLOW);  /* Output drive capability */
 300eaf6:	4585                	li	a1,1
 300eaf8:	013007b7          	lui	a5,0x1300
 300eafc:	23278513          	addi	a0,a5,562 # 1300232 <FLASH_SIZE+0x12e0236>
 300eb00:	52c000ef          	jal	ra,300f02c <HAL_IOCMG_SetPinLevelShiftRate.trans.17>
    HAL_IOCMG_SetPinDriveRate(GPIO1_7_AS_I2C1_SCL, DRIVER_RATE_2);  /* Output signal edge fast/slow */
 300eb04:	4589                	li	a1,2
 300eb06:	013007b7          	lui	a5,0x1300
 300eb0a:	23278513          	addi	a0,a5,562 # 1300232 <FLASH_SIZE+0x12e0236>
 300eb0e:	51a000ef          	jal	ra,300f028 <HAL_IOCMG_SetPinDriveRate.trans.18>

    HAL_IOCMG_SetPinAltFuncMode(GPIO4_7_AS_I2C1_SDA);  /* Check function selection */
 300eb12:	013407b7          	lui	a5,0x1340
 300eb16:	23278513          	addi	a0,a5,562 # 1340232 <FLASH_SIZE+0x1320236>
 300eb1a:	51e000ef          	jal	ra,300f038 <HAL_IOCMG_SetPinAltFuncMode.trans.14>
    HAL_IOCMG_SetPinPullMode(GPIO4_7_AS_I2C1_SDA, PULL_NONE);  /* Pull-up and pull-down */
 300eb1e:	4581                	li	a1,0
 300eb20:	013407b7          	lui	a5,0x1340
 300eb24:	23278513          	addi	a0,a5,562 # 1340232 <FLASH_SIZE+0x1320236>
 300eb28:	50c000ef          	jal	ra,300f034 <HAL_IOCMG_SetPinPullMode.trans.15>
    HAL_IOCMG_SetPinSchmidtMode(GPIO4_7_AS_I2C1_SDA, SCHMIDT_DISABLE);  /* Schmitt input on/off */
 300eb2c:	4581                	li	a1,0
 300eb2e:	013407b7          	lui	a5,0x1340
 300eb32:	23278513          	addi	a0,a5,562 # 1340232 <FLASH_SIZE+0x1320236>
 300eb36:	4fa000ef          	jal	ra,300f030 <HAL_IOCMG_SetPinSchmidtMode.trans.16>
    HAL_IOCMG_SetPinLevelShiftRate(GPIO4_7_AS_I2C1_SDA, LEVEL_SHIFT_RATE_SLOW);  /* Output drive capability */
 300eb3a:	4585                	li	a1,1
 300eb3c:	013407b7          	lui	a5,0x1340
 300eb40:	23278513          	addi	a0,a5,562 # 1340232 <FLASH_SIZE+0x1320236>
 300eb44:	4e8000ef          	jal	ra,300f02c <HAL_IOCMG_SetPinLevelShiftRate.trans.17>
    HAL_IOCMG_SetPinDriveRate(GPIO4_7_AS_I2C1_SDA, DRIVER_RATE_2);  /* Output signal edge fast/slow */
 300eb48:	4589                	li	a1,2
 300eb4a:	013407b7          	lui	a5,0x1340
 300eb4e:	23278513          	addi	a0,a5,562 # 1340232 <FLASH_SIZE+0x1320236>
 300eb52:	4d6000ef          	jal	ra,300f028 <HAL_IOCMG_SetPinDriveRate.trans.18>

    HAL_IOCMG_SetPinAltFuncMode(GPIO1_5_AS_UART2_TXD);  /* Check function selection */
 300eb56:	012807b7          	lui	a5,0x1280
 300eb5a:	23378513          	addi	a0,a5,563 # 1280233 <FLASH_SIZE+0x1260237>
 300eb5e:	4da000ef          	jal	ra,300f038 <HAL_IOCMG_SetPinAltFuncMode.trans.14>
    HAL_IOCMG_SetPinPullMode(GPIO1_5_AS_UART2_TXD, PULL_NONE);  /* Pull-up and pull-down */
 300eb62:	4581                	li	a1,0
 300eb64:	012807b7          	lui	a5,0x1280
 300eb68:	23378513          	addi	a0,a5,563 # 1280233 <FLASH_SIZE+0x1260237>
 300eb6c:	4c8000ef          	jal	ra,300f034 <HAL_IOCMG_SetPinPullMode.trans.15>
    HAL_IOCMG_SetPinSchmidtMode(GPIO1_5_AS_UART2_TXD, SCHMIDT_DISABLE);  /* Schmitt input on/off */
 300eb70:	4581                	li	a1,0
 300eb72:	012807b7          	lui	a5,0x1280
 300eb76:	23378513          	addi	a0,a5,563 # 1280233 <FLASH_SIZE+0x1260237>
 300eb7a:	4b6000ef          	jal	ra,300f030 <HAL_IOCMG_SetPinSchmidtMode.trans.16>
    HAL_IOCMG_SetPinLevelShiftRate(GPIO1_5_AS_UART2_TXD, LEVEL_SHIFT_RATE_SLOW);  /* Output drive capability */
 300eb7e:	4585                	li	a1,1
 300eb80:	012807b7          	lui	a5,0x1280
 300eb84:	23378513          	addi	a0,a5,563 # 1280233 <FLASH_SIZE+0x1260237>
 300eb88:	2155                	jal	ra,300f02c <HAL_IOCMG_SetPinLevelShiftRate.trans.17>
    HAL_IOCMG_SetPinDriveRate(GPIO1_5_AS_UART2_TXD, DRIVER_RATE_2);  /* Output signal edge fast/slow */
 300eb8a:	4589                	li	a1,2
 300eb8c:	012807b7          	lui	a5,0x1280
 300eb90:	23378513          	addi	a0,a5,563 # 1280233 <FLASH_SIZE+0x1260237>
 300eb94:	2951                	jal	ra,300f028 <HAL_IOCMG_SetPinDriveRate.trans.18>

    HAL_IOCMG_SetPinAltFuncMode(GPIO1_6_AS_UART2_RXD);  /* Check function selection */
 300eb96:	012c07b7          	lui	a5,0x12c0
 300eb9a:	23378513          	addi	a0,a5,563 # 12c0233 <FLASH_SIZE+0x12a0237>
 300eb9e:	2969                	jal	ra,300f038 <HAL_IOCMG_SetPinAltFuncMode.trans.14>
    HAL_IOCMG_SetPinPullMode(GPIO1_6_AS_UART2_RXD, PULL_NONE);  /* Pull-up and pull-down */
 300eba0:	4581                	li	a1,0
 300eba2:	012c07b7          	lui	a5,0x12c0
 300eba6:	23378513          	addi	a0,a5,563 # 12c0233 <FLASH_SIZE+0x12a0237>
 300ebaa:	2169                	jal	ra,300f034 <HAL_IOCMG_SetPinPullMode.trans.15>
    HAL_IOCMG_SetPinSchmidtMode(GPIO1_6_AS_UART2_RXD, SCHMIDT_DISABLE);  /* Schmitt input on/off */
 300ebac:	4581                	li	a1,0
 300ebae:	012c07b7          	lui	a5,0x12c0
 300ebb2:	23378513          	addi	a0,a5,563 # 12c0233 <FLASH_SIZE+0x12a0237>
 300ebb6:	29ad                	jal	ra,300f030 <HAL_IOCMG_SetPinSchmidtMode.trans.16>
    HAL_IOCMG_SetPinLevelShiftRate(GPIO1_6_AS_UART2_RXD, LEVEL_SHIFT_RATE_SLOW);  /* Output drive capability */
 300ebb8:	4585                	li	a1,1
 300ebba:	012c07b7          	lui	a5,0x12c0
 300ebbe:	23378513          	addi	a0,a5,563 # 12c0233 <FLASH_SIZE+0x12a0237>
 300ebc2:	21ad                	jal	ra,300f02c <HAL_IOCMG_SetPinLevelShiftRate.trans.17>
    HAL_IOCMG_SetPinDriveRate(GPIO1_6_AS_UART2_RXD, DRIVER_RATE_2);  /* Output signal edge fast/slow */
 300ebc4:	4589                	li	a1,2
 300ebc6:	012c07b7          	lui	a5,0x12c0
 300ebca:	23378513          	addi	a0,a5,563 # 12c0233 <FLASH_SIZE+0x12a0237>
 300ebce:	29a9                	jal	ra,300f028 <HAL_IOCMG_SetPinDriveRate.trans.18>

    HAL_IOCMG_SetPinAltFuncMode(GPIO5_2_AS_GPT2_PWM);  /* Check function selection */
 300ebd0:	011407b7          	lui	a5,0x1140
 300ebd4:	23178513          	addi	a0,a5,561 # 1140231 <FLASH_SIZE+0x1120235>
 300ebd8:	2185                	jal	ra,300f038 <HAL_IOCMG_SetPinAltFuncMode.trans.14>
    HAL_IOCMG_SetPinPullMode(GPIO5_2_AS_GPT2_PWM, PULL_NONE);  /* Pull-up and pull-down */
 300ebda:	4581                	li	a1,0
 300ebdc:	011407b7          	lui	a5,0x1140
 300ebe0:	23178513          	addi	a0,a5,561 # 1140231 <FLASH_SIZE+0x1120235>
 300ebe4:	2981                	jal	ra,300f034 <HAL_IOCMG_SetPinPullMode.trans.15>
    HAL_IOCMG_SetPinSchmidtMode(GPIO5_2_AS_GPT2_PWM, SCHMIDT_DISABLE);  /* Schmitt input on/off */
 300ebe6:	4581                	li	a1,0
 300ebe8:	011407b7          	lui	a5,0x1140
 300ebec:	23178513          	addi	a0,a5,561 # 1140231 <FLASH_SIZE+0x1120235>
 300ebf0:	2181                	jal	ra,300f030 <HAL_IOCMG_SetPinSchmidtMode.trans.16>
    HAL_IOCMG_SetPinLevelShiftRate(GPIO5_2_AS_GPT2_PWM, LEVEL_SHIFT_RATE_SLOW);  /* Output drive capability */
 300ebf2:	4585                	li	a1,1
 300ebf4:	011407b7          	lui	a5,0x1140
 300ebf8:	23178513          	addi	a0,a5,561 # 1140231 <FLASH_SIZE+0x1120235>
 300ebfc:	2905                	jal	ra,300f02c <HAL_IOCMG_SetPinLevelShiftRate.trans.17>
    HAL_IOCMG_SetPinDriveRate(GPIO5_2_AS_GPT2_PWM, DRIVER_RATE_2);  /* Output signal edge fast/slow */
 300ebfe:	4589                	li	a1,2
 300ec00:	011407b7          	lui	a5,0x1140
 300ec04:	23178513          	addi	a0,a5,561 # 1140231 <FLASH_SIZE+0x1120235>
 300ec08:	2105                	jal	ra,300f028 <HAL_IOCMG_SetPinDriveRate.trans.18>

    HAL_IOCMG_SetPinAltFuncMode(GPIO0_5_AS_GPT1_PWM);  /* Check function selection */
 300ec0a:	01a007b7          	lui	a5,0x1a00
 300ec0e:	22278513          	addi	a0,a5,546 # 1a00222 <FLASH_SIZE+0x19e0226>
 300ec12:	211d                	jal	ra,300f038 <HAL_IOCMG_SetPinAltFuncMode.trans.14>
    HAL_IOCMG_SetPinPullMode(GPIO0_5_AS_GPT1_PWM, PULL_NONE);  /* Pull-up and pull-down */
 300ec14:	4581                	li	a1,0
 300ec16:	01a007b7          	lui	a5,0x1a00
 300ec1a:	22278513          	addi	a0,a5,546 # 1a00222 <FLASH_SIZE+0x19e0226>
 300ec1e:	2919                	jal	ra,300f034 <HAL_IOCMG_SetPinPullMode.trans.15>
    HAL_IOCMG_SetPinSchmidtMode(GPIO0_5_AS_GPT1_PWM, SCHMIDT_DISABLE);  /* Schmitt input on/off */
 300ec20:	4581                	li	a1,0
 300ec22:	01a007b7          	lui	a5,0x1a00
 300ec26:	22278513          	addi	a0,a5,546 # 1a00222 <FLASH_SIZE+0x19e0226>
 300ec2a:	2119                	jal	ra,300f030 <HAL_IOCMG_SetPinSchmidtMode.trans.16>
    HAL_IOCMG_SetPinLevelShiftRate(GPIO0_5_AS_GPT1_PWM, LEVEL_SHIFT_RATE_SLOW);  /* Output drive capability */
 300ec2c:	4585                	li	a1,1
 300ec2e:	01a007b7          	lui	a5,0x1a00
 300ec32:	22278513          	addi	a0,a5,546 # 1a00222 <FLASH_SIZE+0x19e0226>
 300ec36:	2edd                	jal	ra,300f02c <HAL_IOCMG_SetPinLevelShiftRate.trans.17>
    HAL_IOCMG_SetPinDriveRate(GPIO0_5_AS_GPT1_PWM, DRIVER_RATE_2);  /* Output signal edge fast/slow */
 300ec38:	4589                	li	a1,2
 300ec3a:	01a007b7          	lui	a5,0x1a00
 300ec3e:	22278513          	addi	a0,a5,546 # 1a00222 <FLASH_SIZE+0x19e0226>
 300ec42:	26dd                	jal	ra,300f028 <HAL_IOCMG_SetPinDriveRate.trans.18>

    HAL_IOCMG_SetPinAltFuncMode(GPIO2_4_AS_GPT0_PWM);  /* Check function selection */
 300ec44:	001c07b7          	lui	a5,0x1c0
 300ec48:	23278513          	addi	a0,a5,562 # 1c0232 <FLASH_SIZE+0x1a0236>
 300ec4c:	26f5                	jal	ra,300f038 <HAL_IOCMG_SetPinAltFuncMode.trans.14>
    HAL_IOCMG_SetPinPullMode(GPIO2_4_AS_GPT0_PWM, PULL_NONE);  /* Pull-up and pull-down */
 300ec4e:	4581                	li	a1,0
 300ec50:	001c07b7          	lui	a5,0x1c0
 300ec54:	23278513          	addi	a0,a5,562 # 1c0232 <FLASH_SIZE+0x1a0236>
 300ec58:	2ef1                	jal	ra,300f034 <HAL_IOCMG_SetPinPullMode.trans.15>
    HAL_IOCMG_SetPinSchmidtMode(GPIO2_4_AS_GPT0_PWM, SCHMIDT_DISABLE);  /* Schmitt input on/off */
 300ec5a:	4581                	li	a1,0
 300ec5c:	001c07b7          	lui	a5,0x1c0
 300ec60:	23278513          	addi	a0,a5,562 # 1c0232 <FLASH_SIZE+0x1a0236>
 300ec64:	26f1                	jal	ra,300f030 <HAL_IOCMG_SetPinSchmidtMode.trans.16>
    HAL_IOCMG_SetPinLevelShiftRate(GPIO2_4_AS_GPT0_PWM, LEVEL_SHIFT_RATE_SLOW);  /* Output drive capability */
 300ec66:	4585                	li	a1,1
 300ec68:	001c07b7          	lui	a5,0x1c0
 300ec6c:	23278513          	addi	a0,a5,562 # 1c0232 <FLASH_SIZE+0x1a0236>
 300ec70:	2e75                	jal	ra,300f02c <HAL_IOCMG_SetPinLevelShiftRate.trans.17>
    HAL_IOCMG_SetPinDriveRate(GPIO2_4_AS_GPT0_PWM, DRIVER_RATE_2);  /* Output signal edge fast/slow */
 300ec72:	4589                	li	a1,2
 300ec74:	001c07b7          	lui	a5,0x1c0
 300ec78:	23278513          	addi	a0,a5,562 # 1c0232 <FLASH_SIZE+0x1a0236>
 300ec7c:	2675                	jal	ra,300f028 <HAL_IOCMG_SetPinDriveRate.trans.18>

    HAL_IOCMG_SetPinAltFuncMode(GPIO1_0_AS_GPIO1_0);  /* Check function selection */
 300ec7e:	016807b7          	lui	a5,0x1680
 300ec82:	23078513          	addi	a0,a5,560 # 1680230 <FLASH_SIZE+0x1660234>
 300ec86:	2e4d                	jal	ra,300f038 <HAL_IOCMG_SetPinAltFuncMode.trans.14>
    HAL_IOCMG_SetPinPullMode(GPIO1_0_AS_GPIO1_0, PULL_NONE);  /* Pull-up and pull-down */
 300ec88:	4581                	li	a1,0
 300ec8a:	016807b7          	lui	a5,0x1680
 300ec8e:	23078513          	addi	a0,a5,560 # 1680230 <FLASH_SIZE+0x1660234>
 300ec92:	264d                	jal	ra,300f034 <HAL_IOCMG_SetPinPullMode.trans.15>
    HAL_IOCMG_SetPinSchmidtMode(GPIO1_0_AS_GPIO1_0, SCHMIDT_DISABLE);  /* Schmitt input on/off */
 300ec94:	4581                	li	a1,0
 300ec96:	016807b7          	lui	a5,0x1680
 300ec9a:	23078513          	addi	a0,a5,560 # 1680230 <FLASH_SIZE+0x1660234>
 300ec9e:	2e49                	jal	ra,300f030 <HAL_IOCMG_SetPinSchmidtMode.trans.16>
    HAL_IOCMG_SetPinLevelShiftRate(GPIO1_0_AS_GPIO1_0, LEVEL_SHIFT_RATE_SLOW);  /* Output drive capability */
 300eca0:	4585                	li	a1,1
 300eca2:	016807b7          	lui	a5,0x1680
 300eca6:	23078513          	addi	a0,a5,560 # 1680230 <FLASH_SIZE+0x1660234>
 300ecaa:	2649                	jal	ra,300f02c <HAL_IOCMG_SetPinLevelShiftRate.trans.17>
    HAL_IOCMG_SetPinDriveRate(GPIO1_0_AS_GPIO1_0, DRIVER_RATE_2);  /* Output signal edge fast/slow */
 300ecac:	4589                	li	a1,2
 300ecae:	016807b7          	lui	a5,0x1680
 300ecb2:	23078513          	addi	a0,a5,560 # 1680230 <FLASH_SIZE+0x1660234>
 300ecb6:	2e8d                	jal	ra,300f028 <HAL_IOCMG_SetPinDriveRate.trans.18>

    HAL_IOCMG_SetPinAltFuncMode(GPIO1_1_AS_GPIO1_1);  /* Check function selection */
 300ecb8:	016c07b7          	lui	a5,0x16c0
 300ecbc:	23078513          	addi	a0,a5,560 # 16c0230 <FLASH_SIZE+0x16a0234>
 300ecc0:	2ea5                	jal	ra,300f038 <HAL_IOCMG_SetPinAltFuncMode.trans.14>
    HAL_IOCMG_SetPinPullMode(GPIO1_1_AS_GPIO1_1, PULL_NONE);  /* Pull-up and pull-down */
 300ecc2:	4581                	li	a1,0
 300ecc4:	016c07b7          	lui	a5,0x16c0
 300ecc8:	23078513          	addi	a0,a5,560 # 16c0230 <FLASH_SIZE+0x16a0234>
 300eccc:	26a5                	jal	ra,300f034 <HAL_IOCMG_SetPinPullMode.trans.15>
    HAL_IOCMG_SetPinSchmidtMode(GPIO1_1_AS_GPIO1_1, SCHMIDT_DISABLE);  /* Schmitt input on/off */
 300ecce:	4581                	li	a1,0
 300ecd0:	016c07b7          	lui	a5,0x16c0
 300ecd4:	23078513          	addi	a0,a5,560 # 16c0230 <FLASH_SIZE+0x16a0234>
 300ecd8:	2ea1                	jal	ra,300f030 <HAL_IOCMG_SetPinSchmidtMode.trans.16>
    HAL_IOCMG_SetPinLevelShiftRate(GPIO1_1_AS_GPIO1_1, LEVEL_SHIFT_RATE_SLOW);  /* Output drive capability */
 300ecda:	4585                	li	a1,1
 300ecdc:	016c07b7          	lui	a5,0x16c0
 300ece0:	23078513          	addi	a0,a5,560 # 16c0230 <FLASH_SIZE+0x16a0234>
 300ece4:	26a1                	jal	ra,300f02c <HAL_IOCMG_SetPinLevelShiftRate.trans.17>
    HAL_IOCMG_SetPinDriveRate(GPIO1_1_AS_GPIO1_1, DRIVER_RATE_2);  /* Output signal edge fast/slow */
 300ece6:	4589                	li	a1,2
 300ece8:	016c07b7          	lui	a5,0x16c0
 300ecec:	23078513          	addi	a0,a5,560 # 16c0230 <FLASH_SIZE+0x16a0234>
 300ecf0:	2e25                	jal	ra,300f028 <HAL_IOCMG_SetPinDriveRate.trans.18>

    HAL_IOCMG_SetPinAltFuncMode(GPIO2_5_AS_GPIO2_5);  /* Check function selection */
 300ecf2:	011007b7          	lui	a5,0x1100
 300ecf6:	23078513          	addi	a0,a5,560 # 1100230 <FLASH_SIZE+0x10e0234>
 300ecfa:	2e3d                	jal	ra,300f038 <HAL_IOCMG_SetPinAltFuncMode.trans.14>
    HAL_IOCMG_SetPinPullMode(GPIO2_5_AS_GPIO2_5, PULL_NONE);  /* Pull-up and pull-down */
 300ecfc:	4581                	li	a1,0
 300ecfe:	011007b7          	lui	a5,0x1100
 300ed02:	23078513          	addi	a0,a5,560 # 1100230 <FLASH_SIZE+0x10e0234>
 300ed06:	263d                	jal	ra,300f034 <HAL_IOCMG_SetPinPullMode.trans.15>
    HAL_IOCMG_SetPinSchmidtMode(GPIO2_5_AS_GPIO2_5, SCHMIDT_DISABLE);  /* Schmitt input on/off */
 300ed08:	4581                	li	a1,0
 300ed0a:	011007b7          	lui	a5,0x1100
 300ed0e:	23078513          	addi	a0,a5,560 # 1100230 <FLASH_SIZE+0x10e0234>
 300ed12:	2e39                	jal	ra,300f030 <HAL_IOCMG_SetPinSchmidtMode.trans.16>
    HAL_IOCMG_SetPinLevelShiftRate(GPIO2_5_AS_GPIO2_5, LEVEL_SHIFT_RATE_SLOW);  /* Output drive capability */
 300ed14:	4585                	li	a1,1
 300ed16:	011007b7          	lui	a5,0x1100
 300ed1a:	23078513          	addi	a0,a5,560 # 1100230 <FLASH_SIZE+0x10e0234>
 300ed1e:	2639                	jal	ra,300f02c <HAL_IOCMG_SetPinLevelShiftRate.trans.17>
    HAL_IOCMG_SetPinDriveRate(GPIO2_5_AS_GPIO2_5, DRIVER_RATE_2);  /* Output signal edge fast/slow */
 300ed20:	4589                	li	a1,2
 300ed22:	011007b7          	lui	a5,0x1100
 300ed26:	23078513          	addi	a0,a5,560 # 1100230 <FLASH_SIZE+0x10e0234>
 300ed2a:	2cfd                	jal	ra,300f028 <HAL_IOCMG_SetPinDriveRate.trans.18>

    HAL_IOCMG_SetPinAltFuncMode(GPIO2_6_AS_GPIO2_6);  /* Check function selection */
 300ed2c:	010c07b7          	lui	a5,0x10c0
 300ed30:	23078513          	addi	a0,a5,560 # 10c0230 <FLASH_SIZE+0x10a0234>
 300ed34:	2611                	jal	ra,300f038 <HAL_IOCMG_SetPinAltFuncMode.trans.14>
    HAL_IOCMG_SetPinPullMode(GPIO2_6_AS_GPIO2_6, PULL_NONE);  /* Pull-up and pull-down */
 300ed36:	4581                	li	a1,0
 300ed38:	010c07b7          	lui	a5,0x10c0
 300ed3c:	23078513          	addi	a0,a5,560 # 10c0230 <FLASH_SIZE+0x10a0234>
 300ed40:	2cd5                	jal	ra,300f034 <HAL_IOCMG_SetPinPullMode.trans.15>
    HAL_IOCMG_SetPinSchmidtMode(GPIO2_6_AS_GPIO2_6, SCHMIDT_DISABLE);  /* Schmitt input on/off */
 300ed42:	4581                	li	a1,0
 300ed44:	010c07b7          	lui	a5,0x10c0
 300ed48:	23078513          	addi	a0,a5,560 # 10c0230 <FLASH_SIZE+0x10a0234>
 300ed4c:	24d5                	jal	ra,300f030 <HAL_IOCMG_SetPinSchmidtMode.trans.16>
    HAL_IOCMG_SetPinLevelShiftRate(GPIO2_6_AS_GPIO2_6, LEVEL_SHIFT_RATE_SLOW);  /* Output drive capability */
 300ed4e:	4585                	li	a1,1
 300ed50:	010c07b7          	lui	a5,0x10c0
 300ed54:	23078513          	addi	a0,a5,560 # 10c0230 <FLASH_SIZE+0x10a0234>
 300ed58:	2cd1                	jal	ra,300f02c <HAL_IOCMG_SetPinLevelShiftRate.trans.17>
    HAL_IOCMG_SetPinDriveRate(GPIO2_6_AS_GPIO2_6, DRIVER_RATE_2);  /* Output signal edge fast/slow */
 300ed5a:	4589                	li	a1,2
 300ed5c:	010c07b7          	lui	a5,0x10c0
 300ed60:	23078513          	addi	a0,a5,560 # 10c0230 <FLASH_SIZE+0x10a0234>
 300ed64:	24d1                	jal	ra,300f028 <HAL_IOCMG_SetPinDriveRate.trans.18>

    HAL_IOCMG_SetPinAltFuncMode(GPIO2_7_AS_GPIO2_7);  /* Check function selection */
 300ed66:	010807b7          	lui	a5,0x1080
 300ed6a:	23078513          	addi	a0,a5,560 # 1080230 <FLASH_SIZE+0x1060234>
 300ed6e:	24e9                	jal	ra,300f038 <HAL_IOCMG_SetPinAltFuncMode.trans.14>
    HAL_IOCMG_SetPinPullMode(GPIO2_7_AS_GPIO2_7, PULL_NONE);  /* Pull-up and pull-down */
 300ed70:	4581                	li	a1,0
 300ed72:	010807b7          	lui	a5,0x1080
 300ed76:	23078513          	addi	a0,a5,560 # 1080230 <FLASH_SIZE+0x1060234>
 300ed7a:	2c6d                	jal	ra,300f034 <HAL_IOCMG_SetPinPullMode.trans.15>
    HAL_IOCMG_SetPinSchmidtMode(GPIO2_7_AS_GPIO2_7, SCHMIDT_DISABLE);  /* Schmitt input on/off */
 300ed7c:	4581                	li	a1,0
 300ed7e:	010807b7          	lui	a5,0x1080
 300ed82:	23078513          	addi	a0,a5,560 # 1080230 <FLASH_SIZE+0x1060234>
 300ed86:	246d                	jal	ra,300f030 <HAL_IOCMG_SetPinSchmidtMode.trans.16>
    HAL_IOCMG_SetPinLevelShiftRate(GPIO2_7_AS_GPIO2_7, LEVEL_SHIFT_RATE_SLOW);  /* Output drive capability */
 300ed88:	4585                	li	a1,1
 300ed8a:	010807b7          	lui	a5,0x1080
 300ed8e:	23078513          	addi	a0,a5,560 # 1080230 <FLASH_SIZE+0x1060234>
 300ed92:	2c69                	jal	ra,300f02c <HAL_IOCMG_SetPinLevelShiftRate.trans.17>
    HAL_IOCMG_SetPinDriveRate(GPIO2_7_AS_GPIO2_7, DRIVER_RATE_2);  /* Output signal edge fast/slow */
 300ed94:	4589                	li	a1,2
 300ed96:	010807b7          	lui	a5,0x1080
 300ed9a:	23078513          	addi	a0,a5,560 # 1080230 <FLASH_SIZE+0x1060234>
 300ed9e:	2469                	jal	ra,300f028 <HAL_IOCMG_SetPinDriveRate.trans.18>

    HAL_IOCMG_SetPinAltFuncMode(GPIO5_1_AS_GPIO5_1);  /* Check function selection */
 300eda0:	010407b7          	lui	a5,0x1040
 300eda4:	23078513          	addi	a0,a5,560 # 1040230 <FLASH_SIZE+0x1020234>
 300eda8:	2c41                	jal	ra,300f038 <HAL_IOCMG_SetPinAltFuncMode.trans.14>
    HAL_IOCMG_SetPinPullMode(GPIO5_1_AS_GPIO5_1, PULL_NONE);  /* Pull-up and pull-down */
 300edaa:	4581                	li	a1,0
 300edac:	010407b7          	lui	a5,0x1040
 300edb0:	23078513          	addi	a0,a5,560 # 1040230 <FLASH_SIZE+0x1020234>
 300edb4:	2441                	jal	ra,300f034 <HAL_IOCMG_SetPinPullMode.trans.15>
    HAL_IOCMG_SetPinSchmidtMode(GPIO5_1_AS_GPIO5_1, SCHMIDT_DISABLE);  /* Schmitt input on/off */
 300edb6:	4581                	li	a1,0
 300edb8:	010407b7          	lui	a5,0x1040
 300edbc:	23078513          	addi	a0,a5,560 # 1040230 <FLASH_SIZE+0x1020234>
 300edc0:	2c85                	jal	ra,300f030 <HAL_IOCMG_SetPinSchmidtMode.trans.16>
    HAL_IOCMG_SetPinLevelShiftRate(GPIO5_1_AS_GPIO5_1, LEVEL_SHIFT_RATE_SLOW);  /* Output drive capability */
 300edc2:	4585                	li	a1,1
 300edc4:	010407b7          	lui	a5,0x1040
 300edc8:	23078513          	addi	a0,a5,560 # 1040230 <FLASH_SIZE+0x1020234>
 300edcc:	2485                	jal	ra,300f02c <HAL_IOCMG_SetPinLevelShiftRate.trans.17>
    HAL_IOCMG_SetPinDriveRate(GPIO5_1_AS_GPIO5_1, DRIVER_RATE_2);  /* Output signal edge fast/slow */
 300edce:	4589                	li	a1,2
 300edd0:	010407b7          	lui	a5,0x1040
 300edd4:	23078513          	addi	a0,a5,560 # 1040230 <FLASH_SIZE+0x1020234>
 300edd8:	2c81                	jal	ra,300f028 <HAL_IOCMG_SetPinDriveRate.trans.18>

    HAL_IOCMG_SetPinAltFuncMode(GPIO1_4_AS_UART3_RXD);  /* Check function selection */
 300edda:	014407b7          	lui	a5,0x1440
 300edde:	23378513          	addi	a0,a5,563 # 1440233 <FLASH_SIZE+0x1420237>
 300ede2:	2c99                	jal	ra,300f038 <HAL_IOCMG_SetPinAltFuncMode.trans.14>
    HAL_IOCMG_SetPinPullMode(GPIO1_4_AS_UART3_RXD, PULL_NONE);  /* Pull-up and pull-down */
 300ede4:	4581                	li	a1,0
 300ede6:	014407b7          	lui	a5,0x1440
 300edea:	23378513          	addi	a0,a5,563 # 1440233 <FLASH_SIZE+0x1420237>
 300edee:	2499                	jal	ra,300f034 <HAL_IOCMG_SetPinPullMode.trans.15>
    HAL_IOCMG_SetPinSchmidtMode(GPIO1_4_AS_UART3_RXD, SCHMIDT_DISABLE);  /* Schmitt input on/off */
 300edf0:	4581                	li	a1,0
 300edf2:	014407b7          	lui	a5,0x1440
 300edf6:	23378513          	addi	a0,a5,563 # 1440233 <FLASH_SIZE+0x1420237>
 300edfa:	2c1d                	jal	ra,300f030 <HAL_IOCMG_SetPinSchmidtMode.trans.16>
    HAL_IOCMG_SetPinLevelShiftRate(GPIO1_4_AS_UART3_RXD, LEVEL_SHIFT_RATE_SLOW);  /* Output drive capability */
 300edfc:	4585                	li	a1,1
 300edfe:	014407b7          	lui	a5,0x1440
 300ee02:	23378513          	addi	a0,a5,563 # 1440233 <FLASH_SIZE+0x1420237>
 300ee06:	241d                	jal	ra,300f02c <HAL_IOCMG_SetPinLevelShiftRate.trans.17>
    HAL_IOCMG_SetPinDriveRate(GPIO1_4_AS_UART3_RXD, DRIVER_RATE_2);  /* Output signal edge fast/slow */
 300ee08:	4589                	li	a1,2
 300ee0a:	014407b7          	lui	a5,0x1440
 300ee0e:	23378513          	addi	a0,a5,563 # 1440233 <FLASH_SIZE+0x1420237>
 300ee12:	2c19                	jal	ra,300f028 <HAL_IOCMG_SetPinDriveRate.trans.18>

    HAL_IOCMG_SetPinAltFuncMode(GPIO1_3_AS_UART3_TXD);  /* Check function selection */
 300ee14:	014007b7          	lui	a5,0x1400
 300ee18:	23378513          	addi	a0,a5,563 # 1400233 <FLASH_SIZE+0x13e0237>
 300ee1c:	2c31                	jal	ra,300f038 <HAL_IOCMG_SetPinAltFuncMode.trans.14>
    HAL_IOCMG_SetPinPullMode(GPIO1_3_AS_UART3_TXD, PULL_NONE);  /* Pull-up and pull-down */
 300ee1e:	4581                	li	a1,0
 300ee20:	014007b7          	lui	a5,0x1400
 300ee24:	23378513          	addi	a0,a5,563 # 1400233 <FLASH_SIZE+0x13e0237>
 300ee28:	2431                	jal	ra,300f034 <HAL_IOCMG_SetPinPullMode.trans.15>
    HAL_IOCMG_SetPinSchmidtMode(GPIO1_3_AS_UART3_TXD, SCHMIDT_DISABLE);  /* Schmitt input on/off */
 300ee2a:	4581                	li	a1,0
 300ee2c:	014007b7          	lui	a5,0x1400
 300ee30:	23378513          	addi	a0,a5,563 # 1400233 <FLASH_SIZE+0x13e0237>
 300ee34:	2af5                	jal	ra,300f030 <HAL_IOCMG_SetPinSchmidtMode.trans.16>
    HAL_IOCMG_SetPinLevelShiftRate(GPIO1_3_AS_UART3_TXD, LEVEL_SHIFT_RATE_SLOW);  /* Output drive capability */
 300ee36:	4585                	li	a1,1
 300ee38:	014007b7          	lui	a5,0x1400
 300ee3c:	23378513          	addi	a0,a5,563 # 1400233 <FLASH_SIZE+0x13e0237>
 300ee40:	22f5                	jal	ra,300f02c <HAL_IOCMG_SetPinLevelShiftRate.trans.17>
    HAL_IOCMG_SetPinDriveRate(GPIO1_3_AS_UART3_TXD, DRIVER_RATE_2);  /* Output signal edge fast/slow */
 300ee42:	4589                	li	a1,2
 300ee44:	014007b7          	lui	a5,0x1400
 300ee48:	23378513          	addi	a0,a5,563 # 1400233 <FLASH_SIZE+0x13e0237>
 300ee4c:	2af1                	jal	ra,300f028 <HAL_IOCMG_SetPinDriveRate.trans.18>

    HAL_IOCMG_SetPinAltFuncMode(GPIO4_2_AS_I2C0_SCL);  /* Check function selection */
 300ee4e:	016007b7          	lui	a5,0x1600
 300ee52:	23278513          	addi	a0,a5,562 # 1600232 <FLASH_SIZE+0x15e0236>
 300ee56:	22cd                	jal	ra,300f038 <HAL_IOCMG_SetPinAltFuncMode.trans.14>
    HAL_IOCMG_SetPinPullMode(GPIO4_2_AS_I2C0_SCL, PULL_NONE);  /* Pull-up and pull-down */
 300ee58:	4581                	li	a1,0
 300ee5a:	016007b7          	lui	a5,0x1600
 300ee5e:	23278513          	addi	a0,a5,562 # 1600232 <FLASH_SIZE+0x15e0236>
 300ee62:	2ac9                	jal	ra,300f034 <HAL_IOCMG_SetPinPullMode.trans.15>
    HAL_IOCMG_SetPinSchmidtMode(GPIO4_2_AS_I2C0_SCL, SCHMIDT_DISABLE);  /* Schmitt input on/off */
 300ee64:	4581                	li	a1,0
 300ee66:	016007b7          	lui	a5,0x1600
 300ee6a:	23278513          	addi	a0,a5,562 # 1600232 <FLASH_SIZE+0x15e0236>
 300ee6e:	22c9                	jal	ra,300f030 <HAL_IOCMG_SetPinSchmidtMode.trans.16>
    HAL_IOCMG_SetPinLevelShiftRate(GPIO4_2_AS_I2C0_SCL, LEVEL_SHIFT_RATE_SLOW);  /* Output drive capability */
 300ee70:	4585                	li	a1,1
 300ee72:	016007b7          	lui	a5,0x1600
 300ee76:	23278513          	addi	a0,a5,562 # 1600232 <FLASH_SIZE+0x15e0236>
 300ee7a:	2a4d                	jal	ra,300f02c <HAL_IOCMG_SetPinLevelShiftRate.trans.17>
    HAL_IOCMG_SetPinDriveRate(GPIO4_2_AS_I2C0_SCL, DRIVER_RATE_2);  /* Output signal edge fast/slow */
 300ee7c:	4589                	li	a1,2
 300ee7e:	016007b7          	lui	a5,0x1600
 300ee82:	23278513          	addi	a0,a5,562 # 1600232 <FLASH_SIZE+0x15e0236>
 300ee86:	224d                	jal	ra,300f028 <HAL_IOCMG_SetPinDriveRate.trans.18>

    HAL_IOCMG_SetPinAltFuncMode(GPIO4_3_AS_I2C0_SDA);  /* Check function selection */
 300ee88:	016407b7          	lui	a5,0x1640
 300ee8c:	23278513          	addi	a0,a5,562 # 1640232 <FLASH_SIZE+0x1620236>
 300ee90:	2265                	jal	ra,300f038 <HAL_IOCMG_SetPinAltFuncMode.trans.14>
    HAL_IOCMG_SetPinPullMode(GPIO4_3_AS_I2C0_SDA, PULL_NONE);  /* Pull-up and pull-down */
 300ee92:	4581                	li	a1,0
 300ee94:	016407b7          	lui	a5,0x1640
 300ee98:	23278513          	addi	a0,a5,562 # 1640232 <FLASH_SIZE+0x1620236>
 300ee9c:	2a61                	jal	ra,300f034 <HAL_IOCMG_SetPinPullMode.trans.15>
    HAL_IOCMG_SetPinSchmidtMode(GPIO4_3_AS_I2C0_SDA, SCHMIDT_DISABLE);  /* Schmitt input on/off */
 300ee9e:	4581                	li	a1,0
 300eea0:	016407b7          	lui	a5,0x1640
 300eea4:	23278513          	addi	a0,a5,562 # 1640232 <FLASH_SIZE+0x1620236>
 300eea8:	2261                	jal	ra,300f030 <HAL_IOCMG_SetPinSchmidtMode.trans.16>
    HAL_IOCMG_SetPinLevelShiftRate(GPIO4_3_AS_I2C0_SDA, LEVEL_SHIFT_RATE_SLOW);  /* Output drive capability */
 300eeaa:	4585                	li	a1,1
 300eeac:	016407b7          	lui	a5,0x1640
 300eeb0:	23278513          	addi	a0,a5,562 # 1640232 <FLASH_SIZE+0x1620236>
 300eeb4:	2aa5                	jal	ra,300f02c <HAL_IOCMG_SetPinLevelShiftRate.trans.17>
    HAL_IOCMG_SetPinDriveRate(GPIO4_3_AS_I2C0_SDA, DRIVER_RATE_2);  /* Output signal edge fast/slow */
 300eeb6:	4589                	li	a1,2
 300eeb8:	016407b7          	lui	a5,0x1640
 300eebc:	23278513          	addi	a0,a5,562 # 1640232 <FLASH_SIZE+0x1620236>
 300eec0:	22a5                	jal	ra,300f028 <HAL_IOCMG_SetPinDriveRate.trans.18>

    HAL_IOCMG_SetPinAltFuncMode(GPIO3_7_AS_GPT3_PWM);  /* Check function selection */
 300eec2:	011807b7          	lui	a5,0x1180
 300eec6:	23178513          	addi	a0,a5,561 # 1180231 <FLASH_SIZE+0x1160235>
 300eeca:	22bd                	jal	ra,300f038 <HAL_IOCMG_SetPinAltFuncMode.trans.14>
    HAL_IOCMG_SetPinPullMode(GPIO3_7_AS_GPT3_PWM, PULL_NONE);  /* Pull-up and pull-down */
 300eecc:	4581                	li	a1,0
 300eece:	011807b7          	lui	a5,0x1180
 300eed2:	23178513          	addi	a0,a5,561 # 1180231 <FLASH_SIZE+0x1160235>
 300eed6:	2ab9                	jal	ra,300f034 <HAL_IOCMG_SetPinPullMode.trans.15>
    HAL_IOCMG_SetPinSchmidtMode(GPIO3_7_AS_GPT3_PWM, SCHMIDT_DISABLE);  /* Schmitt input on/off */
 300eed8:	4581                	li	a1,0
 300eeda:	011807b7          	lui	a5,0x1180
 300eede:	23178513          	addi	a0,a5,561 # 1180231 <FLASH_SIZE+0x1160235>
 300eee2:	22b9                	jal	ra,300f030 <HAL_IOCMG_SetPinSchmidtMode.trans.16>
    HAL_IOCMG_SetPinLevelShiftRate(GPIO3_7_AS_GPT3_PWM, LEVEL_SHIFT_RATE_SLOW);  /* Output drive capability */
 300eee4:	4585                	li	a1,1
 300eee6:	011807b7          	lui	a5,0x1180
 300eeea:	23178513          	addi	a0,a5,561 # 1180231 <FLASH_SIZE+0x1160235>
 300eeee:	2a3d                	jal	ra,300f02c <HAL_IOCMG_SetPinLevelShiftRate.trans.17>
    HAL_IOCMG_SetPinDriveRate(GPIO3_7_AS_GPT3_PWM, DRIVER_RATE_2);  /* Output signal edge fast/slow */
 300eef0:	4589                	li	a1,2
 300eef2:	011807b7          	lui	a5,0x1180
 300eef6:	23178513          	addi	a0,a5,561 # 1180231 <FLASH_SIZE+0x1160235>
 300eefa:	223d                	jal	ra,300f028 <HAL_IOCMG_SetPinDriveRate.trans.18>

    HAL_IOCMG_SetPinAltFuncMode(GPIO5_3_AS_ADC_AIN12);  /* Check function selection */
 300eefc:	012407b7          	lui	a5,0x1240
 300ef00:	23c78513          	addi	a0,a5,572 # 124023c <FLASH_SIZE+0x1220240>
 300ef04:	2a15                	jal	ra,300f038 <HAL_IOCMG_SetPinAltFuncMode.trans.14>
    HAL_IOCMG_SetPinPullMode(GPIO5_3_AS_ADC_AIN12, PULL_NONE);  /* Pull-up and pull-down */
 300ef06:	4581                	li	a1,0
 300ef08:	012407b7          	lui	a5,0x1240
 300ef0c:	23c78513          	addi	a0,a5,572 # 124023c <FLASH_SIZE+0x1220240>
 300ef10:	2215                	jal	ra,300f034 <HAL_IOCMG_SetPinPullMode.trans.15>
    HAL_IOCMG_SetPinSchmidtMode(GPIO5_3_AS_ADC_AIN12, SCHMIDT_DISABLE);  /* Schmitt input on/off */
 300ef12:	4581                	li	a1,0
 300ef14:	012407b7          	lui	a5,0x1240
 300ef18:	23c78513          	addi	a0,a5,572 # 124023c <FLASH_SIZE+0x1220240>
 300ef1c:	2a11                	jal	ra,300f030 <HAL_IOCMG_SetPinSchmidtMode.trans.16>
    HAL_IOCMG_SetPinLevelShiftRate(GPIO5_3_AS_ADC_AIN12, LEVEL_SHIFT_RATE_SLOW);  /* Output drive capability */
 300ef1e:	4585                	li	a1,1
 300ef20:	012407b7          	lui	a5,0x1240
 300ef24:	23c78513          	addi	a0,a5,572 # 124023c <FLASH_SIZE+0x1220240>
 300ef28:	2211                	jal	ra,300f02c <HAL_IOCMG_SetPinLevelShiftRate.trans.17>
    HAL_IOCMG_SetPinDriveRate(GPIO5_3_AS_ADC_AIN12, DRIVER_RATE_2);  /* Output signal edge fast/slow */
 300ef2a:	4589                	li	a1,2
 300ef2c:	012407b7          	lui	a5,0x1240
 300ef30:	23c78513          	addi	a0,a5,572 # 124023c <FLASH_SIZE+0x1220240>
 300ef34:	28d5                	jal	ra,300f028 <HAL_IOCMG_SetPinDriveRate.trans.18>

    HAL_IOCMG_SetPinAltFuncMode(GPIO3_6_AS_CAN_RX);  /* Check function selection */
 300ef36:	011c07b7          	lui	a5,0x11c0
 300ef3a:	23178513          	addi	a0,a5,561 # 11c0231 <FLASH_SIZE+0x11a0235>
 300ef3e:	28ed                	jal	ra,300f038 <HAL_IOCMG_SetPinAltFuncMode.trans.14>
    HAL_IOCMG_SetPinPullMode(GPIO3_6_AS_CAN_RX, PULL_NONE);  /* Pull-up and pull-down */
 300ef40:	4581                	li	a1,0
 300ef42:	011c07b7          	lui	a5,0x11c0
 300ef46:	23178513          	addi	a0,a5,561 # 11c0231 <FLASH_SIZE+0x11a0235>
 300ef4a:	20ed                	jal	ra,300f034 <HAL_IOCMG_SetPinPullMode.trans.15>
    HAL_IOCMG_SetPinSchmidtMode(GPIO3_6_AS_CAN_RX, SCHMIDT_DISABLE);  /* Schmitt input on/off */
 300ef4c:	4581                	li	a1,0
 300ef4e:	011c07b7          	lui	a5,0x11c0
 300ef52:	23178513          	addi	a0,a5,561 # 11c0231 <FLASH_SIZE+0x11a0235>
 300ef56:	28e9                	jal	ra,300f030 <HAL_IOCMG_SetPinSchmidtMode.trans.16>
    HAL_IOCMG_SetPinLevelShiftRate(GPIO3_6_AS_CAN_RX, LEVEL_SHIFT_RATE_SLOW);  /* Output drive capability */
 300ef58:	4585                	li	a1,1
 300ef5a:	011c07b7          	lui	a5,0x11c0
 300ef5e:	23178513          	addi	a0,a5,561 # 11c0231 <FLASH_SIZE+0x11a0235>
 300ef62:	20e9                	jal	ra,300f02c <HAL_IOCMG_SetPinLevelShiftRate.trans.17>
    HAL_IOCMG_SetPinDriveRate(GPIO3_6_AS_CAN_RX, DRIVER_RATE_2);  /* Output signal edge fast/slow */
 300ef64:	4589                	li	a1,2
 300ef66:	011c07b7          	lui	a5,0x11c0
 300ef6a:	23178513          	addi	a0,a5,561 # 11c0231 <FLASH_SIZE+0x11a0235>
 300ef6e:	286d                	jal	ra,300f028 <HAL_IOCMG_SetPinDriveRate.trans.18>

    HAL_IOCMG_SetPinAltFuncMode(GPIO3_5_AS_CAN_TX);  /* Check function selection */
 300ef70:	012007b7          	lui	a5,0x1200
 300ef74:	23178513          	addi	a0,a5,561 # 1200231 <FLASH_SIZE+0x11e0235>
 300ef78:	20c1                	jal	ra,300f038 <HAL_IOCMG_SetPinAltFuncMode.trans.14>
    HAL_IOCMG_SetPinPullMode(GPIO3_5_AS_CAN_TX, PULL_NONE);  /* Pull-up and pull-down */
 300ef7a:	4581                	li	a1,0
 300ef7c:	012007b7          	lui	a5,0x1200
 300ef80:	23178513          	addi	a0,a5,561 # 1200231 <FLASH_SIZE+0x11e0235>
 300ef84:	2845                	jal	ra,300f034 <HAL_IOCMG_SetPinPullMode.trans.15>
    HAL_IOCMG_SetPinSchmidtMode(GPIO3_5_AS_CAN_TX, SCHMIDT_DISABLE);  /* Schmitt input on/off */
 300ef86:	4581                	li	a1,0
 300ef88:	012007b7          	lui	a5,0x1200
 300ef8c:	23178513          	addi	a0,a5,561 # 1200231 <FLASH_SIZE+0x11e0235>
 300ef90:	2045                	jal	ra,300f030 <HAL_IOCMG_SetPinSchmidtMode.trans.16>
    HAL_IOCMG_SetPinLevelShiftRate(GPIO3_5_AS_CAN_TX, LEVEL_SHIFT_RATE_SLOW);  /* Output drive capability */
 300ef92:	4585                	li	a1,1
 300ef94:	012007b7          	lui	a5,0x1200
 300ef98:	23178513          	addi	a0,a5,561 # 1200231 <FLASH_SIZE+0x11e0235>
 300ef9c:	2841                	jal	ra,300f02c <HAL_IOCMG_SetPinLevelShiftRate.trans.17>
    HAL_IOCMG_SetPinDriveRate(GPIO3_5_AS_CAN_TX, DRIVER_RATE_2);  /* Output signal edge fast/slow */
 300ef9e:	4589                	li	a1,2
 300efa0:	012007b7          	lui	a5,0x1200
 300efa4:	23178513          	addi	a0,a5,561 # 1200231 <FLASH_SIZE+0x11e0235>
 300efa8:	2041                	jal	ra,300f028 <HAL_IOCMG_SetPinDriveRate.trans.18>

    HAL_IOCMG_SetPinAltFuncMode(GPIO4_5_AS_QDM0_A);  /* Check function selection */
 300efaa:	013807b7          	lui	a5,0x1380
 300efae:	23578513          	addi	a0,a5,565 # 1380235 <FLASH_SIZE+0x1360239>
 300efb2:	2059                	jal	ra,300f038 <HAL_IOCMG_SetPinAltFuncMode.trans.14>
    HAL_IOCMG_SetPinPullMode(GPIO4_5_AS_QDM0_A, PULL_NONE);  /* Pull-up and pull-down */
 300efb4:	4581                	li	a1,0
 300efb6:	013807b7          	lui	a5,0x1380
 300efba:	23578513          	addi	a0,a5,565 # 1380235 <FLASH_SIZE+0x1360239>
 300efbe:	289d                	jal	ra,300f034 <HAL_IOCMG_SetPinPullMode.trans.15>
    HAL_IOCMG_SetPinSchmidtMode(GPIO4_5_AS_QDM0_A, SCHMIDT_DISABLE);  /* Schmitt input on/off */
 300efc0:	4581                	li	a1,0
 300efc2:	013807b7          	lui	a5,0x1380
 300efc6:	23578513          	addi	a0,a5,565 # 1380235 <FLASH_SIZE+0x1360239>
 300efca:	209d                	jal	ra,300f030 <HAL_IOCMG_SetPinSchmidtMode.trans.16>
    HAL_IOCMG_SetPinLevelShiftRate(GPIO4_5_AS_QDM0_A, LEVEL_SHIFT_RATE_SLOW);  /* Output drive capability */
 300efcc:	4585                	li	a1,1
 300efce:	013807b7          	lui	a5,0x1380
 300efd2:	23578513          	addi	a0,a5,565 # 1380235 <FLASH_SIZE+0x1360239>
 300efd6:	2899                	jal	ra,300f02c <HAL_IOCMG_SetPinLevelShiftRate.trans.17>
    HAL_IOCMG_SetPinDriveRate(GPIO4_5_AS_QDM0_A, DRIVER_RATE_2);  /* Output signal edge fast/slow */
 300efd8:	4589                	li	a1,2
 300efda:	013807b7          	lui	a5,0x1380
 300efde:	23578513          	addi	a0,a5,565 # 1380235 <FLASH_SIZE+0x1360239>
 300efe2:	2099                	jal	ra,300f028 <HAL_IOCMG_SetPinDriveRate.trans.18>

    HAL_IOCMG_SetPinAltFuncMode(GPIO4_6_AS_QDM0_B);  /* Check function selection */
 300efe4:	013c07b7          	lui	a5,0x13c0
 300efe8:	22578513          	addi	a0,a5,549 # 13c0225 <FLASH_SIZE+0x13a0229>
 300efec:	20b1                	jal	ra,300f038 <HAL_IOCMG_SetPinAltFuncMode.trans.14>
    HAL_IOCMG_SetPinPullMode(GPIO4_6_AS_QDM0_B, PULL_NONE);  /* Pull-up and pull-down */
 300efee:	4581                	li	a1,0
 300eff0:	013c07b7          	lui	a5,0x13c0
 300eff4:	22578513          	addi	a0,a5,549 # 13c0225 <FLASH_SIZE+0x13a0229>
 300eff8:	2835                	jal	ra,300f034 <HAL_IOCMG_SetPinPullMode.trans.15>
    HAL_IOCMG_SetPinSchmidtMode(GPIO4_6_AS_QDM0_B, SCHMIDT_DISABLE);  /* Schmitt input on/off */
 300effa:	4581                	li	a1,0
 300effc:	013c07b7          	lui	a5,0x13c0
 300f000:	22578513          	addi	a0,a5,549 # 13c0225 <FLASH_SIZE+0x13a0229>
 300f004:	2035                	jal	ra,300f030 <HAL_IOCMG_SetPinSchmidtMode.trans.16>
    HAL_IOCMG_SetPinLevelShiftRate(GPIO4_6_AS_QDM0_B, LEVEL_SHIFT_RATE_SLOW);  /* Output drive capability */
 300f006:	4585                	li	a1,1
 300f008:	013c07b7          	lui	a5,0x13c0
 300f00c:	22578513          	addi	a0,a5,549 # 13c0225 <FLASH_SIZE+0x13a0229>
 300f010:	2831                	jal	ra,300f02c <HAL_IOCMG_SetPinLevelShiftRate.trans.17>
    HAL_IOCMG_SetPinDriveRate(GPIO4_6_AS_QDM0_B, DRIVER_RATE_2);  /* Output signal edge fast/slow */
 300f012:	4589                	li	a1,2
 300f014:	013c07b7          	lui	a5,0x13c0
 300f018:	22578513          	addi	a0,a5,549 # 13c0225 <FLASH_SIZE+0x13a0229>
 300f01c:	2031                	jal	ra,300f028 <HAL_IOCMG_SetPinDriveRate.trans.18>

}
 300f01e:	0001                	nop
 300f020:	40b2                	lw	ra,12(sp)
 300f022:	4422                	lw	s0,8(sp)
 300f024:	0141                	addi	sp,sp,16
 300f026:	8082                	ret

0300f028 <HAL_IOCMG_SetPinDriveRate.trans.18>:
 300f028:	ceafa06f          	j	3009512 <HAL_IOCMG_SetPinDriveRate>

0300f02c <HAL_IOCMG_SetPinLevelShiftRate.trans.17>:
 300f02c:	c9afa06f          	j	30094c6 <HAL_IOCMG_SetPinLevelShiftRate>

0300f030 <HAL_IOCMG_SetPinSchmidtMode.trans.16>:
 300f030:	c4afa06f          	j	300947a <HAL_IOCMG_SetPinSchmidtMode>

0300f034 <HAL_IOCMG_SetPinPullMode.trans.15>:
 300f034:	bfafa06f          	j	300942e <HAL_IOCMG_SetPinPullMode>

0300f038 <HAL_IOCMG_SetPinAltFuncMode.trans.14>:
 300f038:	bbcfa06f          	j	30093f4 <HAL_IOCMG_SetPinAltFuncMode>

0300f03c <SystemInit>:

void SystemInit(void)
{
 300f03c:	1141                	addi	sp,sp,-16
 300f03e:	c606                	sw	ra,12(sp)
 300f040:	c422                	sw	s0,8(sp)
 300f042:	0800                	addi	s0,sp,16
    IOConfig();
 300f044:	3839                	jal	ra,300e862 <IOConfig>
    UART0_Init();
 300f046:	d84ff0ef          	jal	ra,300e5ca <UART0_Init>
    UART2_Init();
 300f04a:	e2aff0ef          	jal	ra,300e674 <UART2_Init>
    UART3_Init();
 300f04e:	f1aff0ef          	jal	ra,300e768 <UART3_Init>
    APT0_Init();
 300f052:	acffe0ef          	jal	ra,300db20 <APT0_Init>
    APT1_Init();
 300f056:	b65fe0ef          	jal	ra,300dbba <APT1_Init>
    ADC0_Init();
 300f05a:	a43fe0ef          	jal	ra,300da9c <ADC0_Init>
    CAN_Init();
 300f05e:	bf7fe0ef          	jal	ra,300dc54 <CAN_Init>
    GPT0_Init();
 300f062:	e23fe0ef          	jal	ra,300de84 <GPT0_Init>
    GPT1_Init();
 300f066:	eb3fe0ef          	jal	ra,300df18 <GPT1_Init>
    GPT2_Init();
 300f06a:	f45fe0ef          	jal	ra,300dfae <GPT2_Init>
    GPT3_Init();
 300f06e:	fd3fe0ef          	jal	ra,300e040 <GPT3_Init>
    TIMER0_Init();
 300f072:	c7eff0ef          	jal	ra,300e4f0 <TIMER0_Init>
    I2C0_Init();
 300f076:	862ff0ef          	jal	ra,300e0d8 <I2C0_Init>
    I2C1_Init();
 300f07a:	8ecff0ef          	jal	ra,300e166 <I2C1_Init>
    QDM0_Init();
 300f07e:	9acff0ef          	jal	ra,300e22a <QDM0_Init>
    QDM1_Init();
 300f082:	b26ff0ef          	jal	ra,300e3a8 <QDM1_Init>
    GPIO_Init();
 300f086:	ca1fe0ef          	jal	ra,300dd26 <GPIO_Init>

    /* USER CODE BEGIN system_init */
    /* USER CODE END system_init */
 300f08a:	0001                	nop
 300f08c:	40b2                	lw	ra,12(sp)
 300f08e:	4422                	lw	s0,8(sp)
 300f090:	0141                	addi	sp,sp,16
 300f092:	8082                	ret

0300f094 <__adddf3>:
 300f094:	1101                	addi	sp,sp,-32
 300f096:	ce06                	sw	ra,28(sp)
 300f098:	cc22                	sw	s0,24(sp)
 300f09a:	ca26                	sw	s1,20(sp)
 300f09c:	c84a                	sw	s2,16(sp)
 300f09e:	c64e                	sw	s3,12(sp)
 300f0a0:	c452                	sw	s4,8(sp)
 300f0a2:	002024f3          	frrm	s1
 300f0a6:	001008b7          	lui	a7,0x100
 300f0aa:	18fd                	addi	a7,a7,-1 # fffff <FLASH_SIZE+0xe0003>
 300f0ac:	0145d993          	srli	s3,a1,0x14
 300f0b0:	0146d813          	srli	a6,a3,0x14
 300f0b4:	00b8f7b3          	and	a5,a7,a1
 300f0b8:	7ff9f993          	andi	s3,s3,2047
 300f0bc:	00d8f8b3          	and	a7,a7,a3
 300f0c0:	7ff87813          	andi	a6,a6,2047
 300f0c4:	01d65713          	srli	a4,a2,0x1d
 300f0c8:	01f5d913          	srli	s2,a1,0x1f
 300f0cc:	088e                	slli	a7,a7,0x3
 300f0ce:	00379593          	slli	a1,a5,0x3
 300f0d2:	00361313          	slli	t1,a2,0x3
 300f0d6:	01d55793          	srli	a5,a0,0x1d
 300f0da:	41098633          	sub	a2,s3,a6
 300f0de:	82fd                	srli	a3,a3,0x1f
 300f0e0:	8fcd                	or	a5,a5,a1
 300f0e2:	050e                	slli	a0,a0,0x3
 300f0e4:	01176733          	or	a4,a4,a7
 300f0e8:	8e32                	mv	t3,a2
 300f0ea:	3ad91363          	bne	s2,a3,300f490 <__adddf3+0x3fc>
 300f0ee:	10c05263          	blez	a2,300f1f2 <__adddf3+0x15e>
 300f0f2:	06081f63          	bnez	a6,300f170 <__adddf3+0xdc>
 300f0f6:	006766b3          	or	a3,a4,t1
 300f0fa:	e699                	bnez	a3,300f108 <__adddf3+0x74>
 300f0fc:	7ff00713          	li	a4,2047
 300f100:	8832                	mv	a6,a2
 300f102:	04ee1463          	bne	t3,a4,300f14a <__adddf3+0xb6>
 300f106:	a881                	j	300f156 <__adddf3+0xc2>
 300f108:	167d                	addi	a2,a2,-1
 300f10a:	e231                	bnez	a2,300f14e <__adddf3+0xba>
 300f10c:	932a                	add	t1,t1,a0
 300f10e:	97ba                	add	a5,a5,a4
 300f110:	00a33533          	sltu	a0,t1,a0
 300f114:	00a78733          	add	a4,a5,a0
 300f118:	4805                	li	a6,1
 300f11a:	00871793          	slli	a5,a4,0x8
 300f11e:	0e07d463          	bgez	a5,300f206 <__adddf3+0x172>
 300f122:	0805                	addi	a6,a6,1
 300f124:	7ff00793          	li	a5,2047
 300f128:	32f80f63          	beq	a6,a5,300f466 <__adddf3+0x3d2>
 300f12c:	ff8007b7          	lui	a5,0xff800
 300f130:	17fd                	addi	a5,a5,-1 # ff7fffff <RAM_END+0xfb7f7fff>
 300f132:	00135513          	srli	a0,t1,0x1
 300f136:	8ff9                	and	a5,a5,a4
 300f138:	00137313          	andi	t1,t1,1
 300f13c:	00656333          	or	t1,a0,t1
 300f140:	01f79513          	slli	a0,a5,0x1f
 300f144:	00656533          	or	a0,a0,t1
 300f148:	8385                	srli	a5,a5,0x1
 300f14a:	4e01                	li	t3,0
 300f14c:	a4d1                	j	300f410 <__adddf3+0x37c>
 300f14e:	7ff00693          	li	a3,2047
 300f152:	02de1663          	bne	t3,a3,300f17e <__adddf3+0xea>
 300f156:	00a7e733          	or	a4,a5,a0
 300f15a:	6e070963          	beqz	a4,300f84c <__adddf3+0x7b8>
 300f15e:	00979713          	slli	a4,a5,0x9
 300f162:	7ff00813          	li	a6,2047
 300f166:	4e01                	li	t3,0
 300f168:	2a074463          	bltz	a4,300f410 <__adddf3+0x37c>
 300f16c:	48c1                	li	a7,16
 300f16e:	aa61                	j	300f306 <__adddf3+0x272>
 300f170:	7ff00693          	li	a3,2047
 300f174:	fed981e3          	beq	s3,a3,300f156 <__adddf3+0xc2>
 300f178:	008006b7          	lui	a3,0x800
 300f17c:	8f55                	or	a4,a4,a3
 300f17e:	03800693          	li	a3,56
 300f182:	06c6c363          	blt	a3,a2,300f1e8 <__adddf3+0x154>
 300f186:	46fd                	li	a3,31
 300f188:	02c6cb63          	blt	a3,a2,300f1be <__adddf3+0x12a>
 300f18c:	02000593          	li	a1,32
 300f190:	8d91                	sub	a1,a1,a2
 300f192:	00c35833          	srl	a6,t1,a2
 300f196:	00b716b3          	sll	a3,a4,a1
 300f19a:	00b31333          	sll	t1,t1,a1
 300f19e:	0106e6b3          	or	a3,a3,a6
 300f1a2:	00603333          	snez	t1,t1
 300f1a6:	0066e333          	or	t1,a3,t1
 300f1aa:	00c75633          	srl	a2,a4,a2
 300f1ae:	932a                	add	t1,t1,a0
 300f1b0:	963e                	add	a2,a2,a5
 300f1b2:	00a337b3          	sltu	a5,t1,a0
 300f1b6:	00f60733          	add	a4,a2,a5
 300f1ba:	884e                	mv	a6,s3
 300f1bc:	bfb9                	j	300f11a <__adddf3+0x86>
 300f1be:	02000813          	li	a6,32
 300f1c2:	00c756b3          	srl	a3,a4,a2
 300f1c6:	4581                	li	a1,0
 300f1c8:	01060863          	beq	a2,a6,300f1d8 <__adddf3+0x144>
 300f1cc:	04000593          	li	a1,64
 300f1d0:	40c58633          	sub	a2,a1,a2
 300f1d4:	00c715b3          	sll	a1,a4,a2
 300f1d8:	0065e333          	or	t1,a1,t1
 300f1dc:	00603333          	snez	t1,t1
 300f1e0:	0066e333          	or	t1,a3,t1
 300f1e4:	4601                	li	a2,0
 300f1e6:	b7e1                	j	300f1ae <__adddf3+0x11a>
 300f1e8:	00676333          	or	t1,a4,t1
 300f1ec:	00603333          	snez	t1,t1
 300f1f0:	bfd5                	j	300f1e4 <__adddf3+0x150>
 300f1f2:	ca69                	beqz	a2,300f2c4 <__adddf3+0x230>
 300f1f4:	04099963          	bnez	s3,300f246 <__adddf3+0x1b2>
 300f1f8:	00a7e6b3          	or	a3,a5,a0
 300f1fc:	ea89                	bnez	a3,300f20e <__adddf3+0x17a>
 300f1fe:	7ff00793          	li	a5,2047
 300f202:	02f80763          	beq	a6,a5,300f230 <__adddf3+0x19c>
 300f206:	02081d63          	bnez	a6,300f240 <__adddf3+0x1ac>
 300f20a:	851a                	mv	a0,t1
 300f20c:	a991                	j	300f660 <__adddf3+0x5cc>
 300f20e:	56fd                	li	a3,-1
 300f210:	00d61a63          	bne	a2,a3,300f224 <__adddf3+0x190>
 300f214:	006506b3          	add	a3,a0,t1
 300f218:	97ba                	add	a5,a5,a4
 300f21a:	0066b733          	sltu	a4,a3,t1
 300f21e:	973e                	add	a4,a4,a5
 300f220:	8336                	mv	t1,a3
 300f222:	bde5                	j	300f11a <__adddf3+0x86>
 300f224:	7ff00693          	li	a3,2047
 300f228:	fff64613          	not	a2,a2
 300f22c:	02d81663          	bne	a6,a3,300f258 <__adddf3+0x1c4>
 300f230:	00676533          	or	a0,a4,t1
 300f234:	62050263          	beqz	a0,300f858 <__adddf3+0x7c4>
 300f238:	00971793          	slli	a5,a4,0x9
 300f23c:	6207d063          	bgez	a5,300f85c <__adddf3+0x7c8>
 300f240:	87ba                	mv	a5,a4
 300f242:	851a                	mv	a0,t1
 300f244:	b719                	j	300f14a <__adddf3+0xb6>
 300f246:	7ff00693          	li	a3,2047
 300f24a:	fed803e3          	beq	a6,a3,300f230 <__adddf3+0x19c>
 300f24e:	008006b7          	lui	a3,0x800
 300f252:	40c00633          	neg	a2,a2
 300f256:	8fd5                	or	a5,a5,a3
 300f258:	03800693          	li	a3,56
 300f25c:	06c6c063          	blt	a3,a2,300f2bc <__adddf3+0x228>
 300f260:	46fd                	li	a3,31
 300f262:	02c6ca63          	blt	a3,a2,300f296 <__adddf3+0x202>
 300f266:	02000593          	li	a1,32
 300f26a:	8d91                	sub	a1,a1,a2
 300f26c:	00c558b3          	srl	a7,a0,a2
 300f270:	00b796b3          	sll	a3,a5,a1
 300f274:	00b51533          	sll	a0,a0,a1
 300f278:	0116e6b3          	or	a3,a3,a7
 300f27c:	00a03533          	snez	a0,a0
 300f280:	8d55                	or	a0,a0,a3
 300f282:	00c7d633          	srl	a2,a5,a2
 300f286:	951a                	add	a0,a0,t1
 300f288:	00e607b3          	add	a5,a2,a4
 300f28c:	00653733          	sltu	a4,a0,t1
 300f290:	973e                	add	a4,a4,a5
 300f292:	832a                	mv	t1,a0
 300f294:	b559                	j	300f11a <__adddf3+0x86>
 300f296:	02000893          	li	a7,32
 300f29a:	00c7d6b3          	srl	a3,a5,a2
 300f29e:	4581                	li	a1,0
 300f2a0:	01160863          	beq	a2,a7,300f2b0 <__adddf3+0x21c>
 300f2a4:	04000593          	li	a1,64
 300f2a8:	40c58633          	sub	a2,a1,a2
 300f2ac:	00c795b3          	sll	a1,a5,a2
 300f2b0:	8d4d                	or	a0,a0,a1
 300f2b2:	00a03533          	snez	a0,a0
 300f2b6:	8d55                	or	a0,a0,a3
 300f2b8:	4601                	li	a2,0
 300f2ba:	b7f1                	j	300f286 <__adddf3+0x1f2>
 300f2bc:	8d5d                	or	a0,a0,a5
 300f2be:	00a03533          	snez	a0,a0
 300f2c2:	bfdd                	j	300f2b8 <__adddf3+0x224>
 300f2c4:	00198693          	addi	a3,s3,1
 300f2c8:	7ff6f593          	andi	a1,a3,2047
 300f2cc:	4605                	li	a2,1
 300f2ce:	12b64063          	blt	a2,a1,300f3ee <__adddf3+0x35a>
 300f2d2:	00a7e6b3          	or	a3,a5,a0
 300f2d6:	04099463          	bnez	s3,300f31e <__adddf3+0x28a>
 300f2da:	da85                	beqz	a3,300f20a <__adddf3+0x176>
 300f2dc:	006766b3          	or	a3,a4,t1
 300f2e0:	54068163          	beqz	a3,300f822 <__adddf3+0x78e>
 300f2e4:	932a                	add	t1,t1,a0
 300f2e6:	97ba                	add	a5,a5,a4
 300f2e8:	00a33533          	sltu	a0,t1,a0
 300f2ec:	00a78733          	add	a4,a5,a0
 300f2f0:	00871793          	slli	a5,a4,0x8
 300f2f4:	f007dbe3          	bgez	a5,300f20a <__adddf3+0x176>
 300f2f8:	ff8007b7          	lui	a5,0xff800
 300f2fc:	17fd                	addi	a5,a5,-1 # ff7fffff <RAM_END+0xfb7f7fff>
 300f2fe:	8ff9                	and	a5,a5,a4
 300f300:	851a                	mv	a0,t1
 300f302:	4881                	li	a7,0
 300f304:	4805                	li	a6,1
 300f306:	00757713          	andi	a4,a0,7
 300f30a:	12071063          	bnez	a4,300f42a <__adddf3+0x396>
 300f30e:	040e0b63          	beqz	t3,300f364 <__adddf3+0x2d0>
 300f312:	0018f713          	andi	a4,a7,1
 300f316:	c739                	beqz	a4,300f364 <__adddf3+0x2d0>
 300f318:	0028e893          	ori	a7,a7,2
 300f31c:	a0a1                	j	300f364 <__adddf3+0x2d0>
 300f31e:	7ff00613          	li	a2,2047
 300f322:	0cc99163          	bne	s3,a2,300f3e4 <__adddf3+0x350>
 300f326:	5a068163          	beqz	a3,300f8c8 <__adddf3+0x834>
 300f32a:	004008b7          	lui	a7,0x400
 300f32e:	0117f8b3          	and	a7,a5,a7
 300f332:	0018b893          	seqz	a7,a7
 300f336:	0892                	slli	a7,a7,0x4
 300f338:	01381c63          	bne	a6,s3,300f350 <__adddf3+0x2bc>
 300f33c:	00676633          	or	a2,a4,t1
 300f340:	c611                	beqz	a2,300f34c <__adddf3+0x2b8>
 300f342:	00971613          	slli	a2,a4,0x9
 300f346:	00064363          	bltz	a2,300f34c <__adddf3+0x2b8>
 300f34a:	48c1                	li	a7,16
 300f34c:	4e068d63          	beqz	a3,300f846 <__adddf3+0x7b2>
 300f350:	00676733          	or	a4,a4,t1
 300f354:	3c070b63          	beqz	a4,300f72a <__adddf3+0x696>
 300f358:	004007b7          	lui	a5,0x400
 300f35c:	4501                	li	a0,0
 300f35e:	7ff00813          	li	a6,2047
 300f362:	4901                	li	s2,0
 300f364:	00879713          	slli	a4,a5,0x8
 300f368:	00075b63          	bgez	a4,300f37e <__adddf3+0x2ea>
 300f36c:	0805                	addi	a6,a6,1
 300f36e:	7ff00713          	li	a4,2047
 300f372:	52e80363          	beq	a6,a4,300f898 <__adddf3+0x804>
 300f376:	ff800737          	lui	a4,0xff800
 300f37a:	177d                	addi	a4,a4,-1 # ff7fffff <RAM_END+0xfb7f7fff>
 300f37c:	8ff9                	and	a5,a5,a4
 300f37e:	01d79713          	slli	a4,a5,0x1d
 300f382:	810d                	srli	a0,a0,0x3
 300f384:	8d59                	or	a0,a0,a4
 300f386:	7ff00713          	li	a4,2047
 300f38a:	838d                	srli	a5,a5,0x3
 300f38c:	00e81963          	bne	a6,a4,300f39e <__adddf3+0x30a>
 300f390:	8d5d                	or	a0,a0,a5
 300f392:	4781                	li	a5,0
 300f394:	c509                	beqz	a0,300f39e <__adddf3+0x30a>
 300f396:	000807b7          	lui	a5,0x80
 300f39a:	4501                	li	a0,0
 300f39c:	4901                	li	s2,0
 300f39e:	00100737          	lui	a4,0x100
 300f3a2:	177d                	addi	a4,a4,-1 # fffff <FLASH_SIZE+0xe0003>
 300f3a4:	8ff9                	and	a5,a5,a4
 300f3a6:	80100737          	lui	a4,0x80100
 300f3aa:	177d                	addi	a4,a4,-1 # 800fffff <RAM_END+0x7c0f7fff>
 300f3ac:	7ff87813          	andi	a6,a6,2047
 300f3b0:	0852                	slli	a6,a6,0x14
 300f3b2:	8ff9                	and	a5,a5,a4
 300f3b4:	0107e7b3          	or	a5,a5,a6
 300f3b8:	80000837          	lui	a6,0x80000
 300f3bc:	fff84813          	not	a6,a6
 300f3c0:	097e                	slli	s2,s2,0x1f
 300f3c2:	0107f7b3          	and	a5,a5,a6
 300f3c6:	0127e733          	or	a4,a5,s2
 300f3ca:	85ba                	mv	a1,a4
 300f3cc:	00088463          	beqz	a7,300f3d4 <__adddf3+0x340>
 300f3d0:	0018a073          	csrs	fflags,a7
 300f3d4:	40f2                	lw	ra,28(sp)
 300f3d6:	4462                	lw	s0,24(sp)
 300f3d8:	44d2                	lw	s1,20(sp)
 300f3da:	4942                	lw	s2,16(sp)
 300f3dc:	49b2                	lw	s3,12(sp)
 300f3de:	4a22                	lw	s4,8(sp)
 300f3e0:	6105                	addi	sp,sp,32
 300f3e2:	8082                	ret
 300f3e4:	4881                	li	a7,0
 300f3e6:	f6c813e3          	bne	a6,a2,300f34c <__adddf3+0x2b8>
 300f3ea:	4881                	li	a7,0
 300f3ec:	bf81                	j	300f33c <__adddf3+0x2a8>
 300f3ee:	7ff00613          	li	a2,2047
 300f3f2:	02c68163          	beq	a3,a2,300f414 <__adddf3+0x380>
 300f3f6:	932a                	add	t1,t1,a0
 300f3f8:	00a33533          	sltu	a0,t1,a0
 300f3fc:	97ba                	add	a5,a5,a4
 300f3fe:	97aa                	add	a5,a5,a0
 300f400:	01f79513          	slli	a0,a5,0x1f
 300f404:	00135313          	srli	t1,t1,0x1
 300f408:	00656533          	or	a0,a0,t1
 300f40c:	8385                	srli	a5,a5,0x1
 300f40e:	8836                	mv	a6,a3
 300f410:	4881                	li	a7,0
 300f412:	bdd5                	j	300f306 <__adddf3+0x272>
 300f414:	c4b1                	beqz	s1,300f460 <__adddf3+0x3cc>
 300f416:	478d                	li	a5,3
 300f418:	02f49f63          	bne	s1,a5,300f456 <__adddf3+0x3c2>
 300f41c:	04090263          	beqz	s2,300f460 <__adddf3+0x3cc>
 300f420:	57fd                	li	a5,-1
 300f422:	557d                	li	a0,-1
 300f424:	7fe00813          	li	a6,2046
 300f428:	4895                	li	a7,5
 300f42a:	4709                	li	a4,2
 300f42c:	0018e893          	ori	a7,a7,1
 300f430:	46e48163          	beq	s1,a4,300f892 <__adddf3+0x7fe>
 300f434:	470d                	li	a4,3
 300f436:	44e48963          	beq	s1,a4,300f888 <__adddf3+0x7f4>
 300f43a:	ec049ae3          	bnez	s1,300f30e <__adddf3+0x27a>
 300f43e:	00f57713          	andi	a4,a0,15
 300f442:	4691                	li	a3,4
 300f444:	ecd705e3          	beq	a4,a3,300f30e <__adddf3+0x27a>
 300f448:	00450713          	addi	a4,a0,4 # 14003004 <RAM_END+0xfffb004>
 300f44c:	00a73533          	sltu	a0,a4,a0
 300f450:	97aa                	add	a5,a5,a0
 300f452:	853a                	mv	a0,a4
 300f454:	bd6d                	j	300f30e <__adddf3+0x27a>
 300f456:	4789                	li	a5,2
 300f458:	fcf494e3          	bne	s1,a5,300f420 <__adddf3+0x38c>
 300f45c:	fc0902e3          	beqz	s2,300f420 <__adddf3+0x38c>
 300f460:	7ff00813          	li	a6,2047
 300f464:	a015                	j	300f488 <__adddf3+0x3f4>
 300f466:	c08d                	beqz	s1,300f488 <__adddf3+0x3f4>
 300f468:	478d                	li	a5,3
 300f46a:	00f49a63          	bne	s1,a5,300f47e <__adddf3+0x3ea>
 300f46e:	00090d63          	beqz	s2,300f488 <__adddf3+0x3f4>
 300f472:	57fd                	li	a5,-1
 300f474:	557d                	li	a0,-1
 300f476:	7fe00813          	li	a6,2046
 300f47a:	4e01                	li	t3,0
 300f47c:	b775                	j	300f428 <__adddf3+0x394>
 300f47e:	4789                	li	a5,2
 300f480:	fef499e3          	bne	s1,a5,300f472 <__adddf3+0x3de>
 300f484:	fe0907e3          	beqz	s2,300f472 <__adddf3+0x3de>
 300f488:	4781                	li	a5,0
 300f48a:	4501                	li	a0,0
 300f48c:	4895                	li	a7,5
 300f48e:	bdd9                	j	300f364 <__adddf3+0x2d0>
 300f490:	0cc05563          	blez	a2,300f55a <__adddf3+0x4c6>
 300f494:	08081163          	bnez	a6,300f516 <__adddf3+0x482>
 300f498:	006766b3          	or	a3,a4,t1
 300f49c:	c60680e3          	beqz	a3,300f0fc <__adddf3+0x68>
 300f4a0:	167d                	addi	a2,a2,-1
 300f4a2:	e605                	bnez	a2,300f4ca <__adddf3+0x436>
 300f4a4:	40650333          	sub	t1,a0,t1
 300f4a8:	8f99                	sub	a5,a5,a4
 300f4aa:	00653533          	sltu	a0,a0,t1
 300f4ae:	40a78733          	sub	a4,a5,a0
 300f4b2:	4805                	li	a6,1
 300f4b4:	00871793          	slli	a5,a4,0x8
 300f4b8:	d407d7e3          	bgez	a5,300f206 <__adddf3+0x172>
 300f4bc:	00800437          	lui	s0,0x800
 300f4c0:	147d                	addi	s0,s0,-1 # 7fffff <FLASH_SIZE+0x7e0003>
 300f4c2:	8c79                	and	s0,s0,a4
 300f4c4:	8a1a                	mv	s4,t1
 300f4c6:	89c2                	mv	s3,a6
 300f4c8:	ac79                	j	300f766 <__adddf3+0x6d2>
 300f4ca:	7ff00693          	li	a3,2047
 300f4ce:	c8de04e3          	beq	t3,a3,300f156 <__adddf3+0xc2>
 300f4d2:	03800693          	li	a3,56
 300f4d6:	06c6cd63          	blt	a3,a2,300f550 <__adddf3+0x4bc>
 300f4da:	46fd                	li	a3,31
 300f4dc:	04c6c563          	blt	a3,a2,300f526 <__adddf3+0x492>
 300f4e0:	02000593          	li	a1,32
 300f4e4:	8d91                	sub	a1,a1,a2
 300f4e6:	00c35833          	srl	a6,t1,a2
 300f4ea:	00b716b3          	sll	a3,a4,a1
 300f4ee:	00b31333          	sll	t1,t1,a1
 300f4f2:	0106e6b3          	or	a3,a3,a6
 300f4f6:	00603333          	snez	t1,t1
 300f4fa:	0066e333          	or	t1,a3,t1
 300f4fe:	00c75633          	srl	a2,a4,a2
 300f502:	40650333          	sub	t1,a0,t1
 300f506:	40c78633          	sub	a2,a5,a2
 300f50a:	006537b3          	sltu	a5,a0,t1
 300f50e:	40f60733          	sub	a4,a2,a5
 300f512:	884e                	mv	a6,s3
 300f514:	b745                	j	300f4b4 <__adddf3+0x420>
 300f516:	7ff00693          	li	a3,2047
 300f51a:	c2d98ee3          	beq	s3,a3,300f156 <__adddf3+0xc2>
 300f51e:	008006b7          	lui	a3,0x800
 300f522:	8f55                	or	a4,a4,a3
 300f524:	b77d                	j	300f4d2 <__adddf3+0x43e>
 300f526:	02000813          	li	a6,32
 300f52a:	00c756b3          	srl	a3,a4,a2
 300f52e:	4581                	li	a1,0
 300f530:	01060863          	beq	a2,a6,300f540 <__adddf3+0x4ac>
 300f534:	04000593          	li	a1,64
 300f538:	40c58633          	sub	a2,a1,a2
 300f53c:	00c715b3          	sll	a1,a4,a2
 300f540:	0065e333          	or	t1,a1,t1
 300f544:	00603333          	snez	t1,t1
 300f548:	0066e333          	or	t1,a3,t1
 300f54c:	4601                	li	a2,0
 300f54e:	bf55                	j	300f502 <__adddf3+0x46e>
 300f550:	00676333          	or	t1,a4,t1
 300f554:	00603333          	snez	t1,t1
 300f558:	bfd5                	j	300f54c <__adddf3+0x4b8>
 300f55a:	ce69                	beqz	a2,300f634 <__adddf3+0x5a0>
 300f55c:	04099963          	bnez	s3,300f5ae <__adddf3+0x51a>
 300f560:	00a7e5b3          	or	a1,a5,a0
 300f564:	e589                	bnez	a1,300f56e <__adddf3+0x4da>
 300f566:	7ff00793          	li	a5,2047
 300f56a:	8936                	mv	s2,a3
 300f56c:	b959                	j	300f202 <__adddf3+0x16e>
 300f56e:	55fd                	li	a1,-1
 300f570:	00b61d63          	bne	a2,a1,300f58a <__adddf3+0x4f6>
 300f574:	40a305b3          	sub	a1,t1,a0
 300f578:	40f707b3          	sub	a5,a4,a5
 300f57c:	00b33733          	sltu	a4,t1,a1
 300f580:	40e78733          	sub	a4,a5,a4
 300f584:	832e                	mv	t1,a1
 300f586:	8936                	mv	s2,a3
 300f588:	b735                	j	300f4b4 <__adddf3+0x420>
 300f58a:	7ff00593          	li	a1,2047
 300f58e:	fff64613          	not	a2,a2
 300f592:	02b81763          	bne	a6,a1,300f5c0 <__adddf3+0x52c>
 300f596:	00676533          	or	a0,a4,t1
 300f59a:	2c050563          	beqz	a0,300f864 <__adddf3+0x7d0>
 300f59e:	00971793          	slli	a5,a4,0x9
 300f5a2:	2c07d463          	bgez	a5,300f86a <__adddf3+0x7d6>
 300f5a6:	87ba                	mv	a5,a4
 300f5a8:	851a                	mv	a0,t1
 300f5aa:	8936                	mv	s2,a3
 300f5ac:	be79                	j	300f14a <__adddf3+0xb6>
 300f5ae:	7ff00593          	li	a1,2047
 300f5b2:	feb802e3          	beq	a6,a1,300f596 <__adddf3+0x502>
 300f5b6:	008005b7          	lui	a1,0x800
 300f5ba:	40c00633          	neg	a2,a2
 300f5be:	8fcd                	or	a5,a5,a1
 300f5c0:	03800593          	li	a1,56
 300f5c4:	06c5c463          	blt	a1,a2,300f62c <__adddf3+0x598>
 300f5c8:	45fd                	li	a1,31
 300f5ca:	02c5cd63          	blt	a1,a2,300f604 <__adddf3+0x570>
 300f5ce:	02000893          	li	a7,32
 300f5d2:	40c888b3          	sub	a7,a7,a2
 300f5d6:	00c55e33          	srl	t3,a0,a2
 300f5da:	011795b3          	sll	a1,a5,a7
 300f5de:	01151533          	sll	a0,a0,a7
 300f5e2:	01c5e5b3          	or	a1,a1,t3
 300f5e6:	00a03533          	snez	a0,a0
 300f5ea:	8d4d                	or	a0,a0,a1
 300f5ec:	00c7d633          	srl	a2,a5,a2
 300f5f0:	40a30533          	sub	a0,t1,a0
 300f5f4:	40c707b3          	sub	a5,a4,a2
 300f5f8:	00a33733          	sltu	a4,t1,a0
 300f5fc:	40e78733          	sub	a4,a5,a4
 300f600:	832a                	mv	t1,a0
 300f602:	b751                	j	300f586 <__adddf3+0x4f2>
 300f604:	02000e13          	li	t3,32
 300f608:	00c7d5b3          	srl	a1,a5,a2
 300f60c:	4881                	li	a7,0
 300f60e:	01c60863          	beq	a2,t3,300f61e <__adddf3+0x58a>
 300f612:	04000893          	li	a7,64
 300f616:	40c88633          	sub	a2,a7,a2
 300f61a:	00c798b3          	sll	a7,a5,a2
 300f61e:	00a8e533          	or	a0,a7,a0
 300f622:	00a03533          	snez	a0,a0
 300f626:	8d4d                	or	a0,a0,a1
 300f628:	4601                	li	a2,0
 300f62a:	b7d9                	j	300f5f0 <__adddf3+0x55c>
 300f62c:	8d5d                	or	a0,a0,a5
 300f62e:	00a03533          	snez	a0,a0
 300f632:	bfdd                	j	300f628 <__adddf3+0x594>
 300f634:	00198613          	addi	a2,s3,1
 300f638:	7ff67613          	andi	a2,a2,2047
 300f63c:	4585                	li	a1,1
 300f63e:	10c5c063          	blt	a1,a2,300f73e <__adddf3+0x6aa>
 300f642:	00a7e5b3          	or	a1,a5,a0
 300f646:	00676633          	or	a2,a4,t1
 300f64a:	0a099563          	bnez	s3,300f6f4 <__adddf3+0x660>
 300f64e:	e1ad                	bnez	a1,300f6b0 <__adddf3+0x61c>
 300f650:	1c061763          	bnez	a2,300f81e <__adddf3+0x78a>
 300f654:	ffe48913          	addi	s2,s1,-2
 300f658:	00193913          	seqz	s2,s2
 300f65c:	4701                	li	a4,0
 300f65e:	4501                	li	a0,0
 300f660:	00e567b3          	or	a5,a0,a4
 300f664:	20078f63          	beqz	a5,300f882 <__adddf3+0x7ee>
 300f668:	01f55793          	srli	a5,a0,0x1f
 300f66c:	00171e13          	slli	t3,a4,0x1
 300f670:	9e3e                	add	t3,t3,a5
 300f672:	00151793          	slli	a5,a0,0x1
 300f676:	0077f693          	andi	a3,a5,7
 300f67a:	4881                	li	a7,0
 300f67c:	c28d                	beqz	a3,300f69e <__adddf3+0x60a>
 300f67e:	4689                	li	a3,2
 300f680:	1ad48f63          	beq	s1,a3,300f83e <__adddf3+0x7aa>
 300f684:	468d                	li	a3,3
 300f686:	1ad48363          	beq	s1,a3,300f82c <__adddf3+0x798>
 300f68a:	4885                	li	a7,1
 300f68c:	e889                	bnez	s1,300f69e <__adddf3+0x60a>
 300f68e:	00f7f693          	andi	a3,a5,15
 300f692:	4611                	li	a2,4
 300f694:	4885                	li	a7,1
 300f696:	ffc7b793          	sltiu	a5,a5,-4
 300f69a:	18c69e63          	bne	a3,a2,300f836 <__adddf3+0x7a2>
 300f69e:	018e5e13          	srli	t3,t3,0x18
 300f6a2:	001e4e13          	xori	t3,t3,1
 300f6a6:	001e7e13          	andi	t3,t3,1
 300f6aa:	87ba                	mv	a5,a4
 300f6ac:	4801                	li	a6,0
 300f6ae:	b9a1                	j	300f306 <__adddf3+0x272>
 300f6b0:	16060963          	beqz	a2,300f822 <__adddf3+0x78e>
 300f6b4:	406505b3          	sub	a1,a0,t1
 300f6b8:	40e78633          	sub	a2,a5,a4
 300f6bc:	00b53833          	sltu	a6,a0,a1
 300f6c0:	41060633          	sub	a2,a2,a6
 300f6c4:	00861413          	slli	s0,a2,0x8
 300f6c8:	00045c63          	bgez	s0,300f6e0 <__adddf3+0x64c>
 300f6cc:	40a30533          	sub	a0,t1,a0
 300f6d0:	40f707b3          	sub	a5,a4,a5
 300f6d4:	00a33733          	sltu	a4,t1,a0
 300f6d8:	40e78733          	sub	a4,a5,a4
 300f6dc:	8936                	mv	s2,a3
 300f6de:	b749                	j	300f660 <__adddf3+0x5cc>
 300f6e0:	00c5e533          	or	a0,a1,a2
 300f6e4:	14051163          	bnez	a0,300f826 <__adddf3+0x792>
 300f6e8:	ffe48913          	addi	s2,s1,-2
 300f6ec:	00193913          	seqz	s2,s2
 300f6f0:	4701                	li	a4,0
 300f6f2:	b7bd                	j	300f660 <__adddf3+0x5cc>
 300f6f4:	7ff00e93          	li	t4,2047
 300f6f8:	03d99c63          	bne	s3,t4,300f730 <__adddf3+0x69c>
 300f6fc:	1c058263          	beqz	a1,300f8c0 <__adddf3+0x82c>
 300f700:	004008b7          	lui	a7,0x400
 300f704:	0117f8b3          	and	a7,a5,a7
 300f708:	0018b893          	seqz	a7,a7
 300f70c:	0892                	slli	a7,a7,0x4
 300f70e:	03381663          	bne	a6,s3,300f73a <__adddf3+0x6a6>
 300f712:	c611                	beqz	a2,300f71e <__adddf3+0x68a>
 300f714:	00971413          	slli	s0,a4,0x9
 300f718:	00044363          	bltz	s0,300f71e <__adddf3+0x68a>
 300f71c:	48c1                	li	a7,16
 300f71e:	ed91                	bnez	a1,300f73a <__adddf3+0x6a6>
 300f720:	14060963          	beqz	a2,300f872 <__adddf3+0x7de>
 300f724:	87ba                	mv	a5,a4
 300f726:	851a                	mv	a0,t1
 300f728:	8936                	mv	s2,a3
 300f72a:	7ff00813          	li	a6,2047
 300f72e:	bee1                	j	300f306 <__adddf3+0x272>
 300f730:	4881                	li	a7,0
 300f732:	ffd816e3          	bne	a6,t4,300f71e <__adddf3+0x68a>
 300f736:	4881                	li	a7,0
 300f738:	bfe9                	j	300f712 <__adddf3+0x67e>
 300f73a:	da65                	beqz	a2,300f72a <__adddf3+0x696>
 300f73c:	b931                	j	300f358 <__adddf3+0x2c4>
 300f73e:	40650a33          	sub	s4,a0,t1
 300f742:	01453633          	sltu	a2,a0,s4
 300f746:	40e78433          	sub	s0,a5,a4
 300f74a:	8c11                	sub	s0,s0,a2
 300f74c:	00841613          	slli	a2,s0,0x8
 300f750:	06065a63          	bgez	a2,300f7c4 <__adddf3+0x730>
 300f754:	40a30a33          	sub	s4,t1,a0
 300f758:	40f707b3          	sub	a5,a4,a5
 300f75c:	01433733          	sltu	a4,t1,s4
 300f760:	40e78433          	sub	s0,a5,a4
 300f764:	8936                	mv	s2,a3
 300f766:	c03d                	beqz	s0,300f7cc <__adddf3+0x738>
 300f768:	8522                	mv	a0,s0
 300f76a:	39f010ef          	jal	ra,3011308 <__clzsi2>
 300f76e:	ff850813          	addi	a6,a0,-8
 300f772:	47fd                	li	a5,31
 300f774:	0707c263          	blt	a5,a6,300f7d8 <__adddf3+0x744>
 300f778:	02000713          	li	a4,32
 300f77c:	41070733          	sub	a4,a4,a6
 300f780:	01041433          	sll	s0,s0,a6
 300f784:	00ea5733          	srl	a4,s4,a4
 300f788:	008767b3          	or	a5,a4,s0
 300f78c:	010a1333          	sll	t1,s4,a6
 300f790:	07384e63          	blt	a6,s3,300f80c <__adddf3+0x778>
 300f794:	41380833          	sub	a6,a6,s3
 300f798:	00180713          	addi	a4,a6,1 # 80000001 <RAM_END+0x7bff8001>
 300f79c:	46fd                	li	a3,31
 300f79e:	04e6c363          	blt	a3,a4,300f7e4 <__adddf3+0x750>
 300f7a2:	02000693          	li	a3,32
 300f7a6:	8e99                	sub	a3,a3,a4
 300f7a8:	00e35633          	srl	a2,t1,a4
 300f7ac:	00d79533          	sll	a0,a5,a3
 300f7b0:	00d31333          	sll	t1,t1,a3
 300f7b4:	8d51                	or	a0,a0,a2
 300f7b6:	00603333          	snez	t1,t1
 300f7ba:	00656533          	or	a0,a0,t1
 300f7be:	00e7d733          	srl	a4,a5,a4
 300f7c2:	bd79                	j	300f660 <__adddf3+0x5cc>
 300f7c4:	008a6533          	or	a0,s4,s0
 300f7c8:	fd59                	bnez	a0,300f766 <__adddf3+0x6d2>
 300f7ca:	bf39                	j	300f6e8 <__adddf3+0x654>
 300f7cc:	8552                	mv	a0,s4
 300f7ce:	33b010ef          	jal	ra,3011308 <__clzsi2>
 300f7d2:	02050513          	addi	a0,a0,32
 300f7d6:	bf61                	j	300f76e <__adddf3+0x6da>
 300f7d8:	fd850413          	addi	s0,a0,-40
 300f7dc:	008a17b3          	sll	a5,s4,s0
 300f7e0:	4301                	li	t1,0
 300f7e2:	b77d                	j	300f790 <__adddf3+0x6fc>
 300f7e4:	1805                	addi	a6,a6,-31
 300f7e6:	02000693          	li	a3,32
 300f7ea:	0107d833          	srl	a6,a5,a6
 300f7ee:	4601                	li	a2,0
 300f7f0:	00d70763          	beq	a4,a3,300f7fe <__adddf3+0x76a>
 300f7f4:	04000613          	li	a2,64
 300f7f8:	8e19                	sub	a2,a2,a4
 300f7fa:	00c79633          	sll	a2,a5,a2
 300f7fe:	00c36533          	or	a0,t1,a2
 300f802:	00a03533          	snez	a0,a0
 300f806:	00a86533          	or	a0,a6,a0
 300f80a:	b5dd                	j	300f6f0 <__adddf3+0x65c>
 300f80c:	ff800737          	lui	a4,0xff800
 300f810:	fff70513          	addi	a0,a4,-1 # ff7fffff <RAM_END+0xfb7f7fff>
 300f814:	41098833          	sub	a6,s3,a6
 300f818:	00a7f733          	and	a4,a5,a0
 300f81c:	b2ed                	j	300f206 <__adddf3+0x172>
 300f81e:	851a                	mv	a0,t1
 300f820:	bd75                	j	300f6dc <__adddf3+0x648>
 300f822:	873e                	mv	a4,a5
 300f824:	bd35                	j	300f660 <__adddf3+0x5cc>
 300f826:	8732                	mv	a4,a2
 300f828:	852e                	mv	a0,a1
 300f82a:	bd1d                	j	300f660 <__adddf3+0x5cc>
 300f82c:	4885                	li	a7,1
 300f82e:	e60918e3          	bnez	s2,300f69e <__adddf3+0x60a>
 300f832:	ff87b793          	sltiu	a5,a5,-8
 300f836:	0017c793          	xori	a5,a5,1
 300f83a:	9e3e                	add	t3,t3,a5
 300f83c:	b58d                	j	300f69e <__adddf3+0x60a>
 300f83e:	4885                	li	a7,1
 300f840:	e4090fe3          	beqz	s2,300f69e <__adddf3+0x60a>
 300f844:	b7fd                	j	300f832 <__adddf3+0x79e>
 300f846:	87ba                	mv	a5,a4
 300f848:	851a                	mv	a0,t1
 300f84a:	b5c5                	j	300f72a <__adddf3+0x696>
 300f84c:	4781                	li	a5,0
 300f84e:	4501                	li	a0,0
 300f850:	7ff00813          	li	a6,2047
 300f854:	4881                	li	a7,0
 300f856:	b639                	j	300f364 <__adddf3+0x2d0>
 300f858:	4781                	li	a5,0
 300f85a:	bfed                	j	300f854 <__adddf3+0x7c0>
 300f85c:	87ba                	mv	a5,a4
 300f85e:	851a                	mv	a0,t1
 300f860:	4e01                	li	t3,0
 300f862:	b229                	j	300f16c <__adddf3+0xd8>
 300f864:	4781                	li	a5,0
 300f866:	8936                	mv	s2,a3
 300f868:	b7f5                	j	300f854 <__adddf3+0x7c0>
 300f86a:	87ba                	mv	a5,a4
 300f86c:	851a                	mv	a0,t1
 300f86e:	8936                	mv	s2,a3
 300f870:	bfc5                	j	300f860 <__adddf3+0x7cc>
 300f872:	4501                	li	a0,0
 300f874:	004007b7          	lui	a5,0x400
 300f878:	7ff00813          	li	a6,2047
 300f87c:	4901                	li	s2,0
 300f87e:	48c1                	li	a7,16
 300f880:	b4d5                	j	300f364 <__adddf3+0x2d0>
 300f882:	4501                	li	a0,0
 300f884:	4801                	li	a6,0
 300f886:	b7f9                	j	300f854 <__adddf3+0x7c0>
 300f888:	a80913e3          	bnez	s2,300f30e <__adddf3+0x27a>
 300f88c:	00850713          	addi	a4,a0,8
 300f890:	be75                	j	300f44c <__adddf3+0x3b8>
 300f892:	a6090ee3          	beqz	s2,300f30e <__adddf3+0x27a>
 300f896:	bfdd                	j	300f88c <__adddf3+0x7f8>
 300f898:	4501                	li	a0,0
 300f89a:	cc99                	beqz	s1,300f8b8 <__adddf3+0x824>
 300f89c:	478d                	li	a5,3
 300f89e:	00f49863          	bne	s1,a5,300f8ae <__adddf3+0x81a>
 300f8a2:	00090b63          	beqz	s2,300f8b8 <__adddf3+0x824>
 300f8a6:	557d                	li	a0,-1
 300f8a8:	7fe00813          	li	a6,2046
 300f8ac:	a031                	j	300f8b8 <__adddf3+0x824>
 300f8ae:	4789                	li	a5,2
 300f8b0:	fef49be3          	bne	s1,a5,300f8a6 <__adddf3+0x812>
 300f8b4:	fe0909e3          	beqz	s2,300f8a6 <__adddf3+0x812>
 300f8b8:	0058e893          	ori	a7,a7,5
 300f8bc:	87aa                	mv	a5,a0
 300f8be:	b4c1                	j	300f37e <__adddf3+0x2ea>
 300f8c0:	4881                	li	a7,0
 300f8c2:	e5381fe3          	bne	a6,s3,300f720 <__adddf3+0x68c>
 300f8c6:	bd85                	j	300f736 <__adddf3+0x6a2>
 300f8c8:	b33801e3          	beq	a6,s3,300f3ea <__adddf3+0x356>
 300f8cc:	87ba                	mv	a5,a4
 300f8ce:	851a                	mv	a0,t1
 300f8d0:	7ff00813          	li	a6,2047
 300f8d4:	be35                	j	300f410 <__adddf3+0x37c>

0300f8d6 <__divdf3>:
 300f8d6:	7179                	addi	sp,sp,-48
 300f8d8:	d422                	sw	s0,40(sp)
 300f8da:	ca56                	sw	s5,20(sp)
 300f8dc:	c266                	sw	s9,4(sp)
 300f8de:	d606                	sw	ra,44(sp)
 300f8e0:	d226                	sw	s1,36(sp)
 300f8e2:	d04a                	sw	s2,32(sp)
 300f8e4:	ce4e                	sw	s3,28(sp)
 300f8e6:	cc52                	sw	s4,24(sp)
 300f8e8:	c85a                	sw	s6,16(sp)
 300f8ea:	c65e                	sw	s7,12(sp)
 300f8ec:	c462                	sw	s8,8(sp)
 300f8ee:	842a                	mv	s0,a0
 300f8f0:	8cb2                	mv	s9,a2
 300f8f2:	8ab6                	mv	s5,a3
 300f8f4:	002029f3          	frrm	s3
 300f8f8:	00100bb7          	lui	s7,0x100
 300f8fc:	84aa                	mv	s1,a0
 300f8fe:	0145d513          	srli	a0,a1,0x14
 300f902:	1bfd                	addi	s7,s7,-1 # fffff <FLASH_SIZE+0xe0003>
 300f904:	7ff57513          	andi	a0,a0,2047
 300f908:	00bbfbb3          	and	s7,s7,a1
 300f90c:	01f5da13          	srli	s4,a1,0x1f
 300f910:	c50d                	beqz	a0,300f93a <__divdf3+0x64>
 300f912:	7ff00793          	li	a5,2047
 300f916:	06f50c63          	beq	a0,a5,300f98e <__divdf3+0xb8>
 300f91a:	008007b7          	lui	a5,0x800
 300f91e:	0b8e                	slli	s7,s7,0x3
 300f920:	00fbebb3          	or	s7,s7,a5
 300f924:	01d45793          	srli	a5,s0,0x1d
 300f928:	0177ebb3          	or	s7,a5,s7
 300f92c:	00341493          	slli	s1,s0,0x3
 300f930:	c0150b13          	addi	s6,a0,-1023
 300f934:	4c01                	li	s8,0
 300f936:	4901                	li	s2,0
 300f938:	a0b5                	j	300f9a4 <__divdf3+0xce>
 300f93a:	008be7b3          	or	a5,s7,s0
 300f93e:	c7e1                	beqz	a5,300fa06 <__divdf3+0x130>
 300f940:	020b8b63          	beqz	s7,300f976 <__divdf3+0xa0>
 300f944:	855e                	mv	a0,s7
 300f946:	1c3010ef          	jal	ra,3011308 <__clzsi2>
 300f94a:	ff550693          	addi	a3,a0,-11
 300f94e:	47f1                	li	a5,28
 300f950:	02d7c963          	blt	a5,a3,300f982 <__divdf3+0xac>
 300f954:	4775                	li	a4,29
 300f956:	ff850493          	addi	s1,a0,-8
 300f95a:	8f15                	sub	a4,a4,a3
 300f95c:	009b9bb3          	sll	s7,s7,s1
 300f960:	00e45733          	srl	a4,s0,a4
 300f964:	01776bb3          	or	s7,a4,s7
 300f968:	009414b3          	sll	s1,s0,s1
 300f96c:	c0d00b13          	li	s6,-1011
 300f970:	40ab0b33          	sub	s6,s6,a0
 300f974:	b7c1                	j	300f934 <__divdf3+0x5e>
 300f976:	8522                	mv	a0,s0
 300f978:	191010ef          	jal	ra,3011308 <__clzsi2>
 300f97c:	02050513          	addi	a0,a0,32
 300f980:	b7e9                	j	300f94a <__divdf3+0x74>
 300f982:	fd850b93          	addi	s7,a0,-40
 300f986:	01741bb3          	sll	s7,s0,s7
 300f98a:	4481                	li	s1,0
 300f98c:	b7c5                	j	300f96c <__divdf3+0x96>
 300f98e:	008be433          	or	s0,s7,s0
 300f992:	cc3d                	beqz	s0,300fa10 <__divdf3+0x13a>
 300f994:	00cb9793          	slli	a5,s7,0xc
 300f998:	7ff00b13          	li	s6,2047
 300f99c:	4c0d                	li	s8,3
 300f99e:	4941                	li	s2,16
 300f9a0:	f807cbe3          	bltz	a5,300f936 <__divdf3+0x60>
 300f9a4:	014ad513          	srli	a0,s5,0x14
 300f9a8:	00100437          	lui	s0,0x100
 300f9ac:	147d                	addi	s0,s0,-1 # fffff <FLASH_SIZE+0xe0003>
 300f9ae:	7ff57513          	andi	a0,a0,2047
 300f9b2:	01547433          	and	s0,s0,s5
 300f9b6:	87e6                	mv	a5,s9
 300f9b8:	01fada93          	srli	s5,s5,0x1f
 300f9bc:	c125                	beqz	a0,300fa1c <__divdf3+0x146>
 300f9be:	7ff00713          	li	a4,2047
 300f9c2:	0ae50563          	beq	a0,a4,300fa6c <__divdf3+0x196>
 300f9c6:	008007b7          	lui	a5,0x800
 300f9ca:	040e                	slli	s0,s0,0x3
 300f9cc:	8c5d                	or	s0,s0,a5
 300f9ce:	01dcd793          	srli	a5,s9,0x1d
 300f9d2:	8c5d                	or	s0,s0,a5
 300f9d4:	c0150513          	addi	a0,a0,-1023
 300f9d8:	003c9793          	slli	a5,s9,0x3
 300f9dc:	4701                	li	a4,0
 300f9de:	002c1693          	slli	a3,s8,0x2
 300f9e2:	8ed9                	or	a3,a3,a4
 300f9e4:	16fd                	addi	a3,a3,-1 # 7fffff <FLASH_SIZE+0x7e0003>
 300f9e6:	4639                	li	a2,14
 300f9e8:	015a4833          	xor	a6,s4,s5
 300f9ec:	40ab0533          	sub	a0,s6,a0
 300f9f0:	0ad66763          	bltu	a2,a3,300fa9e <__divdf3+0x1c8>
 300f9f4:	00003617          	auipc	a2,0x3
 300f9f8:	b3060613          	addi	a2,a2,-1232 # 3012524 <g_crgIpMatch+0xc8c>
 300f9fc:	068a                	slli	a3,a3,0x2
 300f9fe:	96b2                	add	a3,a3,a2
 300fa00:	4294                	lw	a3,0(a3)
 300fa02:	96b2                	add	a3,a3,a2
 300fa04:	8682                	jr	a3
 300fa06:	4b81                	li	s7,0
 300fa08:	4481                	li	s1,0
 300fa0a:	4b01                	li	s6,0
 300fa0c:	4c05                	li	s8,1
 300fa0e:	b725                	j	300f936 <__divdf3+0x60>
 300fa10:	4b81                	li	s7,0
 300fa12:	4481                	li	s1,0
 300fa14:	7ff00b13          	li	s6,2047
 300fa18:	4c09                	li	s8,2
 300fa1a:	bf31                	j	300f936 <__divdf3+0x60>
 300fa1c:	019467b3          	or	a5,s0,s9
 300fa20:	c3b5                	beqz	a5,300fa84 <__divdf3+0x1ae>
 300fa22:	c80d                	beqz	s0,300fa54 <__divdf3+0x17e>
 300fa24:	8522                	mv	a0,s0
 300fa26:	0e3010ef          	jal	ra,3011308 <__clzsi2>
 300fa2a:	ff550693          	addi	a3,a0,-11
 300fa2e:	47f1                	li	a5,28
 300fa30:	02d7c863          	blt	a5,a3,300fa60 <__divdf3+0x18a>
 300fa34:	4775                	li	a4,29
 300fa36:	ff850793          	addi	a5,a0,-8
 300fa3a:	8f15                	sub	a4,a4,a3
 300fa3c:	00f41433          	sll	s0,s0,a5
 300fa40:	00ecd733          	srl	a4,s9,a4
 300fa44:	8c59                	or	s0,s0,a4
 300fa46:	00fc97b3          	sll	a5,s9,a5
 300fa4a:	c0d00713          	li	a4,-1011
 300fa4e:	40a70533          	sub	a0,a4,a0
 300fa52:	b769                	j	300f9dc <__divdf3+0x106>
 300fa54:	8566                	mv	a0,s9
 300fa56:	0b3010ef          	jal	ra,3011308 <__clzsi2>
 300fa5a:	02050513          	addi	a0,a0,32
 300fa5e:	b7f1                	j	300fa2a <__divdf3+0x154>
 300fa60:	fd850413          	addi	s0,a0,-40
 300fa64:	008c9433          	sll	s0,s9,s0
 300fa68:	4781                	li	a5,0
 300fa6a:	b7c5                	j	300fa4a <__divdf3+0x174>
 300fa6c:	01946633          	or	a2,s0,s9
 300fa70:	ce19                	beqz	a2,300fa8e <__divdf3+0x1b8>
 300fa72:	00c41713          	slli	a4,s0,0xc
 300fa76:	7ff00513          	li	a0,2047
 300fa7a:	02074063          	bltz	a4,300fa9a <__divdf3+0x1c4>
 300fa7e:	470d                	li	a4,3
 300fa80:	4941                	li	s2,16
 300fa82:	bfb1                	j	300f9de <__divdf3+0x108>
 300fa84:	4401                	li	s0,0
 300fa86:	4781                	li	a5,0
 300fa88:	4501                	li	a0,0
 300fa8a:	4705                	li	a4,1
 300fa8c:	bf89                	j	300f9de <__divdf3+0x108>
 300fa8e:	4401                	li	s0,0
 300fa90:	4781                	li	a5,0
 300fa92:	7ff00513          	li	a0,2047
 300fa96:	4709                	li	a4,2
 300fa98:	b799                	j	300f9de <__divdf3+0x108>
 300fa9a:	470d                	li	a4,3
 300fa9c:	b789                	j	300f9de <__divdf3+0x108>
 300fa9e:	01746663          	bltu	s0,s7,300faaa <__divdf3+0x1d4>
 300faa2:	268b9463          	bne	s7,s0,300fd0a <__divdf3+0x434>
 300faa6:	26f4e263          	bltu	s1,a5,300fd0a <__divdf3+0x434>
 300faaa:	01fb9693          	slli	a3,s7,0x1f
 300faae:	0014d713          	srli	a4,s1,0x1
 300fab2:	01f49593          	slli	a1,s1,0x1f
 300fab6:	001bdb93          	srli	s7,s7,0x1
 300faba:	00e6e4b3          	or	s1,a3,a4
 300fabe:	0187d693          	srli	a3,a5,0x18
 300fac2:	0422                	slli	s0,s0,0x8
 300fac4:	8ec1                	or	a3,a3,s0
 300fac6:	0106de93          	srli	t4,a3,0x10
 300faca:	03dbd333          	divu	t1,s7,t4
 300face:	01069e13          	slli	t3,a3,0x10
 300fad2:	010e5e13          	srli	t3,t3,0x10
 300fad6:	00879613          	slli	a2,a5,0x8
 300fada:	0104d793          	srli	a5,s1,0x10
 300fade:	03dbfbb3          	remu	s7,s7,t4
 300fae2:	889a                	mv	a7,t1
 300fae4:	026e0733          	mul	a4,t3,t1
 300fae8:	0bc2                	slli	s7,s7,0x10
 300faea:	0177e7b3          	or	a5,a5,s7
 300faee:	00e7fc63          	bgeu	a5,a4,300fb06 <__divdf3+0x230>
 300faf2:	97b6                	add	a5,a5,a3
 300faf4:	fff30893          	addi	a7,t1,-1
 300faf8:	00d7e763          	bltu	a5,a3,300fb06 <__divdf3+0x230>
 300fafc:	00e7f563          	bgeu	a5,a4,300fb06 <__divdf3+0x230>
 300fb00:	ffe30893          	addi	a7,t1,-2
 300fb04:	97b6                	add	a5,a5,a3
 300fb06:	8f99                	sub	a5,a5,a4
 300fb08:	03d7df33          	divu	t5,a5,t4
 300fb0c:	01049713          	slli	a4,s1,0x10
 300fb10:	8341                	srli	a4,a4,0x10
 300fb12:	03d7f7b3          	remu	a5,a5,t4
 300fb16:	84fa                	mv	s1,t5
 300fb18:	03ee0333          	mul	t1,t3,t5
 300fb1c:	07c2                	slli	a5,a5,0x10
 300fb1e:	8f5d                	or	a4,a4,a5
 300fb20:	00677c63          	bgeu	a4,t1,300fb38 <__divdf3+0x262>
 300fb24:	9736                	add	a4,a4,a3
 300fb26:	ffff0493          	addi	s1,t5,-1
 300fb2a:	00d76763          	bltu	a4,a3,300fb38 <__divdf3+0x262>
 300fb2e:	00677563          	bgeu	a4,t1,300fb38 <__divdf3+0x262>
 300fb32:	ffef0493          	addi	s1,t5,-2
 300fb36:	9736                	add	a4,a4,a3
 300fb38:	08c2                	slli	a7,a7,0x10
 300fb3a:	0098e4b3          	or	s1,a7,s1
 300fb3e:	68c1                	lui	a7,0x10
 300fb40:	fff88f13          	addi	t5,a7,-1 # ffff <RAM_SIZE+0xafff>
 300fb44:	0104d293          	srli	t0,s1,0x10
 300fb48:	01065f93          	srli	t6,a2,0x10
 300fb4c:	40670733          	sub	a4,a4,t1
 300fb50:	01e4f333          	and	t1,s1,t5
 300fb54:	01e67f33          	and	t5,a2,t5
 300fb58:	03e307b3          	mul	a5,t1,t5
 300fb5c:	03e28433          	mul	s0,t0,t5
 300fb60:	026f8333          	mul	t1,t6,t1
 300fb64:	008303b3          	add	t2,t1,s0
 300fb68:	0107d313          	srli	t1,a5,0x10
 300fb6c:	931e                	add	t1,t1,t2
 300fb6e:	03f282b3          	mul	t0,t0,t6
 300fb72:	00837363          	bgeu	t1,s0,300fb78 <__divdf3+0x2a2>
 300fb76:	92c6                	add	t0,t0,a7
 300fb78:	63c1                	lui	t2,0x10
 300fb7a:	01035893          	srli	a7,t1,0x10
 300fb7e:	13fd                	addi	t2,t2,-1 # ffff <RAM_SIZE+0xafff>
 300fb80:	92c6                	add	t0,t0,a7
 300fb82:	007378b3          	and	a7,t1,t2
 300fb86:	08c2                	slli	a7,a7,0x10
 300fb88:	0077f7b3          	and	a5,a5,t2
 300fb8c:	98be                	add	a7,a7,a5
 300fb8e:	00576763          	bltu	a4,t0,300fb9c <__divdf3+0x2c6>
 300fb92:	8426                	mv	s0,s1
 300fb94:	02571e63          	bne	a4,t0,300fbd0 <__divdf3+0x2fa>
 300fb98:	0315fc63          	bgeu	a1,a7,300fbd0 <__divdf3+0x2fa>
 300fb9c:	95b2                	add	a1,a1,a2
 300fb9e:	00c5b7b3          	sltu	a5,a1,a2
 300fba2:	97b6                	add	a5,a5,a3
 300fba4:	973e                	add	a4,a4,a5
 300fba6:	fff48413          	addi	s0,s1,-1
 300fbaa:	00e6e663          	bltu	a3,a4,300fbb6 <__divdf3+0x2e0>
 300fbae:	02e69163          	bne	a3,a4,300fbd0 <__divdf3+0x2fa>
 300fbb2:	00c5ef63          	bltu	a1,a2,300fbd0 <__divdf3+0x2fa>
 300fbb6:	00576663          	bltu	a4,t0,300fbc2 <__divdf3+0x2ec>
 300fbba:	00e29b63          	bne	t0,a4,300fbd0 <__divdf3+0x2fa>
 300fbbe:	0115f963          	bgeu	a1,a7,300fbd0 <__divdf3+0x2fa>
 300fbc2:	95b2                	add	a1,a1,a2
 300fbc4:	00c5b7b3          	sltu	a5,a1,a2
 300fbc8:	97b6                	add	a5,a5,a3
 300fbca:	ffe48413          	addi	s0,s1,-2
 300fbce:	973e                	add	a4,a4,a5
 300fbd0:	411588b3          	sub	a7,a1,a7
 300fbd4:	40570733          	sub	a4,a4,t0
 300fbd8:	0115b5b3          	sltu	a1,a1,a7
 300fbdc:	8f0d                	sub	a4,a4,a1
 300fbde:	57fd                	li	a5,-1
 300fbe0:	0ee68863          	beq	a3,a4,300fcd0 <__divdf3+0x3fa>
 300fbe4:	03d752b3          	divu	t0,a4,t4
 300fbe8:	0108d793          	srli	a5,a7,0x10
 300fbec:	03d77733          	remu	a4,a4,t4
 300fbf0:	8596                	mv	a1,t0
 300fbf2:	025e0333          	mul	t1,t3,t0
 300fbf6:	0742                	slli	a4,a4,0x10
 300fbf8:	8f5d                	or	a4,a4,a5
 300fbfa:	00677c63          	bgeu	a4,t1,300fc12 <__divdf3+0x33c>
 300fbfe:	9736                	add	a4,a4,a3
 300fc00:	fff28593          	addi	a1,t0,-1
 300fc04:	00d76763          	bltu	a4,a3,300fc12 <__divdf3+0x33c>
 300fc08:	00677563          	bgeu	a4,t1,300fc12 <__divdf3+0x33c>
 300fc0c:	ffe28593          	addi	a1,t0,-2
 300fc10:	9736                	add	a4,a4,a3
 300fc12:	40670733          	sub	a4,a4,t1
 300fc16:	03d75333          	divu	t1,a4,t4
 300fc1a:	01089793          	slli	a5,a7,0x10
 300fc1e:	83c1                	srli	a5,a5,0x10
 300fc20:	03d77733          	remu	a4,a4,t4
 300fc24:	026e0e33          	mul	t3,t3,t1
 300fc28:	0742                	slli	a4,a4,0x10
 300fc2a:	8f5d                	or	a4,a4,a5
 300fc2c:	879a                	mv	a5,t1
 300fc2e:	01c77c63          	bgeu	a4,t3,300fc46 <__divdf3+0x370>
 300fc32:	9736                	add	a4,a4,a3
 300fc34:	fff30793          	addi	a5,t1,-1
 300fc38:	00d76763          	bltu	a4,a3,300fc46 <__divdf3+0x370>
 300fc3c:	01c77563          	bgeu	a4,t3,300fc46 <__divdf3+0x370>
 300fc40:	ffe30793          	addi	a5,t1,-2
 300fc44:	9736                	add	a4,a4,a3
 300fc46:	05c2                	slli	a1,a1,0x10
 300fc48:	41c70733          	sub	a4,a4,t3
 300fc4c:	00f5ee33          	or	t3,a1,a5
 300fc50:	010e1793          	slli	a5,t3,0x10
 300fc54:	83c1                	srli	a5,a5,0x10
 300fc56:	010e5893          	srli	a7,t3,0x10
 300fc5a:	02ff0eb3          	mul	t4,t5,a5
 300fc5e:	031f8333          	mul	t1,t6,a7
 300fc62:	03e88f33          	mul	t5,a7,t5
 300fc66:	02ff8fb3          	mul	t6,t6,a5
 300fc6a:	010ed793          	srli	a5,t4,0x10
 300fc6e:	9ffa                	add	t6,t6,t5
 300fc70:	97fe                	add	a5,a5,t6
 300fc72:	01e7f463          	bgeu	a5,t5,300fc7a <__divdf3+0x3a4>
 300fc76:	65c1                	lui	a1,0x10
 300fc78:	932e                	add	t1,t1,a1
 300fc7a:	0107d893          	srli	a7,a5,0x10
 300fc7e:	989a                	add	a7,a7,t1
 300fc80:	6341                	lui	t1,0x10
 300fc82:	137d                	addi	t1,t1,-1 # ffff <RAM_SIZE+0xafff>
 300fc84:	0067f5b3          	and	a1,a5,t1
 300fc88:	05c2                	slli	a1,a1,0x10
 300fc8a:	006efeb3          	and	t4,t4,t1
 300fc8e:	95f6                	add	a1,a1,t4
 300fc90:	01176663          	bltu	a4,a7,300fc9c <__divdf3+0x3c6>
 300fc94:	87f2                	mv	a5,t3
 300fc96:	03171b63          	bne	a4,a7,300fccc <__divdf3+0x3f6>
 300fc9a:	c99d                	beqz	a1,300fcd0 <__divdf3+0x3fa>
 300fc9c:	9736                	add	a4,a4,a3
 300fc9e:	fffe0793          	addi	a5,t3,-1
 300fca2:	02d76163          	bltu	a4,a3,300fcc4 <__divdf3+0x3ee>
 300fca6:	01176663          	bltu	a4,a7,300fcb2 <__divdf3+0x3dc>
 300fcaa:	03171163          	bne	a4,a7,300fccc <__divdf3+0x3f6>
 300fcae:	00b67d63          	bgeu	a2,a1,300fcc8 <__divdf3+0x3f2>
 300fcb2:	00161313          	slli	t1,a2,0x1
 300fcb6:	00c33633          	sltu	a2,t1,a2
 300fcba:	96b2                	add	a3,a3,a2
 300fcbc:	ffee0793          	addi	a5,t3,-2
 300fcc0:	9736                	add	a4,a4,a3
 300fcc2:	861a                	mv	a2,t1
 300fcc4:	01171463          	bne	a4,a7,300fccc <__divdf3+0x3f6>
 300fcc8:	00c58463          	beq	a1,a2,300fcd0 <__divdf3+0x3fa>
 300fccc:	0017e793          	ori	a5,a5,1
 300fcd0:	3ff50613          	addi	a2,a0,1023
 300fcd4:	12c05763          	blez	a2,300fe02 <__divdf3+0x52c>
 300fcd8:	0077f713          	andi	a4,a5,7
 300fcdc:	c771                	beqz	a4,300fda8 <__divdf3+0x4d2>
 300fcde:	4709                	li	a4,2
 300fce0:	00196913          	ori	s2,s2,1
 300fce4:	0ce98063          	beq	s3,a4,300fda4 <__divdf3+0x4ce>
 300fce8:	470d                	li	a4,3
 300fcea:	0ae98863          	beq	s3,a4,300fd9a <__divdf3+0x4c4>
 300fcee:	0a099d63          	bnez	s3,300fda8 <__divdf3+0x4d2>
 300fcf2:	00f7f713          	andi	a4,a5,15
 300fcf6:	4691                	li	a3,4
 300fcf8:	0ad70863          	beq	a4,a3,300fda8 <__divdf3+0x4d2>
 300fcfc:	00478713          	addi	a4,a5,4 # 800004 <FLASH_SIZE+0x7e0008>
 300fd00:	00f737b3          	sltu	a5,a4,a5
 300fd04:	943e                	add	s0,s0,a5
 300fd06:	87ba                	mv	a5,a4
 300fd08:	a045                	j	300fda8 <__divdf3+0x4d2>
 300fd0a:	157d                	addi	a0,a0,-1
 300fd0c:	4581                	li	a1,0
 300fd0e:	bb45                	j	300fabe <__divdf3+0x1e8>
 300fd10:	8852                	mv	a6,s4
 300fd12:	845e                	mv	s0,s7
 300fd14:	87a6                	mv	a5,s1
 300fd16:	8762                	mv	a4,s8
 300fd18:	4689                	li	a3,2
 300fd1a:	00d70f63          	beq	a4,a3,300fd38 <__divdf3+0x462>
 300fd1e:	468d                	li	a3,3
 300fd20:	22d70b63          	beq	a4,a3,300ff56 <__divdf3+0x680>
 300fd24:	4685                	li	a3,1
 300fd26:	fad715e3          	bne	a4,a3,300fcd0 <__divdf3+0x3fa>
 300fd2a:	4401                	li	s0,0
 300fd2c:	4781                	li	a5,0
 300fd2e:	ac09                	j	300ff40 <__divdf3+0x66a>
 300fd30:	8856                	mv	a6,s5
 300fd32:	b7dd                	j	300fd18 <__divdf3+0x442>
 300fd34:	00896913          	ori	s2,s2,8
 300fd38:	4401                	li	s0,0
 300fd3a:	4781                	li	a5,0
 300fd3c:	7ff00613          	li	a2,2047
 300fd40:	00100737          	lui	a4,0x100
 300fd44:	177d                	addi	a4,a4,-1 # fffff <FLASH_SIZE+0xe0003>
 300fd46:	8c79                	and	s0,s0,a4
 300fd48:	80100737          	lui	a4,0x80100
 300fd4c:	177d                	addi	a4,a4,-1 # 800fffff <RAM_END+0x7c0f7fff>
 300fd4e:	7ff67693          	andi	a3,a2,2047
 300fd52:	8c79                	and	s0,s0,a4
 300fd54:	06d2                	slli	a3,a3,0x14
 300fd56:	80000737          	lui	a4,0x80000
 300fd5a:	fff74713          	not	a4,a4
 300fd5e:	8c55                	or	s0,s0,a3
 300fd60:	087e                	slli	a6,a6,0x1f
 300fd62:	8c79                	and	s0,s0,a4
 300fd64:	01046733          	or	a4,s0,a6
 300fd68:	853e                	mv	a0,a5
 300fd6a:	85ba                	mv	a1,a4
 300fd6c:	00090463          	beqz	s2,300fd74 <__divdf3+0x49e>
 300fd70:	00192073          	csrs	fflags,s2
 300fd74:	50b2                	lw	ra,44(sp)
 300fd76:	5422                	lw	s0,40(sp)
 300fd78:	5492                	lw	s1,36(sp)
 300fd7a:	5902                	lw	s2,32(sp)
 300fd7c:	49f2                	lw	s3,28(sp)
 300fd7e:	4a62                	lw	s4,24(sp)
 300fd80:	4ad2                	lw	s5,20(sp)
 300fd82:	4b42                	lw	s6,16(sp)
 300fd84:	4bb2                	lw	s7,12(sp)
 300fd86:	4c22                	lw	s8,8(sp)
 300fd88:	4c92                	lw	s9,4(sp)
 300fd8a:	6145                	addi	sp,sp,48
 300fd8c:	8082                	ret
 300fd8e:	00080437          	lui	s0,0x80
 300fd92:	4781                	li	a5,0
 300fd94:	4801                	li	a6,0
 300fd96:	470d                	li	a4,3
 300fd98:	b741                	j	300fd18 <__divdf3+0x442>
 300fd9a:	00081763          	bnez	a6,300fda8 <__divdf3+0x4d2>
 300fd9e:	00878713          	addi	a4,a5,8
 300fda2:	bfb9                	j	300fd00 <__divdf3+0x42a>
 300fda4:	fe081de3          	bnez	a6,300fd9e <__divdf3+0x4c8>
 300fda8:	00741713          	slli	a4,s0,0x7
 300fdac:	00075863          	bgez	a4,300fdbc <__divdf3+0x4e6>
 300fdb0:	ff000737          	lui	a4,0xff000
 300fdb4:	177d                	addi	a4,a4,-1 # feffffff <RAM_END+0xfaff7fff>
 300fdb6:	8c79                	and	s0,s0,a4
 300fdb8:	40050613          	addi	a2,a0,1024
 300fdbc:	7fe00713          	li	a4,2046
 300fdc0:	00c74963          	blt	a4,a2,300fdd2 <__divdf3+0x4fc>
 300fdc4:	0037d713          	srli	a4,a5,0x3
 300fdc8:	01d41793          	slli	a5,s0,0x1d
 300fdcc:	8fd9                	or	a5,a5,a4
 300fdce:	800d                	srli	s0,s0,0x3
 300fdd0:	bf85                	j	300fd40 <__divdf3+0x46a>
 300fdd2:	4789                	li	a5,2
 300fdd4:	02f98463          	beq	s3,a5,300fdfc <__divdf3+0x526>
 300fdd8:	478d                	li	a5,3
 300fdda:	00f98b63          	beq	s3,a5,300fdf0 <__divdf3+0x51a>
 300fdde:	00098b63          	beqz	s3,300fdf4 <__divdf3+0x51e>
 300fde2:	57fd                	li	a5,-1
 300fde4:	7fe00613          	li	a2,2046
 300fde8:	00596913          	ori	s2,s2,5
 300fdec:	843e                	mv	s0,a5
 300fdee:	bf89                	j	300fd40 <__divdf3+0x46a>
 300fdf0:	fe0819e3          	bnez	a6,300fde2 <__divdf3+0x50c>
 300fdf4:	4781                	li	a5,0
 300fdf6:	7ff00613          	li	a2,2047
 300fdfa:	b7fd                	j	300fde8 <__divdf3+0x512>
 300fdfc:	fe081ce3          	bnez	a6,300fdf4 <__divdf3+0x51e>
 300fe00:	b7cd                	j	300fde2 <__divdf3+0x50c>
 300fe02:	4585                	li	a1,1
 300fe04:	ea29                	bnez	a2,300fe56 <__divdf3+0x580>
 300fe06:	0077f693          	andi	a3,a5,7
 300fe0a:	8722                	mv	a4,s0
 300fe0c:	c2a1                	beqz	a3,300fe4c <__divdf3+0x576>
 300fe0e:	4709                	li	a4,2
 300fe10:	00196913          	ori	s2,s2,1
 300fe14:	02e98963          	beq	s3,a4,300fe46 <__divdf3+0x570>
 300fe18:	470d                	li	a4,3
 300fe1a:	02e98063          	beq	s3,a4,300fe3a <__divdf3+0x564>
 300fe1e:	8722                	mv	a4,s0
 300fe20:	02099663          	bnez	s3,300fe4c <__divdf3+0x576>
 300fe24:	00f7f693          	andi	a3,a5,15
 300fe28:	4591                	li	a1,4
 300fe2a:	02b68163          	beq	a3,a1,300fe4c <__divdf3+0x576>
 300fe2e:	ffc7b713          	sltiu	a4,a5,-4
 300fe32:	00174713          	xori	a4,a4,1
 300fe36:	9722                	add	a4,a4,s0
 300fe38:	a811                	j	300fe4c <__divdf3+0x576>
 300fe3a:	8722                	mv	a4,s0
 300fe3c:	00081863          	bnez	a6,300fe4c <__divdf3+0x576>
 300fe40:	ff87b713          	sltiu	a4,a5,-8
 300fe44:	b7fd                	j	300fe32 <__divdf3+0x55c>
 300fe46:	8722                	mv	a4,s0
 300fe48:	fe081ce3          	bnez	a6,300fe40 <__divdf3+0x56a>
 300fe4c:	8361                	srli	a4,a4,0x18
 300fe4e:	00174713          	xori	a4,a4,1
 300fe52:	00177593          	andi	a1,a4,1
 300fe56:	4705                	li	a4,1
 300fe58:	8f11                	sub	a4,a4,a2
 300fe5a:	03800693          	li	a3,56
 300fe5e:	0ce6c063          	blt	a3,a4,300ff1e <__divdf3+0x648>
 300fe62:	46fd                	li	a3,31
 300fe64:	04e6c963          	blt	a3,a4,300feb6 <__divdf3+0x5e0>
 300fe68:	41e50513          	addi	a0,a0,1054
 300fe6c:	00a416b3          	sll	a3,s0,a0
 300fe70:	00e7d633          	srl	a2,a5,a4
 300fe74:	00a797b3          	sll	a5,a5,a0
 300fe78:	8ed1                	or	a3,a3,a2
 300fe7a:	00f037b3          	snez	a5,a5
 300fe7e:	8fd5                	or	a5,a5,a3
 300fe80:	00e45433          	srl	s0,s0,a4
 300fe84:	0077f713          	andi	a4,a5,7
 300fe88:	c32d                	beqz	a4,300feea <__divdf3+0x614>
 300fe8a:	4709                	li	a4,2
 300fe8c:	00196913          	ori	s2,s2,1
 300fe90:	04e98b63          	beq	s3,a4,300fee6 <__divdf3+0x610>
 300fe94:	470d                	li	a4,3
 300fe96:	04e98363          	beq	s3,a4,300fedc <__divdf3+0x606>
 300fe9a:	04099863          	bnez	s3,300feea <__divdf3+0x614>
 300fe9e:	00f7f713          	andi	a4,a5,15
 300fea2:	4691                	li	a3,4
 300fea4:	04d70363          	beq	a4,a3,300feea <__divdf3+0x614>
 300fea8:	00478713          	addi	a4,a5,4
 300feac:	00f737b3          	sltu	a5,a4,a5
 300feb0:	943e                	add	s0,s0,a5
 300feb2:	87ba                	mv	a5,a4
 300feb4:	a81d                	j	300feea <__divdf3+0x614>
 300feb6:	5685                	li	a3,-31
 300feb8:	8e91                	sub	a3,a3,a2
 300feba:	02000893          	li	a7,32
 300febe:	00d456b3          	srl	a3,s0,a3
 300fec2:	4601                	li	a2,0
 300fec4:	01170663          	beq	a4,a7,300fed0 <__divdf3+0x5fa>
 300fec8:	43e50513          	addi	a0,a0,1086
 300fecc:	00a41633          	sll	a2,s0,a0
 300fed0:	8fd1                	or	a5,a5,a2
 300fed2:	00f037b3          	snez	a5,a5
 300fed6:	8fd5                	or	a5,a5,a3
 300fed8:	4401                	li	s0,0
 300feda:	b76d                	j	300fe84 <__divdf3+0x5ae>
 300fedc:	00081763          	bnez	a6,300feea <__divdf3+0x614>
 300fee0:	00878713          	addi	a4,a5,8
 300fee4:	b7e1                	j	300feac <__divdf3+0x5d6>
 300fee6:	fe081de3          	bnez	a6,300fee0 <__divdf3+0x60a>
 300feea:	00841713          	slli	a4,s0,0x8
 300feee:	02075063          	bgez	a4,300ff0e <__divdf3+0x638>
 300fef2:	00196913          	ori	s2,s2,1
 300fef6:	4401                	li	s0,0
 300fef8:	4781                	li	a5,0
 300fefa:	4605                	li	a2,1
 300fefc:	e40582e3          	beqz	a1,300fd40 <__divdf3+0x46a>
 300ff00:	00197713          	andi	a4,s2,1
 300ff04:	e2070ee3          	beqz	a4,300fd40 <__divdf3+0x46a>
 300ff08:	00296913          	ori	s2,s2,2
 300ff0c:	bd15                	j	300fd40 <__divdf3+0x46a>
 300ff0e:	0037d713          	srli	a4,a5,0x3
 300ff12:	01d41793          	slli	a5,s0,0x1d
 300ff16:	8fd9                	or	a5,a5,a4
 300ff18:	800d                	srli	s0,s0,0x3
 300ff1a:	4601                	li	a2,0
 300ff1c:	b7c5                	j	300fefc <__divdf3+0x626>
 300ff1e:	8fc1                	or	a5,a5,s0
 300ff20:	cf89                	beqz	a5,300ff3a <__divdf3+0x664>
 300ff22:	4789                	li	a5,2
 300ff24:	00196913          	ori	s2,s2,1
 300ff28:	02f98363          	beq	s3,a5,300ff4e <__divdf3+0x678>
 300ff2c:	478d                	li	a5,3
 300ff2e:	00f98b63          	beq	s3,a5,300ff44 <__divdf3+0x66e>
 300ff32:	4795                	li	a5,5
 300ff34:	00099b63          	bnez	s3,300ff4a <__divdf3+0x674>
 300ff38:	838d                	srli	a5,a5,0x3
 300ff3a:	00296913          	ori	s2,s2,2
 300ff3e:	4401                	li	s0,0
 300ff40:	4601                	li	a2,0
 300ff42:	bbfd                	j	300fd40 <__divdf3+0x46a>
 300ff44:	47a5                	li	a5,9
 300ff46:	fe0809e3          	beqz	a6,300ff38 <__divdf3+0x662>
 300ff4a:	4785                	li	a5,1
 300ff4c:	b7f5                	j	300ff38 <__divdf3+0x662>
 300ff4e:	47a5                	li	a5,9
 300ff50:	fe0814e3          	bnez	a6,300ff38 <__divdf3+0x662>
 300ff54:	bfdd                	j	300ff4a <__divdf3+0x674>
 300ff56:	00080437          	lui	s0,0x80
 300ff5a:	4781                	li	a5,0
 300ff5c:	7ff00613          	li	a2,2047
 300ff60:	4801                	li	a6,0
 300ff62:	bbf9                	j	300fd40 <__divdf3+0x46a>
 300ff64:	00080437          	lui	s0,0x80
 300ff68:	4781                	li	a5,0
 300ff6a:	7ff00613          	li	a2,2047
 300ff6e:	4801                	li	a6,0
 300ff70:	4941                	li	s2,16
 300ff72:	b3f9                	j	300fd40 <__divdf3+0x46a>

0300ff74 <__gedf2>:
 300ff74:	002027f3          	frrm	a5
 300ff78:	001007b7          	lui	a5,0x100
 300ff7c:	0145d713          	srli	a4,a1,0x14
 300ff80:	17fd                	addi	a5,a5,-1 # fffff <FLASH_SIZE+0xe0003>
 300ff82:	0146d813          	srli	a6,a3,0x14
 300ff86:	7ff77713          	andi	a4,a4,2047
 300ff8a:	7ff00e93          	li	t4,2047
 300ff8e:	00b7f8b3          	and	a7,a5,a1
 300ff92:	832a                	mv	t1,a0
 300ff94:	8ff5                	and	a5,a5,a3
 300ff96:	81fd                	srli	a1,a1,0x1f
 300ff98:	8e32                	mv	t3,a2
 300ff9a:	7ff87813          	andi	a6,a6,2047
 300ff9e:	82fd                	srli	a3,a3,0x1f
 300ffa0:	01d71a63          	bne	a4,t4,300ffb4 <__gedf2+0x40>
 300ffa4:	00a8eeb3          	or	t4,a7,a0
 300ffa8:	060e8a63          	beqz	t4,301001c <__gedf2+0xa8>
 300ffac:	00186073          	csrsi	fflags,16
 300ffb0:	5579                	li	a0,-2
 300ffb2:	8082                	ret
 300ffb4:	01d81a63          	bne	a6,t4,300ffc8 <__gedf2+0x54>
 300ffb8:	8e5d                	or	a2,a2,a5
 300ffba:	fa6d                	bnez	a2,300ffac <__gedf2+0x38>
 300ffbc:	e305                	bnez	a4,300ffdc <__gedf2+0x68>
 300ffbe:	00a8e533          	or	a0,a7,a0
 300ffc2:	00153513          	seqz	a0,a0
 300ffc6:	a811                	j	300ffda <__gedf2+0x66>
 300ffc8:	ef21                	bnez	a4,3010020 <__gedf2+0xac>
 300ffca:	00a8e533          	or	a0,a7,a0
 300ffce:	00153513          	seqz	a0,a0
 300ffd2:	00081463          	bnez	a6,300ffda <__gedf2+0x66>
 300ffd6:	8e5d                	or	a2,a2,a5
 300ffd8:	c221                	beqz	a2,3010018 <__gedf2+0xa4>
 300ffda:	e901                	bnez	a0,300ffea <__gedf2+0x76>
 300ffdc:	00d59463          	bne	a1,a3,300ffe4 <__gedf2+0x70>
 300ffe0:	00e85863          	bge	a6,a4,300fff0 <__gedf2+0x7c>
 300ffe4:	4505                	li	a0,1
 300ffe6:	e199                	bnez	a1,300ffec <__gedf2+0x78>
 300ffe8:	8082                	ret
 300ffea:	fefd                	bnez	a3,300ffe8 <__gedf2+0x74>
 300ffec:	557d                	li	a0,-1
 300ffee:	8082                	ret
 300fff0:	01075663          	bge	a4,a6,300fffc <__gedf2+0x88>
 300fff4:	557d                	li	a0,-1
 300fff6:	d9ed                	beqz	a1,300ffe8 <__gedf2+0x74>
 300fff8:	4505                	li	a0,1
 300fffa:	8082                	ret
 300fffc:	ff17e4e3          	bltu	a5,a7,300ffe4 <__gedf2+0x70>
 3010000:	00f89863          	bne	a7,a5,3010010 <__gedf2+0x9c>
 3010004:	fe6e60e3          	bltu	t3,t1,300ffe4 <__gedf2+0x70>
 3010008:	4501                	li	a0,0
 301000a:	fdc37fe3          	bgeu	t1,t3,300ffe8 <__gedf2+0x74>
 301000e:	b7dd                	j	300fff4 <__gedf2+0x80>
 3010010:	fef8e2e3          	bltu	a7,a5,300fff4 <__gedf2+0x80>
 3010014:	4501                	li	a0,0
 3010016:	8082                	ret
 3010018:	fd75                	bnez	a0,3010014 <__gedf2+0xa0>
 301001a:	b7e9                	j	300ffe4 <__gedf2+0x70>
 301001c:	f8e80ee3          	beq	a6,a4,300ffb8 <__gedf2+0x44>
 3010020:	4501                	li	a0,0
 3010022:	fa080ae3          	beqz	a6,300ffd6 <__gedf2+0x62>
 3010026:	bf5d                	j	300ffdc <__gedf2+0x68>

03010028 <__ledf2>:
 3010028:	002027f3          	frrm	a5
 301002c:	001007b7          	lui	a5,0x100
 3010030:	0145d713          	srli	a4,a1,0x14
 3010034:	17fd                	addi	a5,a5,-1 # fffff <FLASH_SIZE+0xe0003>
 3010036:	0146d813          	srli	a6,a3,0x14
 301003a:	7ff77713          	andi	a4,a4,2047
 301003e:	7ff00e93          	li	t4,2047
 3010042:	00b7f8b3          	and	a7,a5,a1
 3010046:	832a                	mv	t1,a0
 3010048:	8ff5                	and	a5,a5,a3
 301004a:	81fd                	srli	a1,a1,0x1f
 301004c:	8e32                	mv	t3,a2
 301004e:	7ff87813          	andi	a6,a6,2047
 3010052:	82fd                	srli	a3,a3,0x1f
 3010054:	01d71a63          	bne	a4,t4,3010068 <__ledf2+0x40>
 3010058:	00a8eeb3          	or	t4,a7,a0
 301005c:	060e8a63          	beqz	t4,30100d0 <__ledf2+0xa8>
 3010060:	00186073          	csrsi	fflags,16
 3010064:	4509                	li	a0,2
 3010066:	8082                	ret
 3010068:	01d81a63          	bne	a6,t4,301007c <__ledf2+0x54>
 301006c:	8e5d                	or	a2,a2,a5
 301006e:	fa6d                	bnez	a2,3010060 <__ledf2+0x38>
 3010070:	e305                	bnez	a4,3010090 <__ledf2+0x68>
 3010072:	00a8e533          	or	a0,a7,a0
 3010076:	00153513          	seqz	a0,a0
 301007a:	a811                	j	301008e <__ledf2+0x66>
 301007c:	ef21                	bnez	a4,30100d4 <__ledf2+0xac>
 301007e:	00a8e533          	or	a0,a7,a0
 3010082:	00153513          	seqz	a0,a0
 3010086:	00081463          	bnez	a6,301008e <__ledf2+0x66>
 301008a:	8e5d                	or	a2,a2,a5
 301008c:	c221                	beqz	a2,30100cc <__ledf2+0xa4>
 301008e:	e901                	bnez	a0,301009e <__ledf2+0x76>
 3010090:	00d59463          	bne	a1,a3,3010098 <__ledf2+0x70>
 3010094:	00e85863          	bge	a6,a4,30100a4 <__ledf2+0x7c>
 3010098:	4505                	li	a0,1
 301009a:	e199                	bnez	a1,30100a0 <__ledf2+0x78>
 301009c:	8082                	ret
 301009e:	fefd                	bnez	a3,301009c <__ledf2+0x74>
 30100a0:	557d                	li	a0,-1
 30100a2:	8082                	ret
 30100a4:	01075663          	bge	a4,a6,30100b0 <__ledf2+0x88>
 30100a8:	557d                	li	a0,-1
 30100aa:	d9ed                	beqz	a1,301009c <__ledf2+0x74>
 30100ac:	4505                	li	a0,1
 30100ae:	8082                	ret
 30100b0:	ff17e4e3          	bltu	a5,a7,3010098 <__ledf2+0x70>
 30100b4:	00f89863          	bne	a7,a5,30100c4 <__ledf2+0x9c>
 30100b8:	fe6e60e3          	bltu	t3,t1,3010098 <__ledf2+0x70>
 30100bc:	4501                	li	a0,0
 30100be:	fdc37fe3          	bgeu	t1,t3,301009c <__ledf2+0x74>
 30100c2:	b7dd                	j	30100a8 <__ledf2+0x80>
 30100c4:	fef8e2e3          	bltu	a7,a5,30100a8 <__ledf2+0x80>
 30100c8:	4501                	li	a0,0
 30100ca:	8082                	ret
 30100cc:	fd75                	bnez	a0,30100c8 <__ledf2+0xa0>
 30100ce:	b7e9                	j	3010098 <__ledf2+0x70>
 30100d0:	f8e80ee3          	beq	a6,a4,301006c <__ledf2+0x44>
 30100d4:	4501                	li	a0,0
 30100d6:	fa080ae3          	beqz	a6,301008a <__ledf2+0x62>
 30100da:	bf5d                	j	3010090 <__ledf2+0x68>

030100dc <__muldf3>:
 30100dc:	7179                	addi	sp,sp,-48
 30100de:	d422                	sw	s0,40(sp)
 30100e0:	ca56                	sw	s5,20(sp)
 30100e2:	c266                	sw	s9,4(sp)
 30100e4:	d606                	sw	ra,44(sp)
 30100e6:	d226                	sw	s1,36(sp)
 30100e8:	d04a                	sw	s2,32(sp)
 30100ea:	ce4e                	sw	s3,28(sp)
 30100ec:	cc52                	sw	s4,24(sp)
 30100ee:	c85a                	sw	s6,16(sp)
 30100f0:	c65e                	sw	s7,12(sp)
 30100f2:	c462                	sw	s8,8(sp)
 30100f4:	842a                	mv	s0,a0
 30100f6:	8cb2                	mv	s9,a2
 30100f8:	8ab6                	mv	s5,a3
 30100fa:	002029f3          	frrm	s3
 30100fe:	001004b7          	lui	s1,0x100
 3010102:	0145db93          	srli	s7,a1,0x14
 3010106:	14fd                	addi	s1,s1,-1 # fffff <FLASH_SIZE+0xe0003>
 3010108:	7ffbfb93          	andi	s7,s7,2047
 301010c:	8ced                	and	s1,s1,a1
 301010e:	01f5db13          	srli	s6,a1,0x1f
 3010112:	020b8463          	beqz	s7,301013a <__muldf3+0x5e>
 3010116:	7ff00793          	li	a5,2047
 301011a:	06fb8763          	beq	s7,a5,3010188 <__muldf3+0xac>
 301011e:	008007b7          	lui	a5,0x800
 3010122:	048e                	slli	s1,s1,0x3
 3010124:	8cdd                	or	s1,s1,a5
 3010126:	01d55793          	srli	a5,a0,0x1d
 301012a:	8cdd                	or	s1,s1,a5
 301012c:	00351a13          	slli	s4,a0,0x3
 3010130:	c01b8b93          	addi	s7,s7,-1023
 3010134:	4c01                	li	s8,0
 3010136:	4901                	li	s2,0
 3010138:	a0a5                	j	30101a0 <__muldf3+0xc4>
 301013a:	00a4e7b3          	or	a5,s1,a0
 301013e:	c3f9                	beqz	a5,3010204 <__muldf3+0x128>
 3010140:	c88d                	beqz	s1,3010172 <__muldf3+0x96>
 3010142:	8526                	mv	a0,s1
 3010144:	1c4010ef          	jal	ra,3011308 <__clzsi2>
 3010148:	ff550713          	addi	a4,a0,-11
 301014c:	47f1                	li	a5,28
 301014e:	02e7c763          	blt	a5,a4,301017c <__muldf3+0xa0>
 3010152:	47f5                	li	a5,29
 3010154:	ff850a13          	addi	s4,a0,-8
 3010158:	8f99                	sub	a5,a5,a4
 301015a:	014494b3          	sll	s1,s1,s4
 301015e:	00f457b3          	srl	a5,s0,a5
 3010162:	8cdd                	or	s1,s1,a5
 3010164:	01441a33          	sll	s4,s0,s4
 3010168:	c0d00b93          	li	s7,-1011
 301016c:	40ab8bb3          	sub	s7,s7,a0
 3010170:	b7d1                	j	3010134 <__muldf3+0x58>
 3010172:	196010ef          	jal	ra,3011308 <__clzsi2>
 3010176:	02050513          	addi	a0,a0,32
 301017a:	b7f9                	j	3010148 <__muldf3+0x6c>
 301017c:	fd850493          	addi	s1,a0,-40
 3010180:	009414b3          	sll	s1,s0,s1
 3010184:	4a01                	li	s4,0
 3010186:	b7cd                	j	3010168 <__muldf3+0x8c>
 3010188:	00a4e433          	or	s0,s1,a0
 301018c:	c049                	beqz	s0,301020e <__muldf3+0x132>
 301018e:	00c49793          	slli	a5,s1,0xc
 3010192:	8a2a                	mv	s4,a0
 3010194:	7ff00b93          	li	s7,2047
 3010198:	4c0d                	li	s8,3
 301019a:	4941                	li	s2,16
 301019c:	f807cde3          	bltz	a5,3010136 <__muldf3+0x5a>
 30101a0:	014ad513          	srli	a0,s5,0x14
 30101a4:	00100437          	lui	s0,0x100
 30101a8:	147d                	addi	s0,s0,-1 # fffff <FLASH_SIZE+0xe0003>
 30101aa:	7ff57513          	andi	a0,a0,2047
 30101ae:	01547433          	and	s0,s0,s5
 30101b2:	87e6                	mv	a5,s9
 30101b4:	01fada93          	srli	s5,s5,0x1f
 30101b8:	c12d                	beqz	a0,301021a <__muldf3+0x13e>
 30101ba:	7ff00713          	li	a4,2047
 30101be:	0ae50663          	beq	a0,a4,301026a <__muldf3+0x18e>
 30101c2:	008007b7          	lui	a5,0x800
 30101c6:	040e                	slli	s0,s0,0x3
 30101c8:	8c5d                	or	s0,s0,a5
 30101ca:	01dcd793          	srli	a5,s9,0x1d
 30101ce:	8c5d                	or	s0,s0,a5
 30101d0:	c0150513          	addi	a0,a0,-1023
 30101d4:	003c9793          	slli	a5,s9,0x3
 30101d8:	4701                	li	a4,0
 30101da:	002c1693          	slli	a3,s8,0x2
 30101de:	8ed9                	or	a3,a3,a4
 30101e0:	955e                	add	a0,a0,s7
 30101e2:	16fd                	addi	a3,a3,-1
 30101e4:	4639                	li	a2,14
 30101e6:	015b4833          	xor	a6,s6,s5
 30101ea:	00150893          	addi	a7,a0,1
 30101ee:	10d66563          	bltu	a2,a3,30102f8 <__muldf3+0x21c>
 30101f2:	00002617          	auipc	a2,0x2
 30101f6:	36e60613          	addi	a2,a2,878 # 3012560 <g_crgIpMatch+0xcc8>
 30101fa:	068a                	slli	a3,a3,0x2
 30101fc:	96b2                	add	a3,a3,a2
 30101fe:	4294                	lw	a3,0(a3)
 3010200:	96b2                	add	a3,a3,a2
 3010202:	8682                	jr	a3
 3010204:	4481                	li	s1,0
 3010206:	4a01                	li	s4,0
 3010208:	4b81                	li	s7,0
 301020a:	4c05                	li	s8,1
 301020c:	b72d                	j	3010136 <__muldf3+0x5a>
 301020e:	4481                	li	s1,0
 3010210:	4a01                	li	s4,0
 3010212:	7ff00b93          	li	s7,2047
 3010216:	4c09                	li	s8,2
 3010218:	bf39                	j	3010136 <__muldf3+0x5a>
 301021a:	019467b3          	or	a5,s0,s9
 301021e:	c3b5                	beqz	a5,3010282 <__muldf3+0x1a6>
 3010220:	c80d                	beqz	s0,3010252 <__muldf3+0x176>
 3010222:	8522                	mv	a0,s0
 3010224:	0e4010ef          	jal	ra,3011308 <__clzsi2>
 3010228:	ff550693          	addi	a3,a0,-11
 301022c:	47f1                	li	a5,28
 301022e:	02d7c863          	blt	a5,a3,301025e <__muldf3+0x182>
 3010232:	4775                	li	a4,29
 3010234:	ff850793          	addi	a5,a0,-8
 3010238:	8f15                	sub	a4,a4,a3
 301023a:	00f41433          	sll	s0,s0,a5
 301023e:	00ecd733          	srl	a4,s9,a4
 3010242:	8c59                	or	s0,s0,a4
 3010244:	00fc97b3          	sll	a5,s9,a5
 3010248:	c0d00713          	li	a4,-1011
 301024c:	40a70533          	sub	a0,a4,a0
 3010250:	b761                	j	30101d8 <__muldf3+0xfc>
 3010252:	8566                	mv	a0,s9
 3010254:	0b4010ef          	jal	ra,3011308 <__clzsi2>
 3010258:	02050513          	addi	a0,a0,32
 301025c:	b7f1                	j	3010228 <__muldf3+0x14c>
 301025e:	fd850413          	addi	s0,a0,-40
 3010262:	008c9433          	sll	s0,s9,s0
 3010266:	4781                	li	a5,0
 3010268:	b7c5                	j	3010248 <__muldf3+0x16c>
 301026a:	01946633          	or	a2,s0,s9
 301026e:	ce19                	beqz	a2,301028c <__muldf3+0x1b0>
 3010270:	00c41713          	slli	a4,s0,0xc
 3010274:	7ff00513          	li	a0,2047
 3010278:	02074063          	bltz	a4,3010298 <__muldf3+0x1bc>
 301027c:	470d                	li	a4,3
 301027e:	4941                	li	s2,16
 3010280:	bfa9                	j	30101da <__muldf3+0xfe>
 3010282:	4401                	li	s0,0
 3010284:	4781                	li	a5,0
 3010286:	4501                	li	a0,0
 3010288:	4705                	li	a4,1
 301028a:	bf81                	j	30101da <__muldf3+0xfe>
 301028c:	4401                	li	s0,0
 301028e:	4781                	li	a5,0
 3010290:	7ff00513          	li	a0,2047
 3010294:	4709                	li	a4,2
 3010296:	b791                	j	30101da <__muldf3+0xfe>
 3010298:	470d                	li	a4,3
 301029a:	b781                	j	30101da <__muldf3+0xfe>
 301029c:	00080437          	lui	s0,0x80
 30102a0:	4781                	li	a5,0
 30102a2:	7ff00613          	li	a2,2047
 30102a6:	4801                	li	a6,0
 30102a8:	4941                	li	s2,16
 30102aa:	00100737          	lui	a4,0x100
 30102ae:	177d                	addi	a4,a4,-1 # fffff <FLASH_SIZE+0xe0003>
 30102b0:	8c79                	and	s0,s0,a4
 30102b2:	80100737          	lui	a4,0x80100
 30102b6:	177d                	addi	a4,a4,-1 # 800fffff <RAM_END+0x7c0f7fff>
 30102b8:	7ff67693          	andi	a3,a2,2047
 30102bc:	8c79                	and	s0,s0,a4
 30102be:	06d2                	slli	a3,a3,0x14
 30102c0:	80000737          	lui	a4,0x80000
 30102c4:	fff74713          	not	a4,a4
 30102c8:	8c55                	or	s0,s0,a3
 30102ca:	087e                	slli	a6,a6,0x1f
 30102cc:	8c79                	and	s0,s0,a4
 30102ce:	01046733          	or	a4,s0,a6
 30102d2:	853e                	mv	a0,a5
 30102d4:	85ba                	mv	a1,a4
 30102d6:	00090463          	beqz	s2,30102de <__muldf3+0x202>
 30102da:	00192073          	csrs	fflags,s2
 30102de:	50b2                	lw	ra,44(sp)
 30102e0:	5422                	lw	s0,40(sp)
 30102e2:	5492                	lw	s1,36(sp)
 30102e4:	5902                	lw	s2,32(sp)
 30102e6:	49f2                	lw	s3,28(sp)
 30102e8:	4a62                	lw	s4,24(sp)
 30102ea:	4ad2                	lw	s5,20(sp)
 30102ec:	4b42                	lw	s6,16(sp)
 30102ee:	4bb2                	lw	s7,12(sp)
 30102f0:	4c22                	lw	s8,8(sp)
 30102f2:	4c92                	lw	s9,4(sp)
 30102f4:	6145                	addi	sp,sp,48
 30102f6:	8082                	ret
 30102f8:	6f41                	lui	t5,0x10
 30102fa:	ffff0e93          	addi	t4,t5,-1 # ffff <RAM_SIZE+0xafff>
 30102fe:	010a5713          	srli	a4,s4,0x10
 3010302:	0107d593          	srli	a1,a5,0x10
 3010306:	01da7a33          	and	s4,s4,t4
 301030a:	01d7f7b3          	and	a5,a5,t4
 301030e:	03458633          	mul	a2,a1,s4
 3010312:	034786b3          	mul	a3,a5,s4
 3010316:	02f70fb3          	mul	t6,a4,a5
 301031a:	01f60333          	add	t1,a2,t6
 301031e:	0106d613          	srli	a2,a3,0x10
 3010322:	961a                	add	a2,a2,t1
 3010324:	02b70e33          	mul	t3,a4,a1
 3010328:	01f67363          	bgeu	a2,t6,301032e <__muldf3+0x252>
 301032c:	9e7a                	add	t3,t3,t5
 301032e:	01065293          	srli	t0,a2,0x10
 3010332:	01d67633          	and	a2,a2,t4
 3010336:	01d6f6b3          	and	a3,a3,t4
 301033a:	01045f13          	srli	t5,s0,0x10
 301033e:	01d47eb3          	and	t4,s0,t4
 3010342:	0642                	slli	a2,a2,0x10
 3010344:	9636                	add	a2,a2,a3
 3010346:	03d70fb3          	mul	t6,a4,t4
 301034a:	03da06b3          	mul	a3,s4,t4
 301034e:	034f0a33          	mul	s4,t5,s4
 3010352:	01fa0333          	add	t1,s4,t6
 3010356:	0106da13          	srli	s4,a3,0x10
 301035a:	9a1a                	add	s4,s4,t1
 301035c:	03e70733          	mul	a4,a4,t5
 3010360:	01fa7463          	bgeu	s4,t6,3010368 <__muldf3+0x28c>
 3010364:	6341                	lui	t1,0x10
 3010366:	971a                	add	a4,a4,t1
 3010368:	010a5313          	srli	t1,s4,0x10
 301036c:	933a                	add	t1,t1,a4
 301036e:	6741                	lui	a4,0x10
 3010370:	fff70f93          	addi	t6,a4,-1 # ffff <RAM_SIZE+0xafff>
 3010374:	01fa7a33          	and	s4,s4,t6
 3010378:	01f6f6b3          	and	a3,a3,t6
 301037c:	0104d413          	srli	s0,s1,0x10
 3010380:	0a42                	slli	s4,s4,0x10
 3010382:	01f4f4b3          	and	s1,s1,t6
 3010386:	9a36                	add	s4,s4,a3
 3010388:	02978fb3          	mul	t6,a5,s1
 301038c:	92d2                	add	t0,t0,s4
 301038e:	029586b3          	mul	a3,a1,s1
 3010392:	02f407b3          	mul	a5,s0,a5
 3010396:	028583b3          	mul	t2,a1,s0
 301039a:	00f685b3          	add	a1,a3,a5
 301039e:	010fd693          	srli	a3,t6,0x10
 30103a2:	96ae                	add	a3,a3,a1
 30103a4:	00f6f363          	bgeu	a3,a5,30103aa <__muldf3+0x2ce>
 30103a8:	93ba                	add	t2,t2,a4
 30103aa:	6741                	lui	a4,0x10
 30103ac:	fff70793          	addi	a5,a4,-1 # ffff <RAM_SIZE+0xafff>
 30103b0:	00ffffb3          	and	t6,t6,a5
 30103b4:	0106d593          	srli	a1,a3,0x10
 30103b8:	8efd                	and	a3,a3,a5
 30103ba:	03d487b3          	mul	a5,s1,t4
 30103be:	06c2                	slli	a3,a3,0x10
 30103c0:	96fe                	add	a3,a3,t6
 30103c2:	959e                	add	a1,a1,t2
 30103c4:	03d40eb3          	mul	t4,s0,t4
 30103c8:	029f04b3          	mul	s1,t5,s1
 30103cc:	028f0fb3          	mul	t6,t5,s0
 30103d0:	94f6                	add	s1,s1,t4
 30103d2:	0107d413          	srli	s0,a5,0x10
 30103d6:	94a2                	add	s1,s1,s0
 30103d8:	01d4f363          	bgeu	s1,t4,30103de <__muldf3+0x302>
 30103dc:	9fba                	add	t6,t6,a4
 30103de:	6ec1                	lui	t4,0x10
 30103e0:	1efd                	addi	t4,t4,-1 # ffff <RAM_SIZE+0xafff>
 30103e2:	01d4f733          	and	a4,s1,t4
 30103e6:	01d7f7b3          	and	a5,a5,t4
 30103ea:	0742                	slli	a4,a4,0x10
 30103ec:	9e16                	add	t3,t3,t0
 30103ee:	973e                	add	a4,a4,a5
 30103f0:	014e3a33          	sltu	s4,t3,s4
 30103f4:	971a                	add	a4,a4,t1
 30103f6:	01470433          	add	s0,a4,s4
 30103fa:	9e36                	add	t3,t3,a3
 30103fc:	00de36b3          	sltu	a3,t3,a3
 3010400:	00b40eb3          	add	t4,s0,a1
 3010404:	00de8f33          	add	t5,t4,a3
 3010408:	00673733          	sltu	a4,a4,t1
 301040c:	01443433          	sltu	s0,s0,s4
 3010410:	8c59                	or	s0,s0,a4
 3010412:	00df36b3          	sltu	a3,t5,a3
 3010416:	80c1                	srli	s1,s1,0x10
 3010418:	00beb5b3          	sltu	a1,t4,a1
 301041c:	9426                	add	s0,s0,s1
 301041e:	8ecd                	or	a3,a3,a1
 3010420:	9436                	add	s0,s0,a3
 3010422:	947e                	add	s0,s0,t6
 3010424:	017f5793          	srli	a5,t5,0x17
 3010428:	0426                	slli	s0,s0,0x9
 301042a:	8c5d                	or	s0,s0,a5
 301042c:	009e1793          	slli	a5,t3,0x9
 3010430:	8fd1                	or	a5,a5,a2
 3010432:	00f037b3          	snez	a5,a5
 3010436:	017e5e13          	srli	t3,t3,0x17
 301043a:	01c7e7b3          	or	a5,a5,t3
 301043e:	0f26                	slli	t5,t5,0x9
 3010440:	00741713          	slli	a4,s0,0x7
 3010444:	01e7e7b3          	or	a5,a5,t5
 3010448:	06075e63          	bgez	a4,30104c4 <__muldf3+0x3e8>
 301044c:	0017d713          	srli	a4,a5,0x1
 3010450:	8b85                	andi	a5,a5,1
 3010452:	8fd9                	or	a5,a5,a4
 3010454:	01f41713          	slli	a4,s0,0x1f
 3010458:	8fd9                	or	a5,a5,a4
 301045a:	8005                	srli	s0,s0,0x1
 301045c:	3ff88613          	addi	a2,a7,1023
 3010460:	0cc05863          	blez	a2,3010530 <__muldf3+0x454>
 3010464:	0077f713          	andi	a4,a5,7
 3010468:	c73d                	beqz	a4,30104d6 <__muldf3+0x3fa>
 301046a:	4709                	li	a4,2
 301046c:	00196913          	ori	s2,s2,1
 3010470:	06e98163          	beq	s3,a4,30104d2 <__muldf3+0x3f6>
 3010474:	470d                	li	a4,3
 3010476:	04e98963          	beq	s3,a4,30104c8 <__muldf3+0x3ec>
 301047a:	04099e63          	bnez	s3,30104d6 <__muldf3+0x3fa>
 301047e:	00f7f713          	andi	a4,a5,15
 3010482:	4691                	li	a3,4
 3010484:	04d70963          	beq	a4,a3,30104d6 <__muldf3+0x3fa>
 3010488:	00478713          	addi	a4,a5,4 # 800004 <FLASH_SIZE+0x7e0008>
 301048c:	00f737b3          	sltu	a5,a4,a5
 3010490:	943e                	add	s0,s0,a5
 3010492:	87ba                	mv	a5,a4
 3010494:	a089                	j	30104d6 <__muldf3+0x3fa>
 3010496:	885a                	mv	a6,s6
 3010498:	8426                	mv	s0,s1
 301049a:	87d2                	mv	a5,s4
 301049c:	8762                	mv	a4,s8
 301049e:	4689                	li	a3,2
 30104a0:	00d70d63          	beq	a4,a3,30104ba <__muldf3+0x3de>
 30104a4:	468d                	li	a3,3
 30104a6:	1cd70f63          	beq	a4,a3,3010684 <__muldf3+0x5a8>
 30104aa:	4685                	li	a3,1
 30104ac:	fad718e3          	bne	a4,a3,301045c <__muldf3+0x380>
 30104b0:	4401                	li	s0,0
 30104b2:	4781                	li	a5,0
 30104b4:	aa6d                	j	301066e <__muldf3+0x592>
 30104b6:	8856                	mv	a6,s5
 30104b8:	b7dd                	j	301049e <__muldf3+0x3c2>
 30104ba:	4401                	li	s0,0
 30104bc:	4781                	li	a5,0
 30104be:	7ff00613          	li	a2,2047
 30104c2:	b3e5                	j	30102aa <__muldf3+0x1ce>
 30104c4:	88aa                	mv	a7,a0
 30104c6:	bf59                	j	301045c <__muldf3+0x380>
 30104c8:	00081763          	bnez	a6,30104d6 <__muldf3+0x3fa>
 30104cc:	00878713          	addi	a4,a5,8
 30104d0:	bf75                	j	301048c <__muldf3+0x3b0>
 30104d2:	fe081de3          	bnez	a6,30104cc <__muldf3+0x3f0>
 30104d6:	00741713          	slli	a4,s0,0x7
 30104da:	00075863          	bgez	a4,30104ea <__muldf3+0x40e>
 30104de:	ff000737          	lui	a4,0xff000
 30104e2:	177d                	addi	a4,a4,-1 # feffffff <RAM_END+0xfaff7fff>
 30104e4:	8c79                	and	s0,s0,a4
 30104e6:	40088613          	addi	a2,a7,1024
 30104ea:	7fe00713          	li	a4,2046
 30104ee:	00c74963          	blt	a4,a2,3010500 <__muldf3+0x424>
 30104f2:	0037d713          	srli	a4,a5,0x3
 30104f6:	01d41793          	slli	a5,s0,0x1d
 30104fa:	8fd9                	or	a5,a5,a4
 30104fc:	800d                	srli	s0,s0,0x3
 30104fe:	b375                	j	30102aa <__muldf3+0x1ce>
 3010500:	4789                	li	a5,2
 3010502:	02f98463          	beq	s3,a5,301052a <__muldf3+0x44e>
 3010506:	478d                	li	a5,3
 3010508:	00f98b63          	beq	s3,a5,301051e <__muldf3+0x442>
 301050c:	00098b63          	beqz	s3,3010522 <__muldf3+0x446>
 3010510:	57fd                	li	a5,-1
 3010512:	7fe00613          	li	a2,2046
 3010516:	00596913          	ori	s2,s2,5
 301051a:	843e                	mv	s0,a5
 301051c:	b379                	j	30102aa <__muldf3+0x1ce>
 301051e:	fe0819e3          	bnez	a6,3010510 <__muldf3+0x434>
 3010522:	4781                	li	a5,0
 3010524:	7ff00613          	li	a2,2047
 3010528:	b7fd                	j	3010516 <__muldf3+0x43a>
 301052a:	fe081ce3          	bnez	a6,3010522 <__muldf3+0x446>
 301052e:	b7cd                	j	3010510 <__muldf3+0x434>
 3010530:	4585                	li	a1,1
 3010532:	ea29                	bnez	a2,3010584 <__muldf3+0x4a8>
 3010534:	0077f693          	andi	a3,a5,7
 3010538:	8722                	mv	a4,s0
 301053a:	c2a1                	beqz	a3,301057a <__muldf3+0x49e>
 301053c:	4709                	li	a4,2
 301053e:	00196913          	ori	s2,s2,1
 3010542:	02e98963          	beq	s3,a4,3010574 <__muldf3+0x498>
 3010546:	470d                	li	a4,3
 3010548:	02e98063          	beq	s3,a4,3010568 <__muldf3+0x48c>
 301054c:	8722                	mv	a4,s0
 301054e:	02099663          	bnez	s3,301057a <__muldf3+0x49e>
 3010552:	00f7f693          	andi	a3,a5,15
 3010556:	4591                	li	a1,4
 3010558:	02b68163          	beq	a3,a1,301057a <__muldf3+0x49e>
 301055c:	ffc7b713          	sltiu	a4,a5,-4
 3010560:	00174713          	xori	a4,a4,1
 3010564:	9722                	add	a4,a4,s0
 3010566:	a811                	j	301057a <__muldf3+0x49e>
 3010568:	8722                	mv	a4,s0
 301056a:	00081863          	bnez	a6,301057a <__muldf3+0x49e>
 301056e:	ff87b713          	sltiu	a4,a5,-8
 3010572:	b7fd                	j	3010560 <__muldf3+0x484>
 3010574:	8722                	mv	a4,s0
 3010576:	fe081ce3          	bnez	a6,301056e <__muldf3+0x492>
 301057a:	01875593          	srli	a1,a4,0x18
 301057e:	0015c593          	xori	a1,a1,1
 3010582:	8985                	andi	a1,a1,1
 3010584:	4705                	li	a4,1
 3010586:	8f11                	sub	a4,a4,a2
 3010588:	03800693          	li	a3,56
 301058c:	0ce6c063          	blt	a3,a4,301064c <__muldf3+0x570>
 3010590:	46fd                	li	a3,31
 3010592:	04e6c963          	blt	a3,a4,30105e4 <__muldf3+0x508>
 3010596:	41e88893          	addi	a7,a7,1054
 301059a:	011416b3          	sll	a3,s0,a7
 301059e:	00e7d633          	srl	a2,a5,a4
 30105a2:	011797b3          	sll	a5,a5,a7
 30105a6:	8ed1                	or	a3,a3,a2
 30105a8:	00f037b3          	snez	a5,a5
 30105ac:	8fd5                	or	a5,a5,a3
 30105ae:	00e45433          	srl	s0,s0,a4
 30105b2:	0077f713          	andi	a4,a5,7
 30105b6:	c32d                	beqz	a4,3010618 <__muldf3+0x53c>
 30105b8:	4709                	li	a4,2
 30105ba:	00196913          	ori	s2,s2,1
 30105be:	04e98b63          	beq	s3,a4,3010614 <__muldf3+0x538>
 30105c2:	470d                	li	a4,3
 30105c4:	04e98363          	beq	s3,a4,301060a <__muldf3+0x52e>
 30105c8:	04099863          	bnez	s3,3010618 <__muldf3+0x53c>
 30105cc:	00f7f713          	andi	a4,a5,15
 30105d0:	4691                	li	a3,4
 30105d2:	04d70363          	beq	a4,a3,3010618 <__muldf3+0x53c>
 30105d6:	00478713          	addi	a4,a5,4
 30105da:	00f737b3          	sltu	a5,a4,a5
 30105de:	943e                	add	s0,s0,a5
 30105e0:	87ba                	mv	a5,a4
 30105e2:	a81d                	j	3010618 <__muldf3+0x53c>
 30105e4:	5685                	li	a3,-31
 30105e6:	8e91                	sub	a3,a3,a2
 30105e8:	02000513          	li	a0,32
 30105ec:	00d456b3          	srl	a3,s0,a3
 30105f0:	4601                	li	a2,0
 30105f2:	00a70663          	beq	a4,a0,30105fe <__muldf3+0x522>
 30105f6:	43e88893          	addi	a7,a7,1086
 30105fa:	01141633          	sll	a2,s0,a7
 30105fe:	8fd1                	or	a5,a5,a2
 3010600:	00f037b3          	snez	a5,a5
 3010604:	8fd5                	or	a5,a5,a3
 3010606:	4401                	li	s0,0
 3010608:	b76d                	j	30105b2 <__muldf3+0x4d6>
 301060a:	00081763          	bnez	a6,3010618 <__muldf3+0x53c>
 301060e:	00878713          	addi	a4,a5,8
 3010612:	b7e1                	j	30105da <__muldf3+0x4fe>
 3010614:	fe081de3          	bnez	a6,301060e <__muldf3+0x532>
 3010618:	00841713          	slli	a4,s0,0x8
 301061c:	02075063          	bgez	a4,301063c <__muldf3+0x560>
 3010620:	00196913          	ori	s2,s2,1
 3010624:	4401                	li	s0,0
 3010626:	4781                	li	a5,0
 3010628:	4605                	li	a2,1
 301062a:	c80580e3          	beqz	a1,30102aa <__muldf3+0x1ce>
 301062e:	00197713          	andi	a4,s2,1
 3010632:	c6070ce3          	beqz	a4,30102aa <__muldf3+0x1ce>
 3010636:	00296913          	ori	s2,s2,2
 301063a:	b985                	j	30102aa <__muldf3+0x1ce>
 301063c:	0037d713          	srli	a4,a5,0x3
 3010640:	01d41793          	slli	a5,s0,0x1d
 3010644:	8fd9                	or	a5,a5,a4
 3010646:	800d                	srli	s0,s0,0x3
 3010648:	4601                	li	a2,0
 301064a:	b7c5                	j	301062a <__muldf3+0x54e>
 301064c:	8fc1                	or	a5,a5,s0
 301064e:	cf89                	beqz	a5,3010668 <__muldf3+0x58c>
 3010650:	4789                	li	a5,2
 3010652:	00196913          	ori	s2,s2,1
 3010656:	02f98363          	beq	s3,a5,301067c <__muldf3+0x5a0>
 301065a:	478d                	li	a5,3
 301065c:	00f98b63          	beq	s3,a5,3010672 <__muldf3+0x596>
 3010660:	4795                	li	a5,5
 3010662:	00099b63          	bnez	s3,3010678 <__muldf3+0x59c>
 3010666:	838d                	srli	a5,a5,0x3
 3010668:	00296913          	ori	s2,s2,2
 301066c:	4401                	li	s0,0
 301066e:	4601                	li	a2,0
 3010670:	b92d                	j	30102aa <__muldf3+0x1ce>
 3010672:	47a5                	li	a5,9
 3010674:	fe0809e3          	beqz	a6,3010666 <__muldf3+0x58a>
 3010678:	4785                	li	a5,1
 301067a:	b7f5                	j	3010666 <__muldf3+0x58a>
 301067c:	47a5                	li	a5,9
 301067e:	fe0814e3          	bnez	a6,3010666 <__muldf3+0x58a>
 3010682:	bfdd                	j	3010678 <__muldf3+0x59c>
 3010684:	00080437          	lui	s0,0x80
 3010688:	4781                	li	a5,0
 301068a:	7ff00613          	li	a2,2047
 301068e:	4801                	li	a6,0
 3010690:	b929                	j	30102aa <__muldf3+0x1ce>

03010692 <__subdf3>:
 3010692:	1101                	addi	sp,sp,-32
 3010694:	ce06                	sw	ra,28(sp)
 3010696:	cc22                	sw	s0,24(sp)
 3010698:	ca26                	sw	s1,20(sp)
 301069a:	c84a                	sw	s2,16(sp)
 301069c:	c64e                	sw	s3,12(sp)
 301069e:	c452                	sw	s4,8(sp)
 30106a0:	00202973          	frrm	s2
 30106a4:	001008b7          	lui	a7,0x100
 30106a8:	18fd                	addi	a7,a7,-1 # fffff <FLASH_SIZE+0xe0003>
 30106aa:	00b8f7b3          	and	a5,a7,a1
 30106ae:	0145d993          	srli	s3,a1,0x14
 30106b2:	01f5d493          	srli	s1,a1,0x1f
 30106b6:	00379593          	slli	a1,a5,0x3
 30106ba:	01d55793          	srli	a5,a0,0x1d
 30106be:	00d8f8b3          	and	a7,a7,a3
 30106c2:	8fcd                	or	a5,a5,a1
 30106c4:	0146d593          	srli	a1,a3,0x14
 30106c8:	01d65713          	srli	a4,a2,0x1d
 30106cc:	088e                	slli	a7,a7,0x3
 30106ce:	00361813          	slli	a6,a2,0x3
 30106d2:	7ff5f593          	andi	a1,a1,2047
 30106d6:	7ff00613          	li	a2,2047
 30106da:	7ff9f993          	andi	s3,s3,2047
 30106de:	050e                	slli	a0,a0,0x3
 30106e0:	82fd                	srli	a3,a3,0x1f
 30106e2:	01176733          	or	a4,a4,a7
 30106e6:	00c59563          	bne	a1,a2,30106f0 <__subdf3+0x5e>
 30106ea:	01076633          	or	a2,a4,a6
 30106ee:	e219                	bnez	a2,30106f4 <__subdf3+0x62>
 30106f0:	0016c693          	xori	a3,a3,1
 30106f4:	40b988b3          	sub	a7,s3,a1
 30106f8:	3a969163          	bne	a3,s1,3010a9a <__subdf3+0x408>
 30106fc:	11105363          	blez	a7,3010802 <__subdf3+0x170>
 3010700:	edbd                	bnez	a1,301077e <__subdf3+0xec>
 3010702:	010766b3          	or	a3,a4,a6
 3010706:	e699                	bnez	a3,3010714 <__subdf3+0x82>
 3010708:	7ff00713          	li	a4,2047
 301070c:	85c6                	mv	a1,a7
 301070e:	04e89563          	bne	a7,a4,3010758 <__subdf3+0xc6>
 3010712:	a889                	j	3010764 <__subdf3+0xd2>
 3010714:	fff88693          	addi	a3,a7,-1
 3010718:	e2b1                	bnez	a3,301075c <__subdf3+0xca>
 301071a:	982a                	add	a6,a6,a0
 301071c:	97ba                	add	a5,a5,a4
 301071e:	00a83533          	sltu	a0,a6,a0
 3010722:	00a78733          	add	a4,a5,a0
 3010726:	4585                	li	a1,1
 3010728:	00871793          	slli	a5,a4,0x8
 301072c:	0e07d663          	bgez	a5,3010818 <__subdf3+0x186>
 3010730:	0585                	addi	a1,a1,1 # 10001 <RAM_SIZE+0xb001>
 3010732:	7ff00793          	li	a5,2047
 3010736:	32f58e63          	beq	a1,a5,3010a72 <__subdf3+0x3e0>
 301073a:	ff8007b7          	lui	a5,0xff800
 301073e:	17fd                	addi	a5,a5,-1 # ff7fffff <RAM_END+0xfb7f7fff>
 3010740:	00185513          	srli	a0,a6,0x1
 3010744:	8ff9                	and	a5,a5,a4
 3010746:	00187813          	andi	a6,a6,1
 301074a:	01056833          	or	a6,a0,a6
 301074e:	01f79513          	slli	a0,a5,0x1f
 3010752:	01056533          	or	a0,a0,a6
 3010756:	8385                	srli	a5,a5,0x1
 3010758:	4881                	li	a7,0
 301075a:	a4d1                	j	3010a1e <__subdf3+0x38c>
 301075c:	7ff00613          	li	a2,2047
 3010760:	02c89763          	bne	a7,a2,301078e <__subdf3+0xfc>
 3010764:	00a7e733          	or	a4,a5,a0
 3010768:	6e070c63          	beqz	a4,3010e60 <__subdf3+0x7ce>
 301076c:	00979713          	slli	a4,a5,0x9
 3010770:	7ff00593          	li	a1,2047
 3010774:	4881                	li	a7,0
 3010776:	2a074463          	bltz	a4,3010a1e <__subdf3+0x38c>
 301077a:	4341                	li	t1,16
 301077c:	aa71                	j	3010918 <__subdf3+0x286>
 301077e:	7ff00693          	li	a3,2047
 3010782:	fed981e3          	beq	s3,a3,3010764 <__subdf3+0xd2>
 3010786:	008006b7          	lui	a3,0x800
 301078a:	8f55                	or	a4,a4,a3
 301078c:	86c6                	mv	a3,a7
 301078e:	03800613          	li	a2,56
 3010792:	06d64363          	blt	a2,a3,30107f8 <__subdf3+0x166>
 3010796:	467d                	li	a2,31
 3010798:	02d64b63          	blt	a2,a3,30107ce <__subdf3+0x13c>
 301079c:	02000593          	li	a1,32
 30107a0:	8d95                	sub	a1,a1,a3
 30107a2:	00d858b3          	srl	a7,a6,a3
 30107a6:	00b71633          	sll	a2,a4,a1
 30107aa:	00b81833          	sll	a6,a6,a1
 30107ae:	01166633          	or	a2,a2,a7
 30107b2:	01003833          	snez	a6,a6
 30107b6:	01066833          	or	a6,a2,a6
 30107ba:	00d756b3          	srl	a3,a4,a3
 30107be:	982a                	add	a6,a6,a0
 30107c0:	96be                	add	a3,a3,a5
 30107c2:	00a837b3          	sltu	a5,a6,a0
 30107c6:	00f68733          	add	a4,a3,a5
 30107ca:	85ce                	mv	a1,s3
 30107cc:	bfb1                	j	3010728 <__subdf3+0x96>
 30107ce:	02000893          	li	a7,32
 30107d2:	00d75633          	srl	a2,a4,a3
 30107d6:	4581                	li	a1,0
 30107d8:	01168863          	beq	a3,a7,30107e8 <__subdf3+0x156>
 30107dc:	04000593          	li	a1,64
 30107e0:	40d586b3          	sub	a3,a1,a3
 30107e4:	00d715b3          	sll	a1,a4,a3
 30107e8:	0105e833          	or	a6,a1,a6
 30107ec:	01003833          	snez	a6,a6
 30107f0:	01066833          	or	a6,a2,a6
 30107f4:	4681                	li	a3,0
 30107f6:	b7e1                	j	30107be <__subdf3+0x12c>
 30107f8:	01076833          	or	a6,a4,a6
 30107fc:	01003833          	snez	a6,a6
 3010800:	bfd5                	j	30107f4 <__subdf3+0x162>
 3010802:	0c088a63          	beqz	a7,30108d6 <__subdf3+0x244>
 3010806:	04099863          	bnez	s3,3010856 <__subdf3+0x1c4>
 301080a:	00a7e6b3          	or	a3,a5,a0
 301080e:	ea81                	bnez	a3,301081e <__subdf3+0x18c>
 3010810:	7ff00793          	li	a5,2047
 3010814:	02f58663          	beq	a1,a5,3010840 <__subdf3+0x1ae>
 3010818:	ed85                	bnez	a1,3010850 <__subdf3+0x1be>
 301081a:	8542                	mv	a0,a6
 301081c:	a991                	j	3010c70 <__subdf3+0x5de>
 301081e:	56fd                	li	a3,-1
 3010820:	00d89a63          	bne	a7,a3,3010834 <__subdf3+0x1a2>
 3010824:	010506b3          	add	a3,a0,a6
 3010828:	97ba                	add	a5,a5,a4
 301082a:	0106b733          	sltu	a4,a3,a6
 301082e:	973e                	add	a4,a4,a5
 3010830:	8836                	mv	a6,a3
 3010832:	bddd                	j	3010728 <__subdf3+0x96>
 3010834:	7ff00693          	li	a3,2047
 3010838:	fff8c893          	not	a7,a7
 301083c:	02d59663          	bne	a1,a3,3010868 <__subdf3+0x1d6>
 3010840:	01076533          	or	a0,a4,a6
 3010844:	62050463          	beqz	a0,3010e6c <__subdf3+0x7da>
 3010848:	00971793          	slli	a5,a4,0x9
 301084c:	6007d363          	bgez	a5,3010e52 <__subdf3+0x7c0>
 3010850:	87ba                	mv	a5,a4
 3010852:	8542                	mv	a0,a6
 3010854:	b711                	j	3010758 <__subdf3+0xc6>
 3010856:	7ff00693          	li	a3,2047
 301085a:	fed583e3          	beq	a1,a3,3010840 <__subdf3+0x1ae>
 301085e:	008006b7          	lui	a3,0x800
 3010862:	411008b3          	neg	a7,a7
 3010866:	8fd5                	or	a5,a5,a3
 3010868:	03800693          	li	a3,56
 301086c:	0716c163          	blt	a3,a7,30108ce <__subdf3+0x23c>
 3010870:	46fd                	li	a3,31
 3010872:	0316cb63          	blt	a3,a7,30108a8 <__subdf3+0x216>
 3010876:	02000613          	li	a2,32
 301087a:	41160633          	sub	a2,a2,a7
 301087e:	01155333          	srl	t1,a0,a7
 3010882:	00c796b3          	sll	a3,a5,a2
 3010886:	00c51533          	sll	a0,a0,a2
 301088a:	0066e6b3          	or	a3,a3,t1
 301088e:	00a03533          	snez	a0,a0
 3010892:	8d55                	or	a0,a0,a3
 3010894:	0117d8b3          	srl	a7,a5,a7
 3010898:	9542                	add	a0,a0,a6
 301089a:	00e887b3          	add	a5,a7,a4
 301089e:	01053733          	sltu	a4,a0,a6
 30108a2:	973e                	add	a4,a4,a5
 30108a4:	882a                	mv	a6,a0
 30108a6:	b549                	j	3010728 <__subdf3+0x96>
 30108a8:	02000313          	li	t1,32
 30108ac:	0117d6b3          	srl	a3,a5,a7
 30108b0:	4601                	li	a2,0
 30108b2:	00688863          	beq	a7,t1,30108c2 <__subdf3+0x230>
 30108b6:	04000613          	li	a2,64
 30108ba:	411608b3          	sub	a7,a2,a7
 30108be:	01179633          	sll	a2,a5,a7
 30108c2:	8d51                	or	a0,a0,a2
 30108c4:	00a03533          	snez	a0,a0
 30108c8:	8d55                	or	a0,a0,a3
 30108ca:	4881                	li	a7,0
 30108cc:	b7f1                	j	3010898 <__subdf3+0x206>
 30108ce:	8d5d                	or	a0,a0,a5
 30108d0:	00a03533          	snez	a0,a0
 30108d4:	bfdd                	j	30108ca <__subdf3+0x238>
 30108d6:	00198693          	addi	a3,s3,1
 30108da:	7ff6f313          	andi	t1,a3,2047
 30108de:	4605                	li	a2,1
 30108e0:	10664e63          	blt	a2,t1,30109fc <__subdf3+0x36a>
 30108e4:	00a7e6b3          	or	a3,a5,a0
 30108e8:	04099463          	bnez	s3,3010930 <__subdf3+0x29e>
 30108ec:	d69d                	beqz	a3,301081a <__subdf3+0x188>
 30108ee:	010766b3          	or	a3,a4,a6
 30108f2:	52068e63          	beqz	a3,3010e2e <__subdf3+0x79c>
 30108f6:	982a                	add	a6,a6,a0
 30108f8:	97ba                	add	a5,a5,a4
 30108fa:	00a83533          	sltu	a0,a6,a0
 30108fe:	00a78733          	add	a4,a5,a0
 3010902:	00871793          	slli	a5,a4,0x8
 3010906:	f007dae3          	bgez	a5,301081a <__subdf3+0x188>
 301090a:	ff8007b7          	lui	a5,0xff800
 301090e:	17fd                	addi	a5,a5,-1 # ff7fffff <RAM_END+0xfb7f7fff>
 3010910:	8ff9                	and	a5,a5,a4
 3010912:	8542                	mv	a0,a6
 3010914:	4301                	li	t1,0
 3010916:	4585                	li	a1,1
 3010918:	00757713          	andi	a4,a0,7
 301091c:	10071e63          	bnez	a4,3010a38 <__subdf3+0x3a6>
 3010920:	04088b63          	beqz	a7,3010976 <__subdf3+0x2e4>
 3010924:	00137713          	andi	a4,t1,1
 3010928:	c739                	beqz	a4,3010976 <__subdf3+0x2e4>
 301092a:	00236313          	ori	t1,t1,2
 301092e:	a0a1                	j	3010976 <__subdf3+0x2e4>
 3010930:	7ff00613          	li	a2,2047
 3010934:	0ac99f63          	bne	s3,a2,30109f2 <__subdf3+0x360>
 3010938:	58068d63          	beqz	a3,3010ed2 <__subdf3+0x840>
 301093c:	00400337          	lui	t1,0x400
 3010940:	0067f333          	and	t1,a5,t1
 3010944:	00133313          	seqz	t1,t1
 3010948:	0312                	slli	t1,t1,0x4
 301094a:	01359c63          	bne	a1,s3,3010962 <__subdf3+0x2d0>
 301094e:	01076633          	or	a2,a4,a6
 3010952:	c611                	beqz	a2,301095e <__subdf3+0x2cc>
 3010954:	00971613          	slli	a2,a4,0x9
 3010958:	00064363          	bltz	a2,301095e <__subdf3+0x2cc>
 301095c:	4341                	li	t1,16
 301095e:	4e068e63          	beqz	a3,3010e5a <__subdf3+0x7c8>
 3010962:	01076733          	or	a4,a4,a6
 3010966:	3c070c63          	beqz	a4,3010d3e <__subdf3+0x6ac>
 301096a:	004007b7          	lui	a5,0x400
 301096e:	4501                	li	a0,0
 3010970:	7ff00593          	li	a1,2047
 3010974:	4481                	li	s1,0
 3010976:	00879713          	slli	a4,a5,0x8
 301097a:	00075b63          	bgez	a4,3010990 <__subdf3+0x2fe>
 301097e:	0585                	addi	a1,a1,1
 3010980:	7ff00713          	li	a4,2047
 3010984:	52e58063          	beq	a1,a4,3010ea4 <__subdf3+0x812>
 3010988:	ff800737          	lui	a4,0xff800
 301098c:	177d                	addi	a4,a4,-1 # ff7fffff <RAM_END+0xfb7f7fff>
 301098e:	8ff9                	and	a5,a5,a4
 3010990:	01d79713          	slli	a4,a5,0x1d
 3010994:	810d                	srli	a0,a0,0x3
 3010996:	8d59                	or	a0,a0,a4
 3010998:	7ff00713          	li	a4,2047
 301099c:	838d                	srli	a5,a5,0x3
 301099e:	00e59963          	bne	a1,a4,30109b0 <__subdf3+0x31e>
 30109a2:	8d5d                	or	a0,a0,a5
 30109a4:	4781                	li	a5,0
 30109a6:	c509                	beqz	a0,30109b0 <__subdf3+0x31e>
 30109a8:	000807b7          	lui	a5,0x80
 30109ac:	4501                	li	a0,0
 30109ae:	4481                	li	s1,0
 30109b0:	00100737          	lui	a4,0x100
 30109b4:	177d                	addi	a4,a4,-1 # fffff <FLASH_SIZE+0xe0003>
 30109b6:	8ff9                	and	a5,a5,a4
 30109b8:	80100737          	lui	a4,0x80100
 30109bc:	177d                	addi	a4,a4,-1 # 800fffff <RAM_END+0x7c0f7fff>
 30109be:	7ff5f593          	andi	a1,a1,2047
 30109c2:	05d2                	slli	a1,a1,0x14
 30109c4:	8ff9                	and	a5,a5,a4
 30109c6:	80000737          	lui	a4,0x80000
 30109ca:	8fcd                	or	a5,a5,a1
 30109cc:	fff74713          	not	a4,a4
 30109d0:	04fe                	slli	s1,s1,0x1f
 30109d2:	8ff9                	and	a5,a5,a4
 30109d4:	0097e733          	or	a4,a5,s1
 30109d8:	85ba                	mv	a1,a4
 30109da:	00030463          	beqz	t1,30109e2 <__subdf3+0x350>
 30109de:	00132073          	csrs	fflags,t1
 30109e2:	40f2                	lw	ra,28(sp)
 30109e4:	4462                	lw	s0,24(sp)
 30109e6:	44d2                	lw	s1,20(sp)
 30109e8:	4942                	lw	s2,16(sp)
 30109ea:	49b2                	lw	s3,12(sp)
 30109ec:	4a22                	lw	s4,8(sp)
 30109ee:	6105                	addi	sp,sp,32
 30109f0:	8082                	ret
 30109f2:	4301                	li	t1,0
 30109f4:	f6c595e3          	bne	a1,a2,301095e <__subdf3+0x2cc>
 30109f8:	4301                	li	t1,0
 30109fa:	bf91                	j	301094e <__subdf3+0x2bc>
 30109fc:	7ff00613          	li	a2,2047
 3010a00:	02c68163          	beq	a3,a2,3010a22 <__subdf3+0x390>
 3010a04:	982a                	add	a6,a6,a0
 3010a06:	00a83533          	sltu	a0,a6,a0
 3010a0a:	97ba                	add	a5,a5,a4
 3010a0c:	97aa                	add	a5,a5,a0
 3010a0e:	01f79513          	slli	a0,a5,0x1f
 3010a12:	00185813          	srli	a6,a6,0x1
 3010a16:	01056533          	or	a0,a0,a6
 3010a1a:	8385                	srli	a5,a5,0x1
 3010a1c:	85b6                	mv	a1,a3
 3010a1e:	4301                	li	t1,0
 3010a20:	bde5                	j	3010918 <__subdf3+0x286>
 3010a22:	04090563          	beqz	s2,3010a6c <__subdf3+0x3da>
 3010a26:	478d                	li	a5,3
 3010a28:	02f91e63          	bne	s2,a5,3010a64 <__subdf3+0x3d2>
 3010a2c:	c0a1                	beqz	s1,3010a6c <__subdf3+0x3da>
 3010a2e:	57fd                	li	a5,-1
 3010a30:	557d                	li	a0,-1
 3010a32:	7fe00593          	li	a1,2046
 3010a36:	4315                	li	t1,5
 3010a38:	4709                	li	a4,2
 3010a3a:	00136313          	ori	t1,t1,1
 3010a3e:	46e90063          	beq	s2,a4,3010e9e <__subdf3+0x80c>
 3010a42:	470d                	li	a4,3
 3010a44:	44e90863          	beq	s2,a4,3010e94 <__subdf3+0x802>
 3010a48:	ec091ce3          	bnez	s2,3010920 <__subdf3+0x28e>
 3010a4c:	00f57713          	andi	a4,a0,15
 3010a50:	4691                	li	a3,4
 3010a52:	ecd707e3          	beq	a4,a3,3010920 <__subdf3+0x28e>
 3010a56:	00450713          	addi	a4,a0,4
 3010a5a:	00a73533          	sltu	a0,a4,a0
 3010a5e:	97aa                	add	a5,a5,a0
 3010a60:	853a                	mv	a0,a4
 3010a62:	bd7d                	j	3010920 <__subdf3+0x28e>
 3010a64:	4789                	li	a5,2
 3010a66:	fcf914e3          	bne	s2,a5,3010a2e <__subdf3+0x39c>
 3010a6a:	d0f1                	beqz	s1,3010a2e <__subdf3+0x39c>
 3010a6c:	7ff00593          	li	a1,2047
 3010a70:	a00d                	j	3010a92 <__subdf3+0x400>
 3010a72:	02090063          	beqz	s2,3010a92 <__subdf3+0x400>
 3010a76:	478d                	li	a5,3
 3010a78:	00f91963          	bne	s2,a5,3010a8a <__subdf3+0x3f8>
 3010a7c:	c899                	beqz	s1,3010a92 <__subdf3+0x400>
 3010a7e:	57fd                	li	a5,-1
 3010a80:	557d                	li	a0,-1
 3010a82:	7fe00593          	li	a1,2046
 3010a86:	4881                	li	a7,0
 3010a88:	b77d                	j	3010a36 <__subdf3+0x3a4>
 3010a8a:	4789                	li	a5,2
 3010a8c:	fef919e3          	bne	s2,a5,3010a7e <__subdf3+0x3ec>
 3010a90:	d4fd                	beqz	s1,3010a7e <__subdf3+0x3ec>
 3010a92:	4781                	li	a5,0
 3010a94:	4501                	li	a0,0
 3010a96:	4315                	li	t1,5
 3010a98:	bdf9                	j	3010976 <__subdf3+0x2e4>
 3010a9a:	0d105663          	blez	a7,3010b66 <__subdf3+0x4d4>
 3010a9e:	e1c9                	bnez	a1,3010b20 <__subdf3+0x48e>
 3010aa0:	010766b3          	or	a3,a4,a6
 3010aa4:	c60682e3          	beqz	a3,3010708 <__subdf3+0x76>
 3010aa8:	fff88693          	addi	a3,a7,-1
 3010aac:	e685                	bnez	a3,3010ad4 <__subdf3+0x442>
 3010aae:	41050833          	sub	a6,a0,a6
 3010ab2:	8f99                	sub	a5,a5,a4
 3010ab4:	01053533          	sltu	a0,a0,a6
 3010ab8:	40a78733          	sub	a4,a5,a0
 3010abc:	4585                	li	a1,1
 3010abe:	00871793          	slli	a5,a4,0x8
 3010ac2:	d407dbe3          	bgez	a5,3010818 <__subdf3+0x186>
 3010ac6:	00800437          	lui	s0,0x800
 3010aca:	147d                	addi	s0,s0,-1 # 7fffff <FLASH_SIZE+0x7e0003>
 3010acc:	8c79                	and	s0,s0,a4
 3010ace:	8a42                	mv	s4,a6
 3010ad0:	89ae                	mv	s3,a1
 3010ad2:	a465                	j	3010d7a <__subdf3+0x6e8>
 3010ad4:	7ff00613          	li	a2,2047
 3010ad8:	c8c886e3          	beq	a7,a2,3010764 <__subdf3+0xd2>
 3010adc:	03800613          	li	a2,56
 3010ae0:	06d64e63          	blt	a2,a3,3010b5c <__subdf3+0x4ca>
 3010ae4:	467d                	li	a2,31
 3010ae6:	04d64663          	blt	a2,a3,3010b32 <__subdf3+0x4a0>
 3010aea:	02000593          	li	a1,32
 3010aee:	8d95                	sub	a1,a1,a3
 3010af0:	00d858b3          	srl	a7,a6,a3
 3010af4:	00b71633          	sll	a2,a4,a1
 3010af8:	00b81833          	sll	a6,a6,a1
 3010afc:	01166633          	or	a2,a2,a7
 3010b00:	01003833          	snez	a6,a6
 3010b04:	01066833          	or	a6,a2,a6
 3010b08:	00d756b3          	srl	a3,a4,a3
 3010b0c:	41050833          	sub	a6,a0,a6
 3010b10:	40d786b3          	sub	a3,a5,a3
 3010b14:	010537b3          	sltu	a5,a0,a6
 3010b18:	40f68733          	sub	a4,a3,a5
 3010b1c:	85ce                	mv	a1,s3
 3010b1e:	b745                	j	3010abe <__subdf3+0x42c>
 3010b20:	7ff00693          	li	a3,2047
 3010b24:	c4d980e3          	beq	s3,a3,3010764 <__subdf3+0xd2>
 3010b28:	008006b7          	lui	a3,0x800
 3010b2c:	8f55                	or	a4,a4,a3
 3010b2e:	86c6                	mv	a3,a7
 3010b30:	b775                	j	3010adc <__subdf3+0x44a>
 3010b32:	02000893          	li	a7,32
 3010b36:	00d75633          	srl	a2,a4,a3
 3010b3a:	4581                	li	a1,0
 3010b3c:	01168863          	beq	a3,a7,3010b4c <__subdf3+0x4ba>
 3010b40:	04000593          	li	a1,64
 3010b44:	40d586b3          	sub	a3,a1,a3
 3010b48:	00d715b3          	sll	a1,a4,a3
 3010b4c:	0105e833          	or	a6,a1,a6
 3010b50:	01003833          	snez	a6,a6
 3010b54:	01066833          	or	a6,a2,a6
 3010b58:	4681                	li	a3,0
 3010b5a:	bf4d                	j	3010b0c <__subdf3+0x47a>
 3010b5c:	01076833          	or	a6,a4,a6
 3010b60:	01003833          	snez	a6,a6
 3010b64:	bfd5                	j	3010b58 <__subdf3+0x4c6>
 3010b66:	0c088e63          	beqz	a7,3010c42 <__subdf3+0x5b0>
 3010b6a:	04099963          	bnez	s3,3010bbc <__subdf3+0x52a>
 3010b6e:	00a7e633          	or	a2,a5,a0
 3010b72:	e609                	bnez	a2,3010b7c <__subdf3+0x4ea>
 3010b74:	7ff00793          	li	a5,2047
 3010b78:	84b6                	mv	s1,a3
 3010b7a:	b969                	j	3010814 <__subdf3+0x182>
 3010b7c:	567d                	li	a2,-1
 3010b7e:	00c89d63          	bne	a7,a2,3010b98 <__subdf3+0x506>
 3010b82:	40a808b3          	sub	a7,a6,a0
 3010b86:	40f707b3          	sub	a5,a4,a5
 3010b8a:	01183733          	sltu	a4,a6,a7
 3010b8e:	40e78733          	sub	a4,a5,a4
 3010b92:	8846                	mv	a6,a7
 3010b94:	84b6                	mv	s1,a3
 3010b96:	b725                	j	3010abe <__subdf3+0x42c>
 3010b98:	7ff00613          	li	a2,2047
 3010b9c:	fff8c893          	not	a7,a7
 3010ba0:	02c59763          	bne	a1,a2,3010bce <__subdf3+0x53c>
 3010ba4:	01076533          	or	a0,a4,a6
 3010ba8:	2c050463          	beqz	a0,3010e70 <__subdf3+0x7de>
 3010bac:	00971793          	slli	a5,a4,0x9
 3010bb0:	2c07d363          	bgez	a5,3010e76 <__subdf3+0x7e4>
 3010bb4:	87ba                	mv	a5,a4
 3010bb6:	8542                	mv	a0,a6
 3010bb8:	84b6                	mv	s1,a3
 3010bba:	be79                	j	3010758 <__subdf3+0xc6>
 3010bbc:	7ff00613          	li	a2,2047
 3010bc0:	fec582e3          	beq	a1,a2,3010ba4 <__subdf3+0x512>
 3010bc4:	00800637          	lui	a2,0x800
 3010bc8:	411008b3          	neg	a7,a7
 3010bcc:	8fd1                	or	a5,a5,a2
 3010bce:	03800613          	li	a2,56
 3010bd2:	07164463          	blt	a2,a7,3010c3a <__subdf3+0x5a8>
 3010bd6:	467d                	li	a2,31
 3010bd8:	03164d63          	blt	a2,a7,3010c12 <__subdf3+0x580>
 3010bdc:	02000313          	li	t1,32
 3010be0:	41130333          	sub	t1,t1,a7
 3010be4:	01155e33          	srl	t3,a0,a7
 3010be8:	00679633          	sll	a2,a5,t1
 3010bec:	00651533          	sll	a0,a0,t1
 3010bf0:	01c66633          	or	a2,a2,t3
 3010bf4:	00a03533          	snez	a0,a0
 3010bf8:	8d51                	or	a0,a0,a2
 3010bfa:	0117d8b3          	srl	a7,a5,a7
 3010bfe:	40a80533          	sub	a0,a6,a0
 3010c02:	411707b3          	sub	a5,a4,a7
 3010c06:	00a83733          	sltu	a4,a6,a0
 3010c0a:	40e78733          	sub	a4,a5,a4
 3010c0e:	882a                	mv	a6,a0
 3010c10:	b751                	j	3010b94 <__subdf3+0x502>
 3010c12:	02000e13          	li	t3,32
 3010c16:	0117d633          	srl	a2,a5,a7
 3010c1a:	4301                	li	t1,0
 3010c1c:	01c88863          	beq	a7,t3,3010c2c <__subdf3+0x59a>
 3010c20:	04000313          	li	t1,64
 3010c24:	411308b3          	sub	a7,t1,a7
 3010c28:	01179333          	sll	t1,a5,a7
 3010c2c:	00a36533          	or	a0,t1,a0
 3010c30:	00a03533          	snez	a0,a0
 3010c34:	8d51                	or	a0,a0,a2
 3010c36:	4881                	li	a7,0
 3010c38:	b7d9                	j	3010bfe <__subdf3+0x56c>
 3010c3a:	8d5d                	or	a0,a0,a5
 3010c3c:	00a03533          	snez	a0,a0
 3010c40:	bfdd                	j	3010c36 <__subdf3+0x5a4>
 3010c42:	00198613          	addi	a2,s3,1
 3010c46:	7ff67613          	andi	a2,a2,2047
 3010c4a:	4305                	li	t1,1
 3010c4c:	10c34363          	blt	t1,a2,3010d52 <__subdf3+0x6c0>
 3010c50:	00a7ee33          	or	t3,a5,a0
 3010c54:	01076633          	or	a2,a4,a6
 3010c58:	0a099763          	bnez	s3,3010d06 <__subdf3+0x674>
 3010c5c:	060e1363          	bnez	t3,3010cc2 <__subdf3+0x630>
 3010c60:	1c061563          	bnez	a2,3010e2a <__subdf3+0x798>
 3010c64:	ffe90493          	addi	s1,s2,-2
 3010c68:	0014b493          	seqz	s1,s1
 3010c6c:	4701                	li	a4,0
 3010c6e:	4501                	li	a0,0
 3010c70:	00e567b3          	or	a5,a0,a4
 3010c74:	20078d63          	beqz	a5,3010e8e <__subdf3+0x7fc>
 3010c78:	01f55793          	srli	a5,a0,0x1f
 3010c7c:	00171893          	slli	a7,a4,0x1
 3010c80:	98be                	add	a7,a7,a5
 3010c82:	00151793          	slli	a5,a0,0x1
 3010c86:	0077f693          	andi	a3,a5,7
 3010c8a:	4301                	li	t1,0
 3010c8c:	c295                	beqz	a3,3010cb0 <__subdf3+0x61e>
 3010c8e:	4689                	li	a3,2
 3010c90:	1ad90d63          	beq	s2,a3,3010e4a <__subdf3+0x7b8>
 3010c94:	468d                	li	a3,3
 3010c96:	1ad90163          	beq	s2,a3,3010e38 <__subdf3+0x7a6>
 3010c9a:	4305                	li	t1,1
 3010c9c:	00091a63          	bnez	s2,3010cb0 <__subdf3+0x61e>
 3010ca0:	00f7f693          	andi	a3,a5,15
 3010ca4:	4611                	li	a2,4
 3010ca6:	4305                	li	t1,1
 3010ca8:	ffc7b793          	sltiu	a5,a5,-4
 3010cac:	18c69b63          	bne	a3,a2,3010e42 <__subdf3+0x7b0>
 3010cb0:	0188d893          	srli	a7,a7,0x18
 3010cb4:	0018c893          	xori	a7,a7,1
 3010cb8:	0018f893          	andi	a7,a7,1
 3010cbc:	87ba                	mv	a5,a4
 3010cbe:	4581                	li	a1,0
 3010cc0:	b9a1                	j	3010918 <__subdf3+0x286>
 3010cc2:	16060663          	beqz	a2,3010e2e <__subdf3+0x79c>
 3010cc6:	410505b3          	sub	a1,a0,a6
 3010cca:	40e78633          	sub	a2,a5,a4
 3010cce:	00b538b3          	sltu	a7,a0,a1
 3010cd2:	41160633          	sub	a2,a2,a7
 3010cd6:	00861413          	slli	s0,a2,0x8
 3010cda:	00045c63          	bgez	s0,3010cf2 <__subdf3+0x660>
 3010cde:	40a80533          	sub	a0,a6,a0
 3010ce2:	40f707b3          	sub	a5,a4,a5
 3010ce6:	00a83733          	sltu	a4,a6,a0
 3010cea:	40e78733          	sub	a4,a5,a4
 3010cee:	84b6                	mv	s1,a3
 3010cf0:	b741                	j	3010c70 <__subdf3+0x5de>
 3010cf2:	00c5e533          	or	a0,a1,a2
 3010cf6:	12051e63          	bnez	a0,3010e32 <__subdf3+0x7a0>
 3010cfa:	ffe90493          	addi	s1,s2,-2
 3010cfe:	0014b493          	seqz	s1,s1
 3010d02:	4701                	li	a4,0
 3010d04:	b7b5                	j	3010c70 <__subdf3+0x5de>
 3010d06:	7ff00e93          	li	t4,2047
 3010d0a:	03d99d63          	bne	s3,t4,3010d44 <__subdf3+0x6b2>
 3010d0e:	1a0e0e63          	beqz	t3,3010eca <__subdf3+0x838>
 3010d12:	00400337          	lui	t1,0x400
 3010d16:	0067f333          	and	t1,a5,t1
 3010d1a:	00133313          	seqz	t1,t1
 3010d1e:	0312                	slli	t1,t1,0x4
 3010d20:	03359763          	bne	a1,s3,3010d4e <__subdf3+0x6bc>
 3010d24:	c611                	beqz	a2,3010d30 <__subdf3+0x69e>
 3010d26:	00971593          	slli	a1,a4,0x9
 3010d2a:	0005c363          	bltz	a1,3010d30 <__subdf3+0x69e>
 3010d2e:	4341                	li	t1,16
 3010d30:	000e1f63          	bnez	t3,3010d4e <__subdf3+0x6bc>
 3010d34:	14060563          	beqz	a2,3010e7e <__subdf3+0x7ec>
 3010d38:	87ba                	mv	a5,a4
 3010d3a:	8542                	mv	a0,a6
 3010d3c:	84b6                	mv	s1,a3
 3010d3e:	7ff00593          	li	a1,2047
 3010d42:	bed9                	j	3010918 <__subdf3+0x286>
 3010d44:	4301                	li	t1,0
 3010d46:	ffd595e3          	bne	a1,t4,3010d30 <__subdf3+0x69e>
 3010d4a:	4301                	li	t1,0
 3010d4c:	bfe1                	j	3010d24 <__subdf3+0x692>
 3010d4e:	da65                	beqz	a2,3010d3e <__subdf3+0x6ac>
 3010d50:	b929                	j	301096a <__subdf3+0x2d8>
 3010d52:	41050a33          	sub	s4,a0,a6
 3010d56:	01453633          	sltu	a2,a0,s4
 3010d5a:	40e78433          	sub	s0,a5,a4
 3010d5e:	8c11                	sub	s0,s0,a2
 3010d60:	00841613          	slli	a2,s0,0x8
 3010d64:	06065863          	bgez	a2,3010dd4 <__subdf3+0x742>
 3010d68:	40a80a33          	sub	s4,a6,a0
 3010d6c:	40f707b3          	sub	a5,a4,a5
 3010d70:	01483733          	sltu	a4,a6,s4
 3010d74:	40e78433          	sub	s0,a5,a4
 3010d78:	84b6                	mv	s1,a3
 3010d7a:	c02d                	beqz	s0,3010ddc <__subdf3+0x74a>
 3010d7c:	8522                	mv	a0,s0
 3010d7e:	2369                	jal	ra,3011308 <__clzsi2>
 3010d80:	ff850593          	addi	a1,a0,-8
 3010d84:	47fd                	li	a5,31
 3010d86:	06b7c063          	blt	a5,a1,3010de6 <__subdf3+0x754>
 3010d8a:	02000713          	li	a4,32
 3010d8e:	8f0d                	sub	a4,a4,a1
 3010d90:	00b41433          	sll	s0,s0,a1
 3010d94:	00ea5733          	srl	a4,s4,a4
 3010d98:	008767b3          	or	a5,a4,s0
 3010d9c:	00ba1833          	sll	a6,s4,a1
 3010da0:	0735cc63          	blt	a1,s3,3010e18 <__subdf3+0x786>
 3010da4:	413585b3          	sub	a1,a1,s3
 3010da8:	00158713          	addi	a4,a1,1
 3010dac:	46fd                	li	a3,31
 3010dae:	04e6c263          	blt	a3,a4,3010df2 <__subdf3+0x760>
 3010db2:	02000693          	li	a3,32
 3010db6:	8e99                	sub	a3,a3,a4
 3010db8:	00e85633          	srl	a2,a6,a4
 3010dbc:	00d79533          	sll	a0,a5,a3
 3010dc0:	00d81833          	sll	a6,a6,a3
 3010dc4:	8d51                	or	a0,a0,a2
 3010dc6:	01003833          	snez	a6,a6
 3010dca:	01056533          	or	a0,a0,a6
 3010dce:	00e7d733          	srl	a4,a5,a4
 3010dd2:	bd79                	j	3010c70 <__subdf3+0x5de>
 3010dd4:	008a6533          	or	a0,s4,s0
 3010dd8:	f14d                	bnez	a0,3010d7a <__subdf3+0x6e8>
 3010dda:	b705                	j	3010cfa <__subdf3+0x668>
 3010ddc:	8552                	mv	a0,s4
 3010dde:	232d                	jal	ra,3011308 <__clzsi2>
 3010de0:	02050513          	addi	a0,a0,32
 3010de4:	bf71                	j	3010d80 <__subdf3+0x6ee>
 3010de6:	fd850413          	addi	s0,a0,-40
 3010dea:	008a17b3          	sll	a5,s4,s0
 3010dee:	4801                	li	a6,0
 3010df0:	bf45                	j	3010da0 <__subdf3+0x70e>
 3010df2:	1585                	addi	a1,a1,-31
 3010df4:	02000693          	li	a3,32
 3010df8:	00b7d5b3          	srl	a1,a5,a1
 3010dfc:	4601                	li	a2,0
 3010dfe:	00d70763          	beq	a4,a3,3010e0c <__subdf3+0x77a>
 3010e02:	04000613          	li	a2,64
 3010e06:	8e19                	sub	a2,a2,a4
 3010e08:	00c79633          	sll	a2,a5,a2
 3010e0c:	00c86533          	or	a0,a6,a2
 3010e10:	00a03533          	snez	a0,a0
 3010e14:	8d4d                	or	a0,a0,a1
 3010e16:	b5f5                	j	3010d02 <__subdf3+0x670>
 3010e18:	ff800737          	lui	a4,0xff800
 3010e1c:	fff70513          	addi	a0,a4,-1 # ff7fffff <RAM_END+0xfb7f7fff>
 3010e20:	40b985b3          	sub	a1,s3,a1
 3010e24:	00a7f733          	and	a4,a5,a0
 3010e28:	bac5                	j	3010818 <__subdf3+0x186>
 3010e2a:	8542                	mv	a0,a6
 3010e2c:	b5c9                	j	3010cee <__subdf3+0x65c>
 3010e2e:	873e                	mv	a4,a5
 3010e30:	b581                	j	3010c70 <__subdf3+0x5de>
 3010e32:	8732                	mv	a4,a2
 3010e34:	852e                	mv	a0,a1
 3010e36:	bd2d                	j	3010c70 <__subdf3+0x5de>
 3010e38:	4305                	li	t1,1
 3010e3a:	e6049be3          	bnez	s1,3010cb0 <__subdf3+0x61e>
 3010e3e:	ff87b793          	sltiu	a5,a5,-8
 3010e42:	0017c793          	xori	a5,a5,1
 3010e46:	98be                	add	a7,a7,a5
 3010e48:	b5a5                	j	3010cb0 <__subdf3+0x61e>
 3010e4a:	4305                	li	t1,1
 3010e4c:	e60482e3          	beqz	s1,3010cb0 <__subdf3+0x61e>
 3010e50:	b7fd                	j	3010e3e <__subdf3+0x7ac>
 3010e52:	87ba                	mv	a5,a4
 3010e54:	8542                	mv	a0,a6
 3010e56:	4881                	li	a7,0
 3010e58:	b20d                	j	301077a <__subdf3+0xe8>
 3010e5a:	87ba                	mv	a5,a4
 3010e5c:	8542                	mv	a0,a6
 3010e5e:	b5c5                	j	3010d3e <__subdf3+0x6ac>
 3010e60:	4781                	li	a5,0
 3010e62:	4501                	li	a0,0
 3010e64:	7ff00593          	li	a1,2047
 3010e68:	4301                	li	t1,0
 3010e6a:	b631                	j	3010976 <__subdf3+0x2e4>
 3010e6c:	4781                	li	a5,0
 3010e6e:	bfed                	j	3010e68 <__subdf3+0x7d6>
 3010e70:	4781                	li	a5,0
 3010e72:	84b6                	mv	s1,a3
 3010e74:	bfd5                	j	3010e68 <__subdf3+0x7d6>
 3010e76:	87ba                	mv	a5,a4
 3010e78:	8542                	mv	a0,a6
 3010e7a:	84b6                	mv	s1,a3
 3010e7c:	bfe9                	j	3010e56 <__subdf3+0x7c4>
 3010e7e:	4501                	li	a0,0
 3010e80:	004007b7          	lui	a5,0x400
 3010e84:	7ff00593          	li	a1,2047
 3010e88:	4481                	li	s1,0
 3010e8a:	4341                	li	t1,16
 3010e8c:	b4ed                	j	3010976 <__subdf3+0x2e4>
 3010e8e:	4501                	li	a0,0
 3010e90:	4581                	li	a1,0
 3010e92:	bfd9                	j	3010e68 <__subdf3+0x7d6>
 3010e94:	a80496e3          	bnez	s1,3010920 <__subdf3+0x28e>
 3010e98:	00850713          	addi	a4,a0,8
 3010e9c:	be7d                	j	3010a5a <__subdf3+0x3c8>
 3010e9e:	a80481e3          	beqz	s1,3010920 <__subdf3+0x28e>
 3010ea2:	bfdd                	j	3010e98 <__subdf3+0x806>
 3010ea4:	4501                	li	a0,0
 3010ea6:	00090e63          	beqz	s2,3010ec2 <__subdf3+0x830>
 3010eaa:	478d                	li	a5,3
 3010eac:	00f91763          	bne	s2,a5,3010eba <__subdf3+0x828>
 3010eb0:	c889                	beqz	s1,3010ec2 <__subdf3+0x830>
 3010eb2:	557d                	li	a0,-1
 3010eb4:	7fe00593          	li	a1,2046
 3010eb8:	a029                	j	3010ec2 <__subdf3+0x830>
 3010eba:	4789                	li	a5,2
 3010ebc:	fef91be3          	bne	s2,a5,3010eb2 <__subdf3+0x820>
 3010ec0:	d8ed                	beqz	s1,3010eb2 <__subdf3+0x820>
 3010ec2:	00536313          	ori	t1,t1,5
 3010ec6:	87aa                	mv	a5,a0
 3010ec8:	b4e1                	j	3010990 <__subdf3+0x2fe>
 3010eca:	4301                	li	t1,0
 3010ecc:	e73594e3          	bne	a1,s3,3010d34 <__subdf3+0x6a2>
 3010ed0:	bdad                	j	3010d4a <__subdf3+0x6b8>
 3010ed2:	b33583e3          	beq	a1,s3,30109f8 <__subdf3+0x366>
 3010ed6:	87ba                	mv	a5,a4
 3010ed8:	8542                	mv	a0,a6
 3010eda:	7ff00593          	li	a1,2047
 3010ede:	b681                	j	3010a1e <__subdf3+0x38c>

03010ee0 <__fixdfsi>:
 3010ee0:	002027f3          	frrm	a5
 3010ee4:	001007b7          	lui	a5,0x100
 3010ee8:	0145d693          	srli	a3,a1,0x14
 3010eec:	fff78613          	addi	a2,a5,-1 # fffff <FLASH_SIZE+0xe0003>
 3010ef0:	7ff6f693          	andi	a3,a3,2047
 3010ef4:	3fe00713          	li	a4,1022
 3010ef8:	8e6d                	and	a2,a2,a1
 3010efa:	81fd                	srli	a1,a1,0x1f
 3010efc:	00d74863          	blt	a4,a3,3010f0c <__fixdfsi+0x2c>
 3010f00:	eec9                	bnez	a3,3010f9a <__fixdfsi+0xba>
 3010f02:	00a667b3          	or	a5,a2,a0
 3010f06:	ebd1                	bnez	a5,3010f9a <__fixdfsi+0xba>
 3010f08:	853e                	mv	a0,a5
 3010f0a:	8082                	ret
 3010f0c:	41d00713          	li	a4,1053
 3010f10:	02d75863          	bge	a4,a3,3010f40 <__fixdfsi+0x60>
 3010f14:	80000737          	lui	a4,0x80000
 3010f18:	fff74713          	not	a4,a4
 3010f1c:	00e587b3          	add	a5,a1,a4
 3010f20:	cdbd                	beqz	a1,3010f9e <__fixdfsi+0xbe>
 3010f22:	41e00593          	li	a1,1054
 3010f26:	4741                	li	a4,16
 3010f28:	04b69363          	bne	a3,a1,3010f6e <__fixdfsi+0x8e>
 3010f2c:	062e                	slli	a2,a2,0xb
 3010f2e:	01555693          	srli	a3,a0,0x15
 3010f32:	8e55                	or	a2,a2,a3
 3010f34:	ee0d                	bnez	a2,3010f6e <__fixdfsi+0x8e>
 3010f36:	00b51713          	slli	a4,a0,0xb
 3010f3a:	d779                	beqz	a4,3010f08 <__fixdfsi+0x28>
 3010f3c:	4705                	li	a4,1
 3010f3e:	a805                	j	3010f6e <__fixdfsi+0x8e>
 3010f40:	43300813          	li	a6,1075
 3010f44:	40d80833          	sub	a6,a6,a3
 3010f48:	477d                	li	a4,31
 3010f4a:	8fd1                	or	a5,a5,a2
 3010f4c:	03074463          	blt	a4,a6,3010f74 <__fixdfsi+0x94>
 3010f50:	bed68613          	addi	a2,a3,-1043 # 7ffbed <FLASH_SIZE+0x7dfbf1>
 3010f54:	00c516b3          	sll	a3,a0,a2
 3010f58:	00c797b3          	sll	a5,a5,a2
 3010f5c:	01055533          	srl	a0,a0,a6
 3010f60:	00d03733          	snez	a4,a3
 3010f64:	8fc9                	or	a5,a5,a0
 3010f66:	c199                	beqz	a1,3010f6c <__fixdfsi+0x8c>
 3010f68:	40f007b3          	neg	a5,a5
 3010f6c:	df51                	beqz	a4,3010f08 <__fixdfsi+0x28>
 3010f6e:	00172073          	csrs	fflags,a4
 3010f72:	bf59                	j	3010f08 <__fixdfsi+0x28>
 3010f74:	02000613          	li	a2,32
 3010f78:	4701                	li	a4,0
 3010f7a:	00c80663          	beq	a6,a2,3010f86 <__fixdfsi+0xa6>
 3010f7e:	c0d68713          	addi	a4,a3,-1011
 3010f82:	00e79733          	sll	a4,a5,a4
 3010f86:	8f49                	or	a4,a4,a0
 3010f88:	41300513          	li	a0,1043
 3010f8c:	40d506b3          	sub	a3,a0,a3
 3010f90:	00e03733          	snez	a4,a4
 3010f94:	00d7d7b3          	srl	a5,a5,a3
 3010f98:	b7f9                	j	3010f66 <__fixdfsi+0x86>
 3010f9a:	4781                	li	a5,0
 3010f9c:	b745                	j	3010f3c <__fixdfsi+0x5c>
 3010f9e:	4741                	li	a4,16
 3010fa0:	b7f9                	j	3010f6e <__fixdfsi+0x8e>

03010fa2 <__floatunsidf>:
 3010fa2:	1141                	addi	sp,sp,-16
 3010fa4:	c606                	sw	ra,12(sp)
 3010fa6:	c422                	sw	s0,8(sp)
 3010fa8:	cd21                	beqz	a0,3011000 <__floatunsidf+0x5e>
 3010faa:	842a                	mv	s0,a0
 3010fac:	2eb1                	jal	ra,3011308 <__clzsi2>
 3010fae:	41e00713          	li	a4,1054
 3010fb2:	47a9                	li	a5,10
 3010fb4:	8f09                	sub	a4,a4,a0
 3010fb6:	04a7c063          	blt	a5,a0,3010ff6 <__floatunsidf+0x54>
 3010fba:	47ad                	li	a5,11
 3010fbc:	8f89                	sub	a5,a5,a0
 3010fbe:	0555                	addi	a0,a0,21
 3010fc0:	00f457b3          	srl	a5,s0,a5
 3010fc4:	00a41433          	sll	s0,s0,a0
 3010fc8:	00100537          	lui	a0,0x100
 3010fcc:	157d                	addi	a0,a0,-1 # fffff <FLASH_SIZE+0xe0003>
 3010fce:	801006b7          	lui	a3,0x80100
 3010fd2:	8fe9                	and	a5,a5,a0
 3010fd4:	7ff77713          	andi	a4,a4,2047
 3010fd8:	16fd                	addi	a3,a3,-1 # 800fffff <RAM_END+0x7c0f7fff>
 3010fda:	0752                	slli	a4,a4,0x14
 3010fdc:	8ff5                	and	a5,a5,a3
 3010fde:	8fd9                	or	a5,a5,a4
 3010fe0:	8522                	mv	a0,s0
 3010fe2:	40b2                	lw	ra,12(sp)
 3010fe4:	4422                	lw	s0,8(sp)
 3010fe6:	80000737          	lui	a4,0x80000
 3010fea:	fff74713          	not	a4,a4
 3010fee:	8f7d                	and	a4,a4,a5
 3010ff0:	85ba                	mv	a1,a4
 3010ff2:	0141                	addi	sp,sp,16
 3010ff4:	8082                	ret
 3010ff6:	1555                	addi	a0,a0,-11
 3010ff8:	00a417b3          	sll	a5,s0,a0
 3010ffc:	4401                	li	s0,0
 3010ffe:	b7e9                	j	3010fc8 <__floatunsidf+0x26>
 3011000:	4781                	li	a5,0
 3011002:	4401                	li	s0,0
 3011004:	4701                	li	a4,0
 3011006:	b7c9                	j	3010fc8 <__floatunsidf+0x26>

03011008 <__extendsfdf2>:
 3011008:	1141                	addi	sp,sp,-16
 301100a:	c606                	sw	ra,12(sp)
 301100c:	c422                	sw	s0,8(sp)
 301100e:	c226                	sw	s1,4(sp)
 3011010:	e00506d3          	fmv.x.w	a3,fa0
 3011014:	002027f3          	frrm	a5
 3011018:	0176d513          	srli	a0,a3,0x17
 301101c:	0ff57513          	andi	a0,a0,255
 3011020:	00800437          	lui	s0,0x800
 3011024:	00150793          	addi	a5,a0,1
 3011028:	147d                	addi	s0,s0,-1 # 7fffff <FLASH_SIZE+0x7e0003>
 301102a:	0ff7f793          	andi	a5,a5,255
 301102e:	4705                	li	a4,1
 3011030:	8c75                	and	s0,s0,a3
 3011032:	01f6d493          	srli	s1,a3,0x1f
 3011036:	00f75963          	bge	a4,a5,3011048 <__extendsfdf2+0x40>
 301103a:	00345793          	srli	a5,s0,0x3
 301103e:	38050513          	addi	a0,a0,896
 3011042:	0476                	slli	s0,s0,0x1d
 3011044:	4701                	li	a4,0
 3011046:	a891                	j	301109a <__extendsfdf2+0x92>
 3011048:	e915                	bnez	a0,301107c <__extendsfdf2+0x74>
 301104a:	c459                	beqz	s0,30110d8 <__extendsfdf2+0xd0>
 301104c:	8522                	mv	a0,s0
 301104e:	2c6d                	jal	ra,3011308 <__clzsi2>
 3011050:	47a9                	li	a5,10
 3011052:	00a7cf63          	blt	a5,a0,3011070 <__extendsfdf2+0x68>
 3011056:	47ad                	li	a5,11
 3011058:	8f89                	sub	a5,a5,a0
 301105a:	01550713          	addi	a4,a0,21
 301105e:	00f457b3          	srl	a5,s0,a5
 3011062:	00e41433          	sll	s0,s0,a4
 3011066:	38900713          	li	a4,905
 301106a:	40a70533          	sub	a0,a4,a0
 301106e:	bfd9                	j	3011044 <__extendsfdf2+0x3c>
 3011070:	ff550793          	addi	a5,a0,-11
 3011074:	00f417b3          	sll	a5,s0,a5
 3011078:	4401                	li	s0,0
 301107a:	b7f5                	j	3011066 <__extendsfdf2+0x5e>
 301107c:	c02d                	beqz	s0,30110de <__extendsfdf2+0xd6>
 301107e:	00400737          	lui	a4,0x400
 3011082:	8f61                	and	a4,a4,s0
 3011084:	00345793          	srli	a5,s0,0x3
 3011088:	00173713          	seqz	a4,a4
 301108c:	000806b7          	lui	a3,0x80
 3011090:	0712                	slli	a4,a4,0x4
 3011092:	0476                	slli	s0,s0,0x1d
 3011094:	8fd5                	or	a5,a5,a3
 3011096:	7ff00513          	li	a0,2047
 301109a:	00100637          	lui	a2,0x100
 301109e:	167d                	addi	a2,a2,-1 # fffff <FLASH_SIZE+0xe0003>
 30110a0:	8ff1                	and	a5,a5,a2
 30110a2:	80100637          	lui	a2,0x80100
 30110a6:	167d                	addi	a2,a2,-1 # 800fffff <RAM_END+0x7c0f7fff>
 30110a8:	7ff57513          	andi	a0,a0,2047
 30110ac:	0552                	slli	a0,a0,0x14
 30110ae:	8ff1                	and	a5,a5,a2
 30110b0:	80000637          	lui	a2,0x80000
 30110b4:	8fc9                	or	a5,a5,a0
 30110b6:	fff64613          	not	a2,a2
 30110ba:	01f49693          	slli	a3,s1,0x1f
 30110be:	8ff1                	and	a5,a5,a2
 30110c0:	00d7e633          	or	a2,a5,a3
 30110c4:	8522                	mv	a0,s0
 30110c6:	85b2                	mv	a1,a2
 30110c8:	c319                	beqz	a4,30110ce <__extendsfdf2+0xc6>
 30110ca:	00172073          	csrs	fflags,a4
 30110ce:	40b2                	lw	ra,12(sp)
 30110d0:	4422                	lw	s0,8(sp)
 30110d2:	4492                	lw	s1,4(sp)
 30110d4:	0141                	addi	sp,sp,16
 30110d6:	8082                	ret
 30110d8:	4781                	li	a5,0
 30110da:	4501                	li	a0,0
 30110dc:	b7a5                	j	3011044 <__extendsfdf2+0x3c>
 30110de:	4781                	li	a5,0
 30110e0:	7ff00513          	li	a0,2047
 30110e4:	b785                	j	3011044 <__extendsfdf2+0x3c>

030110e6 <__truncdfsf2>:
 30110e6:	00202873          	frrm	a6
 30110ea:	001006b7          	lui	a3,0x100
 30110ee:	16fd                	addi	a3,a3,-1 # fffff <FLASH_SIZE+0xe0003>
 30110f0:	8eed                	and	a3,a3,a1
 30110f2:	0145d893          	srli	a7,a1,0x14
 30110f6:	00369793          	slli	a5,a3,0x3
 30110fa:	7ff8f893          	andi	a7,a7,2047
 30110fe:	01d55693          	srli	a3,a0,0x1d
 3011102:	8edd                	or	a3,a3,a5
 3011104:	00188793          	addi	a5,a7,1
 3011108:	7ff7f793          	andi	a5,a5,2047
 301110c:	4705                	li	a4,1
 301110e:	81fd                	srli	a1,a1,0x1f
 3011110:	00351613          	slli	a2,a0,0x3
 3011114:	16f75b63          	bge	a4,a5,301128a <__truncdfsf2+0x1a4>
 3011118:	c8088713          	addi	a4,a7,-896
 301111c:	0fe00793          	li	a5,254
 3011120:	0ae7d063          	bge	a5,a4,30111c0 <__truncdfsf2+0xda>
 3011124:	04080063          	beqz	a6,3011164 <__truncdfsf2+0x7e>
 3011128:	478d                	li	a5,3
 301112a:	02f81963          	bne	a6,a5,301115c <__truncdfsf2+0x76>
 301112e:	c99d                	beqz	a1,3011164 <__truncdfsf2+0x7e>
 3011130:	57fd                	li	a5,-1
 3011132:	0fe00713          	li	a4,254
 3011136:	4681                	li	a3,0
 3011138:	4615                	li	a2,5
 301113a:	4509                	li	a0,2
 301113c:	00166613          	ori	a2,a2,1
 3011140:	1aa80063          	beq	a6,a0,30112e0 <__truncdfsf2+0x1fa>
 3011144:	450d                	li	a0,3
 3011146:	18a80a63          	beq	a6,a0,30112da <__truncdfsf2+0x1f4>
 301114a:	12081763          	bnez	a6,3011278 <__truncdfsf2+0x192>
 301114e:	00f7f513          	andi	a0,a5,15
 3011152:	4891                	li	a7,4
 3011154:	13150263          	beq	a0,a7,3011278 <__truncdfsf2+0x192>
 3011158:	0791                	addi	a5,a5,4
 301115a:	aa39                	j	3011278 <__truncdfsf2+0x192>
 301115c:	4789                	li	a5,2
 301115e:	fcf819e3          	bne	a6,a5,3011130 <__truncdfsf2+0x4a>
 3011162:	d5f9                	beqz	a1,3011130 <__truncdfsf2+0x4a>
 3011164:	4781                	li	a5,0
 3011166:	0ff00713          	li	a4,255
 301116a:	4615                	li	a2,5
 301116c:	00579693          	slli	a3,a5,0x5
 3011170:	0006db63          	bgez	a3,3011186 <__truncdfsf2+0xa0>
 3011174:	0705                	addi	a4,a4,1 # 400001 <FLASH_SIZE+0x3e0005>
 3011176:	0ff00693          	li	a3,255
 301117a:	16d70563          	beq	a4,a3,30112e4 <__truncdfsf2+0x1fe>
 301117e:	fc0006b7          	lui	a3,0xfc000
 3011182:	16fd                	addi	a3,a3,-1 # fbffffff <RAM_END+0xf7ff7fff>
 3011184:	8ff5                	and	a5,a5,a3
 3011186:	0ff00693          	li	a3,255
 301118a:	838d                	srli	a5,a5,0x3
 301118c:	00d71663          	bne	a4,a3,3011198 <__truncdfsf2+0xb2>
 3011190:	c781                	beqz	a5,3011198 <__truncdfsf2+0xb2>
 3011192:	004007b7          	lui	a5,0x400
 3011196:	4581                	li	a1,0
 3011198:	008006b7          	lui	a3,0x800
 301119c:	16fd                	addi	a3,a3,-1 # 7fffff <FLASH_SIZE+0x7e0003>
 301119e:	8ff5                	and	a5,a5,a3
 30111a0:	808006b7          	lui	a3,0x80800
 30111a4:	0ff77713          	andi	a4,a4,255
 30111a8:	16fd                	addi	a3,a3,-1 # 807fffff <RAM_END+0x7c7f7fff>
 30111aa:	075e                	slli	a4,a4,0x17
 30111ac:	8ff5                	and	a5,a5,a3
 30111ae:	05fe                	slli	a1,a1,0x1f
 30111b0:	8fd9                	or	a5,a5,a4
 30111b2:	8fcd                	or	a5,a5,a1
 30111b4:	c219                	beqz	a2,30111ba <__truncdfsf2+0xd4>
 30111b6:	00162073          	csrs	fflags,a2
 30111ba:	f0078553          	fmv.w.x	fa0,a5
 30111be:	8082                	ret
 30111c0:	08e04e63          	bgtz	a4,301125c <__truncdfsf2+0x176>
 30111c4:	57a5                	li	a5,-23
 30111c6:	0ef74d63          	blt	a4,a5,30112c0 <__truncdfsf2+0x1da>
 30111ca:	008007b7          	lui	a5,0x800
 30111ce:	4379                	li	t1,30
 30111d0:	8edd                	or	a3,a3,a5
 30111d2:	40e30333          	sub	t1,t1,a4
 30111d6:	47fd                	li	a5,31
 30111d8:	0467ce63          	blt	a5,t1,3011234 <__truncdfsf2+0x14e>
 30111dc:	c8288893          	addi	a7,a7,-894
 30111e0:	011617b3          	sll	a5,a2,a7
 30111e4:	00f037b3          	snez	a5,a5
 30111e8:	011696b3          	sll	a3,a3,a7
 30111ec:	00665333          	srl	t1,a2,t1
 30111f0:	8edd                	or	a3,a3,a5
 30111f2:	00d367b3          	or	a5,t1,a3
 30111f6:	4701                	li	a4,0
 30111f8:	cff9                	beqz	a5,30112d6 <__truncdfsf2+0x1f0>
 30111fa:	00179713          	slli	a4,a5,0x1
 30111fe:	00777693          	andi	a3,a4,7
 3011202:	4601                	li	a2,0
 3011204:	c28d                	beqz	a3,3011226 <__truncdfsf2+0x140>
 3011206:	4689                	li	a3,2
 3011208:	0cd80263          	beq	a6,a3,30112cc <__truncdfsf2+0x1e6>
 301120c:	468d                	li	a3,3
 301120e:	0ad80b63          	beq	a6,a3,30112c4 <__truncdfsf2+0x1de>
 3011212:	4605                	li	a2,1
 3011214:	00081963          	bnez	a6,3011226 <__truncdfsf2+0x140>
 3011218:	00f77693          	andi	a3,a4,15
 301121c:	4511                	li	a0,4
 301121e:	4605                	li	a2,1
 3011220:	00a68363          	beq	a3,a0,3011226 <__truncdfsf2+0x140>
 3011224:	0711                	addi	a4,a4,4
 3011226:	01b75693          	srli	a3,a4,0x1b
 301122a:	0016c693          	xori	a3,a3,1
 301122e:	8a85                	andi	a3,a3,1
 3011230:	4701                	li	a4,0
 3011232:	a83d                	j	3011270 <__truncdfsf2+0x18a>
 3011234:	57f9                	li	a5,-2
 3011236:	40e78733          	sub	a4,a5,a4
 301123a:	02000793          	li	a5,32
 301123e:	00e6d733          	srl	a4,a3,a4
 3011242:	4501                	li	a0,0
 3011244:	00f30663          	beq	t1,a5,3011250 <__truncdfsf2+0x16a>
 3011248:	ca288893          	addi	a7,a7,-862
 301124c:	01169533          	sll	a0,a3,a7
 3011250:	00c567b3          	or	a5,a0,a2
 3011254:	00f037b3          	snez	a5,a5
 3011258:	8fd9                	or	a5,a5,a4
 301125a:	bf71                	j	30111f6 <__truncdfsf2+0x110>
 301125c:	051a                	slli	a0,a0,0x6
 301125e:	00a037b3          	snez	a5,a0
 3011262:	068e                	slli	a3,a3,0x3
 3011264:	8275                	srli	a2,a2,0x1d
 3011266:	8edd                	or	a3,a3,a5
 3011268:	00c6e7b3          	or	a5,a3,a2
 301126c:	4681                	li	a3,0
 301126e:	4601                	li	a2,0
 3011270:	0077f513          	andi	a0,a5,7
 3011274:	ec0513e3          	bnez	a0,301113a <__truncdfsf2+0x54>
 3011278:	ee068ae3          	beqz	a3,301116c <__truncdfsf2+0x86>
 301127c:	00167693          	andi	a3,a2,1
 3011280:	ee0686e3          	beqz	a3,301116c <__truncdfsf2+0x86>
 3011284:	00266613          	ori	a2,a2,2
 3011288:	b5d5                	j	301116c <__truncdfsf2+0x86>
 301128a:	00c6e7b3          	or	a5,a3,a2
 301128e:	00089563          	bnez	a7,3011298 <__truncdfsf2+0x1b2>
 3011292:	00f037b3          	snez	a5,a5
 3011296:	b785                	j	30111f6 <__truncdfsf2+0x110>
 3011298:	cf8d                	beqz	a5,30112d2 <__truncdfsf2+0x1ec>
 301129a:	7ff00793          	li	a5,2047
 301129e:	4601                	li	a2,0
 30112a0:	00f89863          	bne	a7,a5,30112b0 <__truncdfsf2+0x1ca>
 30112a4:	00400637          	lui	a2,0x400
 30112a8:	8e75                	and	a2,a2,a3
 30112aa:	00163613          	seqz	a2,a2
 30112ae:	0612                	slli	a2,a2,0x4
 30112b0:	068e                	slli	a3,a3,0x3
 30112b2:	020007b7          	lui	a5,0x2000
 30112b6:	8fd5                	or	a5,a5,a3
 30112b8:	0ff00713          	li	a4,255
 30112bc:	4681                	li	a3,0
 30112be:	bf4d                	j	3011270 <__truncdfsf2+0x18a>
 30112c0:	4785                	li	a5,1
 30112c2:	bf25                	j	30111fa <__truncdfsf2+0x114>
 30112c4:	4605                	li	a2,1
 30112c6:	f1a5                	bnez	a1,3011226 <__truncdfsf2+0x140>
 30112c8:	0721                	addi	a4,a4,8
 30112ca:	bfb1                	j	3011226 <__truncdfsf2+0x140>
 30112cc:	4605                	li	a2,1
 30112ce:	dda1                	beqz	a1,3011226 <__truncdfsf2+0x140>
 30112d0:	bfe5                	j	30112c8 <__truncdfsf2+0x1e2>
 30112d2:	0ff00713          	li	a4,255
 30112d6:	4601                	li	a2,0
 30112d8:	bd51                	j	301116c <__truncdfsf2+0x86>
 30112da:	fdd9                	bnez	a1,3011278 <__truncdfsf2+0x192>
 30112dc:	07a1                	addi	a5,a5,8 # 2000008 <RAM_CODE_START+0x8>
 30112de:	bf69                	j	3011278 <__truncdfsf2+0x192>
 30112e0:	ddc1                	beqz	a1,3011278 <__truncdfsf2+0x192>
 30112e2:	bfed                	j	30112dc <__truncdfsf2+0x1f6>
 30112e4:	4781                	li	a5,0
 30112e6:	00080e63          	beqz	a6,3011302 <__truncdfsf2+0x21c>
 30112ea:	468d                	li	a3,3
 30112ec:	00d81763          	bne	a6,a3,30112fa <__truncdfsf2+0x214>
 30112f0:	c989                	beqz	a1,3011302 <__truncdfsf2+0x21c>
 30112f2:	57fd                	li	a5,-1
 30112f4:	0fe00713          	li	a4,254
 30112f8:	a029                	j	3011302 <__truncdfsf2+0x21c>
 30112fa:	4689                	li	a3,2
 30112fc:	fed81be3          	bne	a6,a3,30112f2 <__truncdfsf2+0x20c>
 3011300:	d9ed                	beqz	a1,30112f2 <__truncdfsf2+0x20c>
 3011302:	00566613          	ori	a2,a2,5
 3011306:	b541                	j	3011186 <__truncdfsf2+0xa0>

03011308 <__clzsi2>:
 3011308:	67c1                	lui	a5,0x10
 301130a:	02f57663          	bgeu	a0,a5,3011336 <__clzsi2+0x2e>
 301130e:	0ff00793          	li	a5,255
 3011312:	00a7b7b3          	sltu	a5,a5,a0
 3011316:	078e                	slli	a5,a5,0x3
 3011318:	02000713          	li	a4,32
 301131c:	8f1d                	sub	a4,a4,a5
 301131e:	00f557b3          	srl	a5,a0,a5
 3011322:	00001517          	auipc	a0,0x1
 3011326:	3a252503          	lw	a0,930(a0) # 30126c4 <_GLOBAL_OFFSET_TABLE_+0x4>
 301132a:	97aa                	add	a5,a5,a0
 301132c:	0007c503          	lbu	a0,0(a5) # 10000 <RAM_SIZE+0xb000>
 3011330:	40a70533          	sub	a0,a4,a0
 3011334:	8082                	ret
 3011336:	01000737          	lui	a4,0x1000
 301133a:	47c1                	li	a5,16
 301133c:	fce56ee3          	bltu	a0,a4,3011318 <__clzsi2+0x10>
 3011340:	47e1                	li	a5,24
 3011342:	bfd9                	j	3011318 <__clzsi2+0x10>

03011344 <fabsf>:
 3011344:	e00507d3          	fmv.x.w	a5,fa0
 3011348:	80000737          	lui	a4,0x80000
 301134c:	fff74713          	not	a4,a4
 3011350:	8ff9                	and	a5,a5,a4
 3011352:	f0078553          	fmv.w.x	fa0,a5
 3011356:	8082                	ret

03011358 <round>:
 3011358:	7179                	addi	sp,sp,-48
 301135a:	ce4e                	sw	s3,28(sp)
 301135c:	0145d993          	srli	s3,a1,0x14
 3011360:	d422                	sw	s0,40(sp)
 3011362:	d226                	sw	s1,36(sp)
 3011364:	d606                	sw	ra,44(sp)
 3011366:	d04a                	sw	s2,32(sp)
 3011368:	cc52                	sw	s4,24(sp)
 301136a:	ca56                	sw	s5,20(sp)
 301136c:	c85a                	sw	s6,16(sp)
 301136e:	7ff9f993          	andi	s3,s3,2047
 3011372:	43200793          	li	a5,1074
 3011376:	84aa                	mv	s1,a0
 3011378:	842e                	mv	s0,a1
 301137a:	0537c163          	blt	a5,s3,30113bc <round+0x64>
 301137e:	8b2e                	mv	s6,a1
 3011380:	892e                	mv	s2,a1
 3011382:	0005d663          	bgez	a1,301138e <round+0x36>
 3011386:	80000937          	lui	s2,0x80000
 301138a:	00b94933          	xor	s2,s2,a1
 301138e:	03012a37          	lui	s4,0x3012
 3011392:	6a4a2683          	lw	a3,1700(s4) # 30126a4 <__clz_tab+0x108>
 3011396:	6a0a2603          	lw	a2,1696(s4)
 301139a:	8526                	mv	a0,s1
 301139c:	85ca                	mv	a1,s2
 301139e:	20d9                	jal	ra,3011464 <__adddf3.trans.33>
 30113a0:	3fd00693          	li	a3,1021
 30113a4:	0336c863          	blt	a3,s3,30113d4 <round+0x7c>
 30113a8:	c42a                	sw	a0,8(sp)
 30113aa:	c62e                	sw	a1,12(sp)
 30113ac:	8526                	mv	a0,s1
 30113ae:	85a2                	mv	a1,s0
 30113b0:	4601                	li	a2,0
 30113b2:	4681                	li	a3,0
 30113b4:	d29fe0ef          	jal	ra,30100dc <__muldf3>
 30113b8:	84aa                	mv	s1,a0
 30113ba:	842e                	mv	s0,a1
 30113bc:	85a2                	mv	a1,s0
 30113be:	50b2                	lw	ra,44(sp)
 30113c0:	5422                	lw	s0,40(sp)
 30113c2:	8526                	mv	a0,s1
 30113c4:	5902                	lw	s2,32(sp)
 30113c6:	5492                	lw	s1,36(sp)
 30113c8:	49f2                	lw	s3,28(sp)
 30113ca:	4a62                	lw	s4,24(sp)
 30113cc:	4ad2                	lw	s5,20(sp)
 30113ce:	4b42                	lw	s6,16(sp)
 30113d0:	6145                	addi	sp,sp,48
 30113d2:	8082                	ret
 30113d4:	6a0a2603          	lw	a2,1696(s4)
 30113d8:	6a4a2683          	lw	a3,1700(s4)
 30113dc:	2051                	jal	ra,3011460 <__subdf3.trans.43>
 30113de:	8626                	mv	a2,s1
 30113e0:	86ca                	mv	a3,s2
 30113e2:	28bd                	jal	ra,3011460 <__subdf3.trans.43>
 30113e4:	862a                	mv	a2,a0
 30113e6:	86ae                	mv	a3,a1
 30113e8:	8a2a                	mv	s4,a0
 30113ea:	8aae                	mv	s5,a1
 30113ec:	8526                	mv	a0,s1
 30113ee:	85ca                	mv	a1,s2
 30113f0:	2895                	jal	ra,3011464 <__adddf3.trans.33>
 30113f2:	030127b7          	lui	a5,0x3012
 30113f6:	6a87a603          	lw	a2,1704(a5) # 30126a8 <__clz_tab+0x10c>
 30113fa:	6ac7a683          	lw	a3,1708(a5)
 30113fe:	89aa                	mv	s3,a0
 3011400:	892e                	mv	s2,a1
 3011402:	84aa                	mv	s1,a0
 3011404:	842e                	mv	s0,a1
 3011406:	8552                	mv	a0,s4
 3011408:	85d6                	mv	a1,s5
 301140a:	b6bfe0ef          	jal	ra,300ff74 <__gedf2>
 301140e:	02a05363          	blez	a0,3011434 <round+0xdc>
 3011412:	030127b7          	lui	a5,0x3012
 3011416:	6b07a603          	lw	a2,1712(a5) # 30126b0 <__clz_tab+0x114>
 301141a:	6b47a683          	lw	a3,1716(a5)
 301141e:	854e                	mv	a0,s3
 3011420:	85ca                	mv	a1,s2
 3011422:	283d                	jal	ra,3011460 <__subdf3.trans.43>
 3011424:	84aa                	mv	s1,a0
 3011426:	842e                	mv	s0,a1
 3011428:	f80b5ae3          	bgez	s6,30113bc <round+0x64>
 301142c:	800007b7          	lui	a5,0x80000
 3011430:	8c3d                	xor	s0,s0,a5
 3011432:	b769                	j	30113bc <round+0x64>
 3011434:	030127b7          	lui	a5,0x3012
 3011438:	6b87a603          	lw	a2,1720(a5) # 30126b8 <__clz_tab+0x11c>
 301143c:	6bc7a683          	lw	a3,1724(a5)
 3011440:	8552                	mv	a0,s4
 3011442:	85d6                	mv	a1,s5
 3011444:	be5fe0ef          	jal	ra,3010028 <__ledf2>
 3011448:	fea040e3          	bgtz	a0,3011428 <round+0xd0>
 301144c:	030127b7          	lui	a5,0x3012
 3011450:	6b07a603          	lw	a2,1712(a5) # 30126b0 <__clz_tab+0x114>
 3011454:	6b47a683          	lw	a3,1716(a5)
 3011458:	854e                	mv	a0,s3
 301145a:	85ca                	mv	a1,s2
 301145c:	2021                	jal	ra,3011464 <__adddf3.trans.33>
 301145e:	b7d9                	j	3011424 <round+0xcc>

03011460 <__subdf3.trans.43>:
 3011460:	a32ff06f          	j	3010692 <__subdf3>

03011464 <__adddf3.trans.33>:
 3011464:	c31fd06f          	j	300f094 <__adddf3>

03011468 <abs>:
 3011468:	41f55793          	srai	a5,a0,0x1f
 301146c:	8d3d                	xor	a0,a0,a5
 301146e:	8d1d                	sub	a0,a0,a5
 3011470:	8082                	ret

03011472 <memcpy>:
 3011472:	87aa                	mv	a5,a0
 3011474:	0035f713          	andi	a4,a1,3
 3011478:	c319                	beqz	a4,301147e <memcpy+0xc>
 301147a:	1a061a63          	bnez	a2,301162e <memcpy+0x1bc>
 301147e:	0037f693          	andi	a3,a5,3
 3011482:	24068563          	beqz	a3,30116cc <memcpy+0x25a>
 3011486:	477d                	li	a4,31
 3011488:	0ac77363          	bgeu	a4,a2,301152e <memcpy+0xbc>
 301148c:	4889                	li	a7,2
 301148e:	0005c703          	lbu	a4,0(a1)
 3011492:	0005a803          	lw	a6,0(a1)
 3011496:	25168163          	beq	a3,a7,30116d8 <memcpy+0x266>
 301149a:	488d                	li	a7,3
 301149c:	2b168e63          	beq	a3,a7,3011758 <memcpy+0x2e6>
 30114a0:	00e78023          	sb	a4,0(a5)
 30114a4:	0015c703          	lbu	a4,1(a1)
 30114a8:	00358e13          	addi	t3,a1,3
 30114ac:	00378313          	addi	t1,a5,3
 30114b0:	00e780a3          	sb	a4,1(a5)
 30114b4:	0025c703          	lbu	a4,2(a1)
 30114b8:	ffd60893          	addi	a7,a2,-3 # 3ffffd <FLASH_SIZE+0x3e0001>
 30114bc:	4ec1                	li	t4,16
 30114be:	00e78123          	sb	a4,2(a5)
 30114c2:	8772                	mv	a4,t3
 30114c4:	879a                	mv	a5,t1
 30114c6:	00172683          	lw	a3,1(a4) # 80000001 <RAM_END+0x7bff8001>
 30114ca:	01885813          	srli	a6,a6,0x18
 30114ce:	18c1                	addi	a7,a7,-16
 30114d0:	00869593          	slli	a1,a3,0x8
 30114d4:	00b86833          	or	a6,a6,a1
 30114d8:	00572583          	lw	a1,5(a4)
 30114dc:	0107a023          	sw	a6,0(a5)
 30114e0:	82e1                	srli	a3,a3,0x18
 30114e2:	00859813          	slli	a6,a1,0x8
 30114e6:	0106e6b3          	or	a3,a3,a6
 30114ea:	c3d4                	sw	a3,4(a5)
 30114ec:	00972683          	lw	a3,9(a4)
 30114f0:	81e1                	srli	a1,a1,0x18
 30114f2:	0741                	addi	a4,a4,16
 30114f4:	00869813          	slli	a6,a3,0x8
 30114f8:	0105e5b3          	or	a1,a1,a6
 30114fc:	ffd72803          	lw	a6,-3(a4)
 3011500:	c78c                	sw	a1,8(a5)
 3011502:	82e1                	srli	a3,a3,0x18
 3011504:	00881593          	slli	a1,a6,0x8
 3011508:	8ecd                	or	a3,a3,a1
 301150a:	c7d4                	sw	a3,12(a5)
 301150c:	07c1                	addi	a5,a5,16
 301150e:	fb1eece3          	bltu	t4,a7,30114c6 <memcpy+0x54>
 3011512:	fec60713          	addi	a4,a2,-20
 3011516:	8311                	srli	a4,a4,0x4
 3011518:	00170793          	addi	a5,a4,1
 301151c:	0792                	slli	a5,a5,0x4
 301151e:	00fe05b3          	add	a1,t3,a5
 3011522:	1635                	addi	a2,a2,-19
 3011524:	979a                	add	a5,a5,t1
 3011526:	56c1                	li	a3,-16
 3011528:	02d70733          	mul	a4,a4,a3
 301152c:	963a                	add	a2,a2,a4
 301152e:	01067713          	andi	a4,a2,16
 3011532:	c359                	beqz	a4,30115b8 <memcpy+0x146>
 3011534:	0005c703          	lbu	a4,0(a1)
 3011538:	07c1                	addi	a5,a5,16
 301153a:	05c1                	addi	a1,a1,16
 301153c:	fee78823          	sb	a4,-16(a5)
 3011540:	ff15c703          	lbu	a4,-15(a1)
 3011544:	fee788a3          	sb	a4,-15(a5)
 3011548:	ff25c703          	lbu	a4,-14(a1)
 301154c:	fee78923          	sb	a4,-14(a5)
 3011550:	ff35c703          	lbu	a4,-13(a1)
 3011554:	fee789a3          	sb	a4,-13(a5)
 3011558:	ff45c703          	lbu	a4,-12(a1)
 301155c:	fee78a23          	sb	a4,-12(a5)
 3011560:	ff55c703          	lbu	a4,-11(a1)
 3011564:	fee78aa3          	sb	a4,-11(a5)
 3011568:	ff65c703          	lbu	a4,-10(a1)
 301156c:	fee78b23          	sb	a4,-10(a5)
 3011570:	ff75c703          	lbu	a4,-9(a1)
 3011574:	fee78ba3          	sb	a4,-9(a5)
 3011578:	ff85c703          	lbu	a4,-8(a1)
 301157c:	fee78c23          	sb	a4,-8(a5)
 3011580:	ff95c703          	lbu	a4,-7(a1)
 3011584:	fee78ca3          	sb	a4,-7(a5)
 3011588:	ffa5c703          	lbu	a4,-6(a1)
 301158c:	fee78d23          	sb	a4,-6(a5)
 3011590:	ffb5c703          	lbu	a4,-5(a1)
 3011594:	fee78da3          	sb	a4,-5(a5)
 3011598:	ffc5c703          	lbu	a4,-4(a1)
 301159c:	fee78e23          	sb	a4,-4(a5)
 30115a0:	ffd5c703          	lbu	a4,-3(a1)
 30115a4:	fee78ea3          	sb	a4,-3(a5)
 30115a8:	ffe5c703          	lbu	a4,-2(a1)
 30115ac:	fee78f23          	sb	a4,-2(a5)
 30115b0:	fff5c703          	lbu	a4,-1(a1)
 30115b4:	fee78fa3          	sb	a4,-1(a5)
 30115b8:	00867713          	andi	a4,a2,8
 30115bc:	c339                	beqz	a4,3011602 <memcpy+0x190>
 30115be:	0005c703          	lbu	a4,0(a1)
 30115c2:	07a1                	addi	a5,a5,8
 30115c4:	05a1                	addi	a1,a1,8
 30115c6:	fee78c23          	sb	a4,-8(a5)
 30115ca:	ff95c703          	lbu	a4,-7(a1)
 30115ce:	fee78ca3          	sb	a4,-7(a5)
 30115d2:	ffa5c703          	lbu	a4,-6(a1)
 30115d6:	fee78d23          	sb	a4,-6(a5)
 30115da:	ffb5c703          	lbu	a4,-5(a1)
 30115de:	fee78da3          	sb	a4,-5(a5)
 30115e2:	ffc5c703          	lbu	a4,-4(a1)
 30115e6:	fee78e23          	sb	a4,-4(a5)
 30115ea:	ffd5c703          	lbu	a4,-3(a1)
 30115ee:	fee78ea3          	sb	a4,-3(a5)
 30115f2:	ffe5c703          	lbu	a4,-2(a1)
 30115f6:	fee78f23          	sb	a4,-2(a5)
 30115fa:	fff5c703          	lbu	a4,-1(a1)
 30115fe:	fee78fa3          	sb	a4,-1(a5)
 3011602:	00467713          	andi	a4,a2,4
 3011606:	cf59                	beqz	a4,30116a4 <memcpy+0x232>
 3011608:	0005c703          	lbu	a4,0(a1)
 301160c:	0791                	addi	a5,a5,4
 301160e:	0591                	addi	a1,a1,4
 3011610:	fee78e23          	sb	a4,-4(a5)
 3011614:	ffd5c703          	lbu	a4,-3(a1)
 3011618:	fee78ea3          	sb	a4,-3(a5)
 301161c:	ffe5c703          	lbu	a4,-2(a1)
 3011620:	fee78f23          	sb	a4,-2(a5)
 3011624:	fff5c703          	lbu	a4,-1(a1)
 3011628:	fee78fa3          	sb	a4,-1(a5)
 301162c:	a8a5                	j	30116a4 <memcpy+0x232>
 301162e:	0585                	addi	a1,a1,1
 3011630:	fff5c703          	lbu	a4,-1(a1)
 3011634:	0785                	addi	a5,a5,1
 3011636:	167d                	addi	a2,a2,-1
 3011638:	fee78fa3          	sb	a4,-1(a5)
 301163c:	bd25                	j	3011474 <memcpy+0x2>
 301163e:	00072883          	lw	a7,0(a4)
 3011642:	06c1                	addi	a3,a3,16
 3011644:	0741                	addi	a4,a4,16
 3011646:	ff16a823          	sw	a7,-16(a3)
 301164a:	ff472883          	lw	a7,-12(a4)
 301164e:	ff16aa23          	sw	a7,-12(a3)
 3011652:	ff872883          	lw	a7,-8(a4)
 3011656:	ff16ac23          	sw	a7,-8(a3)
 301165a:	ffc72883          	lw	a7,-4(a4)
 301165e:	ff16ae23          	sw	a7,-4(a3)
 3011662:	40e308b3          	sub	a7,t1,a4
 3011666:	fd186ce3          	bltu	a6,a7,301163e <memcpy+0x1cc>
 301166a:	00465713          	srli	a4,a2,0x4
 301166e:	56c1                	li	a3,-16
 3011670:	02d706b3          	mul	a3,a4,a3
 3011674:	0712                	slli	a4,a4,0x4
 3011676:	97ba                	add	a5,a5,a4
 3011678:	95ba                	add	a1,a1,a4
 301167a:	9636                	add	a2,a2,a3
 301167c:	00867713          	andi	a4,a2,8
 3011680:	cb11                	beqz	a4,3011694 <memcpy+0x222>
 3011682:	4198                	lw	a4,0(a1)
 3011684:	07a1                	addi	a5,a5,8
 3011686:	05a1                	addi	a1,a1,8
 3011688:	fee7ac23          	sw	a4,-8(a5)
 301168c:	ffc5a703          	lw	a4,-4(a1)
 3011690:	fee7ae23          	sw	a4,-4(a5)
 3011694:	00467713          	andi	a4,a2,4
 3011698:	c711                	beqz	a4,30116a4 <memcpy+0x232>
 301169a:	4198                	lw	a4,0(a1)
 301169c:	0791                	addi	a5,a5,4
 301169e:	0591                	addi	a1,a1,4
 30116a0:	fee7ae23          	sw	a4,-4(a5)
 30116a4:	00267713          	andi	a4,a2,2
 30116a8:	cb19                	beqz	a4,30116be <memcpy+0x24c>
 30116aa:	0005c703          	lbu	a4,0(a1)
 30116ae:	0789                	addi	a5,a5,2
 30116b0:	0589                	addi	a1,a1,2
 30116b2:	fee78f23          	sb	a4,-2(a5)
 30116b6:	fff5c703          	lbu	a4,-1(a1)
 30116ba:	fee78fa3          	sb	a4,-1(a5)
 30116be:	8a05                	andi	a2,a2,1
 30116c0:	c609                	beqz	a2,30116ca <memcpy+0x258>
 30116c2:	0005c703          	lbu	a4,0(a1)
 30116c6:	00e78023          	sb	a4,0(a5)
 30116ca:	8082                	ret
 30116cc:	872e                	mv	a4,a1
 30116ce:	86be                	mv	a3,a5
 30116d0:	00c58333          	add	t1,a1,a2
 30116d4:	483d                	li	a6,15
 30116d6:	b771                	j	3011662 <memcpy+0x1f0>
 30116d8:	00e78023          	sb	a4,0(a5)
 30116dc:	0015c703          	lbu	a4,1(a1)
 30116e0:	00258e13          	addi	t3,a1,2
 30116e4:	00278313          	addi	t1,a5,2
 30116e8:	00e780a3          	sb	a4,1(a5)
 30116ec:	ffe60893          	addi	a7,a2,-2
 30116f0:	8772                	mv	a4,t3
 30116f2:	879a                	mv	a5,t1
 30116f4:	4ec5                	li	t4,17
 30116f6:	00272683          	lw	a3,2(a4)
 30116fa:	01085813          	srli	a6,a6,0x10
 30116fe:	18c1                	addi	a7,a7,-16
 3011700:	01069593          	slli	a1,a3,0x10
 3011704:	00b86833          	or	a6,a6,a1
 3011708:	00672583          	lw	a1,6(a4)
 301170c:	0107a023          	sw	a6,0(a5)
 3011710:	82c1                	srli	a3,a3,0x10
 3011712:	01059813          	slli	a6,a1,0x10
 3011716:	0106e6b3          	or	a3,a3,a6
 301171a:	c3d4                	sw	a3,4(a5)
 301171c:	00a72683          	lw	a3,10(a4)
 3011720:	81c1                	srli	a1,a1,0x10
 3011722:	0741                	addi	a4,a4,16
 3011724:	01069813          	slli	a6,a3,0x10
 3011728:	0105e5b3          	or	a1,a1,a6
 301172c:	ffe72803          	lw	a6,-2(a4)
 3011730:	c78c                	sw	a1,8(a5)
 3011732:	82c1                	srli	a3,a3,0x10
 3011734:	01081593          	slli	a1,a6,0x10
 3011738:	8ecd                	or	a3,a3,a1
 301173a:	c7d4                	sw	a3,12(a5)
 301173c:	07c1                	addi	a5,a5,16
 301173e:	fb1eece3          	bltu	t4,a7,30116f6 <memcpy+0x284>
 3011742:	fec60713          	addi	a4,a2,-20
 3011746:	8311                	srli	a4,a4,0x4
 3011748:	00170793          	addi	a5,a4,1
 301174c:	0792                	slli	a5,a5,0x4
 301174e:	00fe05b3          	add	a1,t3,a5
 3011752:	1639                	addi	a2,a2,-18
 3011754:	979a                	add	a5,a5,t1
 3011756:	bbc1                	j	3011526 <memcpy+0xb4>
 3011758:	0585                	addi	a1,a1,1
 301175a:	00178313          	addi	t1,a5,1
 301175e:	00e78023          	sb	a4,0(a5)
 3011762:	fff60893          	addi	a7,a2,-1
 3011766:	872e                	mv	a4,a1
 3011768:	879a                	mv	a5,t1
 301176a:	4e49                	li	t3,18
 301176c:	00372683          	lw	a3,3(a4)
 3011770:	00885813          	srli	a6,a6,0x8
 3011774:	18c1                	addi	a7,a7,-16
 3011776:	01869e93          	slli	t4,a3,0x18
 301177a:	01d86833          	or	a6,a6,t4
 301177e:	0107a023          	sw	a6,0(a5)
 3011782:	00772803          	lw	a6,7(a4)
 3011786:	82a1                	srli	a3,a3,0x8
 3011788:	0741                	addi	a4,a4,16
 301178a:	01881e93          	slli	t4,a6,0x18
 301178e:	01d6e6b3          	or	a3,a3,t4
 3011792:	c3d4                	sw	a3,4(a5)
 3011794:	ffb72683          	lw	a3,-5(a4)
 3011798:	00885813          	srli	a6,a6,0x8
 301179c:	07c1                	addi	a5,a5,16
 301179e:	01869e93          	slli	t4,a3,0x18
 30117a2:	01d86833          	or	a6,a6,t4
 30117a6:	ff07ac23          	sw	a6,-8(a5)
 30117aa:	fff72803          	lw	a6,-1(a4)
 30117ae:	82a1                	srli	a3,a3,0x8
 30117b0:	01881e93          	slli	t4,a6,0x18
 30117b4:	01d6e6b3          	or	a3,a3,t4
 30117b8:	fed7ae23          	sw	a3,-4(a5)
 30117bc:	fb1e68e3          	bltu	t3,a7,301176c <memcpy+0x2fa>
 30117c0:	fec60713          	addi	a4,a2,-20
 30117c4:	8311                	srli	a4,a4,0x4
 30117c6:	00170793          	addi	a5,a4,1
 30117ca:	0792                	slli	a5,a5,0x4
 30117cc:	95be                	add	a1,a1,a5
 30117ce:	163d                	addi	a2,a2,-17
 30117d0:	979a                	add	a5,a5,t1
 30117d2:	bb91                	j	3011526 <memcpy+0xb4>

030117d4 <memset>:
 30117d4:	c25d                	beqz	a2,301187a <memset+0xa6>
 30117d6:	0ff5f793          	andi	a5,a1,255
 30117da:	00f50023          	sb	a5,0(a0)
 30117de:	00c50733          	add	a4,a0,a2
 30117e2:	fef70fa3          	sb	a5,-1(a4)
 30117e6:	4689                	li	a3,2
 30117e8:	08c6f963          	bgeu	a3,a2,301187a <memset+0xa6>
 30117ec:	00f500a3          	sb	a5,1(a0)
 30117f0:	00f50123          	sb	a5,2(a0)
 30117f4:	fef70f23          	sb	a5,-2(a4)
 30117f8:	fef70ea3          	sb	a5,-3(a4)
 30117fc:	4699                	li	a3,6
 30117fe:	06c6fe63          	bgeu	a3,a2,301187a <memset+0xa6>
 3011802:	00f501a3          	sb	a5,3(a0)
 3011806:	fef70e23          	sb	a5,-4(a4)
 301180a:	46a1                	li	a3,8
 301180c:	06c6f763          	bgeu	a3,a2,301187a <memset+0xa6>
 3011810:	40a007b3          	neg	a5,a0
 3011814:	8b8d                	andi	a5,a5,3
 3011816:	00f50733          	add	a4,a0,a5
 301181a:	8e1d                	sub	a2,a2,a5
 301181c:	010107b7          	lui	a5,0x1010
 3011820:	10178793          	addi	a5,a5,257 # 1010101 <FLASH_SIZE+0xff0105>
 3011824:	0ff5f593          	andi	a1,a1,255
 3011828:	02f585b3          	mul	a1,a1,a5
 301182c:	9a71                	andi	a2,a2,-4
 301182e:	00c707b3          	add	a5,a4,a2
 3011832:	c30c                	sw	a1,0(a4)
 3011834:	feb7ae23          	sw	a1,-4(a5)
 3011838:	04c6f163          	bgeu	a3,a2,301187a <memset+0xa6>
 301183c:	c34c                	sw	a1,4(a4)
 301183e:	c70c                	sw	a1,8(a4)
 3011840:	feb7aa23          	sw	a1,-12(a5)
 3011844:	feb7ac23          	sw	a1,-8(a5)
 3011848:	46e1                	li	a3,24
 301184a:	02c6f863          	bgeu	a3,a2,301187a <memset+0xa6>
 301184e:	c74c                	sw	a1,12(a4)
 3011850:	cb0c                	sw	a1,16(a4)
 3011852:	cb4c                	sw	a1,20(a4)
 3011854:	cf0c                	sw	a1,24(a4)
 3011856:	feb7a223          	sw	a1,-28(a5)
 301185a:	feb7a423          	sw	a1,-24(a5)
 301185e:	feb7a623          	sw	a1,-20(a5)
 3011862:	feb7a823          	sw	a1,-16(a5)
 3011866:	00477793          	andi	a5,a4,4
 301186a:	07e1                	addi	a5,a5,24
 301186c:	97ba                	add	a5,a5,a4
 301186e:	46fd                	li	a3,31
 3011870:	9732                	add	a4,a4,a2
 3011872:	40f70633          	sub	a2,a4,a5
 3011876:	00c6e363          	bltu	a3,a2,301187c <memset+0xa8>
 301187a:	8082                	ret
 301187c:	c38c                	sw	a1,0(a5)
 301187e:	c3cc                	sw	a1,4(a5)
 3011880:	c78c                	sw	a1,8(a5)
 3011882:	c7cc                	sw	a1,12(a5)
 3011884:	cb8c                	sw	a1,16(a5)
 3011886:	cbcc                	sw	a1,20(a5)
 3011888:	cf8c                	sw	a1,24(a5)
 301188a:	cfcc                	sw	a1,28(a5)
 301188c:	02078793          	addi	a5,a5,32
 3011890:	b7cd                	j	3011872 <memset+0x9e>
	...

03011894 <__rodata_start>:
 3011894:	9680                	pop	{ra,s0-s6},384
 3011896:	4b18                	lw	a4,16(a4)

03011898 <g_crgIpMatch>:
 3011898:	0000 1400 0000 0000 0140 0000 1000 1400     ........@.......
 30118a8:	0000 0000 0144 0000 2000 1400 0000 0000     ....D.... ......
 30118b8:	0148 0000 3000 1400 0000 0000 014c 0000     H....0......L...
 30118c8:	0000 1430 0000 0000 0240 0000 1000 1430     ..0.....@.....0.
 30118d8:	0000 0000 0244 0000 2000 1430 0000 0000     ....D.... 0.....
 30118e8:	0248 0000 3000 1430 0000 0000 024c 0000     H....00.....L...
 30118f8:	0000 1438 0000 0000 0040 0000 0000 1420     ..8.....@..... .
 3011908:	0000 0000 0180 0000 1000 1420 0000 0000     .......... .....
 3011918:	0184 0000 0000 1410 0000 0000 01c0 0000     ................
 3011928:	1000 1410 0000 0000 01c4 0000 0000 1460     ..............`.
 3011938:	0002 0000 02c0 0000 0000 1470 0001 0000     ..........p.....
 3011948:	0440 0000 1000 1470 0001 0000 0444 0000     @.....p.....D...
 3011958:	2000 1470 0001 0000 0448 0000 3000 1470     . p.....H....0p.
 3011968:	0001 0000 044c 0000 0000 1440 0001 0000     ....L.....@.....
 3011978:	0200 0000 0000 14b0 0001 0000 0280 0000     ................
 3011988:	1000 14b0 0001 0000 0284 0000 2000 14b0     ............. ..
 3011998:	0001 0000 0288 0000 0000 1c00 0001 0000     ................
 30119a8:	0300 0000 0000 1450 0001 0000 0480 0000     ......P.........
 30119b8:	1000 1450 0001 0000 0484 0000 2000 1450     ..P.......... P.
 30119c8:	0001 0000 0488 0000 3000 1450 0001 0000     .........0P.....
 30119d8:	048c 0000 4000 1450 0001 0000 0490 0000     .....@P.........
 30119e8:	5000 1450 0001 0000 0494 0000 1000 1440     .PP...........@.
 30119f8:	0005 0000 03c0 0000 0000 14c0 0001 0000     ................
 3011a08:	04c0 0000 1000 14c0 0001 0000 04c4 0000     ................
 3011a18:	0000 147d 0001 0000 0b00 0000 0000 1480     ..}.............
 3011a28:	0001 0000 0380 0000 0000 14a0 0001 0000     ................
 3011a38:	0400 0000 1000 14a0 0001 0000 0404 0000     ................
 3011a48:	2000 14a0 0001 0000 0408 0000 3000 14a0     . ...........0..
 3011a58:	0001 0000 040c 0000 0000 1001 0001 0000     ................
 3011a68:	0340 0000 0000 1810 0006 0000 0a60 0000     @...........`...
 3011a78:	0000 1830 0006 0000 0a70 0000 0000 1840     ..0.....p.....@.
 3011a88:	0006 0000 0a80 0000 0000 1820 0006 0000     .......... .....
 3011a98:	0a90 0000 1000 1820 0006 0000 0a90 0004     ...... .........
 3011aa8:	0000 1800 0003 0000 0a00 0000 0000 1471     ..............q.
 3011ab8:	0004 0000 0500 0000 2e2e 642f 6972 6576     ........../drive
 3011ac8:	7372 612f 6364 692f 636e 612f 6364 695f     rs/adc/inc/adc_i
 3011ad8:	2e70 0068 2e2e 642f 6972 6576 7372 612f     p.h.../drivers/a
 3011ae8:	6364 732f 6372 612f 6364 632e 0000 0000     dc/src/adc.c....
 3011af8:	2e2e 642f 6972 6576 7372 612f 7470 692f     ../drivers/apt/i
 3011b08:	636e 612f 7470 695f 2e70 0068 2e2e 642f     nc/apt_ip.h.../d
 3011b18:	6972 6576 7372 612f 7470 732f 6372 612f     rivers/apt/src/a
 3011b28:	7470 632e 0000 0000 28f2 0300 2a0a 0300     pt.c.....(...*..
 3011b38:	2b22 0300 2c3a 0300 0000 42c8 2e2e 642f     "+..:,.....B../d
 3011b48:	6972 6576 7372 622f 7361 2f65 7273 2f63     rivers/base/src/
 3011b58:	6e69 6574 7272 7075 2e74 0063 31e8 0300     interrupt.c..1..
 3011b68:	323a 0300 328c 0300 32de 0300 3330 0300     :2...2...2..03..
 3011b78:	3382 0300 33d4 0300 3426 0300 34d0 0300     .3...3..&4...4..
 3011b88:	3522 0300 3574 0300 35c6 0300 3618 0300     "5..t5...5...6..
 3011b98:	366a 0300 36bc 0300 370e 0300 4142 4455     j6...6...7..BAUD
 3011ba8:	5220 5441 3a45 2520 0d64 000a 7257 7469      RATE: %d...Writ
 3011bb8:	4465 7461 2161 0a0d 0000 0000 2e2e 642f     eData!......../d
 3011bc8:	6972 6576 7372 632f 6772 692f 636e 632f     rivers/crg/inc/c
 3011bd8:	6772 695f 2e70 0068 2e2e 642f 6972 6576     rg_ip.h.../drive
 3011be8:	7372 632f 6772 732f 6372 632f 6772 632e     rs/crg/src/crg.c
	...
 3011c00:	0001 0000 0002 0000 0003 0000 0004 0000     ................
 3011c10:	0005 0000 0006 0000 0007 0000 4f98 0300     .............O..
 3011c20:	4fa8 0300 4fb2 0300 4fc6 0300 4fa8 0300     .O...O...O...O..
 3011c30:	4fe2 0300 4fa8 0300 67da 0300 6844 0300     .O...O...g..Dh..
 3011c40:	6844 0300 6844 0300 6844 0300 6844 0300     Dh..Dh..Dh..Dh..
 3011c50:	6844 0300 6844 0300 6844 0300 6844 0300     Dh..Dh..Dh..Dh..
 3011c60:	6844 0300 671a 0300 6770 0300 6844 0300     Dh...g..pg..Dh..
 3011c70:	6804 0300 6844 0300 6844 0300 6844 0300     .h..Dh..Dh..Dh..
 3011c80:	6844 0300 6844 0300 6844 0300 6844 0300     Dh..Dh..Dh..Dh..
 3011c90:	6844 0300 6844 0300 67da 0300 6844 0300     Dh..Dh...g..Dh..
 3011ca0:	6844 0300 6744 0300 6844 0300 679a 0300     Dh..Dg..Dh...g..
 3011cb0:	6844 0300 6844 0300 67da 0300 2e2e 642f     Dh..Dh...g..../d
 3011cc0:	6972 6576 7372 672f 6970 2f6f 6e69 2f63     rivers/gpio/inc/
 3011cd0:	7067 6f69 695f 2e70 0068 0000 2e2e 642f     gpio_ip.h...../d
 3011ce0:	6972 6576 7372 672f 6970 2f6f 7273 2f63     rivers/gpio/src/
 3011cf0:	7067 6f69 632e 0000 2e2e 642f 6972 6576     gpio.c..../drive
 3011d00:	7372 672f 7470 732f 6372 672f 7470 632e     rs/gpt/src/gpt.c
 3011d10:	0000 0000 2e2e 642f 6972 6576 7372 692f     ....../drivers/i
 3011d20:	6332 732f 6372 692f 6332 632e 0000 0000     2c/src/i2c.c....
 3011d30:	87c6 0300 87e6 0300 87fc 0300 8840 0300     ............@...
 3011d40:	885c 0300 2e2e 642f 6972 6576 7372 692f     \...../drivers/i
 3011d50:	636f 676d 692f 636e 692f 636f 676d 695f     ocmg/inc/iocmg_i
 3011d60:	2e70 0068 2e2e 642f 6972 6576 7372 692f     p.h.../drivers/i
 3011d70:	636f 676d 732f 6372 692f 636f 676d 632e     ocmg/src/iocmg.c
 3011d80:	0000 0000 2e2e 642f 6972 6576 7372 712f     ....../drivers/q
 3011d90:	6d64 692f 636e 712f 6d64 695f 2e70 0068     dm/inc/qdm_ip.h.
 3011da0:	2e2e 642f 6972 6576 7372 712f 6d64 732f     ../drivers/qdm/s
 3011db0:	6372 712f 6d64 632e 0000 0000 a408 0300     rc/qdm.c........
 3011dc0:	a414 0300 a420 0300 a42c 0300 a43a 0300     .... ...,...:...
 3011dd0:	a448 0300 a454 0300 a460 0300 a46e 0300     H...T...`...n...
 3011de0:	a47a 0300 2e2e 642f 6972 6576 7372 742f     z...../drivers/t
 3011df0:	6d69 7265 692f 636e 742f 6d69 7265 695f     imer/inc/timer_i
 3011e00:	2e70 0068 2e2e 642f 6972 6576 7372 742f     p.h.../drivers/t
 3011e10:	6d69 7265 732f 6372 742f 6d69 7265 632e     imer/src/timer.c
 3011e20:	0000 0000 ae96 0300 aeac 0300 aec2 0300     ................
 3011e30:	aed8 0300 aeee 0300 2e2e 642f 6972 6576     ........../drive
 3011e40:	7372 752f 7261 2f74 7273 2f63 6175 7472     rs/uart/src/uart
 3011e50:	632e 0000 bb0a 0300 bb16 0300 bb22 0300     .c.........."...
 3011e60:	bb2e 0300 bb3a 0300 bb46 0300 bb52 0300     ....:...F...R...
 3011e70:	bb5e 0300 bb6a 0300 7257 7469 2065 6143     ^...j...Write Ca
 3011e80:	6c6c 6162 6b63 0a0d 0000 0000 6552 6461     llback......Read
 3011e90:	4320 6c61 626c 6361 216b 0a0d 0000 0000      Callback!......
 3011ea0:	4554 5453 4320 4e41 0000 0000 0000 0000     TEST CAN........
 3011eb0:	3d3d 4d3d 746f 726f 4520 636e 646f 2065     ===Motor Encode 
 3011ec0:	7245 6f72 2072 203d 6425 202c 6f6d 6f74     Error = %d, moto
 3011ed0:	2072 6973 6564 253a 2c64 6320 6c61 7563     r side:%d, calcu
 3011ee0:	616c 6574 7020 7265 6f69 2064 6425 736d     late period %dms
 3011ef0:	3d3d 0d3d 000a 0000 0000 0000 c000 4050     ===...........P@
 3011f00:	d197 5a7e 21fb 4009 0000 0000 0000 4059     ..~Z.!.@......Y@
 3011f10:	0000 0000 0000 4024 0000 0000 4000 408f     ......$@.....@.@
 3011f20:	6341 7574 6c61 6665 5374 6570 6465 253a     ActualeftSpeed:%
 3011f30:	322e 6d66 2f6d 2c73 6341 7574 6c61 6952     .2fmm/s,ActualRi
 3011f40:	6867 5374 6570 6465 253a 322e 6d66 2f6d     ghtSpeed:%.2fmm/
 3011f50:	2c73 5f41 6f4d 6576 585f 253d 322e 6d66     s,A_Move_X=%.2fm
 3011f60:	2f6d 2c73 5f41 6f4d 6576 5a5f 253d 322e     m/s,A_Move_Z=%.2
 3011f70:	6d66 6172 2f64 0d73 000a 0000 2d2d 2d2d     fmrad/s.....----
 3011f80:	2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 732d 6e65     -------------sen
 3011f90:	5f64 6f63 6e75 3d74 7525 2d2d 2d2d 2d2d     d_count=%u------
 3011fa0:	2d2d 2d2d 2d2d 2d2d 2d2d 0d2d 000a 0000     -----------.....
 3011fb0:	7830 7825 0020 0000 2020 0a0d 0000 0000     0x%x ...  ......
 3011fc0:	6144 6174 7320 6e65 2064 7265 6f72 2c72     Data send error,
 3011fd0:	6320 646f 2065 203d 6425 0a0d 0000 0000      code = %d......
 3011fe0:	6f6d 6564 436c 6c61 654c 7466 7053 6565     modelCalLeftSpee
 3011ff0:	3a64 2e25 6632 6d6d 732f 202c 6f6d 6564     d:%.2fmm/s, mode
 3012000:	436c 6c61 6952 6867 5374 6570 6465 253a     lCalRightSpeed:%
 3012010:	322e 6d66 2f6d 0d73 000a 0000 0a0d 5f67     .2fmm/s.......g_
 3012020:	6954 656d 4372 756f 746e 253d 2c64 5f67     TimerCount=%d,g_
 3012030:	6552 7663 6f43 6e75 3d74 6425 4d2c 766f     RecvCount=%d,Mov
 3012040:	5f65 3d58 2e25 6632 6d6d 732f 4d2c 766f     e_X=%.2fmm/s,Mov
 3012050:	5f65 3d59 2e25 6632 6d6d 732f 4d2c 766f     e_Y=%.2fmm/s,Mov
 3012060:	5f65 3d5a 2e25 6632 726d 6461 732f 0a0d     e_Z=%.2fmrad/s..
 3012070:	0000 0000 0a0d 5f67 6954 656d 4372 756f     ......g_TimerCou
 3012080:	746e 253d 2c64 5f67 6552 7663 6f43 6e75     nt=%d,g_RecvCoun
 3012090:	3d74 6425 0000 0000 0a0d 694c 656e 7261     t=%d......Linear
 30120a0:	7320 6570 6465 7320 7465 6520 7272 726f      speed set error
 30120b0:	203a 3d58 2e25 6632 6d6d 732f 5920 253d     : X=%.2fmm/s Y=%
 30120c0:	322e 6d66 2f6d 2c73 6d20 7375 2074 656c     .2fmm/s, must le
 30120d0:	7373 2520 322e 6d66 2f6d 0d73 000a 0000     ss %.2fmm/s.....
 30120e0:	0a0d 6e41 7567 616c 2072 7073 6565 2064     ..Angular speed 
 30120f0:	6573 2074 7265 6f72 3a72 5a20 253d 322e     set error: Z=%.2
 3012100:	6d66 6172 2f64 2c73 6d20 7375 2074 656c     fmrad/s, must le
 3012110:	7373 2520 312e 6d66 6172 2f64 0d73 000a     ss %.1fmrad/s...
 3012120:	6552 6563 6569 6576 2164 0a0d 0000 0000     Receieved!......
 3012130:	694c 7466 6e69 2067 6c42 636f 736b 0d21     Lifting Blocks!.
 3012140:	000a 0000 614c 6979 676e 6220 6f6c 6b63     ....Laying block
 3012150:	0d73 000a 7542 7474 6e6f 2031 7645 656e     s...Button1 Evne
 3012160:	2c74 6720 4b5f 2050 202b 6625 0a0d 0000     t, g_KP + %f....
 3012170:	5f67 504b 253d 2066 5f67 494b 253d 2066     g_KP=%f g_KI=%f 
 3012180:	5f67 444b 253d 0d66 000a 0000 7542 7474     g_KD=%f.....Butt
 3012190:	6e6f 2032 7645 656e 2c74 6720 4b5f 2049     on2 Evnet, g_KI 
 30121a0:	202b 6625 0a0d 0000 0000 4000 0000 0000     + %f.......@....
 30121b0:	0000 0000 0000 406e 0000 0000 4000 408f     ......n@.....@.@
 30121c0:	999a 9999 9999 3fb9 0000 42c8 0000 0000     .......?...B....
 30121d0:	0000 0000 0000 405e 0000 0000 0000 4000     ......^@.......@
 30121e0:	5000 47c3 0000 0000 0000 0000 6a00 40f8     .P.G.........j.@
 30121f0:	3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d     ================
 3012200:	3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d     ================
 3012210:	3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d     ================
 3012220:	3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 0a0d     ==============..
 3012230:	0000 0000 2020 2020 2020 2020 2020 2020     ....            
 3012240:	2020 2020 80e2 20a2 7545 656c 4372 7261         ... EulerCar
 3012250:	4320 6e6f 7274 6c6f 656c 2072 2e31 2030      Controller 1.0 
 3012260:	80e2 20a2 2020 2020 2020 2020 2020 2020     ...             
 3012270:	2020 2020 2020 0a0d 0000 0000 2020 2020           ......    
 3012280:	2020 2020 2020 2020 2020 2020 2020 2020                     
 3012290:	2020 2020 2020 2020 2020 2020 2020 2020                     
 30122a0:	2020 2020 2020 2020 2020 2020 2020 2020                     
 30122b0:	2020 2020 2020 2020 2020 0a0d 0000 0000               ......
 30122c0:	2020 9ee2 20a4 7953 7473 6d65 4920 666e       ... System Inf
 30122d0:	726f 616d 6974 6e6f 203a 2020 2020 2020     ormation:       
 30122e0:	2020 2020 2020 2020 2020 2020 2020 2020                     
 30122f0:	2020 2020 2020 2020 2020 2020 2020 0d20                    .
 3012300:	000a 0000 2020 2020 2020 80e2 20a2 6f4d     ....      ... Mo
 3012310:	6f74 2072 7954 6570 253a 0d73 000a 0000     tor Type:%s.....
 3012320:	2020 2020 2020 80e2 20a2 6f4d 6f74 2072           ... Motor 
 3012330:	6e45 6f63 6564 4c20 6e69 2065 754e 626d     Encode Line Numb
 3012340:	7265 253a 3530 0d64 000a 0000 2020 2020     er:%05d.....    
 3012350:	2020 80e2 20a2 6f4d 6f74 2072 614d 2078       ... Motor Max 
 3012360:	7053 6565 3a64 2e25 3230 6d66 2f6d 0d73     Speed:%.02fmm/s.
 3012370:	000a 0000 2020 2020 2020 80e2 20a2 7545     ....      ... Eu
 3012380:	656c 4372 7261 4420 7461 2061 6553 646e     lerCar Data Send
 3012390:	5020 7265 6f69 3a64 6425 736d 252c 4864      Period:%dms,%dH
 30123a0:	0d5a 000a 2020 9ee2 20a4 4950 2044 6e49     Z...  ... PID In
 30123b0:	6f66 6d72 7461 6f69 3a6e 2020 2020 2020     formation:      
 30123c0:	2020 2020 2020 2020 2020 2020 2020 2020                     
 30123d0:	2020 2020 2020 2020 2020 2020 2020 2020                     
 30123e0:	2020 0d20 000a 0000 2020 2020 2020 80e2        .....      ..
 30123f0:	20a2 504b 253a 302e 6632 2020 2020 80e2     . KP:%.02f    ..
 3012400:	20a2 494b 253a 302e 6632 2020 2020 80e2     . KI:%.02f    ..
 3012410:	20a2 444b 253a 302e 6632 0a0d 0000 0000     . KD:%.02f......
 3012420:	2020 2020 2020 80e2 20a2 4950 2044 6f43           ... PID Co
 3012430:	746e 6f72 206c 6550 6972 646f 253a 6d64     ntrol Period:%dm
 3012440:	0d73 000a 7545 656c 4372 7261 4d20 5543     s...EulerCar MCU
 3012450:	6920 696e 2074 7573 6363 7365 2173 2121      init success!!!
 3012460:	0a0d 0000 4954 454d 2052 7473 7261 0d74     ....TIMER start.
 3012470:	000a 0000 0000 0000 0000 0000 0000 4059     ..............Y@
 3012480:	4c43 434f 574b 5349 0d45 000a 3249 5763     CLOCKWISE...I2cW
 3012490:	6972 6574 3028 2578 2958 6620 6961 656c     rite(0x%X) faile
 30124a0:	2c64 3020 2578 2158 000a 0000 7373 3164     d, 0x%X!....ssd1
 30124b0:	3033 5f36 7055 6164 6574 6353 6572 6e65     306_UpdateScreen
 30124c0:	7320 6e65 2064 7266 6d61 2065 6164 6174      send frame data
 30124d0:	6620 6c69 6465 203a 6425 0d21 000a 0000      filed: %d!.....
 30124e0:	6425 2578 2064 2040 6425 252c 2064 756f     %dx%d @ %d,%d ou
 30124f0:	2074 666f 7220 6e61 6567 6f20 2072 6e69     t of range or in
 3012500:	6176 696c 2164 0a0d 0000 0000 7373 3164     valid!......ssd1
 3012510:	3033 5f36 7270 6e69 2074 656c 206e 6425     306_print len %d
 3012520:	0d20 000a d810 ffff d806 ffff d80c ffff      ...............
 3012530:	d806 ffff da40 ffff d806 ffff d80c ffff     ....@...........
 3012540:	d814 ffff d814 ffff da40 ffff d80c ffff     ........@.......
 3012550:	d7ec ffff d7ec ffff d7ec ffff d86a ffff     ............j...
 3012560:	df3e ffff df3e ffff df56 ffff df38 ffff     >...>...V...8...
 3012570:	df38 ffff dd3c ffff df56 ffff df38 ffff     8...<...V...8...
 3012580:	dd3c ffff df38 ffff df56 ffff df36 ffff     <...8...V...6...
 3012590:	df36 ffff df36 ffff e124 ffff               6...6...$...

0301259c <__clz_tab>:
 301259c:	0100 0202 0303 0303 0404 0404 0404 0404     ................
 30125ac:	0505 0505 0505 0505 0505 0505 0505 0505     ................
 30125bc:	0606 0606 0606 0606 0606 0606 0606 0606     ................
 30125cc:	0606 0606 0606 0606 0606 0606 0606 0606     ................
 30125dc:	0707 0707 0707 0707 0707 0707 0707 0707     ................
 30125ec:	0707 0707 0707 0707 0707 0707 0707 0707     ................
 30125fc:	0707 0707 0707 0707 0707 0707 0707 0707     ................
 301260c:	0707 0707 0707 0707 0707 0707 0707 0707     ................
 301261c:	0808 0808 0808 0808 0808 0808 0808 0808     ................
 301262c:	0808 0808 0808 0808 0808 0808 0808 0808     ................
 301263c:	0808 0808 0808 0808 0808 0808 0808 0808     ................
 301264c:	0808 0808 0808 0808 0808 0808 0808 0808     ................
 301265c:	0808 0808 0808 0808 0808 0808 0808 0808     ................
 301266c:	0808 0808 0808 0808 0808 0808 0808 0808     ................
 301267c:	0808 0808 0808 0808 0808 0808 0808 0808     ................
 301268c:	0808 0808 0808 0808 0808 0808 0808 0808     ................
	...
 30126a4:	0000 4330 0000 0000 0000 3fe0 0000 0000     ..0C.......?....
 30126b4:	0000 3ff0 0000 0000 0000 bfe0               ...?........

030126c0 <_GLOBAL_OFFSET_TABLE_>:
 30126c0:	0000 0000 259c 0301 ffff ffff 0000 0000     .....%..........
